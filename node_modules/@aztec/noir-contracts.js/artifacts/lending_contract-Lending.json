{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Lending",
  "functions": [
    {
      "name": "get_asset",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "asset_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "asset::Asset",
            "fields": [
              {
                "name": "interest_accumulator",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "last_updated_ts",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "loan_to_value",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "oracle",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1768177060348318876": {
            "error_kind": "string",
            "string": "Function get_asset can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_asset"
      ]
    },
    {
      "name": "deposit_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "_borrow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_borrow"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1ZzdbuI8EIbvhWMOPL+2eyufPq36Q1dIiFa0XWlV9d43oQ1hIZDK8LL4pCLVzLzPTBwziU3eJw+zu7efP+bLx6eXyc1/75PF0/3t6/xp2Ry9f0wnd6v5YjH/+WP735PQ/iH1tcPL8+2yPX55vV29Tm5IWG06mS0f2s+SQhPkcb6YTW5y/pjumwfmzjoo98Y+YKw5xC9jzeQbY9cB46SavoyTtha98f/TCRmdhT7nzpooX5D+PLW3tKl9Gqk9WezoyUWO02cT/TLOjd8uveuZ6Yn/om81Il9AIw5pmHmXvFnqT50JeFCkwZTNiToc53wcx0IKnXFIaQTHqKtlMgl7OAeqY7zBoXAcZyThzHAFdA4cGK7gaAUiuAI8B4bnwIZWkABXULhCRisoPAdNaAUTuMLpMx87dd0R+1YXQEHWEs54CXwWEZ9FdLhEIrwEPouMzyIbWkJCwEsoXiLDJQifBSW4BJ8+gbh0U7lbf2uW7TN+xMYXAscH8yuYX8H8BuY3x8Z3ML8bOH7Gxo8Cjg8enwk8v+H7CsH3FZLhWWggvAS8O1IKeAl8FozPghUvAe/xVAQvAe/xVPFZKPxWV8GdhoI7DfUAjq/g+AkbP4L5I5g/CTg+mD8zOD72+rIQwPEVHB/byRudPj4phW5xkRKlPQXsCDUWcHzwGRDwFQB+lmDgZwlm4PP7jVUF55ErwNW7K8C9h9H1mrx942nCqQqOVojhdAVi2uzXIFbrzYd2dzQPhLtNAhLsr20Ia6B8ZUBJrwwoX9spy/G6gPwbGx0uDJSuDIiubFA7/YMK5c66WbcY2Q5FgWK3W4kCy+4atn+jW7lu/lg3v3Dl/JXX3y7/pSTedX8iW1tKD/BHkQ1/tH3+y0+IKl1FpXmiNsafwqaNC2lvB6Tb5edP3Wz2bPjTGH/ebOBsPlva5XeunD/WzR+pcn6vmz9VXv8slfPXPX/GUHf9Y6i8/lR5/any+nPd/UPkuvuHKHV/f0WxuvntmuafNdA1DegW6KruMNZAl29ZjbsVPbHRW06S3P8iUVl2+f/BLcN5+a1u/hQq56+8/lnPwC9Je43A2/yNRjrLSsaIBoULaBheY3ihjlQ3Xmr9OWe3T69U4jV8uzvqFQu88vBe2lEvL/EaHgvUb9Yj5/7Z6ecach5eTBpzygVOUqJkwz/PP7oung+89eC4k5fkNLwnfsQpcYlTiVIuUcoFShQODPQxLyvyyiVew3f5o16pxIsLhm3jFUu8REq8NBR5WYnXgXeojHkVVcOLtLwor0NTxmGvj+bo1+1qfnu3mH29OefxbXm/9SKd19/Ps5136jyvnu5nD2+rWft2nf7FOu10yiFN2aWhaRNg16lQWrM1h2Q+bQZqe9gWpRmozaE2DA3HHw==",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "get_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "11699106313324679151": {
            "error_kind": "string",
            "string": "Function get_assets can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAZyUAAABoACgBAgIoAgADBIBEJwIEBAIuBAACgAMuBAADgAQuBAAEgAUlAAAA7CgCAAIEgEQnAgMEAjsNAAIAAyYlAAABMh4CAAEAHgIAAgAzOAABAAIAAycCAQEBJAIAAwAAAJElAAABWx4CAAEJJwICAAEKOAECAyQCAAMAAACtJQAAAW0vDAACAAEnAgIAAi8MAAIAAy0IAQInAgQEAwAQAQQBJwMCBAEAKAICBC0MBAUtDgEFACgFAgUtDgMFLQwCASYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAATEuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAAQAmKACABAR4AA0AAACABIADJACAAwAAAVoqAQABBfeh86+lrdTKPAEBAiYqAQABBb4eP/8+pPb6PAEBAiYqAQABBaJbkzUbP0/vPAEBAiY=",
      "debug_symbols": "5VbLbsIwEPwXn3Pwrtdrm1+pKhQgoEhRgkKoVCH+vXaUB6QRFItyaC+RHc1kZj3Oak9ik62Ou2VebquDWLydRFGt0yavSr87nROxqvOiyHfLy9dChgdI1xIO+7QM+0OT1o1YgELSicjKTVgrK/1HtnmRiYVz5+Q7XCL2aEk4gnkGTE6aDkwOeAAzzYAtke3AlgJiBL8nAoCe4t65Hg3gXuj+OWev7XD29s7Zgza9e2Clbrt3WlEHdp43dY/mye4Br9wHDYW/r0HyBRp6VgM1cM9CrextDaN078goA3fCQ9mDHaKdhqflDwzRVdEtTUfROE6NbRTNqFmatIaGH8XJ8fJrNRcojPGDGTWAzVw0Vsk+GqvvRGMY+35jmO1tsPfh1GBEI0+TNPNNRI59yq8V/JFqLf2nap18uNqWRnE0F0NDSXG0ODWIUwMbRUOMo5nHaWe/+0jrPF0VWTe2bY/l+mKKaz732WSg29fVOtsc6yyMduNUFxqgv+Jah1jDHdKcMLQjh98wJkxez2t+AQ==",
      "brillig_names": [
        "get_assets"
      ]
    },
    {
      "name": "repay_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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dcN03TBTN8zWDaO6Ya5umK8bFuqGxbphdVmi67JE12WJrssSXZclui5LdF2W6Los0XVZouuyRNdlianLElOXJaYuS0xdlpi6LDF1WWLqssTUZYmpyxJTlyW2LktsXZbYuiyxdVli67LE1mWJrcsSW5clti5LbF2WUF2WUF2WUF2WUF2WUF2WUF2WUF2WUF2WUF2WUF2WuLoscXVZ4uqyxNVliavLEleXJa4uS1xdlri6LHF1WeLrssTXZYmvyxJflyW+Lkt8XZb4uizxdVni67LE12VJqMuSUJcloS5LQl2WhLosCXVZEuqyJNRlSajLklCXJbEuS2JdlsS6LIl1WRLrsiTWZUmsy5JYlyWxLktiXZakuixJdVmS6rIk1WVJqsuSVJclqS5LUl2WpLosqeu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63qs+6b2m/RuGOpHODDvJkn1LP52S+TYst5Uv00Eht3DCWOHEscJJQ4Vz1tvuFY4eKxwzVjh2rHBorHDcWOGMdVeOY92V41h35TjWXTmNdVdOY92V01h35TTWXTm1viu/POPqFo8bLB4/WDxhsHjiYPGkoeIx+Se45la6fg0zRrtCPDeHrvbwffjz7gW3N9Et3sS0eBPL8ibWP97E28ObZH6RF+22MZBVx32fVH47VbXvuabs47f3SX/FT4PH73b+3ln7HL8THr8XHn8QHn8UHn+SHb9WwuPXwuM3wuMfff0txS98/dXC118tfP3VwtdfLXz91cLXXyN8/TXC118jfP01wtdfI3z9NcLXXyN8/TXC118jfP01wtdfK3z9tcLXXyt8/bXC118rfP21wtdfK3z9tcLXXyt8/bXC118Svv6S8PWXhK+/JHz9JeHr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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "update_accumulator",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "asset::Asset",
            "fields": [
              {
                "name": "interest_accumulator",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "last_updated_ts",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "loan_to_value",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "oracle",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "update_accumulator"
      ]
    },
    {
      "name": "withdraw_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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H674xIcrPvHhik98uOITH674xIcrPvHhik98uOITH674xIcrPvHxik98vOITH6/4xMcrPvHxik98vOITH6/4xMcrPvHxik98vOITn674xKcrPvHpik98uuITn674xKcrPvHpik98kvjEp7hfnRdz8CbpijfJF7xJXq54E3PFm9gr3sRd8Sb+ijdZhd/E2IM3kfjEp/3xj8t2+fQmX69O+yOW5B5PWGyyB9febkgf1+b8+dp78FFz8Elz8Flt8HZZFs3BG83BW83BO83Be83Br5qD17vC3oLXu8Legte7wt6C17zCmr5X2LBda24r0kH0fS+xpej7XmNL0fe9yJai73uVLUXf9zJbil5inc027tGvsRD9++8Y3iKK3UWUuoso9xaRXbqLyHQXke0uItddRL67iNbuIurunm27u0Pa6++Qb7+pbhfnuovo+s9atI+IbPwa0dpdRKG7iGJ3EaXuImrw6fdhj2j1zxF9vdj6PRDrvf8Svl90h290h291h+90h+91h7/qDj/oDj92Hr5Nj/C/FmQ+6Q6/91X3ffhr56vuum41j12De39xuD2u/7g43PqrX+fa+RL9k7muOea3c+18PV/33q9do3l/cVq2F07+6YfWtzbwfaqdr/2SU/XzTLXzmkJyqp3XH5JT7bxWEZxq6H1l/clU163vmGL4NNWDFzZui9ma9fHC/uhJnU3bkueWT5feEfa+YCtAOFId0AjhSPVFI4QehL+LcKR6qBHCkeqsRghHqt8aIey836UBYec9NwUII+7ktxHiTn4bIe7ktxHiTn4XYZo1C5dsd4RPX5U6RJjSFsSnHwcfvrC5vff2yre/49NXsHP8YD5r2rZk7mF+OfNZbXtL5rP6/JbMZ20MtGQ+ayehJfNZWw8NmedZexUtmc/a3GjJHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9mrlZ8KHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cucGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYWH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZO3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ977CaZDMseHXs8cH3o9c3zo5cxVnaGY3l8cw3ZtjJ8o3meqKbt+b6Z+mpm2cPSPA+rXQvDvXvoef1Aef1Qef1Ief9Ydf5PzIyXjN13H7xe3HaDsl5wLL+38Xiw4n57CXs3HbO1Us3VTzdZPNdu+6wbp2fZdZUjPtu+aRHq2fVcw0rPtu94Rnm3suzqSnu1UtVTUW0vd49dbHd3j98rj11vB3OPXW5Pc49dbZdzj77xuMHtD0TvjCy+dFr81291jrjYd9c9z2l4458/X3rl0XmG04pI6r0Wacem8amnGpfP6phmXzuumZlw8XA65dF7nNePSef3YjEvndWkzLtS7x1yodw+5ZOrdYy7Uu8dcfOdczNaP9MYe9ANy73VGKf7e64FS/L2v26X4e19fS/H3vg6+j98uva9Xpfh7X1dK8ffe7yjF33tfohS/7vXXLrrXX7voXn/tonv9tYvu9dcuytdfo3z9NcrXX6N8/TXK198m+/tLxq98/TXK11+jfP01ytdfo3z9tcrXX6t8/bXK11+rfP1tsq+xZPzK11+rfP21ytdfq3z9tcrXX6d8/XXK11+nfP11ytffJvs5SsavfP11ytdfp3z9dcrXX6d8/fXK11+vfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z9XZWvv6vy9XdVvv6uytffJnsOSsavfP3tfCfBcvzK19/OdxIsx698/e18J8Fy/MrX3973BizGr3z97X3/vmL8ytff3vfYK8avfP3tfR+8YvzK19/e96orxq98/e19P7li/MrX3973kyvGr3z97X0/uWL8ytff7veTK8WvfP3tfn+2UvzK19/u9zsrxa98/e1+/7BS/MrX3+734yrFr3z97X5/q1L8ytff7veLKsWvfP3NytffrHz9Vb7/lVW+/5VVvv+VVb7/lVW+/5VVvv+VU77/lVO+/5VTvv+VU77/lVt0r7+u+/2vTttXNGzXmmWxny6+g5l2o+sSmGl3ui6BmXar6xKYafe6LoDpfvOyZmD0nmJyj1/vaSP3+L3y+PVWNff49RYf9/j11gj3+PUu5ff49a64f8Tf/a5ipfj1ntZwj1/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVoi/+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrx615/ffe7ipXi173++u53FSvFr3v99Yvu9dcr3lXsHr/u9dcr3qPrHr/u9dcr3vHqj/gVb0x1j1/5+qt8/yuvfP8rr3z/K9/7/lfB5S3+tLjCS/9oY7m0zTDnz9feuXS+rjfj0nm90IxL53XIeVzeb9Doe99grBmY3ncuawem85KsHZjOa712YDovItuB8X2DSftL++RLYGJwHxfHGPZr/TbVzgtZyal2XptKTrXzcvPNVO/xd14WFuPvvHorxd/59nSr8et2sQkH9rzz7enK8fddspTj77uyKMfvlcff96pejr/vpbocf9/rbzn+vtffcvx9r7/P8Vtjv8bf+fZ05fj1rL/H8etZf4/j17P+HsevZ/09jr/z9TeauF+c8kH8na+/xfg7X3+L8Xe+/hbj73z9LcXf+fZ05fg7X3+L8Xe+/hbj73z9Lcbf+fpbjF/5+tv59nTl+JWvv51vT7cmt2wX55AKL+3zPtnnrzIlc3Ctjct2nLGN9lHZblw6X9dbcel8O712XDqvQ4S43Ofaec0iOtfO6xvRufqJ5tp53SQ6185rLNG5dl6P/Wiut5bbdrFPB3MdqXYrzXWkeqww1863TJSd60h1U2muI9VNpbmOVDeV5uonmutIdVNpriPVTeu6103poG7qfJtJ2bkOVTcV5jpU3fR+rp1vdSk716HqpsJch6qbCnMdqm4qzNVPNNeh6qbCXCeqmzrfHvTdXO/x662F7vHrrW/+iL/z7UHL8eutQ+7x660t7vH3XS+EZdkCCS6Yg/i98vj7XtfL8fe9Vpfj73v9Lcff9/pbjr/v9bcU/9r59qDl+Ptef8vx973+luPXvf6ui+71d+18e9By/LrX37Xz7UHL8etef9fOtwct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HB96PXN86PXM8aHXM8eHXs8cH3o5c4cPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cx7P+B2SOb40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXMx/q8HItzPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9nHvCh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nHnEh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmCR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmWd86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDr2aeF3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ27wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5xYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5g4fej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5l7fOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9nvuJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOAD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMIz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3oxc7cs+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OBDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OXOLD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMHT70eub40OuZ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kngcIZIznzhpw2J2kvE58EOSt5c0O5SwFq62MT/O1fvTDmR38jPXn6eST3Zr39vk0gF5D/lG5Geub9uSn7kePpf8sp9hl0w8ID9z/dyW/Mz1dlvyM9fnTcmvMz+zaEt+5mccbcnjYVuRx8O2Iu8h34g8HrYVeTzsWeTj4yzceNA9WPGwrcjjYVuRx8M2Ij/zadEnk98jv5HPB+TxsK3I42FbkcfDnkXep5386g7Ie8g3Io+HbUUeD9uKPB62FXk8bCvyeNhG5CMethV56vmTyId9W4Tba+fS1d657WqfXOHq4B/fUn50/l04mmVO+1m9y1MYxxcHu24Ag02ll/6188P+5eqUzPLp+nt6edKL9KpOL/8Q/vnu9UgvnBnpdWJ6YT9JrxPTC49NesmkV7AH6UUjgfT6jfTyj/SKa+nV88475OdvIx1dnOz+2sk+Za7ZEpc+DImrMXETbSwSV2Xi8k0WEldl4vJFIBJXZeLy3IXEVZm4nsQlcTUmLs+KSFyVictTKBK3OnGz3QHe/g6frr+nF91W0qv+vpgf3wDKy8E3gDIOnfSqv3uZh/DZmYP0oqojvU68e1F7kV4ytZc7Si++AUR6nZhefAOI9DoxvXCOpNdp6bUufJuG9KpPL/do2GbvD9KL77yQXiemF30v0uvE9OL7I6TXienlSS/S67z0omtPep2YXnTtSa/69Co8c1wXuvak14npRdee9Doxvejak17npZeha096nZhedO1JrxPTi6496XVietG1J71OTC9PepFe56UXfS/S6/HCZr/6lmlLKb2idfuLx9sUDtKLvhfpdWJ60fciverTK7hHesX8Nb0sfS/S68T0ou9Fep2YXvS9SK8T04u+F+lVnV5u2dWJt0Q5SC9PepFe56UX31YlvU5ML76tSnrVp5d/Sq91PUgvuvak14npRdee9Doxvejak17npZeja096nZhedO1JrxPTi6496XVietG1J73q08s9p1c4SC9PepFe56UXXXvS68T0omtPetWn1z7HX38ffGPC0bUnvU5ML7r2pNeJ6UXXnvQ6L708XXvS68T0omtPep2YXnTtSa8T04uuPelVn17xKb3ywakc3pNepNd56UXXnvQ6Mb3o2pNe1enlzb7xePT2YI8JT9ee9Doxvejak14nphdde9LrvPRa6dqTXiemF1170uvE9KJrT3qdmF50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dVkS6rIk1GVJqMuSUJcloS5LQl2WxLosiXVZEuuyJNZlSazLkliXJbEuS2JdlsS6LIl1WZLqsiTVZUmqy5JUlyWpLktSXZakuixJdVmS6rIk1WVJrsuSXJcluS5Lcl2W5LosyXVZkuuyJNdlSa7Lkrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aF73XvH/D0GRvDoa9yJJ9Sz+Ts/007GgrX6GDQm7hxL7CSX2Fk7sK51Vvu1U4pq9wbF/huL7C8X2Fs/YVTl935dTXXTn1dVdOfd2Vc1935dzXXTn3dVfOfd2V89V35bdnXN3iWTuLJ3QWT+wsntRZPLmreOzxE1x7K10/hllr1kI8N4e+7OGH+OfdC25vYq54E3vFmziRN3Hh8SbBPb3JwS/ykts2BnLL875Py/F2qsu+59riHr+9z+Yjft95/OvOP6zOfY1/VR5/UB5/VB5/Uh5/1h2/WZTHb5THb5XH3/v6W4pf+fprlK+/Rvn6a5Svv0b5+muUr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn6a5Wvv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrlK+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+uuVr7+r8vV3Vb7+rsrX31X5+rsqX39X5evvqnz9XZWvv6vy9XdVvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1C+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvVL7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Svv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_deposit"
      ]
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "oracle",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "loan_to_value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    },
    {
      "name": "_repay",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_repay"
      ]
    },
    {
      "name": "borrow_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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meNDr2eOD72cuaozFNP7i2PYro3xE8X7TDVl1+/N1E8z0xaO/nFA/VoI/t1L3+MPyuOPyuNPyuPPuuNvcn6kZPym6/j94rYDlP2Sc+Glnd+LBefTU9ir+ZitnWq2bqrZ+qlm23fdID3bvqsM6dn2XZNIz7bvCkZ6tn3XO8KzjX1XR9KznaqWinprqXv8equje/xeefx6K5h7/Hprknv8equMe/yd1w1mbyh6Z3zhpdPit2a7e8zVpqP+eU7bC+f8+do7l84rjFZcUue1SDMunVctzbh0Xt8049J53dSMi4fLIZfO67xmXDqvH5tx6bwubcaFeveYC/XuIZdMvXvMhXr3mIvvnIvZ+pHe2IN+QO69zijF33s9UIq/93W7FH/v62sp/t7Xwffx26X39aoUf+/rSin+3vsdpfh770uU4te9/tpF9/prF93rr110r7920b3+2kX5+muUr79G+fprlK+/Rvn622R/f8n4la+/Rvn6a5Svv0b5+muUr79W+fprla+/Vvn6a5Wvv032NZaMX/n6a5Wvv1b5+muVr79W+frrlK+/Tvn665Svv075+ttkP0fJ+JWvv075+uuUr79O+frrlK+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+uuVr7+r8vV3Vb7+rsrX31X5+ttkz0HJ+JWvv53vJFiOX/n62/lOguX4la+/ne8kWI5f+frb+96AxfiVr7+9799XjF/5+tv7HnvF+JWvv73vg1eMX/n62/tedcX4la+/ve8nV4xf+frb+35yxfiVr7+97ydXjF/5+tv9fnKl+JWvv93vz1aKX/n62/1+Z6X4la+/3e8fVopf+frb/X5cpfiVr7/d729Vil/5+tv9flGl+JWvv1n5+puVr7/K97+yyve/ssr3v7LK97+yyve/ssr3v3LK979yyve/csr3v3LK979yi+7113W//9Vp+4qG7VqzLPbTxXcw0250XQIz7U7XJTDTbnVdAjPtXtcFMN1vXtYMjN5TTO7x6z1t5B6/Vx6/3qrmHr/e4uMev94a4R6/3qX8Hr/eFfeP+LvfVawUv97TGu7xK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcUK8Xe/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7d66/vflexUvy611/f/a5ipfh1r79+0b3+esW7it3j173+esV7dN3j173+esU7Xv0Rv+KNqe7xK19/le9/5ZXvf+WV73/le9//Kri8xZ8WV3jpH20sl7YZ5vz52juXztf1Zlw6rxeacem8DjmPy/sNGn3vG4w1A9P7zmXtwHRekrUD03mt1w5M50VkOzC+bzBpf2mffAlMDO7j4hjDfq3fptp5ISs51c5rU8mpdl5uvpnqPf7Oy8Ji/J1Xb6X4O9+ebjV+3S424cCed749XTn+vkuWcvx9Vxbl+L3y+Pte1cvx971Ul+Pve/0tx9/3+luOv+/19zl+a+zX+Dvfnq4cv5719zh+Pevvcfx61t/j+PWsv8fxd77+RhP3i1M+iL/z9bcYf+frbzH+ztffYvydr7+l+Dvfnq4cf+frbzH+ztffYvydr7/F+Dtff4vxK19/O9+erhy/8vW38+3p1uSW7eIcUuGlfd4n+/xVpmQOrrVx2Y4zttE+KtuNS+freisunW+n145L53WIEJf7XDuvWUTn2nl9IzpXP9FcO6+bROfaeY0lOtfO67EfzfXWctsu9ulgriPVbqW5jlSPFeba+ZaJsnMdqW4qzXWkuqk015HqptJc/URzHaluKs11pLppXfe6KR3UTZ1vMyk716HqpsJch6qb3s+1860uZec6VN1UmOtQdVNhrkPVTYW5+onmOlTdVJjrRHVT59uDvpvrPX69tdA9fr31zR/xd749aDl+vXXIPX69tcU9/r7rhbAsWyDBBXMQv1cef9/rejn+vtfqcvx9r7/l+Ptef8vx973+luJfO98etBx/3+tvOf6+199y/LrX33XRvf6unW8PWo5f9/q7dr49aDl+3evv2vn2oMX4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S0JdloS6LAl1WRLqsiTUZUmoy5JYlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LUl2WpLosSXVZkuqyJNVlSarLklSXJakuS1JdlqS6LMl1WZLrsiTXZUmuy5JclyW5LktyXZbkuizJdVlS13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V/Oi95r3bxia7M3BsBdZsm/pZ3K2n4YdbeUrdFDILZzYVzipr3ByV+G86m23Csf0FY7tKxzXVzi+r3DWvsLp666c+rorp77uyqmvu3Lu666c+7or577uyrmvu3K++q789oyrWzxrZ/GEzuKJncWTOosndxWPPX6Ca2+l68cwa81aiOfm0Jc9/BD/vHvB7U3MFW9ir3gTJ/ImLjzeJLinNzn4RV5y28ZAbnne92k53k512fdcW9zjt/fZfMTvO49/3fmH1bmv8a/K4w/K44/K40/K48+64zeL8viN8vit8vh7X39L8Stff43y9dcoX3+N8vXXKF9/jfL11ypff63y9dcqX3+t8vXXKl9/rfL11ypff63y9dcqX3+t8vXXKV9/nfL11ylff53y9dcpX3+d8vXXKV9/nfL11ylff53y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/vfL1d1W+/q7K199V+fq7Kl9/V+Xr76p8/V2Vr7+r8vV3Vb7+rsrX36B8/Q3K19+gfP0NytffoHz9DcrX36B8/Q3K19+gfP0NytffqHz9jcrX36h8/Y3K19+ofP2NytffqHz9jcrX36h8/Y3K19+kfP1NytffpHz9TcrX36R8/U3K19+kfP1NytffpHz9TcrX36x8/c3K19+sfP3NytffrHz9zcrX36x8/c3K19+s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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_position",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "position::Position",
            "fields": [
              {
                "name": "collateral",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "static_debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2493037461250685601": {
            "error_kind": "string",
            "string": "Function get_position can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_position"
      ]
    },
    {
      "name": "repay_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAB0woAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAewAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAewLgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAd/AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACAgjAAAIeCQAgA0AAAgVIwAACC4uAIADgAUBAIAFAAKADi4CgAuADiMAAAhzKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAhzIwAACMwoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACMwoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACSwuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACPsuAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "1V3tTuM6EH2X/u4Pjz0z9uyrXF2tWCgrJASIjytdId59ndI0LE0wCj4h/oMa5Jlzztgd25m4ed5c7H49/f55dXN5+7D58c/z5vr2/Ozx6vYmXz2/bDe/7q+ur69+/3z7743r/pCkvcHD3dlNd/3weHb/uPlBwbNsN7ubi+5zSC47uby63m1+mL1sT5s77/vWjv3QWEcas7l4aMxGemysPNI4MadD48Rdi6Hxv9sNaajC3qxvTWQLsq8Te0nH2KdC7Elizz7HLnzM3iTwobFlu/fso1ZmT/4v9h1G4gUwbAzDOA3i3WAkYQRBXHKHxvljKgwKoZ58kuDeh9V4nA73YzQzCx/TKSEYGME7hiPANVCAIyQ0godr8HANwcMRIhqBCY6gaASBaxBBI6iDI3w983mlvrHXN9MuufAKYXCIiFcR8SpSwEMkOIThVRhcRXAeDxHhEER4CIVDeLwKL3iIrycQDf2+QGVoarL3HxjsP2H9M5g/g/kLmL+A+WsA+wfzjx7sX7H+kwP7B4/PBM5vFdYVlFx/j4QSpRME7AhlF8D+sT3AhP0GcIV5/mP/Ees/gPs3gPkzOP4MHj/iwP4F61/B8QfPwBzB4z+C81sC9295hhQvhRnMmWo/hTlLQ4lG9sUBLs+SFTASHEPK++8yBnk6Fo8oV2DeYpw2D47p0Do4+atQ1hEqb6WXJqQrI+TX1mXeVkaovEVfmBC7tRFa26CWb4iQ9a2Dj4WCPTmK7phHfeAT/tI4f2ubv3Lj/BuPf1p+Usp3unr+4c3zLRP8YwhH/lFO+S+fEDn0Ec33ZGOJf3LDOi6d1BfFls+fTDTwTyX+diyP5s+STvhz4/ytaf7qQuP8U9v8qfH4e2mbf2g7f2poPP7cePy58fhL4/EvV4VXzr/x9YM2Pn9pbJt/WlP+2RNa04DuCK1qh7EntPySVXxflw9S3HJSLtQffbMP7/jHb9gy1OUf2+ZPvnH+jcff17hlFI6niTLG2+NE+/JcrFLJKGCwXwAj4jEmDiKI9UcQTalwXqviIb4o48NDjifCTH2BTgFh4tRCTQSBI9iXEQoPBMeJQwtVIfAqEl7FxKGFmhATj01UhYCrSC7gISIcYmL9UBVC4RATDzNWhcCrCA4P8fUE8tFTVykY1j8HsH8wfwHzFzB/BfPXhPUfwfxjxPpPBPYvYP/g8Wng/GbY8WkugP1j428V5voP/XsC+8d+fy2A+zeA+TM4/gwePwJfYpkIHELxKnQBFfD9suF3/Ybf9Rt+12/4Xb/hd/1m8P0yOecXwFhAB9ECGNjVJDnv0ACMBkhggODRAGgFjFbAEQwgaAWiYABFf9G0/EWTUm1I+fh0tOrwcDTrASLBIT5xe+HLEPHrEDUP7ZBLujZGRqtjtLZey1lvdYxsbYw+sX5ZmJFf28gm/w0xqnhmiegTVZeVC+DWBVjjArj1HpDlp6eaB/eIdPm8WPPkXhawfBqt+ehxFmCNC4jcuoDUuIAUWhfQeA9451oX0Hga9dR6D1DrPeBb7wHffA80vpTw37Ajqyyg9YnsEzWDdQvQNWWhV0ZrGtSvjNaUJ/aM4vIr2JqnmbKA1LiA5FsXEBsXYI33QHA17iV9fEwtg9gCIBQXAPF+AZDxil6+8Xo0Yxk63qsczGSOGY9vg8tmPM8szTIb/7GgstnomKDhUR5SP9xfPVSdJ34tvGilc6x4Ftb4yYdCNZ0nXhFZsIqzdE28rrBkZXOsbBaWzcESx7Os0hyr8eNqRas5/SXjNwKKVjLLas7onfiJ25IVu1lWcY6V+FlWaY6VzoqGzsKKs3RN5Y1pq5d89d/Z/dXZr+vd4XW9l08352/e3vv4/93u3Yt87+5vz3cXT/e77pW+w9t8u/AEF7dBfWbTDdOgYZsnhI5bNya8yDZvPLvLLgV7pXwZMofM4w8=",
      "brillig_names": [
        "repay_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zbh0Xpc240K9e8yFeveQS6bePeZCvXvMxXfOxWz9SG/sQT8g915nlOLvvR4oxd/7ul2Kv/f1tRR/7+vg+/jt0vt6VYq/93WlFH/v/Y5S/L33JUrx615/7aJ7/bWL7vXXLrrXX7voXn/tonz9NcrXX6N8/TXK11+jfP1tsr+/ZPzK11+jfP01ytdfo3z9NcrXX6t8/bXK11+rfP21ytffJvsaS8avfP21ytdfq3z9tcrXX6t8/XXK11+nfP11ytdfp3z9bbKfo2T8ytdfp3z9dcrXX6d8/XXK11+vfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z99crX31X5+rsqX39X5evvqnz9bbLnoGT8ytffzncSLMevfP3tfCfBcvzK19/OdxIsx698/e19b8Bi/MrX39737yvGr3z97X2PvWL8ytff3vfBK8avfP3tfa+6YvzK19/e95Mrxq98/e19P7li/MrX3973kyvGr3z97X4/uVL8ytff7vdnK8WvfP3tfr+zUvzK19/u9w8rxa98/e1+P65S/MrX3+73tyrFr3z97X6/qFL8ytffrHz9zcrXX+X7X1nl+19Z5ftfWeX7X1nl+19Z5ftfOeX7Xznl+1855ftfOeX7X7lF9/rrut//6rR9RcM21iyL/TT4Dmbaja5LYKbd6boEZtqtrktgpt3rugCm+83LmoHRe4rJPX69p43c4/fK49db1dzj11t83OPXWyPc49e7lN/j17vi/o6/+13FSvHrPa3hHr/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBB/97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7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T/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezjzjQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejXzvOBDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OXODD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMLT70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM3f40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs7c40OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o58xUfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5kHfOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9nHvGh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nHnCh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmGR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NCLmbtlwYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5gYfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5lbfOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9n7vCh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nLnHh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmKz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXMw/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs484kOvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o584QPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eH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mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq3nRe837NwxN9ubgshdZsm/pZ3K2ny472spX6KCQWzixr3BSX+HkrsJ51dtuFY7pKxzbVziur3B8X+GsfYXT11059XVXTn3dlVNfd+Xc110593VXzn3dlXNfd+V89V357RlXt3jWzuIJncUTO4sndRZP7ioee/wE195K14/LrDVrIZ6bQ1/28EP86+4FtzcxV7yJveJNnMibuPB4k+Ce3uTgF3nJbRsDueV536fleDvVZd9zbXGP395n8xG/7zz+decfVue+xr8qjz8ojz8qjz8pjz/rjt8syuM3yuO3yuPvff0txa98/TXK11+jfP01ytdfo3z9NcrXX6t8/bXK11+rfP21ytdfq3z9tcrXX6t8/bXK11+rfP21ytdfp3z9dcrXX6d8/XXK11+nfP11ytdfp3z9dcrXX6d8/XXK11+vfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z99crX31X5+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff4Py9TcoX3+D8vU3KF9/g/L1Nyhff4Py9TcoX3+D8vU3KF9/o/L1Nypff6Py9TcqX3+j8vU3Kl9/o/L1Nypff6Py9TcqX3+T8vU3KV9/k/L1Nylff5Py9TcpX3+T8vU3KV9/k/L1Nylff7Py9TcrX3+z8vU3K19/s/L1Nytff7Py9TcrX3+z8vU3615/3aJ7/XWL7vXXLbrXX9f9/lel+HWvv075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075/ldO+f5XTvn+V075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fSU22ldi2/068HY35tsEer8LlRyZvf4u1Mvm6SY/NmpYvj7ftjaA5hWaCJpXaBJoXqHJoHmBxi2geYXGgOYVGguaV2gcaF6h8aB5hYZq+CUaquGXaKiGX6KhGn6Jhmr4FRpPNfwSDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EM281fGvj7Wi8PUAzbzVcQrPOWw0X0cxb1xTRzLtCFX6QZ9d5V6gimnlXqCKaeVeoEpow7wpVRDNvv6aIZt5+TRHNvHVNEY0HzSs08/ZrimgOq2G37D+AdsvzWUOHkzUmmP3X2SbYEhxr993QbtX605FKzn8EFSWCWh/71prwdHSG8l7J8a4ZwLnDycB5Ced4BxTg3OEY4LyGY4HzGo4Dzms4Hjiv4azAeQ0nAOc1HCrkN3CokN/AoUJ+DSdRIb+BQ4X8Bg4V8hs4VMhv4HjgvIZDhfwGDhXyGzhUyG/gUCG/gTNzhXyb/QbHLQffnsozV8hFODNXyEU4M1fIRTgzV8hFOB44r+HMXCEX4cxcIRfhzFwhF+HMXCEX4VAhv4TjFirkN3CokN/AoUJ+A4cK+Q0cD5zXcKiQ38ChQn4Dhwr5DRwq5DdwqJBfwzFUyG/gUCG/gUOF/AYOFfIbOB44r+FQIb+BQ4X8Bg4V8hs4VMhv4MxcIRd+levszBVyEc7MFXIRzswVchHOzBVyEY4Hzms4M1fIRTgzV8hFODNXyEU4M1fIJTgTH33k9uMR7a0heoBm3s3Dimjm3TysiGbiTVELbnzio4+KaObdPKyIZt6tdIto5t1Kt4hm4s3eS2gm3uy9gGbio4+KaOathoto5q2Gi2iohl+iub6u+dnh9TFvaG5/Pqa7HV7vGhw187MJpD0Tbn/mgwmk3idg3T4BZw8mkJVPoMHhKsITMNonYLVPwGmfgO99AkvcJ2CXgwms2ifQ+0pcnED3K3FpAt2vxKUJdL8SFyYQul+JSxPofiUuTOB4R6Dot4iiD19NxPF+Jw9Tk9d0cJGrucjXXLTWXBRqLoo1F6Waiw51Mst+3IRZwvrlMn/8i+3yZabuMlt3mau7zNddttZdFuoui3WXpbrL6rLE1GXJ8U9W3t87/PFPOfJ+m8r26KKK24A//gJ36Z1SzUW54qLjL8KWLjIVIKytucjVXHSsU9gyIseDNDr+AlrpolBzUel2fXhRqgGRKy46/lZM6aKajHA1GeFqMsLVfHLdWnNRqLko1lz004y4/Zv/NdL8yHSb9delt3/9f//bv/3Tf/vv//yP//t20a//+3/+5X/8+z/96798/Ou//3//a/s///3f/umf//mf/ud//V//9q//4x//4f/82z/+13/+1//x6//9bfn99r/yy6e/r+5XRGb/T9b/3eZf/8k+/lP8u7O//pP7uPo/x8XZv8fldu3vS//zrfaNf7/Vj+t/+T3o9v9vs4iLTb/+/+83iiH93cf4+4LfVywh30ZE8+Dxa5wJf7e3//Qft7n+/w==",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "1768177060348318876": {
            "error_kind": "string",
            "string": "Function get_asset can only be called statically"
          },
          "2493037461250685601": {
            "error_kind": "string",
            "string": "Function get_position can only be called statically"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "11699106313324679151": {
            "error_kind": "string",
            "string": "Function get_assets can only be called statically"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBVJwAABAMnAgIEAScCAwQAHxgAAwACgFQuCIBUAAElAAAARSUAAADrKAIAAQSAVScCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMoAIBFAQAAKACARgQAACgAgEcGAAAoAIBIAAAAKACASQEAASgAgEoEAAEoAIBLBAACKACATAQABCgAgE0AAAQoAIBOAAAMKACATwAAMygAgFAAADUoAIBRAAA2KQCAUgY7msoAKwCAUwAAAAAAAAAAAgAAAAAAAAAAJiUAADWGKQIAAgAyFfUCCjgBAgMnAgQEACcCBgQDADgEBgUtCAECABABBQEnAwIEAQAoAgIFLQ4EBQAoBQIFLQ4EBScCBQQDADgCBQQtDQIEACgEAgQtDgQCJwIEAAMoAgAFBicQJwIGBQAnAgcAAScCCAACJAIAAwAAAWwjAAAD9C0IAQMnAgkEBQAQAQkBJwMDBAEAKAMCCR8kgEqATAAJLQgBCQAAAQIBLQ4DCS0IAQMAAAECAS4KgEYAAycCCwQMLQgADC0MCQ0tDAMOLgiATQAPABAACwAlAAA1ry0EAAAtDA0KJwIMBA0tCAANLQwJDi0MAw8AEAAMACUAADYoLQQAAC0MDgsnAg0EDi0IAA4tDAsPABAADQAlAAA2ny0EAAAtDA8MJwINBA4tCAAOLQwJDy0MAxAuCIBNABEAEAANACUAADWvLQQAAC0MDwsnAg4EDy0IAA8tDAkQLQwDES4IgE0AEgAQAA4AJQAANa8tBAAALQwQDS0IAQMAAAECAS4KgEUAAy0IAQkAAAECAS4KgEgACS0IAQ4AAAECAScCDwDJLQ4PDicCDwQQLQgAEC0MAxEtDAkSLQwOEwAQAA8AJQAANsQtBAAAJwITBBQtCAAULQwDFS0MCRYtDA4XLQwEGC4IgE8AGS4IgEgAGgAQABMAJQAANuktBAAALQwVDy0MFhAtDBcRLQwYEicCFAQVLQgAFS0MDxYtDBAXLQwRGC0MEhkAEAAUACUAADk/LQQAAC0MFgMtDBcJLQwYDi0MGRMMOAUMFAsoABSARQAVJAIAFQAAA1AnAhYEADwJARYKOAkGFCQCABQAAANmJwIVBAA8CQEVCygAA4BHAAkkAgAJAAADfycCFAQAPAkBFB4CAAMGJwIJBBQtCAAULQwPFS0MEBYtDBEXLQwSGC4IgFIAGS0MAxotDAwbLQwKHAAQAAkAJQAAOtUtBAAAMAwACwAHMAwADQAILQ0CAwAoAwIDLQ4DAgAoAgIKLQ0KCScCCwQCADgKCwM7DQADAAkjAAAD9CkCAAMABbTXqwo4AQMJJAIACQAABA8jAAAHQS0IAQkAAAECAS4KgEUACS0IAQoAAAECAS4KgEgACi0IAQsAAAECAScCDAC9LQ4MCycCDAQNLQgADS0MCQ4tDAoPLQwLEAAQAAwAJQAANsQtBAAAJwIQBBEtCAARLQwJEi0MChMtDAsULQwEFS4IgE8AFi4IgEgAFwAQABAAJQAANuktBAAALQwSDC0MEw0tDBQOLQwVDycCEQQSLQgAEi0MDBMtDA0ULQwOFS0MDxYAEAARACUAADk/LQQAAC0MEwktDBQKLQwVCy0MFhAtCAERAAABAgEtDgkRLQgBEgAAAQIBLQ4KEi0IARMAAAECAS0OCxMtCAEUAAABAgEtDhAUHgIAFQYCOBUKFg44ChUXJAIAFwAABSwlAAA7wAo4FgYKJAIACgAABqgjAAAFPi0IARcAAAECAS4KgFIAFyQCAAoAAAYiIwAABVonAhgFAQI4FhgZDjgYFhokAgAaAAAFdiUAADvAHAwZGAYnAhkFAgw4GRYaJAIAGgAABZsjAAAFki0MBgojAAAFuwI4FhkGDjgZFhokAgAaAAAFsiUAADvALQwGCiMAAAW7HAwWBgYEOAYYFicCGAYCBjgWGBkpAgAWBkuaHv8EOAYWGAA4GBkGDjgYBhYkAgAWAAAF9CUAADvSBygABoBSABYBMIBSABYABg8wgFIABgAYJAIAGAAABhklAAA70i0OBhcjAAAGIi0NFwYEOAkGCicCFwYACjgXBhYkAgAWAAAGVAY4CgYZCjgZCRgkAgAYAAAGVCUAADvkBygACoBSAAYtDgYRLQ4VEi0OCxMtDhAUJwIJBBYtCAAWLQwMFy0MDRgtDA4ZLQwPGi0MBhstDBUcLQwLHS0MEB4AEAAJACUAADrVLQQAACMAAAaoLQ0RBi0NEgktDRMKLQ0UCxwMBgwAHAwJBgAcDAoJACcCDQQEJwIPBAMAOA0PDi0IAQoAEAEOAScDCgQBACgKAg4tDg0OACgOAg4tDg0OJwIOBAMAOAoODS0MDQ4tDgwOACgOAg4tDgYOACgOAg4tDgkOACgOAg4tDgsOACgKAgstDQsJJwIMBAIAOAsMBjsNAAYACSMAAAdBKQIABgDBzK64CjgBBgkpAgAGAIyeVHIpAgAKAF/xtKokAgAJAAAHbiMAAAy4LQgBCScCCwQFABABCwEnAwkEAQAoCQILHySASoBMAAstCAELAAABAgEtDgkLLQgBCQAAAQIBLgqARgAJJwINBA4tCAAOLQwLDy0MCRAAEAANACUAADYoLQQAAC0MDwwnAg4EDy0IAA8tDAwQABAADgAlAAA2ny0EAAAtDBANJwIOBA8tCAAPLQwLEC0MCREuCIBOABIAEAAOACUAADv2LQQAAC0MEAwnAg8EEC0IABAtDAsRLQwJEi4IgE4AEwAQAA8AJQAAO/YtBAAALQwRDicCEAQRLQgAES0MCxItDAkTLgiATQAUABAAEAAlAAA1ry0EAAAtDBIPLQgBCQAAAQIBLgqARQAJLQgBCwAAAQIBLgqASAALLQgBEAAAAQIBJwIRALctDhEQJwIRBBItCAASLQwJEy0MCxQtDBAVABAAEQAlAAA2xC0EAAAeAgARAR4CABIALQ0CEwAoEwITLQ4TAicCFAQBJwIWBAMAOBQWFS0IARMAEAEVAScDEwQBACgTAhUtDhQVACgVAhUtDhQVJwIVBAMAOBMVFC0MFBUtDhEVJwIVBBYtCAAWLgiARgAXLQwCGC4IgEoAGS0MExoAEAAVACUAADxvLQQAAC0MFxEtDBgULQ0UEwAoEwITLQ4TFCcCFQQBJwIXBAMAOBUXFi0IARMAEAEWAScDEwQBACgTAhYtDhUWACgWAhYtDhUWJwIWBAMAOBMWFS0MFRYtDhIWJwIWBBctCAAXLQwRGC0MFBkuCIBKABotDBMbABAAFgAlAAA8by0EAAAtDBgSLQwZFS0NFREAKBECES0OERUcDA0RAAAoEgINLgQAFYADKACABAQAASUAAD0+LgiABQATLgiABgAULQ4RFC0NExIAKBICEi0OEhMAKA0CEi4EABOAAygAgAQEAAElAAA9Pi4IgAUAFC4IgAYAFS0ODBUnAg0EFS0IABUtDAYWABAADQAlAAA+vi0EAAAtDBYMLQ0UDQAoDQINLQ4NFCcCFQQWLQgAFi0MCRctDAsYLQwQGS0MDxotDAwbLQwSHC0MFB0uCIBFAB4uCIBIAB8uCIBFACAuCIBIACEAEAAVACUAAD7TLQQAAC0MFw0tDBgTCygADYBGAAwkAgAMAAAKyScCEgQAPAkBEh4CAAwALQ0CDQAoDQINLQ4NAicCEgQBJwIVBAMAOBIVFC0IAQ0AEAEUAScDDQQBACgNAhQtDhIUACgUAhQtDhIUJwIUBAMAOA0UEi0MEhQtDg4UJwIUBBUtCAAVLgiARgAWLQwCFy4IgEoAGC0MDRkAEAAUACUAADxvLQQAAC0MFg4tDBcSLQ0SDQAoDQINLQ4NEgAoDgINLgQAEoADKACABAQAASUAAD0+LgiABQAULgiABgAVLQ4RFS0NFA4AKA4CDi0ODhQnAhEEAScCFQQDADgRFRItCAEOABABEgEnAw4EAQAoDgISLQ4REgAoEgISLQ4REicCEgQDADgOEhEtDBESLQ4PEicCEgQVLQgAFS0MDRYtDBQXLgiASgAYLQwOGQAQABIAJQAAPG8tBAAALQwWDy0MFxEnAg4EFC0IABQtDAoVABAADgAlAAA+vi0EAAAtDBUNLQ0RDgAoDgIOLQ4OEScCFAQVLQgAFS0MCRYtDAsXLQwQGC0MDBktDA0aLQwPGy0MERwuCIBFAB0uCIBIAB4uCIBFAB8uCIBIACAAEAAUACUAAD7TLQQAAC0MFg4tDBcSCygADoBGAAkkAgAJAAAMmicCCwQAPAkBCwAoAgIMLQ0MCycCDQQCADgMDQk7DQAJAAsjAAAMuAo4AQoJJAIACQAADMojAAAPxC0IAQknAgoEBAAQAQoBJwMJBAEAKAkCCh8kgEqARAAKLQgBCgAAAQIBLQ4JCi0IAQkAAAECAS4KgEYACScCDAQNLQgADS0MCg4tDAkPLgiATQAQABAADAAlAAA//S0EAAAtDA4LJwINBA4tCAAOLQwKDy0MCRAAEAANACUAAEB2LQQAAC0MDwwnAg4EDy0IAA8tDAwQABAADgAlAAA2ny0EAAAtDBANJwIOBA8tCAAPLQwKEC0MCREuCIBNABIAEAAOACUAAD/9LQQAAC0MEAwtCAEJAAABAgEuCoBFAAktCAEKAAABAgEuCoBIAAotCAEOAAABAgEnAg8AtS0ODw4nAg8EEC0IABAtDAkRLQwKEi0MDhMAEAAPACUAADbELQQAAB4CAA8BHgIAEAAKOA8QESQCABEAAA4JJQAAQO0eAgAPACcCEQQSLQgAEi0MAxMAEAARACUAAD6+LQQAAC0MExAtDQIRACgRAhEtDhECJwITBBQtCAAULQwJFS0MChYtDA4XLQwPGC0MEBkuCIBGABotDAIbLgiARQAcLgiASAAdLgiARQAeLgiASAAfABAAEwAlAAA+0y0EAAAtDBURLQwWEi0NEg8AKA8CDy0ODxILKAARgEwADyQCAA8AAA61JwIQBAA8CQEQJwIQBBEtCAARLQwJEi0MChMtDA4ULQwHFQAQABAAJQAAQP8tBAAALQwSDwo4DwwQJAIAEAAADvYnAhEEADwJAREnAhIEEy0IABMtDAkULQwKFS0MDhYuCIBNABcuCIBQABgtDAsZABAAEgAlAABBDy0EAAAtDBQMLQwVDy0MFhAtDBcRJwIKBBItCAASLQwMEy0MDxQtDBAVLQwRFgAQAAoAJQAAQ2UtBAAALQwTCQA4CQ0KDjgJCgskAgALAAAPeyUAADvSJwIJBBItCAASLQwMEy0MDxQtDBAVLQwRFi0MChcAEAAJACUAAEO0LQQAAAAoAgILLQ0LCicCDAQCADgLDAk7DQAJAAojAAAPxCkCAAkA2jQ0AQo4AQkKKQIACQD6osUqJAIACgAAD+gjAAAS2y0IAQonAgsEAwAQAQsBJwMKBAEAKAoCCx8kgEqASwALLQgBCwAAAQIBLQ4KCy0IAQoAAAECAS4KgEYACicCDQQOLQgADi0MCw8tDAoQLgiATQARABAADQAlAABD6y0EAAAtDA8MJwIOBA8tCAAPLQwLEC0MChEAEAAOACUAAERkLQQAAC0MEA0nAgsEDi0IAA4tDA0PABAACwAlAAA2ny0EAAAtDA8KLQgBCwAAAQIBLgqARQALLQgBDQAAAQIBLgqASAANLQgBDgAAAQIBJwIPALAtDg8OJwIPBBAtCAAQLQwLES0MDRItDA4TABAADwAlAAA2xC0EAAAeAgAPAB4CABABLQ0CEQAoEQIRLQ4RAicCEgQBJwIUBAMAOBIUEy0IAREAEAETAScDEQQBACgRAhMtDhITACgTAhMtDhITJwITBAMAOBETEi0MEhMtDhATJwITBBQtCAAULgiARgAVLQwCFi4IgEoAFy0MERgAEAATACUAADxvLQQAAC0MFRAtDBYSLQ0SEQAoEQIRLQ4REicCEwQBJwIVBAMAOBMVFC0IAREAEAEUAScDEQQBACgRAhQtDhMUACgUAhQtDhMUJwIUBAMAOBEUEy0MExQtDgwUJwIUBBUtCAAVLQwQFi0MEhcuCIBKABgtDBEZABAAFAAlAAA8by0EAAAtDBYMLQwXEy0NExAAKBACEC0OEBMcDAoQAAAoDAIKLgQAE4ADKACABAQAASUAAD0+LgiABQARLgiABgASLQ4QEicCEAQSLQgAEi0MCRMAEAAQACUAAD6+LQQAAC0MEwwtDREQACgQAhAtDhARJwITBBQtCAAULQwLFS0MDRYtDA4XLQwPGC0MDBktDAoaLQwRGy4IgEUAHC4IgEgAHS4IgEUAHi4IgEgAHwAQABMAJQAAPtMtBAAALQwVEC0MFhILKAAQgEYACiQCAAoAABK9JwILBAA8CQELACgCAgwtDQwLJwINBAIAOAwNCjsNAAoACyMAABLbCjgBCQopAgAJACnVqC8nAgsABScCDAQFJwINBAYkAgAKAAATBSMAABqwLQgBCicCDgQEABABDgEnAwoEAQAoCgIOHySASoBEAA4tCAEOAAABAgEtDgoOLQgBCgAAAQIBLgqARgAKJwIQBBEtCAARLQwOEi0MChMuCIBNABQAEAAQACUAAD/9LQQAAC0MEg8nAhEEEi0IABItDA4TLQwKFC4IgE0AFQAQABEAJQAAP/0tBAAALQwTECcCEgQTLQgAEy0MDhQtDAoVABAAEgAlAABAdi0EAAAtDBQRJwIOBBItCAASLQwREwAQAA4AJQAANp8tBAAALQwTCi0IAQ4AAAECAS4KgEUADi0IAREAAAECAS4KgEgAES0IARIAAAECAScCEwCsLQ4TEicCEwQULQgAFC0MDhUtDBEWLQwSFwAQABMAJQAANsQtBAAAHgIAEwEeAgAUAAo4ExQVJAIAFQAAFEQlAABE2x4CABMAJwIVBBYtCAAWLQwDFwAQABUAJQAAPr4tBAAALQwXFC0NAhUAKBUCFS0OFQInAhcEGC0IABgtDA4ZLQwRGi0MEhstDBMcLQwUHS4IgEYAHi0MAh8uCIBFACAuCIBIACEuCIBFACIuCIBIACMAEAAXACUAAD7TLQQAAC0MGRUtDBoWLQ0WEwAoEwITLQ4TFgsoABWATAATJAIAEwAAFPAnAhQEADwJARQBKAAWgEQAFC0NFBMAOBYMFS0NFRQAOBYNFy0NFxUcDBMXBhwMFxYAHAwWEwYcDBQXBhwMFxYAHAwWFAYnAhcEGC0IABgtDAkZABAAFwAlAAA+vi0EAAAtDBkWHAwWFwAnAhgEAicCGgQDADgYGhktCAEWABABGQEnAxYEAQAoFgIZLQ4YGQAoGQIZLQ4YGScCGQQDADgWGRgtDBgZLQ4XGQAoGQIZLgqASAAZACgWAhktDRkYJwIaBAIAOBkaFzoDiIBDgEMAFQAXABggAgAVIQIAFi0IARgAKBgCGy0NGxonAhwEAgA4GxwZIjSARgAWABktDBYaJwIcBAMAOBocGwAQARsBJwMYBAEAKBgCHC0OGhwAKBwCHC0OGhwtDBoXBigXAhckAgAVAAAWTCMAABYjLQ0YFQAoFQIVLQ4VGAAoGAIZLQ0ZFicCGgQCADgZGhU8DRUWIwAAFkwtDRgVACgVAhUtDhUYCygAF4BKABUkAgAVAAAWcicCFgQAPAkBFgEoABiARAAWLQ0WFRwMFRcGHAwXFgAcDBYVBicCGgQbLQgAGy0MDhwtDBEdLQwSHi4IgE0AHy4IgFAAIC0MDyEAEAAaACUAAEEPLQQAAC0MHBYtDB0XLQweGC0MHxknAhsEHC0IABwtDBYdLQwXHi0MGB8tDBkgABAAGwAlAABDZS0EAAAtDB0aJwIfBCAtCAAgLQwOIS0MESItDBIjLQwLJC4IgFEAJS0MDyYAEAAfACUAAEEPLQQAAC0MIRstDCIcLQwjHS0MJB4nAh8EIC0IACAtDBshLQwcIi0MHSMtDB4kABAAHwAlAABDZS0EAAAtDCEPAjgaChsOOAoaHCQCABwAABd+JQAAO8AEOBsVGicCHQYACjgdFRwkAgAcAAAXrAY4GhUfCjgfGx4kAgAeAAAXrCUAADvkBygAGoBSABUEOBUUGicCHQYACjgdFBwkAgAcAAAX4gY4GhQfCjgfFR4kAgAeAAAX4iUAADvkBjgaBRQnAhwEHS0IAB0tDBMeLQwPHy4IgEcAIC4IgEcAIQAQABwAJQAARO0tBAAALQweFS0MHxoMOBUUDyQCAA8AABgwJwITBAA8CQETJwIPBBwtCAAcLQwWHS0MFx4tDBgfLQwZIC0MGyEAEAAPACUAAEO0LQQAACcCEwQbLQgAGy0MDhwtDBEdLQwSHi0MBx8AEAATACUAAED/LQQAAC0MHA8eAgATAC0NAhQAKBQCFC0OFAInAhUEAScCFwQDADgVFxYtCAEUABABFgEnAxQEAQAoFAIWLQ4VFgAoFgIWLQ4VFicCFgQDADgUFhUtDBUWLQ4TFicCFgQbLQgAGy4IgEYAHC0MAh0uCIBKAB4tDBQfABAAFgAlAAA8by0EAAAtDBwTLQwdFS0NFRQAKBQCFC0OFBUnAhYEAScCGAQDADgWGBctCAEUABABFwEnAxQEAQAoFAIXLQ4WFwAoFwIXLQ4WFycCFwQDADgUFxYtDBYXLQ4QFycCFwQbLQgAGy0MExwtDBUdLgiASgAeLQwUHwAQABcAJQAAPG8tBAAALQwcEC0MHRYtDRYTACgTAhMtDhMWHAwKEwAAKBACCi4EABaAAygAgAQEAAElAAA9Pi4IgAUAFC4IgAYAFS0OExUtDRQQACgQAhAtDhAUACgKAhAuBAAUgAMoAIAEBAABJQAAPT4uCIAFABMuCIAGABUuCoBIABUnAhQEGy0IABstDAYcABAAFAAlAAA+vi0EAAAtDBwKLQ0TBgAoBgIGLQ4GEycCFQQbLQgAGy0MDhwtDBEdLQwSHi0MDx8tDAogLQwQIS0MEyIuCIBFACMuCIBIACQuCIBFACUuCIBIACYAEAAVACUAAD7TLQQAAC0MHAYtDB0UCygABoBGAAokAgAKAAAakicCDgQAPAkBDgAoAgIOLQ0OCicCDwQCADgODwY7DQAGAAojAAAasCkCAAYA6qeYLQo4AQYKKQIABgBjMTGyJAIACgAAGtQjAAAdxy0IAQonAg4EAwAQAQ4BJwMKBAEAKAoCDh8kgEqASwAOLQgBDgAAAQIBLQ4KDi0IAQoAAAECAS4KgEYACicCEAQRLQgAES0MDhItDAoTLgiATQAUABAAEAAlAABD6y0EAAAtDBIPJwIRBBItCAASLQwOEy0MChQAEAARACUAAERkLQQAAC0MExAnAg4EES0IABEtDBASABAADgAlAAA2ny0EAAAtDBIKLQgBDgAAAQIBLgqARQAOLQgBEAAAAQIBLgqASAAQLQgBEQAAAQIBJwISAKItDhIRJwISBBMtCAATLQwOFC0MEBUtDBEWABAAEgAlAAA2xC0EAAAeAgASAB4CABMBLQ0CFAAoFAIULQ4UAicCFQQBJwIXBAMAOBUXFi0IARQAEAEWAScDFAQBACgUAhYtDhUWACgWAhYtDhUWJwIWBAMAOBQWFS0MFRYtDhMWJwIWBBctCAAXLgiARgAYLQwCGS4IgEoAGi0MFBsAEAAWACUAADxvLQQAAC0MGBMtDBkVLQ0VFAAoFAIULQ4UFScCFgQBJwIYBAMAOBYYFy0IARQAEAEXAScDFAQBACgUAhctDhYXACgXAhctDhYXJwIXBAMAOBQXFi0MFhctDg8XJwIXBBgtCAAYLQwTGS0MFRouCIBKABstDBQcABAAFwAlAAA8by0EAAAtDBkPLQwaFi0NFhMAKBMCEy0OExYcDAoTAAAoDwIKLgQAFoADKACABAQAASUAAD0+LgiABQAULgiABgAVLQ4TFScCEwQVLQgAFS0MBhYAEAATACUAAD6+LQQAAC0MFg8tDRQTACgTAhMtDhMUJwIWBBctCAAXLQwOGC0MEBktDBEaLQwSGy0MDxwtDAodLQwUHi4IgEUAHy4IgEgAIC4IgEUAIS4IgEgAIgAQABYAJQAAPtMtBAAALQwYEy0MGRULKAATgEYACiQCAAoAAB2pJwIOBAA8CQEOACgCAg8tDQ8OJwIQBAIAOA8QCjsNAAoADiMAAB3HCjgBBgokAgAKAAAd2SMAACT7LQgBBicCCgQEABABCgEnAwYEAQAoBgIKHySASoBEAAotCAEKAAABAgEtDgYKLQgBBgAAAQIBLgqARgAGJwIPBBAtCAAQLQwKES0MBhIuCIBNABMAEAAPACUAAD/9LQQAAC0MEQ4nAhAEES0IABEtDAoSLQwGEy4IgE0AFAAQABAAJQAAP/0tBAAALQwSDycCEQQSLQgAEi0MChMtDAYUABAAEQAlAABAdi0EAAAtDBMQJwIKBBEtCAARLQwQEgAQAAoAJQAANp8tBAAALQwSBi0IAQoAAAECAS4KgEUACi0IARAAAAECAS4KgEgAEC0IAREAAAECAScCEgCVLQ4SEScCEgQTLQgAEy0MChQtDBAVLQwRFgAQABIAJQAANsQtBAAAHgIAEgEeAgATAAo4EhMUJAIAFAAAHxglAABGDh4CABIAJwIUBBUtCAAVLQwDFgAQABQAJQAAPr4tBAAALQwWEy0NAhQAKBQCFC0OFAInAhYEFy0IABctDAoYLQwQGS0MERotDBIbLQwTHC4IgEYAHS0MAh4uCIBFAB8uCIBIACAuCIBFACEuCIBIACIAEAAWACUAAD7TLQQAAC0MGBQtDBkVLQ0VEgAoEgISLQ4SFQsoABSATAASJAIAEgAAH8QnAhMEADwJARMBKAAVgEQAEy0NExIAOBUMFC0NFBMAOBUNFC0NFAwcDBIUBhwMFA0AHAwNEgYcDBMUBhwMFA0AHAwNEwYnAhQEFS0IABUtDAkWABAAFAAlAAA+vi0EAAAtDBYNHAwNCQAnAhQEAicCFgQDADgUFhUtCAENABABFQEnAw0EAQAoDQIVLQ4UFQAoFQIVLQ4UFScCFQQDADgNFRQtDBQVLQ4JFQAoFQIVLgqASAAVACgNAhUtDRUUJwIWBAIAOBUWCToDiIBDgEMADAAJABQgAgAJIQIADC0IARQAKBQCFy0NFxYnAhgEAgA4FxgVIjSARgAMABUtDAwWJwIYBAMAOBYYFwAQARcBJwMUBAEAKBQCGC0OFhgAKBgCGC0OFhgtDBYNBigNAg0kAgAJAAAhICMAACD3LQ0UCQAoCQIJLQ4JFAAoFAIVLQ0VDCcCFgQCADgVFgk8DQkMIwAAISAtDRQJACgJAgktDgkUCygADYBKAAkkAgAJAAAhRicCDAQAPAkBDAEoABSARAAMLQ0MCRwMCQ0GHAwNDAAcDAwJBicCFgQXLQgAFy0MChgtDBAZLQwRGi4IgE0AGy4IgFAAHC0MDh0AEAAWACUAAEEPLQQAAC0MGAwtDBkNLQwaFC0MGxUnAhcEGC0IABgtDAwZLQwNGi0MFBstDBUcABAAFwAlAABDZS0EAAAtDBkWJwIXBBgtCAAYLQwKGS0MEBotDBEbLQwLHC4IgFEAHS0MDh4AEAAXACUAAEEPLQQAAC0MGQwtDBoNLQwbFC0MHBUnAhgEGS0IABktDAwaLQwNGy0MFBwtDBUdABAAGAAlAABDZS0EAAAtDBoXBDgWCQwnAhQGAAo4FAkNJAIADQAAImkGOAwJGAo4GBYVJAIAFQAAImklAAA75AcoAAyAUgAJBDgJEwwnAhQGAAo4FBMNJAIADQAAIp8GOAwTFgo4FgkVJAIAFQAAIp8lAAA75AY4DAUJJwINBBgtCAAYLQwSGS0MFxotDAYbLgiARwAcABAADQAlAABE7S0EAAAtDBkFLQwaDAw4BQkNJAIADQAAIusnAgUEADwJAQUnAhMEFC0IABQtDAoVLQwQFi0MERctDAsYLgiAUQAZLQwOGgAQABMAJQAAQQ8tBAAALQwVBS0MFgktDBcNLQwYEicCDgQTLQgAEy0MBRQtDAkVLQwNFi0MEhctDAwYABAADgAlAABDtC0EAAAnAgkEEi0IABItDAoTLQwQFC0MERUtDAgWABAACQAlAABA/y0EAAAtDBMFLQ0CCQAoCQIJLQ4JAicCDAQBJwIOBAMAOAwODS0IAQkAEAENAScDCQQBACgJAg0tDgwNACgNAg0tDgwNJwINBAMAOAkNDC0MDA0tDg8NJwIOBBItCAASLgiARgATLQwCFC4IgEoAFS0MCRYAEAAOACUAADxvLQQAAC0MEwwtDBQNLQ0NCQAoCQIJLQ4JDRwMBgkAACgMAgYuBAANgAMoAIAEBAABJQAAPT4uCIAFAA4uCIAGAA8tDgkPKQIACQBFG1+uJwINBBItCAASLQwJEwAQAA0AJQAAPr4tBAAALQwTDC0NDgkAKAkCCS0OCQ4nAg8EEi0IABItDAoTLQwQFC0MERUtDAUWLQwMFy0MBhgtDA4ZLgiARQAaLgiASAAbLgiARQAcLgiASAAdABAADwAlAAA+0y0EAAAtDBMJLQwUDQsoAAmARgAFJAIABQAAJN0nAgYEADwJAQYAKAICCS0NCQYnAgoEAgA4CQoFOw0ABQAGIwAAJPspAgAFALXzC4oKOAEFBikCAAUAlEiUnCQCAAYAACUfIwAAKe4tCAEGJwIJBAUAEAEJAScDBgQBACgGAgkfJIBKgEwACS0IAQkAAAECAS0OBgktCAEGAAABAgEuCoBGAAYnAgwEDS0IAA0tDAkOLQwGDwAQAAwAJQAANigtBAAALQwOCicCDQQOLQgADi0MCg8AEAANACUAADafLQQAAC0MDwwnAg0EDi0IAA4tDAkPLQwGEC4IgE4AEQAQAA0AJQAAO/YtBAAALQwPCicCDgQPLQgADy0MCRAtDAYRLgiATQASABAADgAlAAA1ry0EAAAtDBANJwIPBBAtCAAQLQwJES0MBhIuCIBNABMAEAAPACUAADWvLQQAAC0MEQ4tCAEGAAABAgEuCoBFAAYtCAEJAAABAgEuCoBIAAktCAEPAAABAgEnAhAAhi0OEA8nAhAEES0IABEtDAYSLQwJEy0MDxQAEAAQACUAADbELQQAAB4CABABLQ0CEQAoEQIRLQ4RAicCEgQBJwIUBAMAOBIUEy0IAREAEAETAScDEQQBACgRAhMtDhITACgTAhMtDhITJwITBAMAOBETEi0MEhMtDhATJwITBBQtCAAULgiARgAVLQwCFi4IgEoAFy0MERgAEAATACUAADxvLQQAAC0MFRAtDBYSLQ0SEQAoEQIRLQ4REhwMDBEAACgQAgwuBAASgAMoAIAEBAABJQAAPT4uCIAFABMuCIAGABQtDhEULQ0TEAAoEAIQLQ4QEwAoDAIQLgQAE4ADKACABAQAASUAAD0+LgiABQASLgiABgAULQ4KFCkCAAoAxhGwxScCEwQULQgAFC0MChUAEAATACUAAD6+LQQAAC0MFQwtDRIKACgKAgotDgoSJwIUBBUtCAAVLQwGFi0MCRctDA8YLQwOGS0MDBotDBAbLQwSHC4IgEUAHS4IgEgAHi4IgEUAHy4IgEgAIAAQABQAJQAAPtMtBAAALQwWCi0MFxMLKAAKgEYADCQCAAwAACf/JwIQBAA8CQEQHgIACgAtDQIMACgMAgwtDgwCJwIQBAEnAhQEAwA4EBQSLQgBDAAQARIBJwMMBAEAKAwCEi0OEBIAKBICEi0OEBInAhIEAwA4DBIQLQwQEi0ODRInAhIEFC0IABQuCIBGABUtDAIWLgiASgAXLQwMGAAQABIAJQAAPG8tBAAALQwVDS0MFhAtDRAMACgMAgwtDgwQACgNAgwuBAAQgAMoAIAEBAABJQAAPT4uCIAFABIuCIAGABQtDhEULQ0SDQAoDQINLQ4NEicCEAQBJwIUBAMAOBAUES0IAQ0AEAERAScDDQQBACgNAhEtDhARACgRAhEtDhARJwIRBAMAOA0REC0MEBEtDg4RJwIRBBQtCAAULQwMFS0MEhYuCIBKABctDA0YABAAEQAlAAA8by0EAAAtDBUOLQwWECcCDQQULQgAFC0MBRUAEAANACUAAD6+LQQAAC0MFQwtDRANACgNAg0tDg0QJwISBBQtCAAULQwGFS0MCRYtDA8XLQwKGC0MDBktDA4aLQwQGy4IgEUAHC4IgEgAHS4IgEUAHi4IgEgAHwAQABIAJQAAPtMtBAAALQwVDS0MFhELKAANgEYABiQCAAYAACnQJwIJBAA8CQEJACgCAgotDQoJJwIMBAIAOAoMBjsNAAYACSMAACnuCjgBBQYkAgAGAAAqACMAAC1uLQgBBScCBgQEABABBgEnAwUEAQAoBQIGHySASoBEAAYtCAEGAAABAgEtDgUGLQgBBQAAAQIBLgqARgAFJwIKBAwtCAAMLQwGDS0MBQ4uCIBNAA8AEAAKACUAAD/9LQQAAC0MDQknAgwEDS0IAA0tDAYOLQwFDwAQAAwAJQAAQHYtBAAALQwOCicCDQQOLQgADi0MCg8AEAANACUAADafLQQAAC0MDwwnAg0EDi0IAA4tDAYPLQwFEC4IgE0AEQAQAA0AJQAAP/0tBAAALQwPCi0IAQUAAAECAS4KgEUABS0IAQYAAAECAS4KgEgABi0IAQ0AAAECAScCDgBkLQ4ODScCDgQPLQgADy0MBRAtDAYRLQwNEgAQAA4AJQAANsQtBAAAHgIADgEeAgAPAAo4Dg8QJAIAEAAAKz8lAABGIB4CAA4AJwIQBBEtCAARLQwDEgAQABAAJQAAPr4tBAAALQwSDy0NAgMAKAMCAy0OAwInAhEEEi0IABItDAUTLQwGFC0MDRUtDA4WLQwPFy4IgEYAGC0MAhkuCIBFABouCIBIABsuCIBFABwuCIBIAB0AEAARACUAAD7TLQQAAC0MEwMtDBQQLQ0QDgAoDgIOLQ4OEAsoAAOATAAOJAIADgAAK+snAg8EADwJAQ8BKAAQgEQADi0NDgMcDAMPBhwMDw4AHAwOAwYnAg8EEC0IABAtDAURLQwGEi0MDRMtDAgUABAADwAlAABA/y0EAAAtDBEOCjgKDg8kAgAPAAAsRycCEAQAPAkBECcCEQQSLQgAEi0MBRMtDAYULQwNFS0MCxYuCIBRABctDAkYABAAEQAlAABBDy0EAAAtDBMKLQwUDi0MFQ8tDBYQJwISBBMtCAATLQwKFC0MDhUtDA8WLQwQFwAQABIAJQAAQ2UtBAAALQwUEScCDwQSLQgAEi0MAxMtDBEULgiARwAVLQwMFgAQAA8AJQAARO0tBAAALQwTCi0MFA4nAhEEEi0IABItDAUTLQwGFC0MDRUtDAsWLgiAUQAXLQwJGAAQABEAJQAAQQ8tBAAALQwTAy0MFAwtDBUPLQwWECcCBQQRLQgAES0MAxItDAwTLQwPFC0MEBUtDA4WABAABQAlAABDtC0EAAAAKAICBi0NBgUnAgkEAgA4BgkDOw0AAwAFIwAALW4pAgACALbv3KQKOAECAyQCAAMAAC2JIwAAL18tCAECJwIDBAIAEAEDAScDAgQBACgCAgMfJIBKgEoAAy0IAQMAAAECAS0OAgMtCAECAAABAgEuCoBGAAInAgYEDC0IAAwtDAMNLQwCDgAQAAYAJQAARjItBAAALQwNBQEoAAWASgADLQ0DAi0IAQMAAAECAS4KgEUAAy0IAQUAAAECAS4KgEgABS0IAQYAAAECAScCCQBjLQ4JBicCCQQMLQgADC0MAw0tDAUOLQwGDwAQAAkAJQAANsQtBAAAHgIACQkKOAkHCiQCAAoAAC5eJQAARo8nAg4EDy0IAA8tDAMQLQwFES0MBhItDAQTLgiATwAULQwCFQAQAA4AJQAANuktBAAALQwQCS0MEQotDBIMLQwTDScCDgQPLQgADy0MCRAtDAoRLQwMEi0MDRMAEAAOACUAADk/LQQAAC0MEAItDBEDLQwSBS0MEwYcDAIJABwMAwIAHAwFAwAnAgoEBCcCDQQDADgKDQwtCAEFABABDAEnAwUEAQAoBQIMLQ4KDAAoDAIMLQ4KDCcCDAQDADgFDAotDAoMLQ4JDAAoDAIMLQ4CDAAoDAIMLQ4DDAAoDAIMLQ4GDAAoBQIGLQ0GAycCCQQCADgGCQI7DQACAAMjAAAvXykCAAIA7bDgiQo4AQIDJAIAAwAAL3ojAAAydi0IAQInAgMEAgAQAQMBJwMCBAEAKAICAx8kgEqASgADLQgBAwAAAQIBLQ4CAy0IAQIAAAECAS4KgEYAAicCBgQMLQgADC0MAw0tDAIOABAABgAlAABGMi0EAAAtDA0FASgABYBKAAMtDQMCLQgBAwAAAQIBLgqARQADLQgBBQAAAQIBLgqASAAFLQgBBgAAAQIBJwIJAEQtDgkGJwIJBAwtCAAMLQwDDS0MBQ4tDAYPABAACQAlAAA2xC0EAAAeAgAJCQo4CQcKJAIACgAAME8lAABGoScCDgQPLQgADy0MAxAtDAURLQwGEi4IgE0AEy4IgFAAFC0MAhUAEAAOACUAAEEPLQQAAC0MEAktDBEKLQwSDC0MEw0nAg8EEC0IABAtDAkRLQwKEi0MDBMtDA0UABAADwAlAABDZS0EAAAtDBEOJwIPBBAtCAAQLQwDES0MBRItDAYTLQwLFC4IgFEAFS0MAhYAEAAPACUAAEEPLQQAAC0MEQktDBIKLQwTDC0MFA0nAgsEDy0IAA8tDAkQLQwKES0MDBItDA0TABAACwAlAABDZS0EAAAtDBACJwINBA8tCAAPLQwDEC0MBREtDAYSLQwEEy4IgE8AFC4IgEgAFQAQAA0AJQAANuktBAAALQwQCS0MEQotDBILLQwTDCcCDQQPLQgADy0MCRAtDAoRLQwLEi0MDBMAEAANACUAADk/LQQAAC0MEAMtDBEELQwSBS0MEwYEOAIDCScCCwYACjgLAwokAgAKAAAx0QY4CQMNCjgNAgwkAgAMAAAx0SUAADvkJwIKBA8tCAAPLQwJEC4IgFIAEQAQAAoAJQAARrMtBAAALQwQAxwMDgkAHAwCCgAcDAMCACcCCwQDJwINBAMAOAsNDC0IAQMAEAEMAScDAwQBACgDAgwtDgsMACgMAgwtDgsMJwIMBAMAOAMMCy0MCwwtDgkMACgMAgwtDgoMACgMAgwtDgIMACgDAgotDQoJJwILBAIAOAoLAjsNAAIACSMAADJ2KQIAAgCRTdXyCjgBAgMkAgADAAAykSMAADO5LQgBAgAAAQIBLgqARQACLQgBAwAAAQIBLgqASAADLQgBBAAAAQIBJwIFACgtDgUEJwIFBAktCAAJLQwCCi0MAwstDAQMABAABQAlAAA2xC0EAAAeAgAFCQo4BQcGJAIABgAAMvslAABHMCcCBgQJLQgACS0MAgotDAMLLQwEDC0MBw0AEAAGACUAAED/LQQAAC0MCgUnAgcECS0IAAktDAIKLQwDCy0MBAwtDAgNABAABwAlAABA/y0EAAAtDAoGJwIDBAInAgcEAwA4AwcELQgBAgAQAQQBJwMCBAEAKAICBC0OAwQAKAQCBC0OAwQnAgQEAwA4AgQDLQwDBC0OBQQAKAQCBC0OBgQAKAICBS0NBQQnAgYEAgA4BQYDOw0AAwAEIwAAM7knAgICdCcCAwJyJwIEAm4nAgUCcycCBgJlJwIHAmwnAggCYycCCQJvJwIKAlUnAgsCaycCDAJ3JwINAiAnAg4CeycCDwJ9LQgBECcCEQQcABABEQEnAxAEAQAoEAIRLQwREi0OChIAKBICEi0OBBIAKBICEi0OCxIAKBICEi0OBBIAKBICEi0OCRIAKBICEi0ODBIAKBICEi0OBBIAKBICEi0ODRIAKBICEi0OBRIAKBICEi0OBhIAKBICEi0OBxIAKBICEi0OBhIAKBICEi0OCBIAKBICEi0OAhIAKBICEi0OCRIAKBICEi0OAxIAKBICEi0ODRIAKBICEi0ODhIAKBICEi0OBRIAKBICEi0OBhIAKBICEi0OBxIAKBICEi0OBhIAKBICEi0OCBIAKBICEi0OAhIAKBICEi0OCRIAKBICEi0OAxIAKBICEi0ODxILIIBFgEkAAiQCAAIAADWFJwIDBB4tCAEEJwIFBB4AEAEFAS0MBAUqAwAFBSdGSLL1QRe9ACgFAgUAKBACBicCBwQbLgQABoADLgQABYAELgQAB4AFJQAAR0InAgYEGwA4BQYFLgqASgAFACgFAgUtDgEFACgFAgU8DQQDJigAgAQEeAANAAAAgASAAyQAgAMAADWuKgEAAQX3ofOvpa3UyjwBAQImJQAANYYnAgYEBy0IAActDAEILQwCCQAQAAYAJQAANigtBAAALQwIBQsoAAOATQABASgABYBKAAYtDQYCJAIAAQAANhojAAA1+AsoAAOATgABJAIAAQAANhEnAgUEADwJAQUtDAIEIwAANiMtDAIEIwAANiMtDAQBJiUAADWGLQ0BAy0NAgQNKAAEgEwABSQCAAUAADZKJQAAR4gAKAMCBgA4BgQHLQ0HBS0IAQYnAgcEAgAQAQcBJwMGBAEAKAYCBy0MBwgtDgUIASgABIBKAAUOOAQFByQCAAcAADaSJQAAO9ItDgMBLQ4FAi0MBgEmJQAANYYBKAABgEoAAy0NAwIcDAIDBhwMAwEAHAwBAgYtDAIBJiUAADWGHgIABAAeAgAFADM4AAQABQAGJAIABgAANuglAABHmiYlAAA1hi0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgFMADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAEesLQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAABHrC0EAAAtDQ4ECygABIBFAAYkAgAGAAA4FCcCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAEjVLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWATwAGCygABIBIAAskAgAGAAA5BCMAADiCCygABYBQAAYkAgAGAAA42iMAADiXCygABYBRAAYkAgAGAAA4sCcCDAQAPAkBDAsoAAuARQAFJAIABQAAOMUlAABJ4y0MAQctDAIILQwDCS0MBAojAAA5LgsoAAuARQAFJAIABQAAOO8lAABJ4y0MAQctDAIILQwDCS0MBAojAAA5LgsoAAuARQAFJAIABQAAORklAABJ4y0MAQctDAIILQwDCS0MBAojAAA5Li0MCgQtDAcBLQwIAi0MCQMmJQAANYYtCAEGJwIHBAUAEAEHAScDBgQBACgGAgctDAcILgqASAAIACgIAgguCoBIAAgAKAgCCC4KgEgACAAoCAIILgqASAAILQgBBwAAAQIBLQ4GBy4IgEYABSMAADmfDSgABYBMAAEkAgABAAA6hiMAADm0LQ0HAQEoAAGASgADLQ0DAi0IAQMnAgQEAgAQAQQBJwMDBAEAKAMCBC0MBAUtDgIFJwIEBAUtCAAFLQwDBgAQAAQAJQAASfUtBAAALQwGAgEoAAGASwAELQ0EAxwMAwUFHAwFBAAcDAQDBQEoAAGARAAFLQ0FBC0IAQUnAgYEAgAQAQYBJwMFBAEAKAUCBi0MBgctDgQHJwIGBActCAAHLQwFCAAQAAYAJQAASfUtBAAALQwIBAEoAAGATAAGLQ0GBS0MAgEtDAMCLQwEAy0MBQQmLQ0HARwMBQIAADgEAgMvDAADAAIuBAABgAMoAIAEBAAFJQAAShouCIAFAAMAKAMCBgA4BgUILQ4CCC0OAwcBKAAFgEoAAS0MAQUjAAA5nyUAADWGJwILBAwtCAAMLQwFDQAQAAsAJQAASqgtBAAALQwNChwMBgUAJwILBAwtCAAMLQwHDQAQAAsAJQAASqgtBAAALQwNBgEoAAqASgALLQ0LBwEoAAaASgALLQ0LCi0IAQYnAgsEBQAQAQsBJwMGBAEAKAYCCy0MCwwtDgcMACgMAgwtDgUMACgMAgwtDgoMACgMAgwtDggMLgiARgAJIwAAO3sNKAAJgEwAASQCAAEAADuRIwAAO5AmHAwJAQAAOAQBAgAoBgIDADgDCQUtDQUBMAwAAQACASgACYBKAAEtDAEJIwAAO3sqAQABBSiGkrBH3P1DPAEBAiYqAQABBUWnynEZQeQVPAEBAiYqAQABBWRhiKjGz5TLPAEBAiYlAAA1hicCBgQHLQgABy0MAQgtDAIJABAABgAlAAA2KC0EAAAtDAgFCygAA4BNAAEBKAAFgEoABi0NBgIkAgABAAA8YSMAADw/CygAA4BOAAEkAgABAAA8WCcCBQQAPAkBBS0MAgQjAAA8ai0MAgQjAAA8ai0MBAEmJQAANYYtCAEGAAABAgEtDgEGLQgBAQAAAQIBLQ4CAS0NBAIAKAICAi0OAgQuCIBGAAUjAAA8pgw4BQMCJAIAAgAAPMkjAAA8uC0NBgItDQEDLQwCAS0MAwImJAIAAgAAPNYlAABHiCcCCAQDADgECAcAOAcFCC0NCAItDQYHLQ0BCC0NCAkAKAkCCS0OCQgAKAcCCS4EAAiAAygAgAQEAAElAAA9Pi4IgAUACi4IgAYACy0OAgstDgkGLQ4KAQEoAAWASgACLQwCBSMAADymLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAPY0jAAA9/SQAgA0AAD2aIwAAPbMuAIADgAUBAIAFAAKADi4CgAuADiMAAD34KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAD34IwAAPlEoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAPlEoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAD61AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAD61LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAD6EAQCADIAIgAYmJQAANYYcDAEDBBwMAwIAHAwCAQQmJQAANYYcDAUMAAAoBgIFLgQAB4ADKACABAQAASUAAErTLgiABQANLgiABgAOLQ4MDhYMCAYcDAgHABwMBggABDgHCQYFKAAIgEMABwA4BgcIFgwKBhwMCgcAHAwGCQAEOAcLBgUoAAmAQwAHADgGBwkAKA0CCi0NCgcnAgsEAgA4CgsGOQPoAAgACQAEAAYAByACAAQhAgAFLQgBBwAoBwIKLQ0KCScCCwQCADgKCwgiNIBGAAUACC0MBQknAgsEAwA4CQsKABABCgEnAwcEAQAoBwILLQ4JCwAoCwILLQ4JCy0MCQYGKAYCBiQCAAQAAD/0IwAAP8stDQcBACgBAgEtDgEHACgHAgMtDQMCJwIEBAIAOAMEATwNAQIjAAA/9C0MBgEtDAcCJiUAADWGJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAEB2LQQAAC0MCAULKAADgE0AAQEoAAWASgAGLQ0GAiQCAAEAAEBoIwAAQEYLKAADgE4AASQCAAEAAEBfJwIFBAA8CQEFLQwCBCMAAEBxLQwCBCMAAEBxLQwEASYlAAA1hi0NAQMtDQIEDSgABIBEAAUkAgAFAABAmCUAAEeIACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASASgAFDjgEBQckAgAHAABA4CUAADvSLQ4DAS0OBQItDAYBJioBAAEF3lzDKfPUzZ88AQECJiUAADWGLwwABAAFLQwFASYlAAA1hi0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgFMADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAEesLQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAABHrC0EAAAtDQ4ECygABIBFAAYkAgAGAABCOicCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAEjVLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWATwAGCygABIBIAAskAgAGAABDKiMAAEKoCygABYBQAAYkAgAGAABDACMAAEK9CygABYBRAAYkAgAGAABC1icCDAQAPAkBDAsoAAuARQAFJAIABQAAQuslAABJ4y0MAQctDAIILQwDCS0MBAojAABDVAsoAAuARQAFJAIABQAAQxUlAABJ4y0MAQctDAIILQwDCS0MBAojAABDVAsoAAuARQAFJAIABQAAQz8lAABJ4y0MAQctDAIILQwDCS0MBAojAABDVC0MCgQtDAcBLQwIAi0MCQMmJQAANYYvDAAEAAUtCAEEJwIGBAIAEAEGAScDBAQBACgEAgYtDAYHLQ4FBycCBgQHLQgABy0MBAgAEAAGACUAAEn1LQQAAC0MCAUtDAUBJiUAADWGJwIHBAgtCAAILQwFCQAQAAcAJQAASqgtBAAALQwJBgEoAAaASgAHLQ0HBTAMAAUABCYlAAA1hicCBgQHLQgABy0MAQgtDAIJABAABgAlAABEZC0EAAAtDAgFCygAA4BNAAEBKAAFgEoABi0NBgIkAgABAABEViMAAEQ0CygAA4BOAAEkAgABAABETScCBQQAPAkBBS0MAgQjAABEXy0MAgQjAABEXy0MBAEmJQAANYYtDQEDLQ0CBA0oAASASwAFJAIABQAARIYlAABHiAAoAwIGADgGBActDQcFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgBKAAEgEoABQ44BAUHJAIABwAARM4lAAA70i0OAwEtDgUCLQwGASYqAQABBZDQwMJqOya9PAEBAiYlAAA1hg0wgEcAAQAFJAIABQAARQsnAgYEADwJAQYEOAIBBScCBwYACjgHAQYkAgAGAABFOQY4BQEJCjgJAggkAgAIAABFOSUAADvkBygABYBSAAYAOAYDBQ44BgUHJAIABwAARVglAAA70gI4BQQGDjgEBQckAgAHAABFbyUAADvABSgAA4BSAAUHKAAFgFIACAo4CAMHJAIABwAARZElAAA75CcCBwQILQgACC0MBQktDAEKABAABwAlAABGsy0EAAAtDAkDBSgABIBSAAUHKAAFgFIACAo4CAQHJAIABwAARdYlAAA75AY4BQEEADgCAwEOOAIBBSQCAAUAAEXyJQAAO9ICOAEEAg44BAEDJAIAAwAARgklAAA7wC0MBgEmKgEAAQUWPCC69BAE5TwBAQImKgEAAQW2SOxlp0llLDwBAQImJQAANYYtDQEDLQ0CBAsoAASARgAFJAIABQAARlQlAABHiAEoAAOASgAFLQ0FBC0IAQUnAgYEAgAQAQYBJwMFBAEAKAUCBi0MBgctDgQHLQ4DAS4KgEoAAi0MBQEmKgEAAQUYidOrDg5UnDwBAQImKgEAAQUimQxcwZa6oTwBAQImJQAANYYGOAECBAQ4BAIFJwIHBgAKOAcCBiQCAAYAAEbrBjgFAgkKOAkECCQCAAgAAEbrJQAAO+QMOAUBAiQCAAIAAEcGIwAARv0tDAQDIwAARysnAgEGAQA4BAECDjgEAgUkAgAFAABHIiUAADvSLQwCAyMAAEcrLQwDASYqAQABBaJbkzUbP0/vPAEBAiYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAR4cuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAR1YmKgEAAQXFa8RaDhAAAjwBAQImKgEAAQW+Hj//PqT2+jwBAQImJQAANYYtDQMGLQ0EBwsoAAeARQAIJAIACAAAR9InAgkEADwJAQkLKAAGgEQAByQCAAcAAEhhIwAAR+ctDQEGLQ0CBy0NAwgtDQQJDSgACIBEAAokAgAKAABIDCUAAEeILgQABoADKACABAQABCUAAEoaLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEoABQ44CAUGJAIABgAASEwlAAA70i0OCgEtDgcCLQ4FAy0OCQQjAABI1CcCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAEjVLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAABKGi4IgAUACQAoCQIKASgACoBGAAstDgULLQ4JAS0OBwIuCoBKAAMtDggEIwAASNQmJQAANYYuCIBGAAUjAABI5Q0oAAWARAAGJAIABgAASVAjAABI+i0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGLQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBKAAYkAgAHAABJbiMAAEnaLQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAABKGi4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAAEnaLQwGBSMAAEjlKgEAAQUC3G4ngHYSnTwBAQImJQAANYYBKAABgEoAAy0NAwIcDAIDBhwMAwEAHAwBAgYtDAIBJi4BgAOABgsAgAYAAoAHJACABwAASjUjAABKQC4AgAOABSMAAEqnLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAASpMuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAASmIoAYAFBAABAwCABgACgAYjAABKpyYlAAA1hhwMAQIALQgBAScCAwQCABABAwEnAwEEAQAoAQIDLQwDBC0OAgQmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAASyIjAABLkiQAgA0AAEsvIwAAS0guAIADgAUBAIAFAAKADi4CgAuADiMAAEuNKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAEuNIwAAS+YoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAS+YoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAATEYuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAATBUuAIAMgAYm",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZBc13Ul+BO1AJVAAUmAK8AF4CKSIinlXllqL9ACWRYlSrJkybIWKysXCiREkAAIiiAB/CoUQBIAAVIkZVuWLVve5EVeZcuy5W53TMTMdIw90+1pR3dMd4xiNK1p93SMHe6emO5ph92NT/6befLU/e//rLyvkCLqRQD187/7zr3vvvvuu2/5/+eCfsrFfyeDEZKAXH3Ta39n4t8bIH/i0r+98e/iaKk0Q3wt8RvF+bkZpX6G8ldmYsycH/yi4HvSf3FjjPPjYR8f6yJ8N136txmujwR9+/BVf2k/n/Xf4aiz2M7bw6CX+nxLlUa9Um7Uy+V2p9hs1+e685W5YmWhVplvLZSKlVq50Z5rVorFTqXTqhbb9flau9Ocr1W6C835umC/Q8WudBYuQdWa9cZCqdusd4sL1blGpdmdm2s32/PVzlyt2C616qVWudRtNJq1WrNVmy+Vup35WrfRw94XetFZWfDf6QW/UhP8HwD8ycC2T0XpXX7wez7tB/3g9/T/bi/678t/f4wfBPa6f48X2Us9/Pf60U1V8B/wg18R/PcBfs4D/vv94Pds5wN+8Hu2/0N+9N8V/A/G+AFglxqVcnmuMj9XnG+0i6Vqu1VuXPL+C9Viq9hslTvz1dJ8t1quVlrt1kKj2miWusVuszXfbbwGLtgf8iJ7pWebP+xF95XeuPJhRTfF0VLP538kGXvV6hfsH1Gwy81KqzjfLTZrjeZcp1G7NFwXL10sNDrderm5cGngLrdLpVKneum/cqddnV9o10sL9c5cubZwiV2vTT8a+mjTUkvwf9QYv94sznfq9V58/DFj/IWF+lzzkj4F/+PG+JVWvdOtzPX8wSeM8Zu1ardbqzQF/5PG+LVSsVMrz/Vs88eM8ecXirV6o9Gzn08Z41+KOyvt+eaC4Det9bPQKbbapfnZGGchxhceURLeLWPecZrPEb8gxud7wj9PslrHZTnih/KgfmT+IrprhytlLSh56GM4b0K5J3w0rI8ZYn3cEOsThlifNMT6MUOsTxliSb/229eqvXG07QW/0hD8jhf8Ykfwuz7wS/3Y8UHAD+zk7+F/GvBzHvD3+9F/D/8hP/rpzWsejvF9YB/wo5teDPYZP/i9ecEjfvB7MepBP/g93/CoH/x5wX/MD34vRj3kB78X4x32g9+LUY/4wW8L/uNe8Es9/RwFfDvfWe75tie84Fd6+J/1g9/zb096wa/28I/5we+tqzzlB7/nn5/2g9/zz8f94PdinxNe8Gu9OfJJL/j1nv2EfvB7a66LfvB79rnkB79nn6f84Pfsc9kPfi9+OO0Hvxc/nPGD34sfnvGD3xu/nvWD3xvfn/OD3xvfz/rB7/m3c37we/7tvBf8ud74/rwf/N4a7AU/+D3/edEPfs9/vuAHv+c/X/SD3/Ofn/OD3/NvL/nB7/m3l/3g9/zbK37we/7n8zF+sHrsCt+IztxE522+vP01vC2X/m2NsR/sHHnbgYOthx94/DMLnUO4Ii01DILBlWqZ+XCKULf3Ud9+8JEjh5qtI29ttw91Dh9mhA0KcpCAmgfUTzf3P/KD7SR5hkT7cOfQ4f0HH2G0yYxocq5oCugNY9bibIw3TfIh742kBRvepbbW8qxl5J8nWY3n36Uc8RN5WD+4bxHlbVJkLSh53IabFD6bFD4FJY9j6FGwnjfEOmWIdc4Qy7KOzxlinTHEOmuItWyIddQQy1L3ln3owphinTTEWjbEstS9pX0tGmJZ9m1LmwgNsSx99IuGWOM6PsrcxG9sVWzMKrwlSR4+04AxFSeOxFHuCP8r2/u4TCdpC/A7/OQjrQcOHukcDhwFoiQH2vn+uCmPA8J8hjoEQbpiv5lBsRzAo2yzhIllcwqWNsVhY0adTyfIgBjSVhgIG04iKlnqgfzXahKhOQltEiH6mfGjn3KO8FGeGUU/bMPcdtE/ecBmCrCQHh/GQnq8lvJ471/EfwvByn4kh/xzSt6Eck/0G+n8n1HdsG3YTv20Q7WU1U6Ffz7w2W/6dqrZhTaYzQQr29nyYFWWdtV822YlT7C2xL/RTpE+D3VEeryW8njvO/HfQrDSptlONyv1wXtop9+Kr2cS6rM3/l0cKc3NaeMU9wPUk+VB8az9QPjnA5921+8HWjtp/kR0t0WRtaDk8aLPFoXPFoVPQcnjQHQUrHOGWKEh1pIh1oUxxTpjiHXWEGvZEOuoIdazhliWdr9siGWlL9c4OCxWlCxt9aIh1mlDLEtbtazjSUOsZUMsS329bIj1hCGWbMJynCn4UZoJVvY967kb8pN64D3knydZbeXpx0qaXrWYVvQz60c/PXlmFXlmFf1IW25V8gRrW/wb5wxIPwt1RHq8lvJ4781xgxUIM0o8Z9iq1Afv4Zzh7txg3bBt2E59tgPyE7nxHvLPBz77TdFpF1r/nwlWtrOhfopZ2hXllbbcpuQJljwEhXaK9FuhjkiP11Ie730v2SnaNNvpNqU+eA/tdI7sFNuG7dRLO5S6me1U+OcDn/2mb6eaXcwqepwJVrazoX6KWdoV5ZW2LCh5gnVV/BvtFOm3QR2RHq+lPN67n+wUbZofDiso9cF7aKf7YtyZhPrsjX8XR0q1qtaWdvhzpVmlntzPUNd2dl3J3M+Efz5YaRc++tlVJE+SHYjutiuyFpQ8tpHtCp/tCp+Cknc6tMNaMsQ6aogVGmI9a4h10hDrjCHWc4ZYljaxaIh1whDrghGW5p9Hket5I7midNEQy7Jvv2yIZekLLfvjWUMsy3Z8xRDL0iYsdW/VtwPjOlraxDlDrHH1E5ZyXQkx0/qYdvl0b9kfTxliWdbxc2Mql2U8YVlH3h/AuWUu/jsTrOx7hvPsTo74ST3wHvLPk6y28vTn2Zper1L0KrrbochaUPJ4nr1D4bND4VNQ8njMGAVryRDrqCGWZR3PGGKdNcS6aIhlqfuXDbHW23E4rFcMsSxtYtEQ65whlqX/umCIZal7S1u11P24+i9LW7W0r+cMsSzb0dK+LPuQpX09b4h10hDLso7jGstZ1tEynhjXdhzXWO5zhljjGudYxpjr8cTrow9Z+glLuazsK7rmddVR5HrBSK4oWereMgaQsZbPuwl+lPyuoZUzn7HlNTQvZ7BS1tC0s3UzwUo7NNRPKUs7o7zSllcreYJ1Tfwbz4Qh/Q6oI9LjtZTHe98fK6VAmFHiM2FXK/XBe6Lf6EzYfPxjJqE+e+PfxdFSg9dDhQfyRj0Z2l2mj0gg/3zg0+76/UBrJ82/iO6uUWQtBCtth+3hGoXPNQqfdazxwnq/EZbLh0l+lGaUctb+FvlJPfAe8s8HXv1CyaVXzV+Kfq71o5/eGeVrFXmuVfQjbXmdkidY18e/cTxC+muhjkiP11Ie77VoPLoOaLkPXKfUB+/hePSJDYN1w7ZhO/XTDtmf+RD++cBnv+nbqWYXWv+fCVa2s6F+ilnaFeWVtrxeyROsG+LfaKdIfx3UEenxWsrjvcfITtGm2U6vV+qD99BOH45/bAuS+2eW/oy4mt9mHWI57g9e2rvUKWbtD8I/H/jsn/3+cF1GvYp+rvein3Y3i/2gvNKWNyh5grUz/o39AemvhzoiPV5Leby3RP0B+w73hxuU+uA97A9Pk9/GtmE79dIOxWI3q50K/3zg00/27VSzC238mwlWtrOhPJ0s7YrySlvuVPIEa1f8G+0U6W+AOiI9Xkt5vPcC2SnaND+rt1OpD95DOz1L812uz974d3Gk1ClpbWmH3+x9lH6nF/zy/IzSXnb4Cw3Bv9EPfl3wb/KC3+i1781e8Gs9/dziB78t+Lv92E9P/j1e8CsVwb/VC36nJ/9tXvCrPfzbveAv9PrvHV7w53v2/wY/+um1751e8Ls1wb/Lj3568t/tR/6e/78H8C3XIgT/Pi/4xYro496gnyaUOgl/iUXeCPS5hL+CxXnCK09YvuI+rW4oP8/77gV5UAdJWPcOiTWj5Plo03sc9Ub+sw5ZuR5ReiK00UmUFg2xjhtiPW+EpcW2o8j1WUO5bjCSS4t/R8HaZYg1ZYQVJf7o4Shy3WgkV3R905hi3WyIdYsh1m5DrD2GWLcaYt1mhBUl/tjVKHLdbijXeUO57jCSK7p+gyGW1dgRXd9piHWXIdbdRlhR4rXTccGSPWS/613Veb/rXZWm3/Wuatvvelet4ne9qzrnd72r2pJYXcZD4YG2tRvu280rqpmfBRX+eZLVVp7+/G43ycP64fM7exRZC0oe99E9Cp89Cp+CksdneUfBetEQ66Qh1rOGWGcMsRYNsY4aYj1niLVkiHVhTLEsbXXZEMtK99E1j9vjYquW/fGiIda49scXDLEs+9C46v60IZaln7Acay19tKXuLfU1rvZlGZtYtqOl7q8EP/GyEVZ0zXPYUeR6ylCuXUZyWWJF6cnQTq4bDeWy0n2UThhiWdoEr6WPgjVlhBUlK5uI0nFDrGOGWJb2ZSmXla2Osy/caiiXpa1atqOlXx1XfVnaKq+tjoOtRsnSf71iiGUZf50yxLJcU7CMyS3nCpZrjxLfyzr2zZCXi//63QMornoP4GY/8jj3AG5W9KqdhzWUp52lnVFeactblTzBui3+jWf7kX4P1BHp8VrK472fixuuQJhR4rP9tyr1wXui3+hs/09NDNZtN9Cxnfpph+zfgBX++cBrvym57GK3okfNLqRsQcnjmD5re2ltz2ffRsE6Z4gVGmItGWJdGFOsM4ZYZw2xlg2xjhpinTfEsuxDlu34oiHWSUOsi4ZYln3b0r4s+5ClX70SdP+cIZalj16OsbTnqAzjj6L2nJMhfu+Zg9scukD+fBZH8rW/gsV5witPWMZ1K7nqhvJzO2McjjpIwrptSCzt2TgfbXqro97I3++zgLWy32cBa3W/zwJWu2Lzd4A+c6S7O720ZSPzu1SEf55k9dWn7iR5WD/SD0R3dymyFpQ8Prt3l8LnLoVPQcnjcXsUrBcNsU4aYj1riHXGEGvREOuoIdZ5Q6znDbEsdT+utnrREGvJEMvSvix9zjlDrCtB988ZYlnW8cKYYln27WVDLCvdR9d8LndcbHVcYwBLrPVxe33c/m4ZO9bH7fVxe33cfn3qflxt9QVDLEt9WfocS92fNsSy7EOW4/a4+uhxjScs62gZ+1q2o6XurwQ/8bIRVnTN53NGwbrVEMtqnTy6vs0IK0p89ngUubYayvWUkVxROmGIddwIK7rm/a913bvryM9OjIK1yxDrRiOsKFnq6w1GclnaapQs+9C42v241vH17gst5YrS+tjx3T92ROlpI6zo2vLMg5W+ouubDOU6ZiiX1VgbJcvx0VJf4zh2ROkVQyzLOd8pQyzLPR3LdQDL9QnL8zn8fBueDcvFf7X3xUd89sa/i6Oldo74ST3wHvLPk6zG8pRcer1T0av2vntDeVo5wkd57lb0I215j5InWPKeTHy+DenvhjoiPV5Lebz395Ov/S0QZpT4+TbtXel4T/QbPd/2nycH64Ztw3bqpx3KmZ9vE/75wGu/KbnsQuv/ml1IWa29eNzP2l4a1hlDrAuGWKEh1jlDrBcNsZYMsZ4fU7kWDbGOGmK9bIj1hCHWK4ZYlvo6a4hl2R8vGmJZ2r2lL7Rsx1OGWJY+x9ImnjPEstT9yTGV67whlqVNWMYmluO2ZTuOq/+ytC/L/jiuPtoSy9K+lg2xRPcyX8H5TS7+6/kbcNUc8ZN64D3knydZbeXpz/U0vd6t6HWY74tF15bfbLL6jleUzhlihYZYS4ZYF8YU64wh1llDrGVDrKOGWOcNsU4aYln2x4uGWJb2ZamvZw2xLO3Lsg9Z+lVLm7D0q+Paty37o2UfetEQy7I/Xgn29ZwhlmUMsBxjbYvzMN7eEwzyGTbmx/JCN6uUy8V//X7Ddz7z+zqEfz5YqRMfMf+9GfUqurtPkbWg5PHZlfsUPvcpfApKHo9No2C9aIh10hDrWUOsM4ZYi4ZYRw2xzhtiPW+IZan7cbXVi4ZYS4ZYlvZl6XPOGWJdCbp/zhDLso4XxhTLsm8vG2JZ6T665vd1jIutjmsMYIk1ruO2pe4tYwBLH20ZT4yrra6P25dvTFuPyYfDWo/JL599rceFl8++lg2xxlX342qrLxhiWerL0udY6v60IZZlH7IcO8bVR4/rmGZZR8vY17IdLXV/JfiJl42woms+4zSKXE8aynWrkVzR9VZDLMv9IUt93WQo1wkjuaJ03AgruuZn+sfBJqLEzzaPg+4t+7Z1f7TqQ9H1bUZYUbLsj1eCffH7hkbB2mWIdaMRVpQs9fUGI7ksfWGULH30uNr9uNbx9T7WWsoVpfXY5Lt/7IjS00ZYlvFElKz0FV1bxuTHDOWyGmujZDk+WuprHMeOKL1iiGW5pnDKEMty38pyncly/cvyfCG/b2gr5OXiv3LOF31dxGdv/Ls4Uiplft+Q8M8HK8cqO3n653yvD1bqdauiV9HdDYqsBSWP58Y3KHxuUPgUlDze8x0F65whVmiItWSIdWFMsc4YYp01xFo2xDpqiHXeEMuyD1m244uGWCcNsS4aYln2bUv7spTLsh0t5bL0E5Y2YdmOzxliWfr75RhLYiuOCfbGv4sjpVpNYhOMZSSmmglWxiaGcV0jR/xET3gP+edJVlt5+nGd1m6oH47rdiqyFpQ8bsOdCp+dCp+Cksd9cxSsZwyxLOU6Z4QVXc8ENljWdTxqiPWcIdYFQ6xlQyxLfV00xHrJEOu8IdaSIZal7s8YYi0aYlnW8WVDrCcMsWSdj2OLKO2N/14aDiuNeqXcqJfL7U6x2a7Pdecrc8XKQq0y31ooFSu1cqM916wUi51Kp1UttuvztXanOV+rdBea83N+Y4fa/Eyw0scbxiYlwd/lB78s+Df6wa8I/k1+8KuCf6sf/Jrg3+YHvy74t/vBn/P77oNSQ/Dv84Pf619v8oPfFPw3+8FvC37RD35H8Et+8LuCX/aCXy4KfsUPfs9/Vv3g9/xnzQ9+z3/W/eD3/OecH/ye/2z4we/5z3k/+D3/+RY/+D3/+Q/84Pf85/f4we/5z+/1g78g+N/nB78l+N/vB7/n//f6we/5/7f6we/5/7d5wa/0/P/b/eD3/P87/OD3/P8+P/g9//9OP/g9//kDfvB7/vNdfvB7/u0H/eD3/Nu7/eD3/Nv9fvB7/u09fvB7/u29fvB7/u0BP/g9//Y+L/jVnv95vx/8nv/5gB/8nv/5IT/4vfjzg37we/Hnh/zg9/znD/vB7/nPD/vB78WfH/GD3/PPP+IHv+efP+oHv+eff9QPfs8/f8wPfs8/f9wPfs8/f8IPfs8/f9ILfq0Xf/6YH/ye//+UH/ye/2/6we/5/wU/+D3/3/KD3/P/bT/4Pf/f8YPf8/9dP/g9//9g0E997Epn4dJWS61ZbyyUus16t7hQnWtUmt25uXazPV/tzNWK7VKrXmqVS91Go1mrNVu1+VKp25mvdRs92T+tYo+S+vsi+33opdTt+YWHAD9nJn+jh/+wF/xir18d8KKfds8vf0Zp23K1XV9oFue6c81mo3tpEC23L/2pX7Kabq3cnK+0mpesqL3QaS5UWvPlVrvcrnQal3xNpzJf73T6Y9Yj1nZTKvb0ftCL3vv7IY+a673x6v/RN03Pb3wNaxvIL7w2Ur3kHNMUXO8PB2kkH+m/kn/tb8TvhRh0lsoEcD1D5W39VGk+R/wC4hUQ/7yiGx9ntCZIHtYPn9GaVGQtUF6UeM9+UuEzqfDRsF4xxDpqiHXeEGvJEOusIdaiIdYZQyzLOi4bYo2rfZ00xHreEOuiIZalfVnq61lDLEv7suxD5wyxLG3C0q/KWc6ZQB8L98a/iyOlekPGWpx3SJI8nDfwGP0Q0L8j7NNxmqDfWKdNl/796fY+LtOxPBjL7Ad8TU+StDP5ljGO4G/0g18Rm5oOBnXKddqYoCvJ1/4GgR4fCq98sFLvPuJDrW4oP/eXaZCHz+lrWNNDYs0oeT7adMpRb+Q/65BVq8ck6UTzRzlFJ3J/o0MupN+m8JayosNNkGeow7JLh9gXhf8WuG53Fh5/8D0HcTmnVx71IHq7nujeHfb1wDY4nYAV0G9+hmcC8DD5nTNe3nFA7g07DqCv2k95q/V7UWLfoLVh1L5/5VhbSLKhrGsLQv8fN/b5/Yf4ejPw3OzguYXykD5K7yb+s1C3CYVmM8ko9P85litqv38dt5+mO5Fnhsq/nmxZ6jSsLWM7omyIKbbDbZvULpOb+rJ8a3tfZua3JUiuh/x+UOEnsm8j2ihJGxfgvuEaV+bvyAn/PMlqPA71YpgCycP6EVvbAno8cLDZfnvz0cOPH+hsIFXyq5sEvkBwQoO0mAogEtJzeTbV94Qry3ESVU6RzLfH5he5k63x9Wygm1eUZoKVdTZsolZWkxH++cCnm+qbzFaSh/WzgfTjyYQXcsFKc51QeIq80pYFJU+wrop/o+tC+m1QR6THaymP926M7akQrOx294eDMmhdEu+JfiM7vZbsFG3lwXAwb1LhKXlTjrxpRx6GrGIDkrcJyu2ncnkFM+Lz0KY+XpKtYXvLcL8tWGn7Sb4oCWsfYWH5AmFdlYL1AGFh+asIa3sK1nsJC8tvJ6wdKVgHCAvL7yCsq1OwPkNYWP5qwromBesRwsLy1xDWtSlYBwkLy19LWNelYD1KWFj+OsK6PgXrMcLC8vwKvxtSsA4RFpbnT67tTME6TFhYnl9xuysF6whhYXl+7d6NKVgdwsLyUnZWweLx2c/jidnHZ+GfJ1l9jc83BSv1ivrh6cPNiqwFJY/91s0Kn5sVPhrWdkOsHYZYVxtiXWOIda0h1nWGWNcbYt1giLXTEIv9Vtp4/UPha39d47WUQ9tFugmg0cZoxEiKB3DJNC0ueA/JrPHUYsyHwsE8XMLleBCXGzkmx6XYAuVhjMl+H5dpr6K8PORJfTDGnKL6fCa+73e5p1hE3SbpCnWcS/gbBNmWA7Ec+/5ZQz6I9Y5wkM/aL7kUO1nqgfx9L7mILrY7dLHDC+9q5uWnHaSL7Z50IXaZNi/gLR4t9t+u0ONy1YOdI5c2Td725IeaD+IOEbohFoe7RYF+X5Ug1l6i20G/JbxgORALE8vBy2FMvzeFHq8nlftR0qZN24in1mx4j10Dlr/GwWf7iHy2K3yka2EI5WMn3dMb43q7rtpUFesk/GcVPQ3j2pFXPljZRj7cgFY3VztjCJtlSn/dkFgzSp6PNr3WUW/kP+uQVasH7t6hn8vHr6iLwqCXHUuHPCz5Oc1TqWe1R+G/Vid/s5480EJbKVugvCjxVx+0UwBTCh8N65wh1guGWGcNsRYNsY4aYlnW0bIdLesYGmJZ1vE5Q6zzhljPGmItGWJdNMQ6Y4hlaROW/dGyD1nahKW+lg2xLhhiWer+lCGWpe6fN8Sy1JelLzxpiGWpr3H1hZb6svQ5V0LMZGkTluO2le6j65nABitKlnZvqfvThliWdm9ZR0s/sWyIZamvlw2xsjwdm1Ow5L72RIG2LnWlPFFQIzqLJwpqdG8i0J8owBPsvB4WAL3f9dhKOUf8uI4B8c+TrMbt7/xSnLbuOeyX4virzePydTfLr+pYfsnrWUMsyy8tWX4d6YwhlqVNWH5NyvILUJY2YamvZUMsS32dMsSy1NcLhliWtrpoiHUltKPl1xbH9YuSll9btNTXuI5Dlvqy9PeW9mXpcyz74+v9a57RNa/BjIvdW+r+tCGWpd1b1tHSTywbYlnq62VDLFmD0R5V4SPy2hz2egcfLH99BixtPiz02qMtrrUe7dEWv1/c6q/1aO2hPR6zmrUe0VuJ6HitB33bzgSsgH6X6F7SWs9UfE/OLR2Pnafo19N5NPVoNp9XxDOjfC5Se1wR77H9ao+p+q3j8G8b2EZ5+NZUPqr/MGDh2yI4TdBvrG9kr98e4k0E2B77EzCnFNoNlCe052f6cvxVLMdat72ftcK1a/t9YZ+Ok9b2Ut9I538zYtvz+VeUW3scl9+qWiBZ+R63I5YvOPjcOSKfOxU+s0q5XMJf4cP3mI8ms2u9fbV8EEt8hd+1++Htn/WM9s9nc/Ftz/xWM3xTM+4DcdL6hugiKlfb0cdlOkl+3+y2djrkR8RQh9i3OWk6FF1k1eG2IL1vb1LqoY0T/EzDsOMElt/q4LNxRD4bFT7jFotspzy0JX5MEW3paso7AHw+HA7mfQbK8Z7ZI5A3RXkHIY/fgPco5LFveAzyhvUNGDPtz2DXWcZN9P8PUd60guv30bVKJcv4gvzzJKutPP39Vu2RWu2NjaK7qxVZC5QXpWNhn47zJpR7GxxYZwyxLhhihYZY5wyxXjTEWjLEen5M5Vo0xDpqiPWyIdYThlivGGJZ6uusIZZlf7xoiGVp95a+0LIdTxliWbajpf+y1Nd5Q6yThliW+rLsQ5bxhKW+njXEWverl8+vWuk+uub91nGxe0vdnzbEsrR7yzpa+ollQ6xxjVc/a4gl8aqUwzk+rjl73pcrX853bGh7zDynl3ztr2BxHr9j42o/dXO+Y8NlB7gHxfv0o7xjg9/L4vsdG9c46o38Zx2yavXYYaiTLF++0NaWhm1b7Z07UtZzH+udXdjh0BPyH+U5lTLR7Qv7euC2uyYBK6DfZbqXdHZB7Ajf7SL7W1EbfiCvyzwV9PWB77QpQD7SPwdfcfxQfL0t0O0J89AHyVqx3y/HDL/OP0l5/KXWIFip9yDQ18ilTsN+4QCfZeIvHAgmthl+4WAK8pG+me/L8q2dOmYOMPGZLv76hewjJH39gmUQ+g7IIF+/YMzJhHpNJ2A+Bbb46byOGSiYWr02Ub1Yho0kg9AfgHp9G955jDTIR9LD4aBseYVXkHAPsbEs57n4ppWNrjcTBj9LyPa6heilfJJO2VaE/nGHrUwpMmB9uV1ZBqbZlCDDk4oM+Hq/1sFHn4y/RhFQwmE0p/zmpuQmmFJwkpKoIareU3kdR367zA+3YacVHtMJMmLZSD3i4tqdA50jnQQFbSCwyQRmGwI9sa+UclHy/DWyzM9h8lfhpvzI4/wqnPa8svYKWylbUPJ4fz8rny1Bv68fPnLwUJIt4Nip2UIugX9OKR8klA2ojPZVKoxduM7DfqFyo1Ifjc+2Eflsy8hn+4h8tit8GEuLI6PUCvv5SP8K+Nfv7NQxNyRgymcuhF6L7bUzJ0KvrU3sUOqoPV9/dZDOG3XJ49E1Q8qatjawg2TV5phZZd0Xrq2sk0PKulHhjWPypUFn/9HOoQcOHum9hTlQxAjoeobu8fDEw8x0gqhbiI7DMF62YVd3Ff3OK/JpSeTAxLJMBOmJjyT/InTRv0zookGgd1Exe56WYlmclopJfBbo2A0/SfVBeuQp9MeAjxb6fZbqLfRfVUI/zbWLPDNU3naIn1sQHT4VrEyS9zTw5qH+ONC/PezTcdKmsVKnSBffHGIai+2IsiEmDhnYtknt8g2cxtKH+pDfk0FyPeT3lMKPdSn5UZI2Pg737dq41swRP6kb3kP++WClbn2ElcdJHtaP5oYdH+p7Cq4R/qMEJzRIi+mjIBLSc3lu9huUcpxElVMk8z+H1Yb/jtwWdn0eHlCGCeUeR1vTivwan00j8tmk8MnyQbcJpa7ax97442uPQd79lHcoWFkvyTvswDziwHzckXfUkfeEkhfVc9+WvozsjrWuwR+Jw7ZL6gdJWPsIC8sfJ6wTKVj8kTgsf4KwTqZg8UfisPxJwgpTsPgjcVg+JKzFFCz+SByWXySspRQs/kgcll8irFMpWPyROCx/irCWU7AeJSwsv0xYp1Ow+CNxWP40YZ1JweKPxGH5M4T1TAoWfyQOyz9DWM+mYB0hLCz/LGE9l4LVISws/xxhnU3B4g83YfmzhHUuBYs/qITlzxHWeQdWdC2L2duU8ucJ6/kUrF2EheWl7KyCJeOQhF8X4L5duFPKfNpf+OdJVlt5+uHXhWClXlE/HOpfVGQtKHk4FmEe8rmo8NGwnjLEOm6IdcIQ66QhVmiItWiItWSIdcoQa9kQ67Qh1hlDrGcMsZ41xHrOEOusIdY5Qywey1xxfXQtb7nYFqz0pU9ROfRnvDw0QWWQHjGS5g0TIPPxFJlvIplXO3+Irm8lrNXOH6Lr2whrtfOH6Pp2wlrt/CG6vpewsDz73KUUrPsIC8sPM3+Irt9EWKPMHx4PB7FGmT98lLBWO3+Irt8cDGKtdv4QXRcJa7Xzh+i6RFirnT9E12XCWu38IbquENZq5w/RdZWwRpk/1AjLNX+4kIJVJywsf4GwLqZgzREWlr9IWC+kYDUIC8u/QFgvpmDNExaWf5GwPpeC9RbCwvKfI6yXUrD+AWFh+ZcI6+UUrO8hLCz/MmG9koL1vYSF5V8hrM+nYH0fYWH5zxPWj6dgfT9hYfkfJ6yfSMHaS1hY/icI6ydTsN5KWFj+JwnrCylYbyMsLP8FwvqpFKy3ExaW/ynC+mIK1jsIC8t/kbB+OgVrH2Fh+Z8mrJ9xYEXpQ+EgFpb/GcL6UgrWOwkLy3+JsH42cNfxncEgFpb/WcL6uRSsHyAsLP9zhPVlB1aU2uEgFpb/MmH9fIpc7yK5sPzPE9YvpGD9IGFh+V8grF9MwXo3YWH5XySsX0rBup+wsPwvEdYvp2C9h7Cw/C8T1ldSsN5LWFj+K4T1KylYDxAWlv8VwvpVB1aU5FTSNqX8rxLWr6XI9T6SC8v/GmH9egrW+wkLy/86YX01BesDhIXlv0pYv5GC9UOEheV/g7B+MwXrg4SF5X+TsH4rBetDhIXlf4uwfjsF64cJC8v/NmH9TgrWhwkLy/8OYf1uCtZHCAvL/y5hfS0F60cIC8t/jbB+LwXro4SF5X+PsH4/BetHCQvL/z5hfT0F62PBa0mwsPzX4Tr69wdBP2lYHycsLP8HhPWNFKxPEBaW/wZh/WEK1icJC8v/IWH9UQrWjxEWlv8jwvpmCtanCAvLf5Ow/jgFq0lYWP6PCesfpmAtEBaWl7KzClYu/iv7T/8I7tvt91RLOeIn9cB7yD9PstrK099/+kfBSr2ifnj/6U8UWQtKHq85/onC508UPhrWCUOsk4ZYoSHWoiHWkiHWKUOsZUOs04ZYZwyxnjHEetYQ6zlDrLOGWOcMsc4bYl0wxLpoiPWCIdaLhlifM8R6yRDrZUOsVwyxPm+I9eOGWD9hiPWThlhfMMT6KUOsLxpi/bQh1s8YYn3JEOtnDbF+zhDry4ZYP2+I9QuGWL9oiPVLhli/bIj1FUOsXzHE+lVDrF8zxPp1Q6yvGmL9hiHWbxpi/ZYh1m8bYv2OIdbvGmJ9zRDr9wyxft8Q6+uGWH9giPUNQ6w/NMT6I0Osbxpi8Zpj2jm5VnztOicn5XDdiR8xnKAySI8YSefwJkDmtPN4bZJ5lPN4HcIa5Txel7Cw/CJhLaVg3UBYWF7Kas/BPRQO5uH6LD/DgE+287N1+OWFpygPn4PjdenDkHec8o5A3gnKexzyTlLeUcgLKe8JyBMdTQf95+Dk+UjR0bvi+zNUN9HV3vh3ccSkfS2N9Yjtlkv4GwSDbSiJfQCW4/Xupwz5IJY8pi02ivaLb4rCPOHD95gPln86AUsezY4SflEN3/aB9B+K2z56dvPf06sCtLPJE3Dv3Y66SlmxKfZre+PfxdFSSfBDP/gVl//FOgl/7dH9YewLeeUJy1p3rrqh/GyHOB5kOTd+ckisGSXPR5uecNRb87marFo9kvom8skrOnGNz1p7uMZn0eEi5BnqsOzSYQg8hf9q3s4pettFdPxlUS3WYayAfu+iexOB/nZOzbdtTpBT+Kb5cSwvdK5XWGTxGxofTWbhg+8XwLeNHqJn5cXu8JUf+FzLTshH+he29zEfjzG1526S+koO+LneyiT8poO+TpBmMkG+YzDu8ZsKtTdj7XTILJgYO6LMD4a6DCcp7vI0Rqpxl/DaRvJy+3BdtDZhuzum6CFJt1HCOAXjGKQ/PWScgvbNcQrKJGW1uR7rQePjGiePZeSzZUQ+WxQ+o8YhGh9NZp5TRQn9yefIn4jdYd/CsvIc/BTRnwB/8orDn/D5FI6d2MeyPxF+Sf6E7VPov+DwJ1ps/p4wWWbBRDtFmdmfCP2XyJ94ip9UfyK8tPFyNtD1EQTZxstZRQ++x8tZ4nPCkA9iSV/RYjn2P8PG1lieY9mk/vrVLTpPrb+i7U4R/Tuhv/4W9Ve0d9G5Zjc8Rp1Q+HKfCYKV87MouXzZiQSsrGOU0P+BY4xyzTWi5JpLu9YckQ5pXOt/Ew4eaLd4X2LjpBgH+Whx+WQCbk6R8dPxtd+5faMkfWExWJkkb0mRWfJOAf0Hwz4dpwn6jXV69avxO/u4TMfyoJ6WEjA1f/FwOEgrdd6g4IaEiz6A9XV/OJgntP8y7gtR//+zLToe20mU5Ou6fuevjTK3LyZuX9YPJ619Re6ofW/a1cdlOuYZQt4pykM+EgPwfA4xIt1/m2ICxB+HvrSa/jKMPrX+oumT9wi0sRP1OUUYU7N9mn9D9t6jCVbau/Qf6bOiv0mlfJQ49hP6v4SxZ/8unb+rvwWB7hdQD/xOxqVAl0Wrs9BuiPUk9niKyuyNfxdHStWePS6TzMj7tCfeOeIXBPo6r/CfVeQRufNK3uQIstZKc3PlerVd6y7UG7VaJ0f4Iivf4zXKMwr9VQq96PoZL7qutMUHTIR9/DOg1yhNQt5pypuCPJEx6kMHdg3Kf8aT/Fn0j/wLCv2+sE83TFsWFD485xgF68QqsbYHg31AGwsxtuGxMIQ88a+RX94DA4bmF12+bjG+Zr+P9WQ/eDP5uiXivTf+XRwpVapaPMq+btkT76y+TvjPBsltm1fyRvF17Vq1VO3O1xba3UqnPdfNBSvHhAnlHvs6zW4LCr1nX1HUfB37s0nIW6Y89HUio+br/IyLlWIW/SP/gkLPvi5rWxYUPuzrRsE6sUos8XUYB3Gcir6O49RQqQ/6Op6X3U4+yc+r7/U1QvapKG+UcA4dgp5Yv4yD9zBuxjK8ZiP090LcfvesLp/U4X5FPu1MEdbrTbPJdKFCF4Xx2+L7D3aOfPDTzUOd9gc7rUOdIxOBLh5XkavP06mA6KLEyzOP02/OZ0wZgieD9IQmgVha0yE2D73lWGWRC3uCXNgk8dob/y2OmLSpIw+1frbxypmnFcI/H6w0OR/HR7SlTdQPD49+tiXKxWj6wUvfUeqGK3XDcvAHJNnetb9SX77Hw0TSVD7NBSa5rPeBy9o726dnH6C1hevV9q5jKzmF/iHKw62znAOfl0HeCf3427QUiqGO1EO+qjNJeXvj+8WRUrkUyXEMlpjYnjCMSrJ/7fMNQu86ShYl2WpwHS3SbAttSWxEa+e1/rCZ7z61jeqDdswh3rBbj5r9pm2hfSyhTyZtoZUhH+nnYAvtk9SeWB71/Gq9wn7eGvWZ8rB9RmsHV59JO7IvOtS2WH84HMzT+oymV7adCUUGbZzTbEfossQPPF7sjX8XR0qlzPGD8F+r+GEyo15FP0/70U8xi4/Q/Jq2zcm+Hvu+Ni3RtuFwnOBp3Gfjzu46UuDqO9rW+KvH/2i64jsOcvWH1fJBLPlsy1T8W+YSSxBDhbPJ5eVTLdNQRjuOwPVBG8Kx4TSNDbhN4tqW57nP31/Vx3x2lWO9z2N+af6dP4GjHXVirM2KXNH1wfha2liWSF6CNn4xYRoeJWyfz1P7oC/U2kd4a9N7/Fri52E5BmX8Asj4E46+hzJ+MYEuun40WEnHvigI9DiE2zAELI2ejwUI/c9mjOfFHvzGJiU1nsf259gk63jEekJ6xBAfVCB61mGUxC6+DnbxK9S/NT+62j6cFEcm+X7Py4bzWWMU4Z8PfMZM/RhF+0SfyyZOKvIvhMn0oYKvtVvk9tnPFwBL+OInAkO6x2OUK6aJEvqeP5zVMbB+Wlwkr6dHjCy+f1h71uo0Dv0mi11rfFwx0zFDPtif+TGskGTYG/8ujpaqovtFkFOLkZF/9G8J6jBBGBo9rzcy/hLRS/lJoMf+LP2Bx72/A5/9ZzT2uuoYJfkcY06RaUKh4SOdp4I+b03m95LMQv/nMFbzsXVt7rIImHxUX+j/AjD5A/GnoHwWP7qs0J8CGpFHOz69TOVwu47bXMPmLXMN5xThcD03wL3tCra2ZRz92xv/Lo6YBE+2VCeBxxlFnimi/z/Jjp8lnbp0Fv17RuGLrz/cTnyfIb6RDb2waxBTZMP5ALY7twnHqSznw5Qv9P8O+vO/pXEvDPoJx8e/Toi5cf5w2iHrsiIr9pmj4WC+0P8/oK+Xdumyojwo6+VbN9Rj84F1j3BQP5r/0B6BGNZ/aFv6IeXhWKwdqWc+rjEG20Gjx3UBpP9bZW7lWm+M8P/OsW7BawDHoA6ucSpt2zu3VcdNeuyrEw7WV+j/GtY5JrfqvKOEfXB6SN77Enj/MvCeiTFdayyW8Z/WVlcHg/Ua9pEXLM+PMvh4vAl5auMzx/rDPt6E5ZMe1Zf8KHmOZzPPXYV/XtGJj7lrGKzUq2uvZVGhf9pBv6TQa+2Gc9cwvodzV+GLc9cluufyxWl+YfeQfgHXjpH+KfALt5Ff0M6waD7jmkCXJQjcbVRQyvNrinzNC6+h+jztqM+w+6xYfq0e8byG+CTZTZnsZrWPMH8c7KbmsBvek9T2oLU2yLIG72qDyYx8jo/IJ+vjn69nm9pnZFPvBpt6F9mUts/4etXzSUM+2loPj1usX8wTPnzPFSeFVJ8ku/nIVp1nVrsR+jLYzY9msButDZJegYR81+pMzlr5QxeWFnsLvRbbumKwUKHX1qPFXhYhT2zb72Mn2c+TCP88yWorTz/ePRWs1N2iorstQX/to9k5XCo33tFpHXry0SPcGAJYICUvEaDQB/Sby0VCJRkn0kYJ3xOChlSg8iHdZ/wsMqXRpuVrnXAxoZ5BkK0TYvlh33nIz6cK/aHY4WV9TwMazzDvaTiRIPuEUod8QjlcNMY8rPO7HXUW+icddT6ZUud94WCdk963hr+ZbkKpw6ZgpQ0ghqbja4NB2Ye1Jyy/VsHKtcQnaXA/TYN72rtXDkA+0t+Ch4NocNeCb9/1T3onE9brANAkvRtkUsGM0oNhHw/pX4zr7nnhR33WSXhpC6V4UP6lrem6cbW50F8Fbf75DG3u6j/au8ZcvuK7OpApdYpZbBz5f9cHMt/KDSo5ayDD5VyBDNMmdepRAxlNpiTaYQMZ5L1ItMOeGMHyQuf3NFV5xYlm3NXBzpT0okM8YeGawfEpFcbnAQAf1tR0xycshP5XIYj5fLxrqLXVdQnyBUG2tsLya3W65zri42MVN0q8orHWwXqSDcoTHGlB0jeGHDD5qTOh/8eFPuY3acDMeoosy0ot23wQZFvhd/W3rP2HdaTJHiUOoIT+X1IA5efJ1lrx8u3a1TIP/sLfdaoir+RNjiBrba5bKtbrc5Vuudno1Oo8RoqsfC/Ljt4tCr3fFaOq+rKeRdBrlCYhL6S8KcjDnUF+gcWiJ/mz6B/5FxR6fuGsCytKGzxgyUsntMn65fJlWT9cIfT/u2NBQ3uBsvbSX9cLhHkyxHVknxilvfHfNEvqpiThJ+2zUZGFnwwS2u+AXn5y12Bdkk7+TCbUF+sWKBhJumMe2ks8PhMMynYyg2zawhNiHEuQM8JYqxMoGp+bR+Rzs8LH584X8kyLx/7TkDtSR8J+PtL/JsRj/4XiMZSdT95pC6sYC7GP5JN3TMP+Ruj/K/SrtA8GYD1ddobxGMqctKA1GT/qfjkXtLjOk0H/dC/6xx+gOgj9n8d1iPS/cdtwmO9KwKwCZn5IzB9MwLwDMGfja80erw8G+aGta/bPfQ7LC53fJ8H7H0065Ae/94GdxxRdYJ2Ev+ZjhvFlyGutnlrX6uZqZ/x4HK9paViPDYk1o+T5aNNJR72R/6xDVq0eHFdofK5XdCL0hx1yIb30YbR9KSs6xI/yGeqw7Gpv/Eig8F/NR5NEb9cRHX80CXV/KAEroN/X0b2JQP9o0qtvoInHc23dZGuCzCID32P7x/Js/3585lxHOyktiWMxlpHTBP1GuaP2/sr2Pi7TIQbbcdIHSDWfm4ShreWm9fso4WaEnPo+fOTgoc77D+0/2jzS2Xe088gRxX43BYP120C/+U10KCvKNUt0vJn5GP0+Sr+fUOThxDrBNKvQJaW0/nE3XK+mf2B51/rlnhH57FH4uLDuVrBc/nuPQn+l+O/biE7mXKP479voXpL/XqsnphkL50/7wj4Nr+EL/UdpPuQn9pmviH9H3yk6E96HPfHOET/RN95D/rOKPCJ3XskbZX263KiUSo1LW+idYrXYbBddfRnvcd8/otDfo9CLro/60bX6guUjoNcoTULeYcqbgjyRUVuf9uOf5jPpH/kXFHpeL8nalhrWvlViyfo0+njp22vlm/z6lOHjyQnKCyGPD3ItAhaupXPS4lCp76tPmGaIQ7W3EPFaKOtQrjFP5OF7rrYSOr/rGWvXVtj3OGltJfUdtq2wPURuv75p7XSIPoeTpkOpb6TDvxlCh2hrvCaPvjaMr8dNv3zwLgT6d4R9Ok5pOvzTIXSoretPBLqeGIvnbw8q8oiPeSIYlB/bL0q8H4jlnyCsYylY+wgLy2d58gWxHiAs157siRSs9xKWdnBdsE6mYB0grKS3arNdaVifISztQ3SCtZiC9QhhYflFwlpKwTpIWFh+ibBOpWDx2w6x/CnCWk7BeoywsPwyYZ1OwTpEWFj+dEI59G9RmlXuSV/3+0GR0tAf2tLmPz72BjS9a3Gu6O6MImtBycNxG/OQzxmFj4Y1aYh13BDriCHWE4ZYxwyxnjbEOmGIddIQKzTEWjTEWjLEOmWItWyIdcgQ63HC0ubWmm/bEvQ/Ev/qPsDbm48efvxAJ6CEsV0uWLn+fzSBf0EpH1DZHN0rJGAJTo7weC1E/O90oO998tkRof8f4nVKfGuTq3yUXOfNPe/1lrOOq7zn7uu8Ausf9aet62hzNClbUPJ4TWIiIx8LG4/SO0Kdf04pHxBWTrkXJW2PCfvSbsI4SvLyPfYRWF7oND57RuSzR+HjwtqtYAm9Nkfao9Br8y1+K6qntzb19pi0Oas2z1rNHpPobRfR8R6TNndlrIB+76J7aXtM2KaHEuQUvmm2guVdNjkxIp8JhQ9jJT2gzXtZQv9faC/rCZJ3b/y7OFJqVFzPF/l9zqOReS8r6e10KHdeyRtlL6vbKBdblW6nWKssLLSKbZfPGPZNH3co9J4/yK7uZeE6ZZQmIe8E5U1Bnsio7WX58YONYhb9I3/tSygcvw37xkQLLNnLwrFE+vZa+Sa/PmV897LwTM8w+yPYHryXxTqUa8wTefieq62ecPC5c0Q+dyp8ZpVyuYS/wofvMR9NZm0eg88PXFXol8F+gs8PYNnDYT8f6X8anh+42nG2iteEuD3RBqPE/R7fcptlfBf6G2KZtOcHtGegDofJMguPrM9zCv3NsQx+x3n9+QHX82W8Fjns82WaHvzWca6rPX8jSfNrfNZ9EfL47A6uUR2hvFPA58PhYB6uIfFcGNfgj1KetpYrec9A3iTl4Zvc0UY5ab4ZXwK0f0cfl+kC4ol2E1Ke9iy7dl7wLrjGPJGV77G9YflDCeXYj3g+m1jy3Kd75/+1ZyuxThy7a/tCWcYX5LVW+zZa3VxnnXDfg/ctNKzjQ2LNKHk+2vSIo96aT9Bk1erB83mtn92l6EToTzjkQnrtRUdrvV6j6dBqvUb0dg/R8TMdaIPHE7AC+n0P3Utar0l7DvT+gi5z1vdyCP0yxHEPwDWvZWr12ka/o79Pxdeez/M1tXUV1t1TxBvzeE8wCILMYyme2fvmKs/sPUX8BRPb70mgSdrr+DjEud/aqWPmAj2251hbbCLrs7pC/ylHrC00kwn1eiwB8yjYYivB1gMFU6vXYaoXy3CIZBD6B6Feso8UBCv9Ivf1h8NB2Y4ovIKEezwWHEnIc/FNKxtdf5YweKxne32S6GWfMkmnbCtC/6jDVrRnoVxnpVkGpjmcIMMRRYZonNgc57cOPvpkwtYSbw/yVhM3JTfBpIKTlAQ/qt7Rgo4jv13mp23LBQn3uBmkLL7zrt050DmStPe2QamAxoz35CSt78P20qr3YQ8rshaUPI4Xs/JZ7T4s/84l8M8p5YOEsgGViTrL+Y2vXWtzUV77GHYuqnUOxkp6F0cr7Ocj/VnwR/wFv0Mgh4YpZ1aFXouLXS8MTZtfCn/RpTZPcfHWzv0K/YkhZdX2ejDmP0Kyonwnh5R1X7i2sh4aUtakfilj2CUnvf9o59ADB490sKuwGAFdz9C9pONB8vtwgqhbiI6XvfnVRTxu8pj0uCKflkQOTCzLRJCe+H3eX4Au+pcJXTQI3MeatGP4GHLfT1MubQvLZY5ZXsODrgkx+DVBQv9lh2sKA3e9uUssKvQh0PCSNXYDKatts67Nh82Lbe3jiWG/SsFUmL2+mn6WFPpFoOHXeeCyNW/Lor2EwaDMOIThu7GvIvsLFXxX3TSb57olfdy2E/bzkf5rDvs7pcjg+nCadtT/FNCIPNpjA1JWs7/40rf9dTT7Qx2w/bnqq+lHO0aPWxzSvgWiR11przYTnpr/E53jq8207e1cwt8gWBmiY920owX3h4N8fH3MSLYF2V9qoVx0XQ4G6ZeBr+YvmV70jEstWvvxR6n/FPrYC2RfOE7j8uP/XNB5Y/8+rsjKvP9vWOb5Z+R/tPCNX5n7z0H2L+5KLs9jCx9jwrykVyOi/rGe2Obsx4T+fwM5vwQ6jhL6ElxGj9Ik5Bn6ku6wY5nma5F+WF/L4xXaadL3KxALdZ40rdA+zo54HON9R1nu06Z9Icl+bEjZs8aGx6Ee36BXNGrjlqutNL+vvUb8VAasMEiu7zLIrNGjn0D6v1F0z5hTgW5LSwmY/y9g/vshMQ8kYP4nRzyijZ+LcI/7iPaYiPaxcu1xwTOUh7LzuHka+DPtI8Qf87APM9/AIS+PuWnysm+XvK1XvfY3sqUN8fUM4Rn7xYqrLd+o1CdrWx531J+xpNxksNJetT50WtHXzFU65tSQmFtiHBxftVjnobDPeyvx1nwI+kX2gccVuTDmcL1amOODq0F+6a+uo7pex91Sp6iNu6gLHndDyNN0N+wcm2N4pP90OJiX5ZtSyGc149pLNK65XhcdOnhG1zuJXuqGPj4Emv2Qj/S3KzYjmNoc3dUemu3jvDIMBuu/CHk4b3q1fNjPu5z2GvartMJeNf2EI+iH7VWLezR7DYmPthyb1V7xFdanyV6RD38cdVHBcOlpUak362k6gZ5jIKFvgC0nxVUog+tRi6zrA9oYdzrQeWPfRJ3wh3SF/vsy+vP40vM8qlTS+gfqlfuHS4dRGjZG5HUX7XFprX8sU5621prF70bJ1XekLH5M2fXh42H7K8uozcs1Xy/073P4+kVFBpevT+vT/GhDCHlS9vKtCei2jDrI4usXHfoZxdeHlKcdPU7z3fsc9pe0zoOyTjrqptlKqNRt2L2Ny9n2Yb9KK9reVV9NP1nHO9feRo50gliab9DWZ+KskePNKPG3oqU+SfEmr4EK/SNDxpsuO/yujjdXYYfjFm9qPgjXI8sZPn3nsj/X/taiQh8qdXP5oAlFLhyLtcdoo7Q3/lscMbn2ZPx+bqxYyxE/0QfeQ/55RY+G8pRc7ap9vsjv5+SK1chNse1HqRuu1E2S38lRedkLi9J7w0G5o6Qd88Z9qHO01iR80AdjWeHBceCLsHZ2gTC1x+Oyxr/4+OJux9yRXyultbnrs25LwEejx7EJ6T/vmB9qvlKzO6FP2/Phz3dq++vMWzsvoI2lQv/FsZoflkuXe8+exyzX3BFt8BTxCRU+2C+4D2gxl9Zf8ZN1Wt/i12hq+7aCxXPGKHXCPs1EQp2SfIW8kpJ9xVeHnDPugHvDxsXcZ0LIWwrSeWtt5PIZ2G5JPuNrDp+Rds6HdSr0X3foVPNDLp1anPPJqtN9oS5rVp0K/T/M4Iez6lTo/7FDp5qOXDrN6meyrP2l6ZSPNGt7yi6dCv3/6NCp9toDl06F/n+6jDrFOvPrYtFnhHA9Eaz0d/mEctsdmEsJmK75F2MktWWo8OG2/AtHW4ZKvZYy1uuUUb1ODVkvof9Xnup1LKFex4as11JKvY5RvYT+/8hQr6QzVLz2L/T/JmNsd6WsmfEZKrSNY5SnnV9y2cRq5jfTNL9xvXIEP6fsWlvjM1r/MaMNrM2ZcN0GcH2SbcD1WEiU2AZChV57tZP2uXKZJ2s2kPRZaeSzGhvI0RleX2dr8dVUWG+cR+AaxXuJfgn4an2R6Rfj+3i2Fvsbnz8R+unYSWtnayeU+kQ63LRd553UV3hNQ+h3be9jbo6vtcf5+fxrCHm89q49R4J65n7b81GgB1e/FbkuR79F+8riu11rIWm+W3Sm+e6QsCYULO2VWVo/50+l8Oe7o/TquYbZdPlDpazQrzb+uQXsIsu8B/VUScC8Hez+1u2D9cd2lPNOEd29221436nYuWBq8wPXI4Rp8wORxzXn4npzW91LfsG17yblssajmIf8MR7V+tUppY6sw+nAPbfn+UNFsbMsZx80+bKOi70xIOj79Cz7PlqM4LKTUKHXYgRtDU3Kar5YZPS8Rloe1heHjvpq+tHaMAwG6xIl7Tw8x0naJ4Q0e8jii9FWBDeylY/FjaHt0R7LUDe8xzGUa91E5Lsf+gqfm9fGf1fcLvQPOPyiVgeXvWc9S6Dtcy45ymn7nMhrb/y3WOyOlISf+K2NiixJ4+WHQY8/uUuXNbdC3tGSNnbmSE+8jmLDu1zMEb8gWDlX4LFJs4e9JvL092RPkTxJ/U70s+xFnlIX92TRfnFPFttGix+0tQucj3yKYiPNB4SAW4J8pO9CXNZKwAyC4cdZPOP11S2DuNZn1ML4WvMtpyhPmx+6ntcRGdKeTeKzjEL/CPgG1zOGIpffs+Pdy342VnSW5dNLmv2hLWTZOzul4PO66JOOONR1PvfEkLKHiuzcz7nvfIpiVOR5PANPrb/miGfS+dydkI/0p9Ywblg/n7uSPuvZuJDy0F6EZ5rv/lzsu7Xnt7N8ftO11+16/0l0vQvykf4Vh/2FigzYB4adh6z2/SeiJ8/2V77c+x28p6GtVWQ5m6l9Ziiyv0Ox/fnU41yj2ItppQ3FJjlNQj7S/3Jsk3moh/ydHEHO7lyz1K00u81as92utpr8WvkoSZtFr5mK7OHL2/s6475tGHcXBX/KD37vud9JqOuEUifhL7a0AehzCX+DQJ+zCK88YRnXreSqG8rPawWTJI9cJ2FNDok1k5C316bevTadcNSb+SfRa31A7k878JFe/Dra8DTpYqMfXZRd7TYNPIX/al6bLb9vJDr+zBnqeyoBK6DfN9K9iUB/bTb7pSyvE/XkUzK/TlT4r9XrRKdInqS+i68TPHCw2Y7f8skuj5sO1YlwXG1uut6wSPfYHDZQOQn1tCGU5cwpGJoK+Av1OYW/5komEvgGQd9c2X2kYcn1hEOWJIwcYcw6MNa7znrXUdJ618nWdayj8XKjUZ8vLxSrc+1Wt12tpEXj1vxbC/WFamehVS9V65VqsT3MbICjDW23CPU3RfT/l2MHaoMDM0r8JlOh/3eOmbwWFWn1zOIGUJ5twUq74hnEWtnTXLOxMN+arzar9WKrOFcfpj21yDWXQSdTCnZBKT+VAQvb+FA4SC8RbNKHwgVviuj/f8fpk2koI1hHwnSZ0Q5wZvBgOCiD0P8dyPBlWl1BPfDQi1G74VDXyhG/INCHXuGfD7yGAiVuD5Enyb48z6QWcoSP8mxU9CNtuUnJEyxZcUKfhvQboY5Ij9dSHu9tjh8/KBBmlOQtqDklb0K5J/qNZJ/aMVg3bJtcwl/B5XvsF1A37CvRT+MOZWHHYF2wv2sxivgP7ou37Ohj7oivtTiG2499P/v8pDgvyV/xuCj018cyaR9P4XER68kyIr9JhW+U2F8J/U2xDJ6nAOpHLZNW37B+0djlWmlx9V/Xipf0hekEesGbIvrboc14jNkEZSYUuTiWEfo7AZNjmRmlXlp/k/t5hX5Gqde2YKVfkrLaroTo3vObbFvargTqcCpM18/GEfQjNlAgetSV5ts2Ep+0qSXv4mqraOgLtfiNYwbkr42veI/9NJYXOo0P63Ojg4/mp7R+p+mR+8j3OfqdFtvhB4A3JsiQNbYT+reBDL/oiO1wLHvHDres7NdwjoX098NY9gM0lnHbR0mLy3nHF9tSdIT+dlrB1fwG24TWJ5GeY23pY9MJ9BhPIf0HFJvYFqzstxMJ/FA+vOfqG/kELK09o8SxidB/xOHzNyvyTSjyCf0WhX4z0Ig8mm62BDpvrA+2J39AXOg/odRHG0dwhyRKk5BnOI6oX/dAvfI44tJhlFjnswo96lLqVyB61L/WRzdTHvLdRDKkzaF4jNHiJ/RR2nIx6kDknFHqa9d2rVKO+En98B7yzwcrbd7HnDWrjYh+Zv3op+iywVlFPyLPVi/yFCtiKwWFt8gaP+g54FeQfhZ0iPR4LeXx3gmau26DcoJfoLwo8XwZ8yaUexsuE1ZBwUK9SZtG/fgw6YK/lKX9FVy+xzJie4rNu3zEavkglsRRWn+K/u2NfxdHSpWy1GOrUg/hjXZl13dqc1l9nfDPB177csllw6gfaTet70vZQrDShp8M+3Rp9o18NKyLY4q1ZIj1nCHWeUMsS32dMcQ6a4i1bIh11BDLso7nDLEs5QoNsSz7o2U7LhpiWfahC4ZYlu1oaasvGmJZ2tfzhlgvGWJZ2v24+hzLOr5siPWEIdYrhliW+rKMTSzta1zjQku7H9dY7qQh1rOGWFdCLDeudm8Zm6yPacNhjWssN66+0DKWs/SFlu1oqa9xjb8+a4g1rvHXKUMsy75t2Ycs9WU5Dln2oXHVvaX/WjbEGte1IUv7sox9xzXGHMexI7rmPSuLsWNbAjZeu/aGNT45RWZtT3kDYMwEK+trua8s+Ns94Uu9r1J0hXUS/rzHLPnaX8HiPOGVJyzjupVcdXPtReO+O+ogCeuqIbFmlDwfbVpw1Bv5zzpk1eoxa6iTKUMsPqun9X9t/1botyv0mp1sU3hLWWnbHZBn2LZlV9uijxD+q3nqXfT2YaKTr1hsCFb2jasSsAL6/WG6NwF4mNbKv/NvOVuDZ3rlPIp2hij6tzf+XRwp1csu3+p3nKlXcsRPdBqQ3oT/Wvlulw+LEp/ByOLDovRU2Kcbxe9E6XOGWOcNsZYMsUJDrIuGWJZ1XDTEOmqIZWkTJw2xLG3iGUOsK8EmzhpinTPEGte+bal7S32dMsSyrOOzhliW7Whp98uGWJZ2f9oQy9ImXjbEsrSJ9fjr9eGjLcfaE4ZYV4IvfMUQy8rnRNc81x5FrhdCOyzLPmTpo5cNscY1LhzXMW1c51aWurfsQ5b6svTR62PHd//YESXLuZWlL3zeEGt9TeHy9SFL3VvW8SVDrHGdD1nq/owh1riuF1rGOet+4vLFE+t+4vLpflz9RJb4C997yO8z1vbxBWt7CtY+wsLy2wlrRwrWA4SlnWeQclcn8MF3a+AZjKsV3hq+YGjnOKJ/e+PfxZHSXHNGqYcdfrkt++HXQL1z8V/hfS3ct9u7r2Z+36rwz5OstvL0zxJcS/KwfvgswXWKrAXKi9LxsE/HeRPKvQ0OrHOGWBcNsZYMsY4aYp02xDppiHXBEMtSX5Z1tJJL87PjYqvPG2JZ9m1LmzhriLXuv9b9l886Wuo+NMSytPsXDLEs+/a49kdLHz2uY61lOy4aYl0J49CVUEdLuSz96jiO29E1z9vHxb4s9fU5Q6wzhliWscm4jmnr/fHy1XFcx+0rYZ5m6aP57Njr0e7PG2KN61rHi4ZYPnw0PxcYpb3x3+JIqVKVtWjcO8kFg3wxFjFcN+/kiJ/oCO8h/zzJaixPbx1f28tB/Wwg/fjZ5yi2c4SP8lyr6EfbV+A48vr4N+5jIf21UEekx2spj/f+It7osPST0fPW/0uMO0QfKLe6pUqtM1cr1pvVWrteKbfLc8V2tdYtlRql8ny1Ual0W9VGu1GudMtz5dZssLLduQ94auNq1j7Ae1me+qRzL+tqpY2G3ct6OOzTjdP4+2A4WB/Xe+r92EJlYbW24Ps99ZotuN5Tn9UWng77dKO2n2VMbTmXfNYQyzK2GNc1OstYf1zX6MZ1X+A5QyzLeYPlfsWVsOc3jnvwUVrfB758uj9tiLW+Dzwc1ilDLEu7H9d9zXU/cfl0b1nHlwyxLOOJcdX9y4ZY631oOKwThljrfejy6d5y7m45R5ZnKHgNKUp747/F0VJ5RuFrhF0V7OvtsXvvoL1hdOw23xDsnfZydwV7l4JdqlRKl8SZK3Xb3Uptbr68UKpX6vVutTtXb1Tb3Vq12Z7rlKrNSnm+M1fslhqdSyvWldZcvTvfbtV72Deay12pyTodfo8bv6feio1T7B6/lz5BZaPrDZCP9P/k2j5mN76eBdwAMKI0Q3i5wHI9s1zMEb8g0NdXhX+eZLWVp7++uoHkYf3w+uqEImuB8qJ0LOzTcd6Ecs+FdcYQ64IhVmiIdc4Q60VDrCVDrOfHVK5FQ6yjhlgnx1Sui4ZYlnZvKZel7p81xLJsR0vdnzLEsqzjy4ZYTxhivWKIZamvs4ZY49q3LccOiSfkuW6MH7cEg3kYO22mvEnIQwzMQ/kmHfJh+cmEclwPiX+nKX9v/Ls4WioJ/iY/+L3vQmxUdIV1Ev4Sz04BfS7hr2BxnvDKE5a17lx1Q/nZDjaCPPz9CA1r45BYM0qejzaddtQb+c86ZNXqMUk60fpZTtGJ3N/kkAvptym8pazocAbyDHVYdukQ+6LwX803NURvtxCdvItjQ7DSBjcmYAX0+xa6NwF4mLYRhuZHuT8ntW8hoXyUZh18ZpVyUr/NIOMtkL/JUd8J5R7LiOWFTuOTG5FPTuHDWNoaTZRaYT8f6f88XpeJ6vCdnYOYuxX5XH1xj0K/G2hEHk03UnZW4Z1L+Ct8gsBtQ7uBhv3UHkM+e4BmivjcasjnVqDZQnxuM+RzG9BshnLR79shD+1MfOndkG/nS8tNqecbg5VJ8u6Be58P+3JwmqDfKHfUH76yq4/LdMzzDsi7h/LeAHn3Ut6dkHcf5d0FeW+ivLsVeVbbzthWdyTUy4IP6ugNxOcNhnxQ33cSnzsN+WDbSVvNBCvb7nLZP7at5N0LedzW90Eet8+bII91+mbIw7PRnLT+JnqK+tt/n6G/Xen61exS0rp++3mr1S+Oa5zW9dvPy6Lf1ehQNjyzjLnYVlIniW+l/BvizfBo3nPrdYPlca75YDiYdxPk3U95Nyt5Ef7fxxvYEt+iHniOgePQhHLPNce4MwFrErBmAEveezhF9G+P9eHXJutzrphFeL/RE+8sYzvyn1XkEbnzSt7kCLJ2W41ipVivtzv16kKt2s0FK/vuhHKP5133KPTaNwxF1/f60XW5903jsI+PsXCUJiHvjZQ3BXkiY2T3B3YNyn+PJ/mz6B/5FxT6B6AOw7SlTyz0BxZYG1eJtT0Y7E/oczyPi/OaD5Kk9fkC5aHNXUV52J/4O9Y4ZuLaG6e0cfGGIcZFHB/emIApY8HtkC9j2RTRfhDG0PfTGIrzw/eFg3k4DxM+EcZD1/XvIx9tPI7SQwlyPUjjl581h2pbi6l4/LrHE++s4xevOaA8IndeyRtl/FoodSud4sJCtbzQrtXrddd4hPd4/LpXodfemyu6vs+Prhe08QvXa6I0CXk8tuH4JTJq45ef8be6kEX/yL+g0O+HOgzTluLbtbhJ8xWfDgfzcP0HY+qHqI/7iRPLC9raYUDyY7vx+IA2yeMDzo14fMC557Djg+hi2PEB/STWCTEn4Z7m46eI/kkYI56gMQLHdOEd0f0ttS3qybBtu6zrQNFJEe4Nu2Yscg+7Zoy2XKQ87K8lysM2K1Me2mGF8t6kyJNlfIkSx4PYVklzJws+Wtyt9dVR+Wj+kfVtwQfbTtrK77g2nP1j20peCfK4rcuQx+1TgTzWaRXyroNrTlp/w7F1mDW3K1W/eE6D07p++3mr1S+Op5zW9dvPy6Lf1egwWGXsg3UaJfb5I4pj/MwFi8XtVC/ktR5DrcdQSXzWY6jX/xiE7+njtD4G9fNWq19cy+S0rt9+3noMtTJdCTFU1rWerLHWB8LX/nKsJY7u1f3265Llugt4L8Vl1mOk9Rgpic96jLS+zoRpfYxZX2fCNA76xbGV07p++3njECNhWw27zpQU+7yN4pjLuc7kyUY6WgzBukX7GTaGwvZc7fMdb6Y8n/EVyrPaWADbaq2e73i9xmp+z3AMZ//Ytpr/5La28J/DrjPhOc5hxqArVb/DrjOtVr/I50rS77AxlOhpTJ7vGCv9ZtXhap/vQBvlMRfXeoQO13oYA3n4baPs3zUS/vnAZ5/sv7viLpKH9SPj35ag/4zLg50j73984cD+1v2dJw+/9ZH2+5uHjuxvHnhru32oc/gw1gY5zCq1ZWthGrkuKPcR440ptZA3HmwLVrbyGwnrnhSsfYSlRR6CdW8K1gOEpUUXUu6+BD5Io63woDz3pcjz3jBZnvsI600pWAcIC8u/ibDenIL1GcLC8m+mcsUEPkiD3rCo8Nbw2W5LKTI/Eg7KjHKVCKucgnWQsLB8mbAqKViPEhaWr1C5agIfpMGRtAp8cso9TZ7HwmR5qoRVS8E6RFhYvkZY9RSsw4SF5etUbi6BD9LU4f4c8Mkp9zR5joTJ8kjZLCMcymo4omR+KkH4r9UIl6ZXfktMQ5G1oOThGIJ5yKeh8NGw3miIda8h1j2GWPcZYr3ZEKtoiFUyxKoYYpUNsaqGWOITxadhu+4gPlqM8GYHHyzPMwUsl0v4K3z4HvPRZNZW0vaHr/2NZiT/9Pp+GbRBfFMTlpWxaIro/2xnH/N/jTFFl9pMScYAtC07n1upS71xbA1IJzj+3ADXnLRZo8g97EotthGPldj/G5SH/Xme8rBPvYXyKoo8q7UvbKu1smNesS4a8tHiYNa3BR8tRtZiTOwnmCd8+J7rzUK8Yp/U///6ep1nUv+X2G+K6P8Y+v9/oJ0gjDcN+/gc92NMWgzFJ0HmIY/t+S2Qxzb4DyAP25aT5jdEF8OuNuFYJ3UaJ/1GadjdLtTFan0o+0ns0+wnsa2S/CS2rzaGjOoLsK3WfWh2Pth20laeY4ih/Uud8iz9i+R9D+TthGtOaTHLMLsFV6p+0edyWtdvP2+1+uX1KUyW+sV2fL3qN6sORRfDxh9oow3A5zEA6TCGTFrnDhQMxuFxUeq8QSkrX7vS1rqvJh7aejve4zHoakVe15jqt3+/9vZz5Cf1wHvIP6/oxMc6ZyWjXrXYtkI6xzxea9PW86sKHw2L/ZIWe80EK/uYob6qWdtP+OcVPfhoP20/6WpFr2th30ntXHTIU/MjT+8NbNp+jbb+F71pZToIEuNXtsmkfR25l9Q2yJv3l117fZUUrH2ElVSHpDZCLN5f1nQwRXlH40W5SIcfv2GQRvZFHwGaT8bXrnmb572nzH2a9578zOHde0+oH7TZjYHbdrDtkvbl36TUlW35vhSZ2JaHPQOAWGzLrjMAxRQstmUsz3EB+mo++VVV6iN5NUW+yMYP3ZCMX3Tglxz4FQe+62QxrjdWKQ/XNWuAf8yB73oz/X0O/Dcp+IwpfqMAeXdQntAejzFenWfEMfJM4HPsrVS09fqA6ow+dti1NpF7lJPl3MbYH2uUh/2L5z2ab/C9BrZWJ8vX6sQ394f7DPlovtHv06nD2b/mi9CfcVvj2Mrtg3EA6zTpjAUnrb/h07CX/2Tu+OsXz51wSju1u67fdP0O+2TZavXr5w2Y46XfrDrEN2Cu9uk8qVN06lmeEH6wc+T+zpMfbh7Y324e2X/wkR/qPPZ45/CRSYK9I0Ec+c1Dk5gI4gQOcaO0gfLuonx5WeqGQE9iNn6WpPyHVSL3sGGV1sRa6MRhFQ6/HFZlOVqC8qw2PMC2uiuhXhZ8UEdrHe6wvi34aEe5x2lagW2ruU1ua3Sb3D7oNlmnOCzdCNec0qYxwwxLV6p+h31x0Wr16+fl9uOv32HDKvyA3+V/4HS89JtVh/hQ6WpfDMVjLsY88kEHybsJyvHHuW6GPHyhFH9sCZcIdgeDebshb098PUVyXROf9ZghOmN7aPPSm/BA3nd64p1lXNXaAOURufNK3igfkyh3Flr1ZrNbaXWLrWb31YcoEV9k5Xv8MQntIcetCr1nv9qU/oIfk+DHIych707Km4I89Gn8MQlP0+1mFv0j/4JC/26owzBtWVD4YP8eBks+TIFL3dK3/fa3ckOL2SWxz4zSsHMjkXvYuRF+dJ0/0oF+jx8CH/UjtyhPFl8UJZdNTCbUy4IP6mgP8dljyAf1vdYf3/X8Moih7F8bd/hDe5iHS/XcPlk/YjnsC+FW+zKIK1W/u+Gak6V+d0PelaRfjJs5afrdHV+v228/D/0ipzQbHWZutBvypE7r8cd6/JHEZz3+eP377+vhmtN6/NHPW61+h/2Y+7p+xzO+W48/+jSW8QfLPqXQ3kJ5QvsyPI78h/H1tmDl2HVrMJh3C+TdRnm7FZkkb48iU4544OMwQh+lVjhYB6H/qVjuSJdf2qVjbkjAlCOq2jrf7vjeTPx3EvLs7LdViuQ+Bv0IdfpqfcPBOuF4PqHQ81rqGxR6tFfRkfZ4/O2EtVvBuhXuyVqhpk+R8XLoE2Vkfd6eUifWp6Z/1NPu+FqLmW4irJsUrN1wz6VPkfFy6HM3yMj6vC2lTqxPTf+3AY3oqBCs1PXNhKXpcw/c47VsKT+t0CPeFNF/HXzOt3cOyod+czfJfouCjb43RxhYj7xSj1nKw7IRbuvaQdy0V7tx22iP8OA+p9i29poOKev58dKhX2HDr7fQXlMlefjoKe/p4qOn/NgAPnrKr+HDlPboaZb4Kkd8BJd9FdvMHYqM+KoT7dEofrSwlJGn0Ke96pDtT7NXfKzGZX/82isph/EFys+vbBH6v4C+/p34WvPHoie//rjY0fwx6pX9sUuHURq2z4vOtFd1lCkP7YX73R0KJr5qC32a/B1pb7rd7pSqpbn5Rqdabc/X+AMJqIvNHvhXa825VnOuVJqvljrV0przb9XqC61LQhQ7pVfVsdb8a+2FRnGu3Jxvt+rtSq211vw7C9X5uYX5Vq3YLs6X5itp/KN+9uWYyOfaYJQeDl/7K2PlNJS3fDRX8DeSfEb4JdHTVLBST8J7k5e6dbtZ2gH550lWY133HindRPKwfvgsy4wf/XSiR1bF9tDnTyu6YTk2kox5TzJq46rIpJ23ETkimn9CjyBu8CSj3z7a7Z0tw9hwf/ja31fnKbTGIW2DcQ3a/QbIR/pNu/qY0/H1NsCV8uKnNkP+RiVffkt7bVBo8Zp/i+ysV6QXm5xOqOs01VXot8b1i2T719t1TNQfyrUhAfMqwPwOzd9wrubq80K/WaHHPibybAtW9s3NVA5lnwkGE97T2idHtDwGyziF5ZJ+zyg4STJsUnC0+fQMyYo82R6ixHOeCYUP9ikc82cU/objQ00bKyVJ3jTVF/Ow7h8J+3SctDmm1Cmq71/RnAbpWB6tr1nGRnJ/Cu4z3wminSZaHM9ZZ1MGMhYUPtOEu9Ehf45wJpVys4HeH7W/WeXNKfJqY82ofBDrR8JBPtjOOKbN0ZiGfnxCKft42M9H+u+BMe0tGcc09iVYh4+G/XvsszmO5T7Jax88djENjuNI/1Zl7GL/gFjRvbdniBG0uI9jhBbo852kTy0G2Bas1A3b8AzxwvhYxhfWwQMgx/27knmJXmcddYzuvX+XTocyIB1jaGOnYGj9WsptU+Tivse+Y9rBQxvPNB5TlDdq+2jjNsYaWgyj5eN4jnz43gaFPi3+yCdga7jTCo7m5zdRXk7JYx+G9UUfxrGJNidD36j1u6S2c8XemuxZ4qpph+ya/tAPWa/lFBvFUrE1V+t2S+16c6GatpYj9zeGg/V69S/cm4J6RWkT0lPeDORNhoP88/HvSeCDWCLHFNEfhbaO0jSUkfIFhf808R+QW7mHtsZYE8o9oY/a9GAso481unJtvtGcXyiWyt1yudKop7WrpidcO4iS6BrbYlqp2xTRn4AxJ6R9mCmFX0R30UGXS/j7KoZybzIcvKe1Edqu0AvvfLhSRsnbDHlTxGdL/Bv1hVgixxTRnyfbRXuT8gWF/ybiPyC3co9td7NCv1mhj9rnNPkjrLv12t+rPAkf77FsFz32q3q1Xmo0mo1WvdWdr7YW1nzvYb7ena9UFkqV+XZnvlRf87X/amWhW+peWv+vdIuVRmnN9z6axfKlPZ+FhVqp05yf7655/UulUrdeXWjUW+VLS4xrvvdS7c416925Yq3crnbK7eZa82/Odear9Uq5VenONxvFxlrzX2jXW8X5SqndbM4V5+qN1ew98RpJlGSNitdH9q5STkqZX9PZ89PByljWx57KBMnD+pFrXpvCsto+nLyHJ6fkTSj3Nqwxlmu9xvd6ZVZbEP75wKttllx6nVD0ymuAWJbnelHi9ptS+Ghr+t8tWFI+Stoa7oPhYB62MeuU+zvmaftY7ONc6yKu9SaRS+be2loq1oXXNP6MnsP3s/daLLK/Z14or8TdqI8oPUB1EPp/C/OUf0prBdr+gabPDZSnralpe0/cDr24GuqwyVEHof8Xyl6athcs9fF8xqqqnbHCPSycN0T/XPt3UeK14y0K/Wag4XWmLZDH/Vfr/6hzXofGtSWmRzxeW/82tBGfeUW7zpPsWHdeg5pQ+Lr2/SJZ/iv1WU9nZea0fTZJs4re2JdiP2F/yecnMA/tAHXAaYJ+oy5e3SvI8FyJpZ/AZ2delS9cKdfl6Le47sz9VtunR/ph9umjJONbIVjZlmzf2lgwTJ+J0ruJn7bngH0madzVYiL2F5NKXaLEY2vPv9B5HN5f2xv/Lo6YtLGVzyt5OuNV1/aPJM0q9WYfgf2HfQTHIpinnffP6iNEF8P6CC1u1PwH+whtX1XrA9w/tP0Q176XNm+Sd5TlCDMI3Psa2p5x2vyczwBEybPtZ56fC/984HXM7M3J0vaP2NZd53+0MTZHechnk8JHw9pgiMXPjWJ7sC14WhvJPD8X/vlgpU592ILW53KKXrW1mixnpnNK3rDrK+OO5VoDzNLuGh+2f+SD4/vAOZ0bB8tIOZzvYVme7wn9127sY74lvtaeO+az0Vj/vfHf4nCpyjc8z/2b2vwxIH1vVuqcU+i18VzkHvb9LTieb6Y8HB+2UB6OZbOUhz5xK+X5st2phHpZ8NHO+LnG+9Xy0c5PaPPPUflg2/GZJG08W+3YqM1DtLERfctHbtR5om/Bsu8N+/lI/wvgW36U5iCe1sYbbP+Yhl0PYHtG38A2iOtC/EwPprQzwMO8gwJtbwbwuV8iT89x8FD6j9Kw78jqPTMRDOdjsU/OUB7aYp7yRvXNKI+Fr3Ct6Y/KB2nW6l1caz1meF6rHNr/8Bgz7Hqk5n9Yp9g/MCbmlLaOOcw7hq5E/bJP5mSp3xzVY2/8uzhaGnv9DhuTC92w+vW0NjBW+s2qQ9GFRXyCz3lo59C1+bjQu/YIkJ8WR0vZcZ1jDtsPOP7cCnlsM9sgD3XCKW1OO8w7ULR5CtLxufWcIiPORVzrwHJfW9+ZUni6ZNTWRl32qu3XauvtbKfanArlT5pTfTPWR9r+vOjJ8z5fTdvnQ71OkUwuHUZp2D7P54a0Z3W1tQqeC2v7brjOZn0Oca7cqjUrtfliq1Oba9bn0s4h9vbdwz6dYTuWha+010TQ9weTYV8m4S82h2fLhU5knfEja1FklbPo0oeQJ9ZlA9HzNT/78a9g/QPrKPXAe4gv9No5eHw+QGTUnpnYHA6HtYmwNo6AJXJpzwZsXKVcGtY0YQ3zzMufxW2TtPeXtF7+LVrT0p5rda2XC/3/B2ta36axyXJf1rUWqJ3/4nMjrmf8gsC97snrI1gOxxUtHt0b/y6OljLvoQn/fOA1riu5xiMtZhD9bPYjT1Xk0c6vae0cvXNma7CyzVA+wdLikGHPCfA5miznBNDe8R0nrveQaM9Ta+s+3O+DwB0j8tnOv4V+vz1+YaTrOVCt/3K/186VSF7SuZKkNnfFULMKvTbPEN5oE7MZsDY6eG9V6GcdvFEuLMu8k2xXi4VFN5cjFsZzahwLu86eRimLLrV2LBA96k7rx644eTPlaevoWj8W+8X+osXaeAZWxuj/Bsp8Yp8hoAQA",
      "debug_symbols": "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ndj1fif2vd+Jvfn7wNPdmC8TsH4Vqjky//6rkJXN0y+p6DZHv3xd3/Y+g+YRmgKaB2jCAppHaBxoHqHxoHmEJoDmERoBzSM0K2geoYmgeYSGbvghGrrhh2johh+hEbrhh2johh+ioRt+iIZu+CEaAc0jNHTDD9HQDT9EQzf8EA3d8EM0dMOP0KzzdsOX8HdHI/4AzbzdcBXNvN1wFc28fU0Vzbx3qMoP8vw67x2qhibOe4eqopn3DlVFM+8dqopm3rymikZA8wjNvH1NFc28eU0Vzbx5TRXNYTcclv0H0GG5f9bQ4WSdi27/dbaLvgbH+303tEu3fvdIpSAfgyotBrXe9q118e7RGZ1nJce7ZgDnCscB5zEcD5zHcAJwHsMR4DyGswLnMZwInMdwEnAew8nAeQyHDvkxnEyH/AQOHfITOHTIT+DQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75MZxCh/wEzswd8uVzs8EJy8G3p8rMHXIVzswdchWOAOcxnJk75CqcmTvkKpyZO+QqnJk75CqcmTvkCpywzNwhV+HQIT+BQ4f8BA4d8hM4ApzHcOiQn8ChQ34Chw75CRw65Cdw6JAfw3F0yE/g0CE/gUOH/AQOHfITOAKcx3DokJ/AoUN+AocO+QkcOuQncOiQH8PxdMhP4MzcIVd+lRv8zB1yFc7MHXIVjgDnMZyZO+QqnJk75CqcmTvkKpyZO+QqnJk75BqcMHOHXIUz7+ZhYX88or9E6Qdo5t08rIpGQPMIzcSbolbc+MSPPqqimXfzsCqaebfSraKZdyvdGpqJH31URTPxZu81NBNv9l5DM283XEUjoHmEhm74IZr39zU/e3h9Khuay5+36W4Prw8Kj5r52QTyXgmXP8vXCSg8EOaHE/Bhn0DwBxNwvU/A9z6B0PsEpPcJrL1PIFqfwJL2CfjlYAKp9wlYvxNXJ2D+TlyZQDR/J65NwPyduDYB83fi2gTM34krEzjeESjJNqIk8auJON7v5GZqypoPTlrPnBTPnJTOnJTPnFR+fpIc//6+dtKhTm7ZHzfhlrgenObPnRbOnSbnTlvPnRbPnZbOnZbPnVZOnXb8C7T6aeeqxJ2rkuOfrDy/dsjxTznKfpkq/uikE5cBOf4Cd+Wdjr/YXDvJnTnJnzkpnADh5cxJ65mTjnWKW0WUdFBGx19Aq52Uz5xUu1wfnRTOXK6DO3OSP3PSmYoIZyoinKmIcOaTG9KZk/KZk87cwOWnFfFfl3/9f//x3//2j//093/5j8spv/7v//nXf/7Pv/3bv37863/+f/97+z//9O9/+/vf//a//uF///u//fO//I//8+//8g9//7d//vX//rJ8/OO/pyXIX9Oyrpfh/Cq0Sx9a/ppCTpd/D7//v18u/z8sv/7/rxMkpeWvl3/8PuH3GUtylyNSuIztMr7/Hw==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "deposit_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAAHfCQAgA0AAAcZIwAABzIuAIADgAUBAIAFAAKADi4CgAuADiMAAAd3KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAd3IwAAB9AoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAB9AoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAg0AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAg0LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAgDAQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACIwjAAAI/CQAgA0AAAiZIwAACLIuAIADgAUBAIAFAAKADi4CgAuADiMAAAj3KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAj3IwAACVAoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACVAoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACbAuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACX8uAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "deposit_public"
      ]
    },
    {
      "name": "borrow_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1ZzdbuIwEIXfhWsuPJ4f232V1WpFW7pCQrSi7Uqrqu++DiWEhdBUhkPjm4pUM3O+mRhnEpu8Te7nt6+/fy1WD4/Pk5sfb5Pl493sZfG4ykdv79PJ7XqxXC5+/9r/98Q1f0hs4/D8NFs1x88vs/XL5IbYi04n89V985mjy0EeFsv55Cal9+mxufO+tXbiO2PrMZbkwtZYEtnO2KTHOIrErXGUxqIz/jmdkNJF6FNqrYnSFekvU3uNu9rHgdqThpaejPlz+qQsW+OU/Q7pTS5MT/4/+kYj+CtohD6NIKEdFEFSNyiUwYMi9qYclKjFUT+Aoy66rXH+GAdwlNpaRmV3hHOiOhZ2OOQ+xxlIOHm4AjoH7zxcwdAKRHAFeA4enoNXtAI7uILAFRJaQeA5SEQrKMMVzp/5vFF7IfS21wWQ442EebwEPouAzyIYXCISXgKfRcJnkRQtwc7hJQQvkeAShM+CIlzCnz+BGLdTuWl3a5b0I37AxmcCxwfzC5hfwPwK5lfDxjcwvyk4fsLGDwyODx6fETy/4fsKxvcVnOBZiCO8BLw7EnJ4CXwWHp+FF7wEvMcTZrwEvMcTwWch8FtdAXcaAu40xBw4voDjR2z8AOYPYP7I4Phg/uTB8bHfL3UOHF/A8bGdvNL545Oia1dWKVI8UsCOUPUMjg8+Awz+BoCfJSj4WYIq+Px+YVVBBpaoycTab4BZByObNXn9wtOEcxUMrRDc+Qrkabdfg7xoZ963uyM/EG43CbDT/7YhbIDSyICijAwoje2UpTAuIPvCRocrA8WRAdHIBrXRN1QotdZ53WJgOxQ5Cu1uJXKeD9ew7Qvdyrj5Q9387Cvnr7z+ev2LElvb/THvbSk9wR+Yd/yZ5Yj/+hOicFtRzk/Uhvij27VxLh7tgDS9/vwpu82emT8O8afdBs78WeMhv/nK+UPd/IEq57e6+WPl9U9cOX/d82dwddc/uMrrT5XXnyqvv6+7fwi+7v4hcN3Xr8BaN7+Oaf7ZAI1pQDdAo7rD2ABdv2VV367osQ7echKn7heJ4vmQ/xtuGS7Lr3XzR1c5f+X1T3IBfo7SaTi/z5814kVWMgY0yF1BQ/Ea/Qt1JLLzEu3OuTf98IolXv23u4NeocAr9e+lHfSyEq/+sUDdZj0y3z07/VhDTv2LSUNOqcCJS5S0/+f5n66LpxNvPfjcyUpy6t8TP+AUfYlTiVIqUUoFSuRODPQhLy3ySiVe/Xf5g16xxMsXDNvsFUq8mEu8xBV5aYnXiXeoDHkVVcOKtKwor1NTxmmv93z0Z7ZezG6X8+2bcx5eV3d7L9J5+fs0P3inztP68W5+/7qeN2/X6V6s00yn3sWpN840TQLeZMoUN2z5kNSmeaA2h01R8kDNh5IZMsc/",
      "brillig_names": [
        "borrow_public"
      ]
    },
    {
      "name": "_withdraw",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3tjhynEn2X/b0/gKKKqrxKdBXZjhOtZNmR7VzpKsq7X2Zmm25vw+AtN22Ynj+RJ+7jc+rwVdA0/PPw+/u3f//529PHPz59efjl138ePnx69+br06eP8dc//z4+vP389OHD05+/Lf/3gzn9x4o/A7789ebj6feXr28+f334JQR2jw/vP/7+8Atb6+I/8cfTh/cPv4j8+5/HCOLXg5wBDUgUIKthspqYnNeANEygiQk0TN7lQBacx2eUBWCzhD2uHzdu4rDGLzgo87AXE54f9mIpPUw+8zB7z5N6f3pifvisPmyiXmR62lrZTz1u4z1y8p4r3lsMk3pLANfVC4J/flgi7qV6Mhurt+4b9WcObs8Rsm0tVgSBCeWMtdc50LB5fjr+kSvVAu0knxHMS2NDPugoIsyCIFwXtGU95e9xCORl18KsgglpYGBsDobsaCqXGFoCIbT1DAzl5Vif5BBfl2MN8KJbRXjJYe0OHDvE4XaIw2F7DjA7cOwQh98hDu934JD2HAg7cHB7DvrxOAhoyqOIluMsnhmCa84QWjOwbc6ArRnENGdoH4M0ZvCm3h4CXmdgg1PGwibMCSTShSG0ZrCuOQP9OEOs8imPsrBkWD8MBqcMDQxX5i8hJYy8mPe6WNYn6d+RdGws3dskHelF/+sddSUH+nIH+nLnOxKkXeVgV3KwL3ewM3ekKznk+5LDXckJ0Jecvtxh15ec3QcJScmIC5XlIhtX70yagDl4uWAUF5yGVo8Dq0djhlY/tPd27z4NaFq3ja8OXE19gLTqbAKu1Lu9u0APk5txCS3U1LOhpJ5Xbxpw90mHt3ZWzzX1kl6TxD8jv1QPZmj1OLR6GVn9dyw+96x+aO/JDq1+6B4zDO19GNp7Htp7Htp7GTpTkKEzBRl5tCIDI6t3/fQ5Zzn9VOSTnI7mD2c5fmc56KZ/GbA6lbQg8yY672ClXkZW72Fo9Tyyehzae9pgAQjTChnHROu6ekY/7x0Vv3z4LIe6krPFhGNLObivHBsorR6GMPf4/iKHoSs5YvuSQz3JCVu8I3iVHE47yuMfw0oOdyXHur7khK7kuL7ccdSVHLB9yenLnS32GpVHxZycQGmnMIew2Dkn4aIIe1OE3XmE3XlE3XlE3XkU8h5JmrdHjsq24mDTx2bB28VHWnhhkNYM7JszcGsGcc0ZQmMGNq45A7VmsPX2gJVv6qwHSJ8telg0uvzkPDbjaXLOjNcn51c3eLPF/cV7SOJXq7HsTG+CenMIenMIfG+CpDNBvjeHfG8OFdY3f6Ig7kwQud4Ehc4Ehd4cCtSZIO5t6ODeBtfC8m5TQelgFW9qyVztC2UWGlq/mLH9F4Nj6/8Zk5lN9Q/uv9s97Ygz2nSeixVb0399q7/A7mNwfN2c/Hfffu+U0399s78A7a/fmVl/9WOF65uZxJvB9ePg+mVs/egH1z+4/8EOrn/w/pMH958H918G91/G9t8aM3YCEQMYO4OIAYw9hFljYfAAoKdO6KKop0p9VtTVROOiyO+uCNJk2EN16lnZJB0DkMED2P8lztYB8OAB0OglsMk7HHTpqHKPHq8HEB8xfn4cv/kw4qKJ+tO0yTxla024u6aru9Hj4A6dKbLGdqeIelO0yTuI1ym6urs4KuLeFLlN+slyg84pqmwMjaJCh6KgR6cg6xQZM+HILAbHSHhG5a8hqaJUXGhVKFShRIPK5zpVlMqNoOIKKi5WlTKruERVyqIqZdGUcuGKpCqq4EY6GJlMMCuUdSoUaVD5fa5VlFehWIMClRugct6ruLzKeSw4n2YmFOvPGoUaFKm4yKtQrEEFp0KRBsUqN1jFJSou0ZQyGKNCeRVKU8pgnQqlcR4KPVvMDRLq22sHLihUoUSDyl8cV0UFDcpbFUrlBqqcRx2XyvlCzgZhmhDSck9UNhlnP23g4cWdZmifCbgxQWgdQX5lZ0sC+mGCefIkTlYEYlsTNI7AG9uaQBoTWN+aoHUE+cWEDQkK+e3rCKZFmm8+Inwm8LY1wQbtIKSFDWNoxYC2OUPzGKh5DCStGYJvztA8Bg6tGWSDFh3m7c3LdYWJQRozxIXGLINP28aJbHW50iQKv7gCNVFIcwrbPor8Cvi2FKE5RX6ryeso0CUKxAwFNafw7aPw7aNA355CmlNQ+yiCa08RtqBIb2FwcYfFRMEbRBHS9YiWwS4pcpsf5js+7PLMlklPPmRK94sTLTdjXGbUWBjzrqOosGJVQ6EKla/zxDNKahezxhlZ6kXdXFvi25zc9BfsVCoMi8Q/vyVl8VoW/awegC/yC0NZQ/ku1UCOi4TX5bOZD/WMqx+VWGNhpCZhya+231Bh7Y59ahO8vN8yG6ydr523i+X3fLCB01UtgbHy9Vl8rTqVVSCqnfscs7XUxcRSpnWweKBgC4mG4FQzSWrBbnjze9STH89ZZj1orutZPByM9auOx5v2FNieQn6YwlHqEB2FRf9jnjkKmc+2HDvEQTvEUVhh3pSjsMi8LccOcfAOcRTSpk05CknWthzUnCMU1rW35dghDmt24PjxvoQgvShdrApdjo2LBNKYwEFrgtYRQOsIoHUEvnUEnhsTYOsIMDQmINuaAFsTtK6moXVnt0O2EXbINgrHum7LITvEIe2zpsLhrhtz7BCH3SEO2z5rYmd34MD2HGB24NgjjvYzYm6df3Dr/IPRtSagxgRkWhO0jiC0jiA0zqAKJ19uSeBbE7RuaNK6oUnjairGtib48WoaU5a0h4Utryhs44paOCFxQwLXuhRc45YgrZcdpPWyg/jWhexbR9B62UGwdS0i15qg8cKJhNZl0HpUFm7dDqR1ZydtC9kZ8+OFHHhxxwisKTaYQFcpQnOKDca1KgU2p9hg8lyl2CEKaU5RnTm/fFufyfUofYgT3xvPei6HOESK0JyiOnvegIJ+nMI6m84csq52OAbMX/iC4bnoXn//kTPVlwMN1Hub1OPLnTpREfWmKLjuFElviqrz/90VielOUW8125qf4JGkvsuF6nH1iz3DxoFfB4CjByCDB2D96AGMXgKw//AENE2pABafFqjuzIgB7N8v+rQTGbyvHph7/dIMZ/3+3ahP3/bGAGq7oysn/sYA/OgByOABIIweAA8eAI1eAgEHD4BH70Z59BKQ0UtABi8BZwYvgbiqN3oAg6cSzg4+kDkbBg8AeuqFLop6qtRnRV1NOS6K9s9g0U2bYQCr09DK5QHO/YQ5xMYBhMEDIDd6AKOXQNhiLQnS4QaRxHxzA8iZZJOXHTUScXuQhPYkULBLXOKYKaYXk8CiAImCyeffIZwuk0lR2bmi2dN4v34apxVCtzAATsfDrp4Nkg5NCCKLd7IM+fbx/LBfnDngTO7ZOP+Zyu2Ux1aenk/+wMWaprtsnXeFMxoPb0v+fcfdlnttydni7rUla8u9tuRsyW+8vttyry05W/y9b8nZkj8F/m7LPcvN2ZLf/3gAW9IWFLK4tiV/OOTdFrrbkrFF7o0oa8u9tmRsQXOvLVlb7rUlZ4s9ajpXseVeW3K2uHvfkrUl3G3J2AL3LDdrC99tydjij7o6V7HlEH3LOVQ8xOhyCfUQ+cU5VDpEhnkJ1R8n1EO8NDiHGg4xMF1CPc5gc4wl2Euoh0g4z6HKcUpVDtNWydxOD+w4nagKCx1zqLfTVmuh2ttpq9VQbyfdr4Xqbifdr4bqjxPqcbqlG1q1rIZ6OylELVR/nFL1xxlsbmjFsBrq7Wwwq4Z6O2tLtVDpODMbOs5gE47TLYXjdEt8nJkNH6hUb2ewCTbJCC82Y7/u6bMxcjtD06uMOZ1CPEVIgVfGhBvaYLmxMQdtSlVjbuij1o2NuZ1lpdcZE0KKMMh6VCpcrns3JtzQVsttjYGjjkpVY24nl93YmKMO1zVjbmgn6sbG3IfrvDF4rzEFY+7Ddd6YG/owemNj7sN1wZj7cJ035ob2525szL3zzRvD9863YMxRa4yY6S2BFZcxRo46KlWNyY9KltM5ossjSk/GnGBsvA72arZ1SIgyLUoSu/nASnsqlHVBUDqqc7GAGVczL4Ly911W4yjsW6nCdGYX3rzXYPl7+eow6qyM2HcmSFxfgqSwDP/zBLnO6pBAZ3VIyPQmqLc61Fk/BKawXdymkd7aYL6BZSg43awW4iiSns7fTUvpcLZAVLt2wXqZkxl0L2+zBFMa616n3836qXY3H80nndPiZj4AflaEvSny3XlUODzM+3SouMf5WHhH+AxDDaxw42kd5nUwVsHyN7jUYfk0imzKkGnRRVzurwZbODKnhiINyqu4Clnl1Xu5oXCfWw0VVHEVMrgaSjQoUXGJhqtwmVMVxRpU4Wu7GkpTXq7wDVgNhSqUpva6Qj5XQRV69xoqaFDoVCjWoEjlBqm4giquUr9xDeVN6egRNy2XxAWc1ZE7EeZ1sEIGnDK2mAbwGlbKUyuw0qy2BhMVrLAZNLbIBOO1JYXbqy2kI49OF85kYKyCOaeDkQpWSIerMF1sXieysNCEKcO0y0uBZlhQwQoNpwoTFazw6UENVtjGX4Up2QqxURrUkGUNKxzuUIHFdWUVrHAIaBWGOpjKElfYElmF6ZyEQnubl8PBrdubK2TgVRjqYKKCFXarVGFBBSOdJaQrgKBjC7oCCLoCYF0BFN7OwTxvBVx3Qa4wdldgUJjKV2Goglmrg5EKVliKq8JUYzeA08FUQz54HVs+ew0+3e3maQ3Kj27zu8vl7a0JlK+PNVB4Pcjnv9SpgVADUhhRuOusBmLN5MQXcuMqLKhgoGMDHZvXsXkdG+rYUFdupGMrjJ41WDA6GL6+7/D5sVPM1E2Jy4BY0WSw0KKvMqFRyMP8ynINFBQgp+jaMD/TrYBAw5R/MyNpuUDCuhphfnmtBlIx1brrHAg1dS+/BFUDKQY7zC+s1UCsADFoQBom0cQkilpOxmhAr60R/8af/33z+enN2w/vv0TI6W///vju69Onj88/v/7vr+lv3n5++vDh6c/f/vr86d373//+/P63D5/enf7uwTz/51cO/pEFT2LiL/LwSMLx16lNkMhjQIi/ztP72Hc++svPU4NG8Y/Rqagoqvo/",
      "brillig_names": [
        "_withdraw"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PriceFeed"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "collateral_asset",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "collateral",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "static_debt",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::update_accumulator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "interest_accumulator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "asset::Asset"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::update_accumulator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::get_assets_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_assets_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_repay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_repay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::get_position_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "collateral",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "static_debt",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "debt",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "position::Position"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_position_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_borrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_borrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "asset_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::get_asset_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "interest_accumulator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "asset::Asset"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "132": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "140": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "141": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "151": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "184": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "185": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "187": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "192": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "203": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "220": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "222": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "265": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "268": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "270": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "275": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "282": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "283": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "297": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "299": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "300": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "309": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "320": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "334": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "338": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "339": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "355": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "358": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "368": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        wrapping_add_hlp(self, y)\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        wrapping_sub_hlp(self, y) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        wrapping_sub_hlp(self, y) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        wrapping_sub_hlp(self, y) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        wrapping_sub_hlp(self, y) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n"
    },
    "399": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/helpers.nr",
      "source": "use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value) / ltv_precision;\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/interest_math.nr",
      "source": "use std::ops::{Add, Div, Mul, Sub};\n\n// Binomial approximation of exponential\n// using lower than desired precisions for everything due to u128 limit\n// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3]...\n// we are losing around almost 8 digits of precision from yearly -> daily interest\n// dividing with 31536000 (seconds per year).\n// rate must be measured with higher precision than 10^9.\n// we use e18, and rates >= 4% yearly. Otherwise need more precision\npub fn compute_multiplier(rate_per_second: u128, dt: u64) -> u128 {\n    let base = 1000000000 as u128; // 1e9\n    let WAD = 1000000000000000000 as u128; // 1e18\n    let diff = WAD.div(base);\n    let mut res = base;\n    if dt != 0 {\n        let exp_minus_one = (dt - 1) as u128;\n        let exp_minus_two = (if (dt > 2) { dt - 2 } else { 0 }) as u128;\n        let dt = dt as u128;\n\n        // if rate_per_second < sqrt(WAD), then base_power_two and base_power_three = 0\n        let rate = rate_per_second;\n        let base_power_two = (rate * rate) / WAD;\n        let base_power_three = (base_power_two * rate) / WAD;\n\n        let temp = dt.mul(exp_minus_one);\n        let second_term = temp.mul(base_power_two).div(2 as u128);\n        let third_term = temp.mul(exp_minus_two).mul(base_power_three).div(6 as u128);\n\n        // throwing away precision to keep us under u128 :sob:\n        let offset = dt.mul(rate).add(second_term).add(third_term).div(diff);\n\n        res = base.add(offset);\n    }\n    res\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/main.nr",
      "source": "mod asset;\nmod position;\nmod interest_math;\nmod helpers;\n\n// Single asset CDP contract.\n// Shoving re-entries up the ass.\n// TODO's:\n// - Use asset address instead of 0. We only use 0, as there is only one collateral asset :shrug:.\n// - Update accumulator should be for specific asset, just abusing only 1 asset atm.\n// - A way to repay all debt at once\n// - Liquidations\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier, covered_by_collateral, debt_updates, debt_value};\n    use crate::interest_math::compute_multiplier;\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        collateral_asset: PublicMutable<AztecAddress, Context>,\n        stable_coin: PublicMutable<AztecAddress, Context>,\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n        collateral: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        static_debt: Map<AztecAddress, PublicMutable<u128, Context>, Context>, // abusing keys very heavily\n    }\n\n    // Constructs the contract.\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn init(\n        oracle: AztecAddress,\n        loan_to_value: u128,\n        collateral_asset: AztecAddress,\n        stable_coin: AztecAddress,\n    ) {\n        let asset_loc = storage.assets.at(0);\n        let asset: Asset = asset_loc.read();\n\n        let loan_to_value = loan_to_value;\n\n        assert(loan_to_value <= (10000 as u128));\n        assert(asset.last_updated_ts == 0);\n        assert(asset.interest_accumulator == 0 as u128);\n\n        let last_updated_ts = context.timestamp();\n\n        asset_loc.write(\n            Asset {\n                interest_accumulator: 1000000000 as u128,\n                last_updated_ts,\n                loan_to_value,\n                oracle,\n            },\n        );\n\n        storage.collateral_asset.write(collateral_asset);\n        storage.stable_coin.write(stable_coin);\n    }\n\n    // Create a position.\n    #[public]\n    fn update_accumulator() -> Asset {\n        let asset_loc = storage.assets.at(0);\n        let mut asset: Asset = asset_loc.read();\n\n        let timestamp = context.timestamp();\n        let dt = timestamp - asset.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(dt == 0) {\n            let precision = 1000000000 as u128;\n            let rate_per_second = 1268391679 as u128; // 4% yearly rate / (60 * 60 * 24 * 365)\n            // if rate_per_second < sqrt(WAD) our approx is eq precision + rate * dt\n            let multiplier = compute_multiplier(rate_per_second, dt);\n\n            // accumulator *= multiplier, and multiplier >= 1\n            asset.interest_accumulator = (asset.interest_accumulator * multiplier) / precision;\n            asset.last_updated_ts = timestamp;\n\n            asset_loc.write(asset);\n        }\n\n        asset\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:start:enqueue_public\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .enqueue(&mut context);\n        // docs:end:enqueue_public\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, collateral_asset: AztecAddress) {\n        let _asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        let coll_asset = storage.collateral_asset.read();\n        assert(coll_asset.eq(collateral_asset));\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n        coll_loc.write(collateral + amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, recipient: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n\n        let debt_loc = storage.static_debt.at(owner);\n        let static_debt = debt_loc.read();\n\n        // debt_covered will revert if decrease would leave insufficient collateral to cover debt.\n        // or trying to remove more collateral than available\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, amount);\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            static_debt,\n            0 as u128,\n            0 as u128,\n        );\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        coll_loc.write(collateral - amount);\n\n        // @todo @LHerskind Support both shielding and transfers (for now just transfer)\n        let collateral_asset = storage.collateral_asset.read();\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.this_address(), recipient, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        // Fetch collateral and static_debt, compute health of current position\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, 0 as u128);\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, amount, 0 as u128);\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n\n        // @todo @LHerskind Need to support both private and public minting.\n        let stable_coin = storage.stable_coin.read();\n        let _ = Token::at(stable_coin).mint_to_public(to, amount).call(&mut context);\n    }\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        stable_coin: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(stable_coin).burn_private(from, amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, stable_coin)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, stable_coin: AztecAddress) {\n        let _ = Token::at(stable_coin).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n        let _ = Lending::at(context.this_address())._repay(owner, amount, stable_coin).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, stable_coin: AztecAddress) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        // To ensure that private is using the correct token.\n        assert(stable_coin.eq(storage.stable_coin.read()));\n\n        let static_debt = storage.static_debt.at(owner).read();\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, 0 as u128, amount);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n    }\n\n    #[public]\n    #[view]\n    fn get_asset(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_position(owner: AztecAddress) -> pub Position {\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n        let asset: Asset = storage.assets.at(0).read();\n        let debt = debt_value(static_debt, asset.interest_accumulator);\n        Position { collateral, static_debt, debt }\n    }\n\n    #[public]\n    #[view]\n    fn get_assets() -> pub [AztecAddress; 2] {\n        [storage.collateral_asset.read(), storage.stable_coin.read()]\n    }\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "56": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "65": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "91": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "96": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
