{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "AMM",
  "functions": [
    {
      "name": "add_liquidity",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "9973162865762580702": {
            "error_kind": "string",
            "string": "INCORRECT_TOKEN1_LIMITS"
          },
          "11541850750363945201": {
            "error_kind": "string",
            "string": "INCORRECT_TOKEN0_LIMITS"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15296099587266009905": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNTS"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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D0/pbjndwfqP2nQH6xNq0x3sfl6brsw13cFSvtp0p+qqfA9Prm053am6Kt/DE1UbTreHp5O2nO5cXVUPT81sOd25uqoenubYcrpzdVU9PGWw5XTn6qp6ePpdy+nO1VX18FS2ltOdq6vq4WlhLac7V1fVw1OsWk53rq6qh6crtZzuXF1VD0/9aTndubqqHp5G03K6c3VVPTwlpeV05+qqenh6R8vpztVV9fBUiZbTnaur6uFpBy2nO1dX1cMu/C2nO1dX1cPu8C2nO1dX1cOu5S2nO1dXJXN1VTJXVyVzdVUyV1e1ztVVrXN1VetcXdU6V1fVw1MsWk53rq6qhydOtJzuXF3VWM+RqE93rq5qrOdI1Kc7V1c11nMk6tOdq6sa7MkQ1enO1VUN9vSG6nTn6qoGe8JCdbpzdVWDPQWhOt25uqrBnlRQne5cXdVgTxOoTneurmqwpwlUpztXVzXY0wSq052rqxrtaQK16c7VVY22O39tunN1VaPtdl+b7lxd1Wi7x9emO1dXNdpu7LXpztVVjba7eW26c3VVo+0WXpvuXF1VkbmmO1dXNdfe6n6uvdX9XHur+7n2Vg9z7a0e5tpbPcy1t3qYa2/1sMhc052qqwpz7a0eRttb/WXPOYrbsW75Nau7g68ceSRhG448k7AJx9G2mVfjyFMJ23DksYRtOMosHK/Tnebx3dfpTvOY7et0p2k+r9Odpke8TneaVu73dEfbgr423Wkao+t0p+lfrtOd5vHH1+nKXNOdq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nSn6qpk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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token0",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_amount_in_for_exact_out",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "balance_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "balance_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3bjvM6kq37LnVdFyIZ4qFfZWGj0afVKKDQ3ejDBjYa9e7b/3RKds6UzUxN2hEkv5vCX1VSivxGWIoxaFP/+6d//pd//J9//fu//Nv//ff/+tPf/Z///dNf//2f/uG///Lv/3b5b//7tz//6R//8y9//etf/vXv7//nPy2//sN5+e2E//qPf/i3X//9v/77H/7zv//0d24RF/78p3/5t3/+7d/JX/7I//3LX//lT39X0t/+/OXwlOPHwXmR/dAoB4eufv04dF2X/VAXyt/+nz9fRrM2GE0OaRvNWp6PRkL5OFRi/jqa2GI0WbbRlPx8NHHZ2EQfv44mNRhN8f7j4BLWymjy8nFoWg6UyoejCXnZ4F+OjPH5aHxZ3MfRYbk/+OMa5fXXCMsbruHecA3/hmuEN1xD3nCN9Q3XiG+4RnrDNd7wOQ9v+JzLGz7n8obPubzhcy5v+JzLGz7n8obPubzhcy5v+JzLGz7n8obP+fqGz/n6hs/5+obP+fqGz/n6hs/5+obP+fqGz/n6hs/5+obP+fqGz3l8w+c8vuFzHt/wOY9v+JzHN3zO4xs+5/ENn/P4hs95fMPnPL7hc57e8DlPb/icpzd8ztMbPufpDZ/z9IbPeXrD5zy94XOe3vA5T2/4nOc3fM7zGz7n+Q2f8/yGz3l+w+c8v+Fznt/wOc9v+JznN3zO8xs+56XF5zwsa9yv8euIbXFi8deLuHdcxL/jIuEdF5F3XGR9x0VafNrDZR1tu4j35dNFvh59SQa2IV0Mo787Oh4tOOZtsW4Nt2FckrHr8NP7h5/3RcfL8zFXhr/GtC/fxhz2o9dwHX/ufPyl6/H7Zel8/K7z8fvOxx86H790Pv618/HHzsff9/PXL+afv0m2ZmlNq9yP/8BJrPs3m/ya3POD87oNI6e7xiocWhS3f0PMXxbz9qPlaII+3+zMp0N/A26+YRgMuDPf4YwG3HxLNhpw8z3kaMDNN72jAReAvxe4eVsxGnDzPmg04OaN22jAcZpvBo7TfC9wj9N8M3Cc5puB4zTfDByn+WbgAvD3Asdpvhk4TvPNwHGabwaO03wzcJzme4EHnOabgeM03wwcp/lm4DjNNwMXgL8XOE7zzcA7cJruBjw/Z+jy/kMSV3yo/GknZdsnzq13W6x9fO0ydOAJtdB04N600HTgs5TQSAeOSAtNB95FC00HLkMLTQd+QAuNgOYRmg56bC00dMMP0dANP0RDN/wQDd3wIzQr3fBDNHTDD9HQDT9EQzf8EI2A5hEauuGHaOiGH6KhG36Ihm74IRq64UdoIt3wQzR0ww/R0A0/REM3/BCNgOYRGrrhh2johh+ioRt+iIZu+CEauuFHaBLd8EM0dMMP0dANP0RDN/wQjYDmERq64Ydo6IYfoqEbfoiGbvghGrrhR2gy3fBDNHTDD9HQDT9EQzf8EI2A5hEauuGHaOiGH6KhG36Ihm74IRq64UdoCt3wQzR0ww/R0A0/REM3/BCNgOYRGrrhh2gm7oYvk9/QhMUtVZBJdpDu7m/no5HEJX8cHH28O/a6k4f9t4wOSX3iHl6R+sT2QI16sP8e2iGpT2xqFKlP7JcUqU9sxRSpC9QVqE9sIBWp4001qONNNajjTTWo400VqPfwBvFXUb+0zWmnXmoDcS75/Y+7stz/9fJqlSb2sh2pNLH37Uilib1yRyoJKnWg0sRevCOVJvbuHak0sdfvSKWJs4GOVJo4S+hHpR7eKY9KPbyIHpV6eHs9KvXwyntU8oJK31TJL+s2EucvM66o5C+qfhzuXb6Dktejo9OyH5387evS8aoS2UMPKpE99KAS2UMPKpE99KAS2UMHKgWyhx5UInvoQSWyhx5UInvoQSVBpQ5UInvoQSWyhx5UInvoQSWyh2+rFHLeVRKprVz4uI/Fx7jeji7LIUK//fHg1rujcz46OqR95KGET0f/pipZxYCqCtnGiKqShYyoKtnJiKqStYyoqqDqgKqS5YyoKtnPiKqSFY2oKtnSiKqSLQ2o6kq2NKKqZEsjqkq2NKKqZEsjqiqoOqCqZEsjqkq2NKKqZEsjqkq2NKKqZEsDqhrJlkZUlWxpRFXJlkZUlWxpRFUFVQdUlWxpRFXJlkZUlWxpRFXJlkZUlWxpQFUT2dKIqpItjagq2dKIqpItjaiqoOqAqpItjagq2dKIqpItjagq2dKIqpItDahqJlsaUVWypRFVJVsaUVWypRFVFVQdUFWypRFVJVsaUVWypRFVJVsaUVWypQFVLWRLI6pKtjSiqmRLI6pKtjSiqoKqA6pKtjSiqmRLI6pKtjSiqmRLI6pKtjSeqrKQLY2oKtnSiKqSLY2oKtnSiKoKqg6oKtnSiKqSLY2oKtnSiKqSLY2oKtnSgKo6sqURVSVbGlFVsqURVSVbGlFVQdUBVSVbGlFVsqURVSVbGlFVsqURVSVbGlBVT7Y0oqpkSyOqSrY0oqpkSyOqKqg6oKpkSyOqSrY0oqpkSyOqSrY0oqpkSwOqGsiWRlSVbGlEVcmWRlSVbGlEVQVVB1SVbGlEVcmWRlSVbGlEVcmWRlSVbGlAVYVsaURVyZZsqOpl3RHmmqpSdlXXZSlfVSVbGlFVsqURVRVUHVBVsqURVSVbGlFVsqURVSVbGlFVsqUBVV3JlkZUlWxpRFXJlkZUlWxpRFUFVQdUlWxpRFXJlkZUlWxpRFXJlkZUlWxpQFUj2dKIqpItjagq2dKIqpItjaiqoOqAqpItjagq2dKIqpItjagq2dKIqpItDahqIlsaUVWypRFVJVsaUVWypRFVFVQdUFWypRFVJVsaUVWypRFVJVsaUVWypQFVzWRLI6pKtjSiqmRLI6pKtjSiqoKqA6pKtjSiqmRLI6pKtjSiqmRLI6pKtjSgqoVsaURVyZZGVJVsaURVyZZGVFVQdUBVyZZGVJVsaURVyZZGVJVsaURVyZbGU/Xyv6HqgKqSLY2oKtnSiKqSLY2oqqDqgKqSLY2oKtnSiKqSLY2oKtnSiKqSLQ2oqiNbGlFVsqURVSVbGlFVsqURVRVUHVBVsqURVSVbGlFVsqURVSVbGlFVsqUBVfVkSyOqSrY0oqpkSyOqSrY0oqqCqgOqSrY0oqpkSyOqSrY0oqpkSyOqSrY0oKqBbGlEVcmWRlSVbGlEVcmWRlRVUHVAVcmWRlSVbGlEVcmWRlSVbGlEVcmWBlRVyJZGVJVsaURVyZZGVJVsaURVBVUHVJVsaURVyZZGVJVsaURVyZZGVJVsaUBVV7KlEVUlWxpRVbKlEVUlWxpRVUHVAVUlWxpRVbKlEVUlWxpRVbKlEVUlWxpQ1Ui2NKKqZEsjqkq2NKKqZEsjqiqoOqCqZEsjqkq2NKKqZEsjqkq29G1V4+J2VdOngZfDv17cDuVe1Qc1kJetBpIrtaP9UrajvU+fjv5NVbKlAVVNZEsjqkq2NKKqZEsjqkq2NKKqgqoDqkq2NKKqZEsjqkq2NKKqZEsjqkq2NKCqmWxpRFXJlkZUlWypR1UlhO1oybU1wSj+4+AYbxUQ4tEsy221cbkbxvHB0e1HR78ulaNdcnEvqsscQ+2vl513LO6udI/WJvNlbfTj4Oyjvz/4tzInbKPMJyhzocwp8/HLnDiWMp+gzMmnKfMJypzAnjKfoMxZwaDMJyhzlnQo8/HLvLDGRZlPUOYs+lHmE5Q5q6CU+QRlziooZT5BmQtlTpmPX+asglLmE5Q5q6CU+QRlziooZT5BmbMKSplPUOasglLmw5d5XFgFpcwnKHNWQSnzCcqcVVDKfIIyZxWUMp+gzIUyp8zPlrlf017mufanXY77qH/9Wz4d/1sxslZJMZopRlYUKUYzxci6H8VophhZnaMYzRQja2gUo5VidKx0UYxmipH1KIrRTDGyakQxmilG1nYoRjPFKBQjxWilGFmBoRjNFCMrMBSjmWJkBYZiNFOMrMDYKMa0f7nq8s/PR/+mE4sTXejkye370IlIuw+dSHv70IkgtA+dBJ260In4rA+dSJb60InQpQ+dyCP60Ik8ogudAnlEHzqRR/ShE3nEd3UKIfmdiay+Qt5dBrOvVbicbr91joc6LX7Xyfu7Y39TiTSiB5UElTpQiSTiuyrJkvZxi5NUUSkut60dbvxc9lfuJAs63EkKdLjj/HW44+RVuAvOXIc7TluHO85ZhzteWIe7wF2FO35Vhzt+VYc7flWHO35Vhzt+9dvcL7B27rH6oxUf0gbeh3K39pV/nhqvuNseVMIL96ASzrkHlfDZPagkqNSBSnj4HlTC8fegEvlADyqRJvSgEtlDBypFsoceVCJ76EElsoceVCJ7eJVK4vZNokSWTyr9Rl4gr0SejECLPL5fizxeXos8/lyLPJ5biXzCR2uRxxtrkcfvapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRz3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tDPi14WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuRn9rBBdvIhxdrRMW/gQwrr3dH5SnJmT9qW5MwesynJOLNnbEtyZg/YluTMnq4tyZk9WluSAslGJGf2UG1JzuyJ2pLE47QiicdpRRKP04hkwuO0IonHaUUSj9OKJB6nFUmBZCOSeJxWJPE4rUjicVqRxOO0IonHaUQy43FakcTjtCKJx2lFEo/TiqRAshFJPE4rknicViTxOK1I4nFakcTjNCJZ8DitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJx2pDMCx6nFUk8TiuSeJxWJPE4rUgKJBuRxOO0IonHaUUSj9OKJB6nFUk8TiOSDo/TiiQepxVJPE4rknicViQFko1I4nFakcTjtCKJx2lFEo/TiiQepxFJj8dpRRKP04okHqcVSTxOK5ICyUYk8TitSOJxWpHE47QiicdpRRKP04hkwOO0IonHaUUSj9OKJB6nFUmBZCOSeJxWJPE4rUjicVqRxOO0IonHaURS8DitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJxGpFc8TitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJxGpGMeJxWJPE4rUjicVqRxOO0IimQbEQSj9OKJB6nFUk8TiuSeJxWJPE4jUgmPE4rknicViTxOK1I4nFakRRINiKJx2lFEo/TiiQepxVJPE4rknicRiQzHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5IFj9OKJB6nFUk8TiuSeJxWJAWSjUjicVqRxOO0IonHaUUSj9OKJB6nDcmy4HFakcTjtCKJx2lFEo/TiqRAshFJPE4rknicViTxOK1I4nFakcTjNCLp8DitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJxGpH0eJxWJPE4rUjicb5JUsLiP46WsMZPJA9GImlD4lZ3N5J8NO645I+Do7/7y9lfNcI92ddI0Mi8Rjg++xrhJe1rhEu1rxH+175GOGvzGgU8u32NSAPsa0TOYF8jcgb7GgkamdeInMG+RlPnDHk7OohfPx39G5up/X2FzdS+usJmaj/7nI1M7SMrbKb2bxU2U/umCpup/UqFjcDmIZup+/MKG/rix2zoix+zoS9+zIa++CGblb74MRv64sds6Isfs6EvfsxGYPOQDX3xYzb0xY/Z0Bc/ZkNf/JgNffFDNpG++DEb+uLHbOiLH7OhL37MRmDzkA198WM29MWP2dAXP2ZDX/yYDX3xQzaJvvgxG/rix2zoix+zoS9+zEZg85ANffFjNvTFj9nQFz9mQ1/8mA198UM2c7/rvcKGvvgxG/rix2zoix+zEdg8ZENf/JgNffFjNvTFj9nQFz9mQ1/8kM3c7wevsKEvfsyGvvgxG/rix2wENg/ZzNwXS7ixqe6L4dK2d4Vfbn/Z5+Xg2LzzyKFUji27QKV8PvY3fWbuzXvQZ2Z/0IM+M3uUHvSZ2SfZ18ctU7/ovAuBZnaMXQg0s23tQqCZvXMXAgkC2RaIFMG4QMQIxgWaOkfI+/60WVxNIJ/3HWdDkLujD5Gsbhd//SXM3dFX8FMHBJrgp3b+iuDd1I5eE/zUTl0T/NQOXBP81M5aE7wAXgf81E5YE/zUDlcTPM5VCTzOVQk8zlUHvMe5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce56oAPOFcl8DhXJfA4VyXwOFcl8AJ4HfA4VyXwOFcl8DhXJfA4VyXwOFcd8IJzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QG/4lyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41x1wEecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74hHNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAZ9xrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgC85VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VBbxbcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464B3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQe8x7kqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgA84VyXwOFcl8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wgnNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAb/iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAR5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviEc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBn3GuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuALzlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUFvF9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgHc5VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB7zHuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqADzhXJfA4VyXwOFcl8DhXJfACeB3wOFcl8DhXJfA4VyXwOFcl8DhXHfCCc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBv+JclcDjXJXA41yVwONclcAL4HXA41yVwONclcDjXJXA41yVwONcdcBHnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+IRzVQKPc30JePGpfBwtYfWVo52k/W+v7m7c+WiWcckfB0cf7471H5LiiYeTFLc9nKSCpKNJSkIwnKRkD8NJSqoxnKTkJcNJShIzmqSZjGc4SUmPhpOU9Gg4SUmPhpNUkHQ0SUmPvitp2Afi4hIqInm/LB9HewmfJb2CJ+NRAk8SowSevEQJPKmGDvhC9qAEnoRACTw+Xgk8blsJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUFfFhwrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgHc5VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB7zHuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqADzhXJfA4VyXwOFcl8DhXJfACeB3wOFcl8DhXJfA4VyXwOFcl8DhXHfCCc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBv+JclcDjXJXA41yVwONclcAL4HXA41yVwONclcDjXJXA41yVwONcdcBHnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+IRzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAj+zc83rDr4s8unoK5yZ3WUVzswOsApnZpdWg5NndlJVODO7nSqcmR1JFc7MrqEKR4DzGM7M3XcVDh3yEzh0yE/g0CE/gUOH/BhOoUN+AocO+QkcOuQncOiQn8AR4DyGQ4f8BA4d8hM4dMhP4NAhP4FDh/wQjix0yE/g0CE/gUOH/AQOHfITOAKcx3DokJ/AoUN+AocO+QkcOuQncOiQH8NxdMhP4NAhP4FDh/wEDh3yEzgCnMdw6JCfwKFDfgKHDvkJHDrkJ3DokB/D8XTIT+DQIT+BQ4f8BA4d8hM4ApzHcOiQn8ChQ34Chw75CRw65Cdw6JAfwwl0yE/g0CE/gUOH/AQOHfITOAKcx3DokJ/AoUN+AocO+QkcOuQncOiQH8OZ+h3iVTh0yE/g0CE/gUOH/ASOAOcxHDrkJ3DokJ/AoUN+AocO+QkcOuTHcKZ+V3EVzswdcnHrDifWjnYpfxzs73Y99Xk5ODbvPHIolWNL3oZcyudjrwLN3KV3IdDMTqELgWRmgdI2bHGyVI72KfhNoVTuj5YjiS59x6aRd/HT0VfwMzshVfAzuyxV8DM7OFXwM7tDVfAzO09N8FO/x1gV/NSOWRP81E5YE/zUDlcTvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUH/NTvMVYFj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBP/V7o1XB41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAT/0+d1XwOFcl8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4VxXw64JzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QHvcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464D3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQd8wLkqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgBecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74FeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqAz7iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAJ5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviMc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBX3CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuKuDjgnNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAe9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgPc5VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB3zAuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqAF5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDvgV56oEHueqBB7nqgQe56oEXgCvAx7nqgQe56oEHueqBB7nqgQe56oDPuJclcDjXJXA41yVwONclcAL4HXA41yVwONclcDjXJXA41yVwONcdcAnnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+IxzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QFfcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca4q4NOCc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UB73CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuA9zlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHfMC5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce56oAXnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsS+Imdq7j9aHElfjr6Cmdid1mHM7EDrMJZJ3ZpdTgTO6k6nIndTh3OxI6kDkeA8xjOxJ19Hc7E3XcdDh3yEzh0yE/g0CE/hhPpkJ/AoUN+AocO+QkcOuQncAQ4j+HQIT+BQ4f8BA4d8hM4dMhP4NAhP4aT6JCfwKFDfgKHDvkJHDrkJ3AEOI/h0CE/gUOH/AQOHfITOHTIT+DQIT+Gk+mQn8ChQ34Chw75CRw65CdwBDiP4dAhP4FDh/wEDh3yEzh0yE/g0CE/hlPokJ/AoUN+AocO+QkcOuQncAQ4j+HQIT+BQ4f8BA4d8hM4dMhP4NAhP4STFzrkJ3DokJ/AoUN+AocO+QkcAc5jOHTIT+DQIT+BQ4f8BM7MHbK4sMFJbjmAM3OHXIMz8/vJ63Bm7pCrcGbukKtwZu6Qq3AEOI/hzNwhV+HM3CFX4czcIVfh0CE/gUOH/BjOzO9BrsOhQ34Chw75CRw65CdwBDiP4dAhP4FDh/wEDh3yEzh0yE/g0CE/hjPz+1brcOiQn8ChQ34Chw75CRwBzmM4dMhP4NAhP4FDh/wEDh3yEzh0yI/hzPxexzocOuQncOiQn8ChQ34CR4DzGA4d8hM4dMhP4NAhP4FDh/wEDh3yYzhTv1OvCocO+QkcOuQncOiQn8AR4DyGQ4f8BA4d8hM4dMhP4NAhP4FDh/wQTrEfsMe0Hb3GHO7h/DaBDkLw5abuEr9OoEkz5cNWFSGkXJlAiGXZjs53Q7pQ+BiTGBzTanBM0eCYksExZYNjKvbG1CavaDwmZ3BM3uCYDN7HV4P38dXgfXw1eB9fDd7HV4P38dXgfTwavI9Hg/fxaPA+Hg3ex6PB+3g0eB+PBu/j0eB9PBq8j0eD9/Fk8D6eDN7Hk8H7eDJ4H08G7+PJ4H08GbyPJ4P38WTwPp4M3sezwft4Nngfzwbv49ngfTwbvI9ng/fxbPA+ng3ex7PB+3g2eB8vBu/jxeB9vBi8jxeD9/Fi8D5eDN7Hi8J9PKf96LK4gzElg2PKBsdUrI3JL8ticEzO4Ji8wTEFg2MS3TE5fzAmhft43r/tFYpfPo3p69F5/85TDrevPPm8HBx76eQ/jr3cTz4de51rnGiuaaK55onmWuaZq1smmqubaK5+ormGieYqE811or7JTdQ3uYn6JjdR3+SG6pvidqxbFv91sn6oxqk22aE6p9pkh2qdapMdqneqTVZmmqxC91R82ie7pspkn/+e7zKB2PsEUu8TyL1PoHQ+gbD0PgHX+wR87xMIvU9Aep9A70/i0PuDLJh/kD3dGsAvD/awdetatgm4NcmtC1wPLuLccjs63BZPV/dxEf+Oi4R3XETecZG1yUX2xWPnSv56kdjiIpdPwHa09/HrRVKbmay3i6SvF8nvuEh5w0Ue/Da/8UWafOJj3m4rLi3y9SL+HRcJ77iIvOMi6zsuEt9xkfSOi+R3XKS0vogrXy4Sl3dcxL3jIv4dFwnvuIi84yJNPvFJ9qguxa/P+BjfcZH0jovkd1yktLnI3hKle8fwcZG0vOMi7h0X8e+4SHjHReQdF2nzid+/Ru8uCwBfL9LmE5/3o/NBV5/SOy6S33GR8oaL5OUdFzEfxlWCCI3fO/5wAv42gXtftU3AfBhXm4D5ZbHaBMynibUJ2E8TKxMwvyyWJO4TWOV+Al8P9rIPxIvIl9kW82toTWdrfsGt6WzNr841na397qHlbGWq2drvS1rO1n4T03K29jueH83W59tsv1qEYr89ajnbwXqpp7N1y1i91LpufbJfY3h+cFyWLdOJi5OvaMZqvH6CZi2pPEUzVpe27l/p9Wtyzw/Oy/aHs9y9TSKkDzJjdXQtyQhkHpAZq1NsSWasrrIlmbE60IZk3GAdzU/IrNs3kHKKn8gc/OHL/7z9Ybfe/rAcTdDvi+ph+XTolfhgjVIHxCfuv5SIT9zXKREXiL+Z+MR9qBLxiftbJeIT981KxMdKj3sgPlaC3QFxj+d8N3E857uJ4znfTRzP+Wbi9vcGsEF8KX4nfved4kPiOW+D+LSX8uEfdpdrb3/58u90twtOWT8k4kNhXiJBIusSEfWYl4hsyLxEhEnmJSJ9Mi8RcZV1iYR8y7xEBGLmJSJdMC8R6YJ5iQSJrEtEumBeItIF8xKRLpiXiHTBvESkC9YlWkkXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2iSLpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXzEtEumBeItIF6xIl0gXzEpEumJeIdMG8RKQL5iUSJLIuEemCeYlIF8xLRLpgXiLSBfMSkS5YlyiTLpiXiHTBvESkC+YlIl0wL5EgkXWJSBfMS0S6YF4i0gXzEpEumJeIdMG6RIV0wbxEpAvmJSJdMC8R6YJxifwy8KcoPz84xe3YlD5Bv4IZuHb/GBgBzDGYDlIgdwNTmeuzP32dbgeJSsvpdpBOtJxuB06/5XQ7cM0Np+s6cKAtp9uBm/v+dGUJ5eNgWUqp/OkgewsYJN8NW8oHnA46QD04HXSBenAEOI/hDNUNtoYzVO/YGs5QnWZrOEP1pa3hDNXFNobTw7vi9eDQIT+BM02HfJ3uND3vdboy13Sn6Uuv052m07xOd5re8TrdsbpBty9cSHBS+dN5kY+Dc7ih8Xk5OLbk7Q+X8vnYK8ax+kYtjGGsDlMN41i9qBrGsbpWNYxjdcNqGAWMLTCO1b2rYRzLFahhHMttqGHExTTBiItpgVFwMU0w4mKaYJSxMLptqUGcPwi0eniDe8vpDtaH1aY7WL9Um+5gfU1tuoP1H5Xp9vD26JbTHex5XpvuYOlhbbqDpXy16cpc052rq+rhLbAtpztXV9XD20lbTneurqqHt2a2nO5cXVUPb3NsOd25uqoe3jLYcrpzdVU9vP2u5XTn6qp6eCtby+nO1VX18LawltOdq6vq4S1WLac7V1fVw9uVWk53rq6qh7f+tJzuXF1VD2+jaTndubqqHt6S0nK6c3VVPby9o+V05+qqenirRMvpztVV9fC2g5bTnaur6mEX/pbTnaur6mF3+JbTnaur6mHX8pbTnaurKjLXdOfqqspcXVWZq6sqc3VVZaquKixTdVVhmaqrCj28xaLldKfqqsIic013qq4qjPUeifp0p+qqwljvkahPd66uaqz3SNSnO1dXNdibIarTnaurGuztDdXpztVVDfaGhep05+qqBnsLQnW6c3VVg72poDrdubqqwd4mUJ3uXF3VYG8TqE53rq5qsLcJVKc7V1c12tsEatOdq6sabXf+2nTn6qpG2+2+Nt25uqrRdo+vTXeurmq03dhr052rqxptd/PadOfqqkbbLbw23bm6Kpmrq5K5uqq59lYPc+2tHubaWz3Mtbd6mGtv9TDX3uphrr3Vw1x7q4e59lYPc+2tHubaWz2Mtrf6y95zFLdj3fJrVncHXznySsI2HHknYRuOvJSwDUfeStiE42gb46txnOa14NfpTvP67ut0Za7pTtN8Xqc7TY94ne40rdx1utN0XNfpTtMY/Tbd0bagr013mtcfX6c7V1c12hb0tenKXNOdq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9OdqquS0bagr013qq5KRtuCvjbdqboqWWSu6U7VVcloW9DXpjtVVyWjbUFfm+5cXdVoW9DXpjtXVzXaFvS16c7VVY22BX1tunN1VaNtQV+b7lxd1Whb0NemO1dXNdoW9LXpztVVjbYFfW26c3VVo21BX5vuXF3VaFvQ16Y7V1c12hb0tenO1VWNtgV9bbpzdVWjbUFfm+5cXdVoW9DXpjtXVzXaFvS16c7VVY22BX1tunN1VaNtQV+b7lxd1Whb0NemO1dXNdoW9LXpztVVjbYFfW26c3VVo21BX5vuXF3VaFvQ16Y7V1c12hb0tenO1VWNtgV9bbpzdVXz7BR/ne5cXdU8+65fpztXVzXPLubX6c7VVc21t7rMtbe6zLW3ugy2t3oMZZtuXkLlT//ohQt5m2Epn4+9YhyrW1PDOFYXqIZxrO7ydRifv0VFBtu8Xo3jYLvi63Ecq9HW4zhWB6/HcSxroMdRhuKY9z8tWWocUwwfB6d0m6H4DzJj2ZOWZMZyHC3JjGUinpC5TnesZr863bF68tp0x3r1wepk3Q528SCOGuvVB/XpDtWI1qc7VL9Yn67MNd2herX6dIdqwOrTHaqrqk93qK6qPt2huqr76Xrnv053rFcf1Kc7bFd1PN1hu6rj6Q7bVR1PV+aa7lhdVXJpPziXg+mO1VVVpztWV1Wd7lhdVXW6Y3VVlemuY736oD7dsbqq6nTH6qqq0x2rq6pOV+aa7lRd1TrWqw/q052qq1rHevXBmsOyHVxirvzpSwe9B1t3uVYqB8f6tPiPg33yN68VPzCO1a1pYRzrVQ16GMfqLhthvKIZqxNtimasrrUpGgHNIzRjdcNN0YzVOTdFM1aX/SM0l6x+O1jyAZqJO/Iamom77AqasV7H0RbNxN1wDc3E3XANzcTdcA2NgOYRmom74Rqaibvhdd274XzQDY/1CpO2aGbuhitoZu6Gn6MZ6zUqbdHM3A1X0MzcDVfQzNwNV9AIaB6hmbkbrqChG36IZppu+DrdaTrc63Sn6Vp/m+5Yr56pT3ea7vI63Wk6xut0h+oC47JsA4khuoPpylzTHapbq093qA6sPt2huqr6dIfqqurTHaqrqk53rFfP1Kc7VFdVn+5QXVV9unN1VWO9eqY+3bm6qrFePVOf7lxd1VivnqlPd66uaqxXz9SnO1dXNdarZ+rTnaurGuvVM/XpztVVjfWKmPp05+qqxnrlSn26c3VVY73ApD7dubqqsV4HUp/uXF3VWC/XqE93rq5qrNdg1Kc7V1c11rst6tOdq6sa690W9enO1VWN9W6L+nTn6qrGerdFfbpzdVVjvduiPt25uqqx3m1Rn+5cXdVY77aoT3eurmqsd1vUpztXVzXWuy3q052rqxrr3Rb16c7VVY31bov6dKfqquJY77aoT3eqriqO9W6L+nSn6qriInNNd6quKo71bov6dKfqquJY77aoT3eurmqsd0XUpztXVzXWexrq052rqxrrfQr16c7VVY313oP6dOfqqsZ6P0F9unN1VWO9R6A+3bm6qrH2+69Pd66uaqx9+evTnaurGmv//Pp05+qqxtrnvj7dubqqsfajr093rq5qrH3j69Odq6saa3/3+nTn6qrG2oe9Pt25uqqx9lavT3eurmqsvdXr052rqxprb/X6dOfqqubaWz3Otbd6nGtv9TjX3upxrr3V41x7q8e59laPc+2tHufaWz3Otbd6nGtv9TjX3upxrr3V41x7q8e59laPc+2tHufaWz3Otbd6nGtv9TjX3upxsL3VJW8HX8yPP5juWF1VSLu6lxMrfzov8nFwDmU/1ufl4NiStz9cyudjrxjH6tbUMI7VBaphHKu7VMM4VteqhXGwPfHVMI7VZathHKt7V8M4litQwyhgbIERF9MEIy6mCUZcTBOMuJgmGHExLTAO9g4KNYy4mO9hjNuxbln8AUdsTBuO+Jg2HAWOTTjiZNpwxMq04ThW97jmsnGMrsbRrWUJ2yzX4sJ+fLzCGewdC0/gXKc71rOyOt2hHmkppe3glO468+M/7VNcP472KYX7P31lM9RjqjGboR49jdkMFY01ZjNU3tWYzVBtSFM2aaw3TjRmM1Tc1JjNUN3rT9kUv7HJd83fzmaoVrcxG4HNQzYT98XBL5uhCt6nr2wm7ourbCbui6tsJu6Lq2wm7osvbJZnbMZ6q8QP2Yjbjg7il69sJu5vqmwENg/ZzNzf1NjM3N+Eknc2bnn+p9eStofaWsrBjXvmZugnIOOyPwHjcuBGxnp7x3sq8hjkzG2WhL0FldX9sY/2WG8ceQ/Iw4oc610mPwW5fxsiSMlf2Uzd+FfYTN34V9gIbB6ymbrxv7FZ774ktbOZufGvsZm5l6+xmbk9r7GZueMOt4GsLj3/0y7mzQO6JHc7vIR0JTnW+1l+SDLt29+EVMIf8y5jvfnlhSBrscRY75R5T0Ueg5SZQe5/OvxuJf7gJrmU/YvcLiwHN8mZ29vsZSdZKn9adiDiPz9sDqjfIjh3yc73o8NOfebGWY/6zC25HvWZm3096jPbCDXqY72rqRvqMxs9Peozu8IfUQ+bKZT7Ge4cZzaFLTmO9QPypj/YTYO9qqoxnLG2rWoMZ6zNqBrDYZOAx3AGe8VWYzhjbQfVGM4020ucgTPNZhRn4MjUcILc4Kz+Ds7x0f7u6PgF5dz9dFOUc3ffTVHO3av/AKW4PcARf/dlig3k3H19Q5Bze4B2IAd7eZwiyLm9RUOQc/uQhiDn9iwNQQog24DE3TQCibdpBBJn0wgkzqYRyMmdzaMg4uBv5/23CCnc/eb6wd8ueZvkhfrdq3ilXMEP9uLAjsBP7pzagL+inNw7tUQ5uXt6Ggi3eXWb298cELwvFTguL9v+oi67e5TxEM5yg7PEezjXCSTzE/C3CRxsN9bmdWWaEyidT6DNK7o0J+B6n4A3PwGJt1t05VdjXvZnhRf5+vO7Nu+O6ma2MtVs16lma797aDlb+61Gy9na70taztZ+E9NwtsV+x/Oj2fp8m+1Xi1Dst0ctZztYL1WZ7Vi91LpufbJf4x/cLqPNe8i6RFPbAKOM1aWtLuxoUmWDyLxsfzjL3Zi3n4GVsTq6lmTG6v5akhmrU2xJZqyush2ZvIzVgbYkM1hH8xMy6zaMnOInMgd/+PI/b3/Y3e2KLEcT9LfNs5ZPh16JC8TfTHzi/kuJ+MR9nRLxiftFJeIT96E6xP3EXdxPiC+3tz+6u+8wHBLPeRtEcdVdhi7X3r/ekVO6He/L+iHRWOHnkBKNldgOKRGmzLxEgkTWJcL2mZcIn2heIoyleYlwouYlmnhpphOJAumCeYlIF8xLRLpgXiLSBfMSCRJZl4h0wbxEpAvmJSJdMC8R6YJ5iUgXrEskpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLtFKumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEkXSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXKJEumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEmXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iUqpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl0wLlFZSBfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXSJHumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEnnSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXKJAumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEQrpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXzEtEumBeItIF6xKtpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLlEkXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iRLpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLlEkXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2iQrpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXzEtEumBeItIF2xKFZSFdMC8R6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJHOmCeYlIF8xLRLpgXiLSBfMSCRJZl4h0wbxEpAvmJSJdMC8R6YJ5iUgXrEvkSRfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXaJAumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEgnpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLtJIumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEkXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iVKpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLlEmXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iQrpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF4xL5BbSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXyJEumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEnnTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iUKpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLpGQLpiXiHTBvESkC+YlIl0wL5EgkXWJSBfMS0S6YF4i0gXzEpEumJeIdMG6RCvpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLFEkXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2iRLpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXrEuUB7au+fnBKW7HpvQJ+m9gysCG8Y+BGdim/TEwHZgjdwNTmeuzP32dbgdGo+V0Za7pdtAAt5xuB81ky+l20Ji1nG4HSyg/me66Pd8uz5xQ+dNOStmOXu86wMufvrLpoAFUYuOXDnpANTYdtIGvYuNz2pvGXErl6OBL3iYZ3K0fjR8gB2sb9UAO1pDqgRRAfhNkiGUHmdMdyK/Hituhi3fpC/TBGu4+oA/W9v8M+j5JX9xSOTrvc8zhNsXL3zg4tuRtGKV8PvYKfTDz0Qf0iS2QHvSJvZUadDexadODPrUb1II+tXPUgj61y9SCLkB/P/SpHakWdBypAnQcqQJ0HKkCdBzp+6F7HOkroMftWLcs/oA6llSDOp5UgzqmVIO6QF2BOrZUg/rMvrTcFpyXKnUnaUe5uru/nY9GEpdtfTr6eHes/8A+szNVxD6zN1XEPrM71cMeZvanithnNqiK2AXsL8Eu28FxdQfY6WReg33/hW+M+QA7ncx3sa9uH/Ya5BP2K0q6k1Yoe3hPeS8o6SKaoZw5u/7hI2ofyAXlWnlEXS6f5TaU8uVr+D28zXtM8AJ4HfAzh9iq4MmxlcBP7P/CEtIOvtQGUvnNWg/vsu4D5MR+rinIHt4LbQOkc3Hdmbh4t4mcW8rRX3/+Q+0e3vY8JviJnaIu+Imd4ovBt/tVfQ/vZkakiR3oT0VKfv/jriyhIpJPaf+SVrrbUnIDP7ED1QWPA1UCj2N9EfimX4zo4R3JyOR7eE8yMvke3pWMTL6H9yUjk+/hncnI5Ht44+sUMj3/LmYP76ucQqbn393s4Z2VncpU+ypYD++iHBU9HZkaerosNfQC+lc9kpt+j6mHN0Mi1C+h8CKdCMW6TCdCsY7TiVD4++8K5Zd1J+8vM64I5S/CfhzuXb6Dktejo9OyH528/71MGX/fhUxkAV3IRG6gINMVPbmBGnoBvRZ6kgA19Hh7NfS4dTX0+O9Xoff79xr85d8H6HHUWugLLlkNPX29Gno6nFehX2XZ0K/rEXo6HDX0dDhN0F9h0rM0gxkWupCGMEnUvw3Tu7LD9Pf3zBM/nw8LGbkSeDppJfAC+BeBb7YXQVhI0jsQCUd6TqToDjogPGZDmLjGhjBxjd+GGXLeYYrUvuTno98zvxjuji7Xd2xdoIH+HejTAXoc6TvQiz9Ajyd9Gfp9LD7G9RP6o7HEZR9LvF9+zofzTHvIk3OoHJ39Ns0s7tOx1xLAHU9fAkIJzF4CpADTlwAZw/QlQDIyfQmQ50xfAqRQs5eAJw0bvwTW7RvveU0HJUAqN34JyH4XuAN4KwHSwZlKIIaDEiAX6LAE/Bo2KH5d/YGseP0uZb1t9R/deiAr/n1IWfHkQ8qKzx5R1oB3HlJW/PCQsuJxh5QVg9NjdFFu35AtR7l0wOAMKSsGZ0hZMTgjyioYnCFlxeAMKSsGZ0hZaZlsyOpl3RHmtSJriDlsR8dcDmSlZRpR1pWWaUhZaZmGlJWWqUNZJexv9JSQD77LtPJLxx5lLXvULyUffEtxFWTtWtZ1WY5uwnzzcEhZWZgbUlYW5oaUlZRpSFlJmUaUNZIyDSkrKdOQspIyDSkrKdOQsgqyjigrKdOQspIyDSkrKdOQspIyDSkrKdOIsiZSpiFlJWUaUlZSpiFlJWUaUlZB1hFlJWUaUlZSpiFlJWUaUdaMwbEhq9tfShXcWv2xRthlvUh48PXvjMHpXdZy8GONjMEZUlZB1hFlxeAMKSsGZ0hZMThDysoy+pCysow+oqyFZfQhZSVlGlJWUqYhZSVlGlJWQdYRZSVlGlJWUqYhZSVlGlJWUqYhZSVlGlBWWUiZhpSVlGlIWUmZhpSVlGlIWQVZR5SVlGlIWTE475A1+YqsKW6b76d0oy3+qpLDr/SgEvajB5VwE69SKaXtcJ+XUFGphLwhLLKku0fT4XMsl9tz7O7gI3F8yW6f5eKfH+zcknZx3CcoH49Ih09RKJgregH9i9BnX3b063KAnnWql6GPsqO/I7ij9zyhvo1+Dfu4/ZpcBX1J27uQ3OLuHgyXgV/Jc6v/Nvm4uJ18+jTwcvjXy/5M9vcm90G/l7e3gl7+dqkd7dz+GHGSKkfnskEp7uC+53nkTF8CRF3TlwBfvhq+BEoJezOw5E818PXgWPZZxuIqbjVfusCPg7OP/ouj9PTWVNfrqouvolFdr6suFoyorpdVV2Chi+p6XXWxQEd1va66iG2prtdVF9E01fW66hKqa+LqutYAsTc1QO5NDZBOD18DFxmWvQhkqbQarsT9Cy6lDPPFPiFsGr/QQw43Mf3Xu52QCVEEQnQzWRGUgyIgYaEIRCgCioAkhCIQohAaQyELoQiEL9RRBML33iiClcSQIlhJDCmClcSQIlhJDCmClbCIIlgJi3osAr/sm6B4/7kIrrIS/wwpK4HOkLIS0YwoayR0GVJWYpQhZSUY6VJWWXdZ03IgK1HHkLIKso4oK751RFkTnXCXsu6/WvHhdyO5ykon3KOsYd0/rZ9erbHLSic8pKx0wkPKKsg6oqyszg4pK+utQ8qKbx1SVtZbh5SV9dYeZZWwfZfJSw6Vo6Nsb0yJ8bbaE+LRLPO6Icm5fDr2t3LJpFeUyw/KhVSMcvlBuZC2US53x5bbO9kWVyoHr5fa2LRxWSpHxxiWfRzBHdQiESG1aKUWhVqkFo3UImEstWilFkmQqUUrtUjsTS1aqUWyemrRSi2ywEAtGqnFwuoFtWilFlkaoRat1CLrLtSilVpk3YVatFKLQi1Si0ZqkXUXatFKLbLuQi1aqUXWXahFK7XIugu1aKUWWXehFt9TiynsVZIuRL7U4rqw7kItWqlF1l2oRSu1KNQitfimWszrXot3uG+1SKZDLb6pFsXv98XL+A9qEe9CLRqpRcd3I6jFN9ViXjcgKcejWuS7EdTi6VqUfdf3VdxyUF1CdVFdL6suvr9Adb2uunCvVNfp6kp7NrLmxR1UF98xoLpeV118a4DqOl9dcdmry9ccpguL39UJy+885hHwm/SXf0dXO35dd4ZujcvBk9rjYal2s9W+z/JXtddG4ySv++Alp4NVlUB6SLW/q9qd3/94cOvBvTdw76Ua7VSjUI1Uo5lqJJ+kGu1UI3km1Xi+Gu+1SQfVRZ5Jdb2uusgzqa7XVRffDaS6XlZdwi+VqK7XVRe/PaK6XlddrDVQXa+rLvIxqut0dZX9xV9ryetBdZF3UV2vqy7yLqrrddVF3kV1na2uuOzfDo3OHfVd5F1U18uqayXvorpeV13kXVTX66qLvIvqel118V1Zqut11SVUF9X1suoiq6e6XlZdkb6L6jpdXU7SXl1HexxF+i6q63XVJVQX1fWy6qLvorpeV118R4Lqel118R0Jqut11cV3JKiu89W1Hx39734t+/Xo7GWrkuyjvw06f5QiX6igFG2UYuLbF5SikVLkqxqUopFSZH2BUjRSiixGUIpGSlEoRUrxLaXo4rq/tuby77ti3POcxEoH1WinGlkZoRrtVCMrKVSjnWpk5YVqfFs1JnerxnxQjZmYkWp8VzXGLHs1puXgm8yZpJFqfFc1Jn97UieJB9VI2Eg12qlGoRqpRjPVSN5INdqpRvJGqtFONZI3Uo12qpG8kWq0U4182ZtqfFs15nirxjvgezUWvu9NNdqpRtZiqEY71chaDNX4rmrMy7JXY3buoBpZi6Ea7VSjUI1Uo5lqZC2Ganxb33j3jbLsfO14f5P+8u/oasevl4RoO35dSzmodtZ6qPZ5qp21JKp9nmpnrYpqn6faWQuj2mep9riw1ka1z1PtrOVR7fNUO2uFVPs81c5aJNU+TrXvq0vrpUc/qHah2ql2q9W+z/JXtddG4yTfBJLf//1rtZPJUO3DVPuab9Wevn7HLzoyGap9nmonk6Ha56l2MhmqfZ5q5zuQVPvbqn29++1MPKpGvqNINdqpRr5DSDXaqUa+40c12qlG8l6q0Uw1evJYqtFONZKXUo12qpE8k2q0U418B4xqfFc15p335d9rOqhGoRqpRjPVyFoM1WinGlmLoRrtVCNrMVSjnWok/aYa31WN5fbLlFiifK3GQPpNNdqpRhIeqvFt1RhvT+qSykE18q0JqvFN1Zi829/Tevn3+rUahZVBqvFt1biGWzXmg18oCyuDVOPpavRr2qsxpz9w9LUW6RqpRSu1KNQitfiWWnQ53n7Rdfn3gZ8WVgWpRjvVyKog1WinGlkVpBrtVCNZI9VopxpZo6YazVTjyho11WinGlmHoRrtVCPrMFSjnWpkJYZqfFc1JncTPq3uoBqFaqQazVQjazFUo51qZC2GarRTjazFUI12qpG1GKrRTjWyFkM1mqnGyFoM1WinGlmLoRrtVKNQjVTjm6oxL/sbU3N2B7/QinhqqvFd1Vju7o0lHN0b8dQ2qjGJ7NUon4++CoXd7EOohBPrRChMSidC8V2qToTia0adCCUIZUOodPMgyR0IxZdTOhGK7210IhTxSydCkUx0IhTJRB9CZXyUEaHKrT0v8UAouj4bQmXZsnmf13AgFF1fJ0LR9TUR6gqTzqwhTLqndjALay8NYbI+0hAmvXdDmKwzfBtm8fv3kXwpqdJIxeW2HfWdMcn+A7wAXgc8jlAJPA5PCTyOTQk87k4FfFrot18Ffv86RLz7fcANvAD+ReDj7XvQ+QA8Xc13wYeQ/M5EVl8B7y6D2feEcjndfocQDxcklu2P++T93bFXmeiBupCJjqkLmeivFGS6oidr10LvSObV0OMr1NCT+quhZ41ADb2A/mXo9x8tO1cW97QRLS5tIy/u7sfCm0y47y5kwn13IRPeogeZPB2ZDZn8HpIU7/MXmejeupBJkKkHmej0msh0hUk/1hAmaxYNYbKy0BAm/Xw7mIH0vyFM8vxvw1zdDeZ6l1TeYOIHG8LEtTWEKcBsBxMH1BAmDqghTBxQQ5g4oIYwcUDtYAoOqCFMHFBDmDighjBxQN+GGcu+wPHr+6GfYB78dV+2X0+F4G7vuP5Y4hABvA54nJUSeFzYq8Bfjt/Bf/oKyddjxe0iiXdfvm4iuLsORMI1nhPJH3VAuMbvw8zlDmb8CnPFNX4b5mVd7AZzdX/s4briMJXA40aVwONcXwW+XaeyCiLZFwlHfE6k6A46IFzuD9rJfAfz4JtDK270uzBlSfu4xckf3NppxWEqgceN6oCPOFcl8DhXJfA4VyXw9NuvAv9830TeHf4y8M/3TeRd4N8HH8K+YCHhdy9b+nq8T2n765d/fvkhJe/21gJPV6MEnq7mReBdimGfZ4ryFT2JvBp6Ab0Werp5NfRk7Wro6ehfhj7ddiu8/Lv8Hj1vxX0h+pRv6HP8gp4O59vo5YZSVi+f0F9hCjDbwaQLaQiTvqIhTNbwG8IkwW4Ikx62HUzeZNwSJulxQ5j4pW/DjLL/wENiDn+r+KWnx1/h45gU4Qvw9eDjyF4E/wJiG7gPy91XE/JHTMM7kPXQ4/bU0OMN1dDjJN+B3vkv6POC71RDj0tVQ4+nfRX6sOcJPpT1E/qDo5++OjcvuN8uZBJk6kEmHLWCTFf0OGo19DhqNfQ4ajX0OGot9Lz5Xg89jvpV6FfZpunX+31bdvQ4ajX0uGQ19AJ6LfT09VroPR3Oi9BfVsf8/tfvj97R0+GooZ+5wwmyow8pVo4ucZujW5ZbDOnz8kFy5oalLUmBZCOSM4fjPyJ5t4v5r/cs3h2dP1DOHHY3Rjlzk9sY5cxhdGOUM4fLbVFO/aL0xihntkaNUWJ1mqHE6zRDKaBshRK30wwlbqcZStxOM5S4nWYocTutUE79UvTGKHE7zVDidpqhxO00QymgbIUSt9MMJW6nGUrcTjOUuJ1vopTFbZvjihM5QInbaYVy6pd5N0aJ2/kuSpfKjrIsn1Ae/O2n74jOU7+cWxE7LkoFu4D9JdibvWo7T/2q7U4kwiF+VyIf9q7Hp1yRSHLZ/rYU7ytHr2n702u5w7e1U1hP+xrhae1rhFk2r9HULybvRSPs/Ws0KutNo1i+5ipTv8NcFTwW/0Xgy36jWfxBkhgF8C8C73fwkg/AY91fBX4f9rLGA/AYciXwuGwl8Fjn74IP+46hEn6H8mdHX8Hjh3XAJ0yuEnic60vAO0n7fg2ru9+N5WjccdlWJKK/+8vZf4iEy+1AJBxxByIJItkXCafdgUi48g5Ews9YEEm2g+PqvoqU6e4siBS3Px1jPhCJ7u41Iq1un+Qa5JNIV/ACeB3wdGFK4OmslMCz3vGiB/E+7Av4tfIgvgw2y23g5csXdDOrI13IhPfoQabCyksXMrFO04VMU3v5vB0dxK+fjr7CmdlR5P0LlaEscgBn4q5G3H60uBK/wCkzv2n8coPav1uU3HIAZ+J7Th3OxLldHY5MDCfdvrKXl6VydN7nmMNtir9evvH12LI/Bkv5fOwV+sRPQT3oE2dqetAnztP0oM/cR6pBnzjrUoM+83uq9aDP7MTUoM/s8NSgz+wc1aAL0N8PHUeqAB1HqgAdR6oAHUf6CujP3wdcHJZUgbrHk2pQx5RqUMeValDHlmpQn9ki1b6d4We2MlU4M1uOKpyZrYHfJyle8gGcmTv4GpyZ3ztfhzNzP1yFM3PbWoUzc3dZhSMTwwnrNmyRxVeOjnHfliDf2nT/sV1ymfnt7W1Bztx5NwU5c5f+5GvCB0553zXduXL3p2UjOXNL35Tk1C8br/xcpkz9+vAqnJl/hVaFM/NOLmXfAuEyx9rRLm3PTL/cjj0OUBuuF0/94vAuBJr5d5xdCDTzDjI2BKqsJ0397vQ+FJp5l5k+FJp5g5kuFJr6BfJ9KDSzje5DoZm9fNl3cBUntTzNp7Bt/OPTpzdGy6FG65bVXVDKp6Ov4KfOCTTBC+B1wE/t618I3u0bgGfv4gH4qf26Jvipbbgm+KndtSb4qU2zIvipX+OuCn5qi6sJHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgN+6nezq4LHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHub4GfNwnmVP2B+Bxrkrgca464DPO9TXgL9A28CW7A/A4VyXwOFcl8DhXJfACeB3wOFcl8DhXJfA4VyXwOFcl8DhXHfAF56oEHueqBB7n+hLwZfHLx9FlCesBeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrBnhZFpyrEnic64vAp7KBd0s5AI9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UB73CuSuBxrt8EH24v1A0+xwp4l24jSVHuh33ljnHV4Y5v1eEucFfhjmvV4Y5p1eGOZ9XhjmXV4Y5jfQ33Uraj/SWPeT7seFl5/Tg4XjqdLyJ53K2+SGvZrfCxSDjhF4m0vxTWL8E/H7bssMXf/ag8pMNbY3G3e2Pxt2H7sn5oisseT1Mc/HiaCpoOpynJw3iakmqMpymJyXiaksaMpylJz3CaBoKh8TQlRxpPU3Kk8TQlRxpPU0HT4TQlRxpPU3Kk8TQlRxpPU3Kk8TQlRxpOUyFHGk9TcqTxNCVHGk9TcqTxNBU0HU5TcqTxNCVHGk9TcqTxNCVHGk9TcqThNF3JkcbTlBxpPE3JkcbTlBxpPE0FTYfTlBxpPE3JkcbTlBxpPE3JkcbTlBxpOE0jOdJ4mpIjjacpOdJ4mpIjjaepoOlwmpIjjacpOdJ4mpIjjacpOdJ4mpIjDadpIkcaT1NypPE0JUcaT1NypPE0FTQdTlNypPE0JUcaT1NypPE0JUcaT1NypOE0zeRI42lKjmRA07C9+FBS/qTpVSNyIfsakfO8RCPv9kl6dzeS7X2TWeCuwp28RIc7mYYOd3KHF3EPYedeSsPeN5S8TVGc248O+xOb1GE0RckcBlO0kDiMpih5w2iKkk6MpihZxmiKCooOpij5iwFFn2fChazGvkYzpwAh79TFr5+OvsKZ2VBX4LhlZm9ahTOzzZNwg5Ni5WiXtgf9ZQ1yP9bn5eDYvPPIoVSOLbtCpXw+9irQzK6tC4FmNmFdCCQIpCxQ3I69PIz9gUIze6Q+FJrZIfWh0Mzr3n0oNLOD7UOhmW10Fwq5mb38E4WucPDyT+Dgo5/AmdrD5m2SIYur3fh83u9QIcjd0YdILpnbDl7ip6Ov4AXwOuCntpya4Kd2ki8Ev+6/IAtrXg7AT20QNcFP7fs0wU9t5xTB+6ldmib4qR2gJvip3aUmeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviAc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zfQ34Evbfxi8lH4DHueqAF5yrEnic60vAi7+B96s/AI9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBv+JcXwQ+lQ18+B34nx19lQmf24VMuOIuZMJDG5Dp0ubuf3t1d+POR7OMy7bpQfTx7lj/Iakg6WiS4vuHk5REYThJySqGk5QUZDRJI/6xP0llOziu7kBSQdLuJI1+kzTmA0npeC1IurodyXr/t3P4kIkutguZ6Ey7kIluswuZWKEz0W7sk7zItFbajcvUbkMp/pckH8d/bD2ZWP0bUFS83oCisrI4oKisQw4oqiDqN0UNN/BxCTWZnhx9BU96ogSePEQJPAnHS8B7v2yvQ/USDr5AlMgslMCTQuiAzyQFSuBx80rgcdxK4HHFSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuALzlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zvU14Fe/He3Xo70DCs71NeAllB18XCpH551fDjd8/tduxF+OLXmbYimfj70KiiMeTFCc9lCCXh6FCDqWoCQDgwlK4jCYoCQZgwkqCDqWoCQvgwlKojOYoCRFgwlKUjSYoCRFYwnqSIoGE5SkqDdB4/7r6GXxB4oSFY2mKFnRaIoKig6mKGnRaIoSF42mKG70NYquMe2KlvpGiGUJ2x9fy92Wvtf9fbyfpt25Tlfmmu5YD8oS9louIpU/7VPcBuJTCvd/+spmrEdOWzZjhf1t2YyVm7dlM9ZDvymbMFaa25bNWMFoWzZjRYxt2YzVvf6QTdlev+Gzk69sBDYP2UzdF1fYTNwXh8si+m3Y6SubifviKpuJ++Iqm4n74hobmbgvDrcfxh6zmbi/uaSi258O4pevbAQ2D9lM3N9U2czc39TYzNzfhJJ3Nm55/qfXsr+TYS3l4MY9czP0E5Bx2Z+AcTlwIzJz53SyIg9BrjO3WbdV8CB3b5899dFeJ84qz4I8rsiJg80gKe4gS/7KZurGv8JGYPOQzdSNf4XN1I3/jc1693Wtnc3MjX+Nzcy9fI3NzO15hU2cueMOfv8G5OpS5U/HvHlAl+TuK40hfZCcuVNMeY9sUgl/zLvEmdvKn4CsxRJRAPnTijwGOXPDevvT4Xcr8Qd/ein7n3ZhObhJztzeZr8PO5fKn5YdiPjPD5uDYdwiOHfJzvejw0595sZZj/rMLbke9ZmbfTXqaWYboUd95pRfj/rMRk+P+syu8EfUw2YKJeWvHXgSODbhyI/Brxxt/3Q4sSNgFzKxz18XMrFfgg2ZgtxkuntlTnxwtL87Ov5e1MwOfgOKyi5+A4rKRn7difrrbVe7C75bZN4kZSe/4SQVJB1NUvbyG05S8pvhJCXrGU5ScqHhJCVDGk3SQoI0nKTkR8NJSno0nKSkR8NJKkhqQ9JHUfzB385h/5GVu9Pmwd8u+ywv+t/NUspHCZA2TV8CpFNDlcBVVPKpAUUloTIu6i+ZwoKf/a5MlwXMHUmQCvhf3wnbutmwVmWSdGuU775e5vLh71tlOzjebePjsv+QFD/bn6Rp4xfzeiApfnY4SQVJR5MUfzqcpPjNDiV1u6TxQFLc5nCS4jWHk5RvQ/QnadyihhjzV0kd34YYTlLSo+EkJT0aTlLSo+EkFSQdTVLSo+EkJT0aTtKZfWmQXdKQYuXoXwuRN5Huj85/XKTnK6B+ZqdpR6Tn0bqf2Tt2I9LMbrAbkWb2d92IJIhkQaSnqw5+Zg/WjUgzu6puRJp5ld2OSM/NrJ953bwbkUgc7IsUSBw6EInEoQORSBw6EInEoQORBJHsizSzT1rCLtJSagNxEmVb9bv8O9//9XJwvF/ztp/E5Z93UPLHTx/DzO5HGf3MnkYXvczsVJTRz+w/lNHP7CqU0c/sFV6LPu3ba/kkywF6Ab0W+plXEpXRz7w+qIweN6uFfqWvfxX6WLaBX/4ZDtDT4bwKfc7b4b4s6wF6Af1r0F8i0dtf9wd9/UqHo4aeDkcNPR3Oy9Anv//1/Pkx+7Ojr0KR7nciFGsBJoSKed1/VJXv9l7+kCniL7qQiTWGLmRiPcKGTGWHEotPX2TC2XchkyBTDzKRGHQhE+lCFzKRRHQhEzlEFzKRQhiR6ba1S1m/yJRIIbqQiRSiC5lIIbqQiRSiC5kEmXqQiRRCQaYrerzQi9BXv6OW8Dda6DOeRQ09PuRV6D99H1kO0OMt1NDjF9TQC+i10NPXvwy9v6EPNfsVfNl+EBqCk9/br8zqYhcysbrYhUw4ahsyXRYQd5nyfeb0k2OvkuLUR5O0kAAMJynJQneSitufpeLdV0lJLIaTlCRkOEkFSd8v6RU9CcvL0Me0o0/5AD2pycvQ530NKZWDX3wXkpB3VP0hetINNfSkEEroZcGHvAp9XrdpXv55hB6/oIZeQK+Fnr5eDT19/cvQi3+Ong7nZeif79onjvUQNfSsW6ihp69XQy+g10JPfPZt9CEsO/oLlAp6l9IatuMv/75h2dATn6mhp7nUQu9pLl+HPuUb+rvXfm/oaS7V0NNcqqEnNFZDL6DXQk9orIae0FgNPW5WDT1uVgt9oK//Nvol7eO+xI6pgj7etqpZ3V145j/A09W/Cvx+dMzrAXh6eiXwAngd8PTzSuDp5l8G3u3g4wF4enkl8HTySuBZlXoV+Lh92SzG/BW8sCalBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgN+pY//LvgQ9s3gXZDVV8A7l/O+ZuXKcv/G1K9HF5e2kRf3ZXMmWen6u5AJj2BDJu82KMX7rzLhKLqQSZCpB5lwK13IhLcxIlNwu0zhy489VpxQFzKx4teFTKwP9iBTJIXoQiZSiC5kIoUwItPibw15/iITKUQXMgky9SATKUQXMpFCdCETKUQXMpFCdCETKUQPMiVSiC5kIoXoQiZBpm/K5Ivfdyj0pfzBn1gnnNCrwD//3WPC2yiBx60ogcd/KIHHUbwM/NMfnGY8ghJ4un4l8Kwmvgr8859mZNYHlcAL4HXA41yVwONclcDjXJXA41yVwONcdcAX+vhvg4+L28GnTwMvh3+9uB1KXCtH+1RuL6X/3U62V6Ho+20Ilf22GOZzyAdCCUL1IRS+ohOh8CFGhNqB++zSgVD4lk6Ewud0IhS+qAuh1oUVwE6EYsWwE6FIJjoRimSiE6EEofoQimSiE6FIJowItf+i4fLPfCAUyUQnQpFMdCIUyUQfQjmSCSNC7SO/CFUOhCKZ6EQokolOhCKZMCKU5F2oNRwIJQjVh1AkE50IRTLRiVAkE50IRTLRiVAkE30I5UkmOhEKH2VDqLhvxHT526V2tISwHS05VI6OcvudyG2lK8SjWZa81Ytb7oZxfHD06wYw+lz707/2mtp/3pKzWz4df61GoRqpxndVo9yEv7833qoRR0w12qlGbD/VaKcayTaoRpVqjP6gGglwqMb3VaPcqjGttb9edt6x3H/RMB8cnP3+t7O/K/TLwdc6J/+izieo80B8SJ3PUOd8L4w6n6HO+VoddT5DnbOaRp3PUOdCnVPnE9Q5K4DU+Qx1ztoidf6uOi9+B3j5d/x0/LUaSbmpxrfddcvtO2llOfhOmpBdUI1vuze6m/AluINqpCOlGu3cG+kbqUaVvjEcVSPfSaMa7VQj30mjGu1UI56aajRTjSvf76Ia31aN4ZarF5GDauRbWFSjnWokb6Qa7VQj32iiGu1Uo1CNVKOZamQthmq0U42sxVCNb6vG2jr1yloM1WinGlmLoRrtVCNrMVSjmWqMrMVQjXaqkbUYqtFONbIWQzXaqUbWYqhGO9UoVCPVaKYayRupxtPV6PajL4W51Kox+bD/8XSZwkE1kjdSjXaqkbyRanxbNcZwq8ZUvlZjIm+kGu1UI3kj1WinGskbqUY71UjeSDW+qxrDsquTLoVyUI1CNVKNZqqR735TjXaqke9+U41vq0a5q8Z1PahG1mKoRjvVyFoM1WinGlmLoRrNVGNmLYZqtFONrMVQjXaqkbUYqtFONbIWQzW+rRrDfTXGg2oUqpFqNFONrMVQjXaqkbUYqvFt1bjP8de/D77Dk1mLoRrtVCNrMVSjnWpkLYZqNFONhbUYqtFONbIWQzXaqUbWYqhGO9XIWgzV+LZqTHfVWA7epVWEaqQazVQjazFUo51qZC2GanxXNYrb39CRxB/sw1NYi6Ea7VQjazFUo51qZC2GarRSjXFhLYZqtFONrMVQjXaqkbUYqtFONbIWQzW+rRqX+2qUg2oUqpFqNFONrMVQjXaqkbUYqvFd1ejzbW9bCWvteAluP16OdtiLC2s3VK/Z6g3rrXpXVz0+r/vgJad8UO2sDVHtZqt9lVu1x6NMgLUkqreLe/VR9TrWnqjefquXtSqqt9/qZW2L6u23elkLo3rNVm+Kt+ot/o9nFE6odqrdarWX2736sjJyUL2szVG9Pdyrj6uXtTyqt9/qZS2P6u23elmbo3r7rV7W5qheq9UrLt2qN4Q/nlF41vKodrPVHu7u1bIeVC9reVRvF/fqw+plLY/q7bd6WcujevutXqF6qd5uq5e1OarXQvVeq5G1NqrRTjWydkY12qlG1sKoxrdV43qrRp+Xg2pkbYtqNFONgbUnqtFONbKWRDXaqUbWhqhGO9XIWg/VaKcahWqkGs1UI2sxVKOdamQthmq0U43kjVTjm6oxlrgXVSypfK1GIW+kGt91b1xuwl/+HQ+qkbyRarRTjeSNVKOdaiRvpBrf1jeW5a4aD3ZWF6EaqUYz1UjeSDXaqUbyRqrRTjXy3W+q0U418t1vqtFONbIWQzWaqcaVtRiq0U41shZDNdqpRqEaqcaT1bheamPTxmWpHJ0kbn/78s+D70yspI3UopVaJGukFq3UIkkjtfimWoxu0z1Fnw5qkZyRWrRSi6SM1KKRWoxkjNSilVokYaQWrdSiUIvU4ntqcc1blaS1HGTdER9NLb6pFlPZBp1ycAe1iI+mFq3UIj6aWjRSiwkfTS1aqUV8NLVopRb5zTS1+KZazKvbazGGg1rkF9PUopVaFGqRWjRSi3x/kVq0Uot8f5FatFKLrLtQi1ZqkXUXatFKLbLuQi0aqcXMugu1aKUWyRepxTfV4v33F4/WXbJQi9SikVokX6QWrdQi+SK1aKUWyRepxXfVYty/p3PJEr/WYuF7OtTim2ox7fxScnJQi/hoatFKLQq1SC0aqUV8NLX4rn6xpFstrge1iI+mFq3UIj6aWrRRi2lhPZpafFe/uL9a+vJPOahFfgdILb6rFu9+B+hC5Wgned2HIvkgj0wLeSS1+6bazS7utXuwTpMW8khqUeE+eliLQi1Si0ZqkTySWrRSi+SR1KKVWiSPpBat1CK/G6QWjdSiI4/ssRa9bAi9T8uno6+yEtX1KGvw29/2QcKBrKReQ8oqyDqirGQxXT5b803W343kKiuxxpCykhAMKStme0hZ2e9mRFk9X9UbUlZSpiFlJWUaUlZSpiFlxbd+W9Zlvcl6mXEV/ZL3ON7fxfF5/UCPt1RDj/9TQ49Hexl62dei/Ro+oT8Yiy+bUCHc/Yj5Ywk44Lm6kAkPZUOmEMsuU053Mv3k2Kuk+KfhJMU7DSepIGlvkorbn6Xi3VdJWZkfTlLSjeEkJTV5laTh9v3RkJaKpGva9F/LHcD8oRIBSw8qkcV0oJIQxfSgEklMDyoRrrxKJbmtNMr9Xz9UKZZ9iTSWuybvF58vB2cvG+/so/8qKvHKgKIKoo4nKhHLgKISsgwoKjHLgKKSygwoKiHOeKKu+NRXibr6feFi9esnUa/o6VFfhl72ry6v68F3A1eeTy9Dvx/u15gP0PMU0UIfyffV0BPaK9zrTzwZIv1QJ0KRxZsQKuZ1Qxhzuu3x9vEtmijI1INMeJEuZCIBtyFT2aHE4r98dTCSaXchEylAFzKRGPQgUyJd6EImkoguZCKH6EImUggjMu3LnLGsX2USZOpBJlKILmQihehCJlKILmQihehCJlIIBZl+Q5/xQt9F75Lf/7grS6igd5I2KG519z+uPxp5vH1AVnd3rP+QCS9kQ6a0O9a8HsgkyNSDTHihLmTCC3UhE17IiEz7TxdyPJAJL9SFTHihHmQqrMjakCne3sabD2RiRbYLmUghupCJFKILmQSZepCJFKILmUghupCJFKIDmfIysW/y5baB8uKWmkwN14/yMrEPein2p9FoXib2NZrYJ/YpmtgF7BrYJ/YRr8X+LAHOy8S+QBP7xH2+JvaJVw9fir1ilyZeDVTE7nCpKthxqSrYcakq2HGpKtgF7BrYcaka2P0x9rS/3/0u/vd5ObhA3pHnUCrHlrxRKeXzsdfBREuDSZYGky0NphgazIN32CsNxlkajLc0mGBpMGJpMJbuwMHSHTi89w4c96fqsviD0WRToymWRiOLqdE4U6PxpkZzfLeRUvaWcvXPe9vLysY2HLlrsUP6uEJ8+RXSy6+QX36F8uorrMvLr+D++BXWzYHlFD9d4cAlLWWzMv43Z/RxtBx5u5y3F4AU52t/+GIstz8sy20FNewT9bNMNMwyUZllovX7ffo00etZ8dRZ6cxZ0b36PhX9y68QXn4FefkVXt4ZxJd3BjFN8rGOeZaJlkkmmpZZJurOPCWSP3VWOHPW8Q9vgi+bZQvB3TZWih8nxTMnpTMnHX72Q7itIYR8v4XWn39w7PUC5bUXKMdf8m95AfdHLyBu10C8+3oB/+oLhBdf4PgrLD6lbbnt8s/85SR35iR/5qQHn9yfLH1djvg4eL1fC/xY+ioPFnqbXmJ9/SXi6y+Rml5CloNL5Ndforz8En55/SXcH79EXLYbQ/Tx4BL+9ZcIr7+EvP4S6+svEV9/ifT6S+TXX6K8/BJhef0lXv/pDq//dIfXf7rD6z/d4fWf7vD6T3d4/adbWnwunv48tUiLinr6RagixxW1uv0rYmuQT5e4nraeOy2eOy2dO+3B/Xf/QtvltLWCz13u4jvty+32i6F4tKLV9CKPFrXaXsS94yL+HRdZX/7RXFvcw57+gLGs6fWXyK+/RHn5JeLy+ku411/Cv/4SLZ4nT38QV6K8/hLr6y8RX/7gjen1l8ivv0R5+SXS8vpLuNdfwr/+Eq/vFpO8/hKHRbuuW2q65rtOL5WPk8qJk/Jy5qTjUlnSPqtf/y6/70gevE9iSWVvYZfs4pfTwrnT5Nxp67nTjm+WSw7hdtrdSza209K50/K508qp0x7swLmU2+tGlktz8OW0ByQvNbed5pblC8kHe6pVT0vnTisn5rYuD7aqqp724INTSrgb5PrlNH/utHDuNDl32nrutHjutHTutOMPzuXQcjvN31fJn39aU5eLlDdc5MHP0BtfxP3xizxdi7xcwr/+EuH1l5CfXuJ62nrutHjutDO3yMtp+dxp5dRpfjl3mjt3mj93Wjh3mpw7bT13Wjx12qMf1a37jTWl+5+pHrW3Pi37N4yS918u4V5/Cf/6S4TXX0Jef4n19ZeIr79Eev0l8usvUV5+CXn9p1te/+mW13+65fWfbnn9p1te/+mW13+65fWfbnn9p1te/+lef/zpvp7mzp3mz50Wzp0m505bz50Wz52Wzp2Wz51WTp0Wz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVUk8VyXpXJWkc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLPVUk+VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJeVclZRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVlFNV4pbl3Gnu3Gn+3Gnh3Gly7rT13Gnx3Gnp3Gn53GnnqsSdqxJ3rkrcuSpx56rEnasSd65K3LkqceeqxJ2rEneuSvy5KvHnqsSfqxJ/rkr8uSrx56rEn6sSf65K/Lkq8eeqJJyrknCuSsK5KgnnqiScq5JwrkrCuSoJ56oknKuScK5K5FyVyLkqkXNVIueqRM5ViZyrEjlXJXKuSuRclci5KjmXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736B9lr2b9heGmv3MFpD6pk39Lv0oL4T6cdbeXb6EUhl+EUU8N5lBVrDcfZGo63NZxgazhiazirreFEW8NJtoZj664stu7Kq6278mrrrrzauiuvtu7Kq6278mrrrry++6789B1Xl/EkY+PJxsZTbI0nLsbG44yN53gD9csizsdpl9hkrYznsuZ5e5FyTF92L/DH672tLyLvuMja5CIh3i4Sw91FDn6Rl8O2MVBY7vd9Wo63U132PdeWcPvtfS4f44/Gx7/u/OMawtfxp87Hnzsff+l7/MdffOho/K7z8fvOxx86H790Pn7rz9/a+Dt//qbOn7+p8+dv6vz5mzt//ubOn7+58+dv7vz5mzt//ubOn7+58+dv7vz5mzt//ubOn7+l8+dv6fz5Wzp//pbOn7+l8+dv6fz5Wzp//pbOn7+l8+dv6fv5G5a+n79h6fv5G5a+n79h6fv5G5a+n79h6fv5G5a+n79h6fv5G5a+n79h6fz56zp//rrOn7+u8+ev6/z56zp//rrOn7+u8+ev6/z56zp//rrOn7++8+ev7/z56zt//vrOn7++8+ev7/z56zt//vrOn7++8+ev7/z5Gzp//obOn7+h8+dv6Pz5Gzp//obOn7+h8+dv6Pz5Gzp//obOn7/S+fNXOn/+SufPX+n8+SudP3+l8+evdP78lc6fv9L581c6f/6unT9/186fv2vnz9+18+fv2vnzd+38+bt2/vxdO3/+rp0/f9fOn7+x8+dv7Pz5Gzt//sbOn7+NNqnSG3/nz9/O978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/JZ3vfyWd738lne9/JZ3vfyVL389f6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8r6Xz/K+l8/yvpfP8rMb//1e1Px1Tc/fiPDt5GHXO8/eHsP+Zq/VndcK7m99VqOVfrPUDLuVrvF1rO1Xpv0XKuYnuua1nzba7++VwllW0ckkPeD/ZlPRy2S/uog+xHhxA/2BjvcVTZGO+fVNkY783SKv7j6BSX+JxNCNuxQe4G7Y+Yx3Ub8pqWu4PDcjTmUva/vCz509FXjMZbxF4wGu8+O8FofcO6XjAa75l7wWi8He8Fo/FOvxeMAsYWGI37jV4wGrcmvWDExTTBiItpghEX0wKj9W0/e8GIi2mCERfTBCMupglGAWMLjLiYJhhxMU0w4mKaYMTFNMGIi2mAcbW+eXIvGHExTTDiYppgxMU0wShgbIERF9MEIy6mCUZcTBOMuJgmGHExLTBa34K+F4y4mCYYcTFNMOJimmAUMLbAiItpghEX0wQjLqYJRlxME4y4mBYYrb/IoxeMuJgmGHExTTDiYppgFDC2wIiLaYIRF9MEIy6mCUZcTBOMuJgWGK2/DqkXjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYFhitv1SuF4y4mCYYcTFNMOJimmAUMLbAiItpghEX0wQjLqYJRlxME4y4mBYYrb+asxeMuJgmGHExTTDiYppgFDC2wIiLaYIRF9MEIy6mCUZcTBOMuJgWGK2/4LgXjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYFhitv869F4y4mCYYcTFNMOJimmAUMLbAiItpghEX0wQjLqYJRlxME4y4mBYYMy6mCUZcTBOMuJgmGHExTTAKGFtgxMU0wYiLaYIRF9MEIy6mCUZcTAuMBRfTBCMupglGXEwTjLiYJhgFjC0w4mKaYMTFNMGIi2mCERfTBCMupgHGuOBimmDExTTBiItpghEX0wSjgLEFRlxME4y4mCYYcTFNMOJimmDExbTA6HAxTTDiYppgxMU0wYiLaYJRwNgCIy6mCUZcTBOMuJgmGHExTTDiYlpg9LiYJhhxMU0w4mKaYMTFNMEoYGyBERfTBCMupglGXEwTjLiYJhhxMS0wBlxME4y4mCYYcTFNMOJimmAU2xjXsuYNY3algjHl7eCQ74Ydyno0bPHbQJykO4WODg4uL9ufduV2sI9How6L37E7uWEPSzo4OrsoH0dnfyeSz+7gaElL+Dha0q8S2f72Gj4kNe6okPTnkhp3d0j6c0mNO00k/bmkxl0vkv5cUuMOHEl/LKkYTwOQ9OeSGk8mkPTnkhpPSZD055IaT2yQ9OeSCpKOJinp0XCSkh4NJynp0XCSkh4NJynp0fckFVe2Py3ZVyRdF7evgC6SbnOMV+orAY8GdTIYDerEJBrUSTI0qAvUFaiTB2hQx7JrUMdVa1DH+GpQx5sqUI94Uw3qprzpdUimjNt1SKZczXVIYm9Ipvrh65BMNYvXIZnqpK5DMtVmXIdk6hn825CSqQfUdUj27t7J3t072bt7J3t372Tv7p3s3b1tveP+OiR7d29b717/bUi23mN+HZK9u7et92tfh2Tv7m3rvc/XIdm7e9t6H/F1SPbu3rbek3sdkr27t633t16HZO/ubeu9otch2bt723rf5XVI9u7ett7DeB2Svbu3rfcDXodk7u6dbL237jokc3fvZOt9atchmbt7p8Xc3TvZemfWdUjm7t7J1rucrkMyd/dOtt4x9NuQbL2v5zoke3dvW++RuQ7J3t3b1vtNrkOyd/e29d6N65Ds3b1tvQ/iOiR7d29b7ym4Dsne3dvW/vnXIdm7e9va1/06JHt3b1v7jV+HZO/ubWsf7OuQ7N29be3PfB2Svbu3rX2Dr0Oyd/e2tZ/tdUj27t629hO9Dsne3dvWfo7XIdm7e9vaT+86JHt3b1v7mV2HZO/ubWs/qeuQ7N29be3ncx2Svbu3rf1UrkOyd/e2tVnGdUj27t62tlm4Dsne3dvWD/SvQ7J397b10+7rkOzdvW39KPg6JHt3b1s/J70Oyd7d295vLZO931ome7+1TPZ+a5ns/dYy2futZbL3W8tk77eWyd5vLZO931ome7+1TPZ+a5ns/dYy2futZbL3W8tk77eWyd5vLZO931ome7+1TPZ+a5ka/YBoSbchuXQ3pOtFfnzzu562njstnjstnTstnzutnDkt//xHDNfT3LnT/LnTwrnT5Nxp67nT4rnT0rnT8rnTzlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLOVYk7VyXuXJX4c1Xiz1WJP1cl/lyV+HNV4s9ViT9XJf5clfhzVeLPVUk4VyXhXJWEc1USzlVJOFcl4VyVhHNVEs5VSThXJeFclci5KpFzVSLnqkTOVYmcqxI5VyVyrkrkXJXIuSqRc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WynquS9VyVxHNVEs9VSTxXJfFclcRzVRLPVcnxYojE/bRPr8W5nZaOT3O30/zyt+eZwMXNfRx8eaTsx/q8HBxb8hZolPL52Otwsq3hFFPDOV6k0BuOszUcb2s4wdZwxNZwVlvDibaGY+uunGzdlZOtu3K2dVfO774r76/pc8viD8bjjY0nGBuPGBvPamw80dh4fnxvvp6Wz51WTp3WaBe8p0t9udG+dpWLrO+4SHzHRdI7LpLfcZE23wAQd7vIWu4u8rOV8F9DKo12fGs6JGdvSP7dQxJXtvfSiP9SSaXRfm8NByTWBvT2b25VHoDl/Vu9VUeUzI0omxtRsTai92/zVh2RMzcib25EwdyIxNyIzN2znbl7tsL+buuybH97lVL722Xd/3TJ7m4C7mMC2fgELiZwO3oJnydw4JC92y2yX2tHpyLbV01TKb5ydFj91uC4eDt2OTrWu3Ljt5RPR1+xF7ArYFfY1Q/sF+wO7BrYPdg1sAewa2AXsGtgX8GugT2CXQO7db83KHZcqgp2XKoG9oBLVcGOS1XBjktVwY5LVcEuYNfAjktVwY5LVcGOS1XBjktVwY5L1cAuuNRXYPe5bKMO99842bHjUlWw41JVsONSVbAL2DWw41JVsONSVbDjUlWw41JVsONSNbCvuFQV7LhUFey4VBXsuFQV7AJ2Dey4VBXsuFQV7LhUFey4VBXsuFQN7BGXqoIdl6qCHZeqgh2XqoJdwK6BHZeqgh2XqoIdl6qCHZeqgh2XqoE94VJfgT25DYhPYTnAjktVwY5LVcGOS1XBLmDXwI5LVcGOS1XBjktVwY5LVcGOS9XAnt9/b89hm2xYXKj87V/fbdhALuV2dC4f40+djz93Pv5ie/xx3V9rFNfwdfxl6Xz8rvPx+87HHzofv3Q+/rXz8Rt//lbHb/z5Wx2/8edvdfxdP3/jsnT9/L2Mv+vn72X8XT9/L+Pv+vl7GX/Xz9/L+Lt+/l7G3/Xz9zL+rp+/l/F3/fy9jL/z56/r/PnrOn/+us6fv67z5+/7XyTZePzGn793+WHM6WD8/eTPx+PvJ38+Hn8/+fPx+I0/f2vj98afv9XxG3/+Vsdv/PlbHb/x5291/Mafv9XxG3/+plW21eIUl3g//oOV5bAdG+Ru0P6IS9xflbym5e7gX4vMX8d8WefZx7zkT0f/hjEYv43YwBiWsn3nPHzicXh02kec9iMlfPA2ftsbjrfx2/RwvI0/VobjzWPwvbyN2+bheBu3+cPxNh5LDMfbeIwyGm8xHvsMxxt/+V7e+Mv38sZfvpe3wPutvPGX7+WNv3wvb/zle3njL9/LG3/5Vt4r/vK9vMU4b5/jPvq799Me8nYXcts4Urz7YXQ4XCFftt9Fr7J8OvZKxnrnpkfGeo+lR8Z6N6RHxnrfokfGeoehRiZa7wX0yFhPhfXIWM9v9chYT1r1yMi8ZOK2289acuVY8euGUXyWT6bjynHeJ1neD77/ru3xsT747WAv0s2GTK7cZLyD97EhU1zSvE9r1F/SvB0J6i9p3q4L9Zc0b2eJ+ovCltKob0f9eVNy1F/SvCsBqL+keVc7UH9J867ooP6SyPomVj+T9c2sPlnfzOqT9c2sPlnfzOoL6k+sPlnfzOqT9c2sPlnfzOqT9c2sPlnfxOpbf9Ec6r9UfbK+gdX3efsZqQ+LP1CfrG9m9cn6ZlZfUH9i9cn6ZlafrG9m9cn6ZlafrG9m9cn65lXfWX+pNeq/VH2yvpnVJ+ubWX2yvpnVF9SfWH2yvpnVJ+ubWX2yvpnVJ+ubWX2yvonVd2R9M6tP1jez+mR9M6tP1jez+oL6E6tP1jez+mR9M6tP1jez+mR9M6tP1jex+p6sb2b1yfoGVj+5DZ5PYTlQn6xvZvXJ+mZWX1B/YvXJ+mZWn6xvZvXJ+mZWn6xvZvXJ+iZWP5D1zaz+vFlf8dscy7pWjl2XtL/4/LeB7kcvHxznTc3acpw3f2rLUeDYhOPEmUgO28HLEmuPRxf3x6MPqZfHY2U7WxcmDkWQ34WJUxHkd2HiWAT5XZg4F0F+JxMHI8jvZOJvQSG/k4m/BoX8Tib+HhTyOxHkn1l+Ur+p5Sf1m1p+Ur+p5Sf1m1p+Ur+Z5V9J/aaWn9RvavlJ/aaWn9RvavkF+WeWn9RvavlJ/aaWn9RvZPlrm96spH5Ty0/qN7P8kdRvavlJ/aaWn9RvavlJ/aaWX5B/ZvlJ/aaWn9RvavlJ/aaWn9RvavlJ/WaWP5H6TS0/qd/U8pP6TS0/qd/U8gvyzyw/qd/U8pP6TS0/qd/U8pP6TS0/qd/M8mdSv6nlJ/WbWn5Sv6nlJ/WbWn5B/pnlJ/WbWn5Sv6nlJ/UbWf7aq+4yqd/U8pP6zSx/IfWbWn5Sv6nlJ/WbWn5Sv6nlF+SfWX5Sv6nlJ/WbWv6hfH/0ssufqoqWZTvalzVUjpZl2apFFrkvreu70P0y1GP0RyTDsrh9ILnKPfj9kyTievkkVXbI9MtQz1H0/7H+Qz1I0f/H+g+1fob+P9Z/qAU09P+x/vN20uh/0d8NtYSG/j/Wf6g1NPT/sf5DLaKh/4/1H2oVDf1/rL+g/9T6k//NrT/539z6k//NrT/539z6k/9Nrb8n/5tbf/K/ufUn/5tbf/K/ufUX9J9af/K/ufUn/xta/8r+Gd6T/82tP/nf3PqT/02tfyD/m1t/8r+59Sf/m1t/8r+59Rf0n1p/8r+59Sf/m1t/8r+59Sf/m1t/8r+p9Rfyv7n1J/+bW3/yv7n1J/+bW39B/6n1J/+bW3/yv7n1J/+bW3/yv7n1J/+bWv+V/G9u/cn/5taf/G9u/cn/5tZf0H9q/cn/5taf/G9o/Stv0vIr+d/c+pP/za0/+d/U+kfyv7n1J/+bW3/yv7n1J/+bW39B/6n1J/+bW/+J8z+35G0gbk2VoyWVbSCSZbk7+uNN6nHiJK0xyYkzqcYkJ0532pJME+ckLu0kva+R9C7uz0kfUi/Pydo+uWninAT9L/pPnJOg/0X/iXMS9L/oL+g/tf4T5yTof9F/5pwE/X2aOd1Bf59mzqTQ36eZkzT095n8b279yf/m1p/8b279yf/m1l/Qf2r9yf/m1p/8b279yf/m1p/8b279yf+m1r+Q/82tP/nf3PqT/w2tf22fnEL+N7f+gv5T60/+989T60/+N7f+5H9z60/+N7f+5H8z6x8W8r+59Sf/m1t/8r+59Sf/m1t/Qf+p9Sf/m1t/8r+59Sf/m1t/8r+59Sf/m1p/R/43t/7kf3PrT/43t/7kf3PrL+g/tf7kf3PrT/43t/7kf3PrT/43t/7kf1Pr78n/5taf/G9u/cn/hta/8p684Mn/5tZf0H9q/cn/5taf/G9u/cn/5taf/G9u/cn/ptY/kP/NrT/539z6i23917JuIqXsKvqHlHdF892wQ1mPhh1C2kYd8k2jfHSwhE1PyXc8JH1gNG6je8Fo3I32gtG4qesFo3Fv1AtG4xajE4xivFO3gnFdtxmu8Qij8Ya3F4zG143NYEzLhjGVA4zGl197wShg/BbGsj1i4hIOMOJimmDExfwUo3MHGHExTTDiYr6FMaYNSMzLAUZcTAuMKy7mexjzNuhY5AAjLqYJRlzMtzBeVl62Ybh8gBEX0wSjgPGHGH08wIiLaYIRF9MEIy7mexjLNui8HD2pcTFNMOJivoUx7x/qfPSkjriYJhhxMd/DGMKGUfwBRlxME4y4mJ9iXA8SnihgbIERF/MtjMVtx5aj9jviYppgxMV8D2PYgBQ5WIuJuJgmGHEx38O4f4enxIMPdcLFNMGIi/kpxnQQTSRcTBOMuJhvYXTLun2lzC3xoAFPAsg2ICd2MuK3gVxwxOcgg8sbyODK3S+74tGowxJvc7z7TuTlvxwOe9m+JHQpbPfp6KtIE/ukfkSa2IX1I9LEHq8fkSZ2kN2IlCf2p/2INLH77Uekib11PyJN7Nz7EUkQyb5IJA4diETi0IFIJA4diETi0IFIJA72RSokDh2IROLQgUgkDh2IROLQgUiCSPZFInHoQCQShw5EInHoQCQShw5EInEwL5IsJA4diETi0IFIJA4diETi0IFIgkivEMn7/WjJFZGyi7cXyCy3o49fCSNp2X5MLsnd9jYIa/iQlHxiOElJM4aTlOxjOElJSoaTlFxlNEkd3rE7SfeNDi//jAeS0vH2Jmletl+dy+XwA0npePUltfJiU1duqt+9F3Z7sak4emmK5dvFQpdOsXy7WOj/KZbvFotnfZdi+XaxsM5MsXy7WMgsKJZvFwvr7hTLt4tFKBaK5bvFQs5KsXy7WEhwKZZvFwsJLsXy7WIhwaVYvl0sJLgUy3eLJZDgUizfLhYSXIrl28VCgkuxfLtYSHAplm8Xi1AsFMt3i4UEl2L5drGQ4FIs3y4WElyK5dvFQoJLsWzK+HBTXfxBsZDgUizfLRYhwaVYvl0s5CwUy7eLBTdEsWzKJLfJ6FNYDooFN0SxfLtYcEMUy7eLBTdEsXy3WFbcEMXy7WLh+ywUy7eLhe+zUCzfLhZyForl28UiFAvF8t1i4fssFMu3i4UE93vF4v22OV8IOVeKpZsvHaxkslPLT8o6tfzkpjPLH0lCp5afbHNq+Ukrp5af/HFq+QX5Z5afjHBq+Un9ppaf1G9q+Un9ppaf1G9m+ROp39Tyk/pNLT+p39Tyk/pNLb8g/8zyk/pNLT+p39Tyk/pNLT+p38jy+1w2HcNysFVHIvWbWf5M6je1/KR+U8tP6je1/KR+U8svyD+z/KR+U8tP6je1/KR+U8tP6je1/KR+M8tfSP2mlp/Ub2r5Sf2mlp/Ub2r5Bflnlp/Ub2r5Sf2mlp/Ub2r5Sf2mlp/Ub2L514XUb2r5Sf2mlp/Ub2r5Sf2mll+Qf2b5Sf2mlp/Ub2r5Sf2mlp/Ub2T5K69yWhdSv5nld6R+U8tP6je1/KR+U8tP6je1/IL8M8tP6je1/KR+U8tP6je1/KR+35Nfwi6/ZFeRP7hlP9rJHb8jIC7JBtuleHfw0avho2x1Fddwf+hVTUK8gdT0ZHJ9qbkLE+8eELuaRGydqblsOJaDzyaJ2TfVdOWmpq+ouS57u7Iuku7VvFInqNKgLlBXoE4so0GdNESDOiGEBnW8vwZ1PLoC9YCX1qCO59WgjjfVoI431aAuUG9PXUrJO/W1/O1pqiZr2VJsibJ8lQgja14iXK95ibDI5iXCT5uXCPNtXSLBqZuXCFtvXiIyAPMSERiYl0iQyJRE4atEpAvmJSJdMC8R6YJ5iUgXzEtEumBdolWQ6OcSxYpETvZvYTsJ+blEcZHtT8elLM8PdpcjtqMv/17jV0VpAEdTlH5xNEVpL0dTlG50NEVpXgdTNLKS1rWi5auiLLyNpijrdKMpyrLeaIoKig6mKJnRYIrmmZ+jS36g6BXNzA+kCpqZ7+wVNEPdIvMqO5q01NC4Zdv6xbl7kMvRPjHi9u3YRG53yHJ07As3enPlJsxSPh191XOoUB0981CROnrmoQJ19MxDxenoWYYK09GzDBWlo2cZKgBAzzJUaoGeRdBzKD3Jh8bSk3xoLD3Jh8bSk3xoLD3Jh0bSMy7kQ2PpST40lp7kQ2PpST40lp6CnkPpST40lp7kQ2PpST7UlZ4+b1+A9mHxB3qSD42lJ/nQUHo68qGx9CQfGktP8qGx9CQfGktPQc+h9CQfGktP8qGx9CQfGktP8qGx9CQfGkpPTz40lp7kQ2PpST40lp7kQ2PpKeg5lJ7kQ2PpST40lp7kQ2PpST40lp7kQ0PpGciHxtKTfGgsPcmHxtKTfGgsPQU9h9KTfGgsPcmHxtKTfKgrPZPbSPsUlgM9yYfG0pN8aCg9hXxoLD3Jh8bSk3xoLD3Jh8bSU9BzKD3Jh8bSk3xoLD3HyofK/qeLl4qeYf/LcjeM/P1DncQPiEOFMiVsHwpZYg1i9m47OvvVVUpXcaMtGSpoGVOjdajwZFCNhgpEBtVoqJBjUI2GCi4G1UjQyLxGQwUMg2o0VGgwqEZDBQGDakTOYF8jcgbzGkVyBvsakTPY14icwb5G5Az2NRI0Mq8ROYN9jcgZ7GtEzmBfI3IG+xqRM5jXKJEzqGtU+4FkImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCvUSZnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM9jXiJzBvkbkDPY1ImewrxE5g3mNCjmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZrGuUFnIGdY0qGwenhZzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8Rk4saXQdkqk25jok3ad2qFWyy3txuix5P1r8x/hT5+PPnY+/9D1+v3Q+ftf5+H3n4w+dj186H//a+fg7f/76zp+/vvPnr+/8+Rs6f/6Gzp+/ofPnb+j8+Rs6f/6Gzp+/ofPnb3j78ze4sL0pObiyVP62D36brRepxUW9bP6ZQga7BvYCdgXssoBdA7sDuwZ2D3YN7AHsGtgF7BrYV7BrYI9g18COS1XBjktVwY5L1cC+4lJVsONSVbDjUlWw41JVsAvYNbDjUlWw41JVsONSVbDjUlWw41Jfgb22/UXEpapgx6WqYMelqmDHpapgF7BrYMelqmDHpapgx6WqYMelqmDHpWpgT7hUFey4VBXsuFQV7LhUFewCdg3suFQV7LhUFey4VBXsuFQV7LhUDewZl6qCHZeqgh2XqoIdl6qCXcCugR2XqoIdl6qCHZeqgh2XqoIdl/oK7LWN6AsuVQU7LlUFOy5VBTsuVQW7gF0DOy5VBTsuVQU7LlUFOy5VBfv7Xar3YcPus69hd3HH7kPqBXvl58D5/a9lB/sv7A7sGtg92DWwB7BrYBewa2Bfwa6BPYJdA3sCuwb2DHYN7LhUDewOl6qCHZeqgh2XqoIdl6qCXcCugR2XqoIdl6qCHZeqgh2XqoIdl6qB3eNSVbDjUl+BvfKzguxxqSrYcakq2AXsGthxqSrYcakq2HGpKthxqSrYcaka2AMuVQU7LlUFOy5VBTsuVQW7gF0DOy5VBTsuVQU7LlUFOy5VBTsuVQO74FJVsONSVbDjUlWw41JVsAvYNbDjUlWw41JVsONSVbDjUlWw41I1sK+4VBXsuNRXYK9s0ZZXXKoKdlyqCnYBuwZ2XKoKdlyqCnZcqgp2XKoKdlyqBvaIS1XBruBSy3ZwCHdbg//629chib0hrfaG9PZeSJaw/W1Z1trn5dnR1wmk3ieQbU/glzv8ODrm5O7+8nX4pevhp6Xv4Tvjwy/L9kiKxacvw/d9Dz/0PXzpe/hr38M3/uStDd/4c7c2fOtP3crwrT91nw8/W3/qVobf91M39/3UzX0/dXPfT93c91M39/3UzX0/dXPfT93c91O39P3ULX0/dUvfT93S91P3/W8xbjt8809d2WOqsn4dvvmn7vPhm3/qPh+++afu8+Gbf+o+G35ZzD91nw//xY+t60XefnvzOWz327C4UPnba1nzx9Epu9u+vLkcrbmlvB0c8t2wQ1mPhi37K46dpNtCbD46OLh89/bku1XbeDTqsHi/Hy35NpAlWV5rDsu2nu6Dc5+OvhZLpFgolu8WS6JYKJbvFkumWCiWD2UqP8wp7389IsXSbbG8/6WOFEu/xeIoForlu8XiKRaK5bvFEigWiuW7xSIUC8Xy3WIhwaVYvl0sJLgUy7eLhQSXYvl2sZDgUizfLRZPzqJfLC7eimXJFfkllW3Yl3/eRhLW8CEpaUhvkub9biH3RG6Skll0J+m+I4Lk4A8kFSQdTVL8/3CS4tKHkxQvPZykON7hJOWbRd1JuqRdUr98lTTw/Z/hJCU9Gk5S0qPhJCU9Gk5SQdLRJCU9Gk5S0qPRJD1+J8plhvtZt+G7nD9OCmdOkjMnHd5EVrcV3OrDp5OOKui2OXPOd7vlbleIL79CevkV8suvUF59heNNvptewb38Cv7lVwgvv4K8/Aov/0zHl3+m48s/08fb6K77vg6rpK+3y+PtU9e0bwYhy8FJ6cyVjm85+/N3jXJw0vFdJG+Pv7WErycd7ytZO8mdOcmfOSmcOUnOnLSeOen4o7D3J2s50Ol4R7raSfnMSeX5SXE5mNPxnmdrKvtJ+eCkw4qIbqMXQzk4yVeudPR5Ot5Vq/IhPN7LqnbSmY/78dY7zq/bpJyPX1Ck5XjLm/pp7txp/txp4dxpcu609dxp8dxp6dxp+dxpD6okp/20uy927qe5pX5aPDjNnTvNnzstnDvtuEou9m07LXy98VxOW8+dFs+dls6dls+dVk6d5pdzp7lzpz3QLe5yhxQOTjsmeevx3CoHnwD/AEnZP2+yrF9PC0v9tIOPaXDnTvPnTgvnTovnTjsmeR/EBPf1NFnOnXZMUuKynxYPbgoiD067zS0tB6c9mNv+VfhLEHRQk+ty7jR37rTjKpEi+ydgOZjbcTpUP03OnbaeOy0++HTvuq3+4GO6pnOn5XODLKdOi8u509y50/yp++RxklE/Tc6dtp47LZ+6c8Vzd6507s6V3JnT3PH6zOq3qa1f3wl3OSmeOSmdOSmfOamcOOn4gVE7yZ05yZ85KZw5Sc6cdKYi5LgiytZcxbulldtJ6cxJ+cxJ5cRJx4/Z2knuzEn+zEnhzEly5qT1zElnKmI9UxHrmYp48Ci4LcK5y9Pi4LR47rTjhuHiVLbT7pf8bqflc6eVU6c9ePBUTzt+8Li4I3H5AEl64MfKzY+Vo6ut506L505L507L504rp07Ly7nTjnVb/XJrhtLBaf7caeHcaXLutPXcafHcaencacdVst5M45rLwWnl1GnHcXn9NHfuNH/utHDuNDl32nrutEfh2n5a8Aeft5LPnVbOnOaX5dxp7txp/txp4dxpcu609dxp8dxp6dxp+dxpD6pkX769GL2vtyD/IKivnubOnebPnRbOnSbnTlvPnXaqwfAunTstnzvtVIPhH/xO//mb4y+nHQsQb1lqTEdXW8+dFs+dls6ddixAStvvvy7NnD84rZw67cGyQPU0d+40f+60cO40OXfaeu60eO60dO60c1USzlWJnKsSOVclcq5K5FyVPFhgKbfHYvFHp63nTjv+5W122/eafI5336I9/KpwDnvymsPdmtHx0ZVv6F6GVMwN6Tgf0x2Sszckb29Iwd6QxN6QVntDivaGlOwNyd7de21x9/b7dzyzuFQ7+oe7r+3vz5Hk/NcJxKX3CbjeJ+B7n0DofQLS+wTW3icQe59A6n0CufcJ9P4kTr0/iVPvT+LU+5M49f4kTr0/iZP558DT3ZiTz9bvQjVHlt9/F7KyefplTX+bo1++rm/77EHzCE0AzSM0AppHaFbQPEITQfMITQLNIzQZNI/QFNA8QFMW0DxCQzf8EA3d8EM0dMMP0QhoHqGhG36Ihm74IRq64Ydo6IYfoqEbfoAmLHTDD9HQDT9EQzf8EA3d8EM0Mi0aH25oxB+gmbcbrqKZtxuuopm3r6mhcfM+oSo/yAtu3idUFc28T6gqmnmfUFU08z6hqmjmzWuqaObNa6po5u1ramj8vHlNFc28eU0VzWE3fAn/th9AX7x5rkzWuej2X2e76GtwvN93Q7t06+vt6OA/BhVaDGq97Vvr4t2rMzrPSo53zQDOFc4KnMdwInAew0nAeQwnA+cxnAKch3COdyYCzhWOA85jOB44j+HQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75MRyhQ34Chw75CRw65Cdw6JCfwBHgPIYzc4fs8zZLH5aDb0/JzB1yFc7MHXIVzswdchXOzB1yDc46c4dchTNzh1yFM3OHXIUzc4dchSPAeQyHDvkJHDrkJ3DokJ/AoUN+AocO+TGcSIf8BA4d8hM4dMhP4NAhP4EjwHkMhw75CRw65Cdw6JCfwKFDfgKHDvkxnESH/AQOHfITOHTIT+DQIT+BI8B5DGfmDrn2q9w0c4dchTNzh1yFM3OHXIUzc4dcg5Nn7pCrcGbukKtwZu6Qq3Bm7pCrcAQ4j+HMu3lY2F+P6INzB2jm3TysimbezcOqaCbeFLXixid+9VEVzbybh1XRzLuVbhXNvFvpVtEIaB6hmXiz9xqaiTd7r6GZtxuuopm3G66ioRt+gEYUXmLzs5fXp7KhufzzNt3t5fWi8KqZn00g75Vw+Wc5mIBYn4AP+wSCP5jA2vsEYu8TSL1PIPc+gdL5BNxifQJL2ifgl4MJuN4nYP1JXJ2A+SdxbQLmn8S1CZh/EtcmYP5JXJuA+SdxZQLHOwIl2UaUJH41Ecf7ndxMTVnzwUnlxEnH+2PUTnJnTvJnTgpnTpIzJx3q5Jb9dRNuievBafHcaencafncaeXUace/DK2f5s6d5s+dFs6dJudOO1cl8VyVHP9kpXLvOP4pR9lvU8UfnJTO3AaOv8Bdu5KcOWk9c1I8c1I6A+LM7TqduV0ff9GuxK0iSjooo+MvoNVO8mdOqt2uD086c7vO65mT4pmTzlREPlMR+UxFlDOf3HLmAV7OPMDLmQd4+WlF/O3yX//ff/jPv/zDP/71X/7rcsqv//d//u2f/vsv//5vH//1v/+//9j+n3/8z7/89a9/+de//4///Pd/+pd//p///Je//+u//9Ov/+9Py8d//J+0FPfn5Jy/DOcXqsstN/z50mG5y38Pv/3/Kf05LTn9+v9/nSC/GtJfmcCv/+G3M5xfL3/Bp8vYLuP7/wE=",
      "brillig_names": [
        "get_amount_in_for_exact_out"
      ]
    },
    {
      "name": "_remove_liquidity",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "config",
            "type": {
              "kind": "struct",
              "path": "config::Config",
              "fields": [
                {
                  "name": "token0",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "token1",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "liquidity_token",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token0_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token1_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13588333240659585881": {
            "error_kind": "string",
            "string": "INSUFFICIENT_1_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14258647237672879755": {
            "error_kind": "string",
            "string": "Function _remove_liquidity can only be called internally"
          },
          "17059742737981442965": {
            "error_kind": "string",
            "string": "INSUFFICIENT_0_AMOUNT"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_remove_liquidity"
      ]
    },
    {
      "name": "_add_liquidity",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "config",
            "type": {
              "kind": "struct",
              "path": "config::Config",
              "fields": [
                {
                  "name": "token0",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "token1",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "liquidity_token",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "refund_token0_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "refund_token1_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14234046914994891820": {
            "error_kind": "string",
            "string": "AMOUNT_0_BELOW_MINIMUM"
          },
          "15854867267750979296": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY_MINTED"
          },
          "16715174358392770615": {
            "error_kind": "string",
            "string": "Function _add_liquidity can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18164859091538951175": {
            "error_kind": "string",
            "string": "AMOUNT_1_BELOW_MINIMUM"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_add_liquidity"
      ]
    },
    {
      "name": "get_amount_out_for_exact_in",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "balance_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "balance_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3djuw6dqX7LnVdFyI5xZ9+lcaBYbvdjQIKdsN2H+Cg4Xc/sVakFJE7FcFMbUbMSfK7KayqklLkN2ZIcwxGUP/3L//jX/7p//yvf/jbv/7Pf/uPv/y3//5///L3f/vnf/zPv/3bv17+2//9r7/+5Z/+/W9///vf/tc/3P/Pf1l+/Yfz8vuE//jf//ivv/77f/znP/77f/7lv7lFXPjrX/7lX//H738nf/kj//Nvf/+Xv/y3kv7rr18OTzl+HJwX2Q+NcnDo6tePQ9d12Q91ofzX//PXy2jWBqPJIW2jWcvz0UgoH4dKzF9HE1uMJss2mpKfjyYuG5vo49fRpAajKd5/HFzCWhlNXj4OTcuBUvlwNCEvG/zLkTE+H40vi/s4Oiz3B39co7z+GmF5wzXcG67h33CN8IZryBuusb7hGvEN10hvuMYbPufhDZ9zecPnXN7wOZc3fM7lDZ9zecPnXN7wOZc3fM7lDZ9zecPnXN7wOV/f8Dlf3/A5X9/wOV/f8Dlf3/A5X9/wOV/f8Dlf3/A5X9/wOV/f8DmPb/icxzd8zuMbPufxDZ/z+IbPeXzD5zy+4XMe3/A5j2/4nMc3fM7TGz7n6Q2f8/SGz3l6w+c8veFznt7wOU9v+JynN3zO0xs+5+kNn/P8hs95fsPnPL/hc57f8DnPb/ic5zd8zvMbPuf5DZ/z/IbPeX7D57y0+JyHZY37NX4dsS1OLP56EfeOi/h3XCS84yLyjous77hIi097uKyjbRfxvny6yNejL8nANqSLYfR3R8ejBce8Ldat4TaMSzJ2HX56//Dzvuh4eT7myvDXmPbl25jDfvQaruPPnY+/dD1+vyydj991Pn7f+fhD5+OXzse/dj7+2Pn4+37++sX88zfJ1iytaZX78R84iXX/ZpNfk3t+cF63YeR011iFQ4vi9m+I+cti3n60HE3Q55ud+XTob+DmG4bBgDvzHc5owM23ZKMBN99DjgbcfNM7GnAB+HuBm7cVowE374NGA27euI0GHKf5ZuA4zfcC9zjNNwPHab4ZOE7zzcBxmm8GLgB/L3Cc5puB4zTfDByn+WbgOM03A8dpvhd4wGm+GThO883AcZpvBo7TfDNwAfh7geM03wy8A6fpbsDzc4Yu7z8kccWHyp92UrZ94tx6t8Xax9cuQweeUAtNB+5NC00HPksJjXTgiLTQdOBdtNB04DK00HTgB7TQCGgeoemgx9ZCQzf8EA3d8EM0dMMP0dANP0Kz0g0/REM3/BAN3fBDNHTDD9EIaB6hoRt+iIZu+CEauuGHaOiGH6KhG36EJtINP0RDN/wQDd3wQzR0ww/RCGgeoaEbfoiGbvghGrrhh2johh+ioRt+hCbRDT9EQzf8EA3d8EM0dMMP0QhoHqGhG36Ihm74IRq64Ydo6IYfoqEbfoQm0w0/REM3/BAN3fBDNHTDD9EIaB6hoRt+iIZu+CEauuGHaOiGH6KhG36EptANP0RDN/wQDd3wQzR0ww/RCGgeoaEbfohm4m74MvkNTVjcUgWZZAfp7v52PhpJXPLHwdHHu2OvO3nYf8vokNQn7uEVqU9sD9SoB/vvoR2S+sSmRpH6xH5JkfrEVkyRukBdgfrEBlKROt5UgzreVIM63lSDOt5UgXoPbxB/FfVL25x26qU2EOeS3/+4K8v9Xy+vVmliL9uRShN7345Umtgrd6SSoFIHKk3sxTtSaWLv3pFKE3v9jlSaOBvoSKWJs4R+VOrhnfKo1MOL6FGph7fXo1IPr7xHJS+o9E2V/LJuI3H+MuOKSv6i6sfh3uU7KHk9Ojot+9HJ374uHa8qkT30oBLZQw8qkT30oBLZQw8qkT10oFIge+hBJbKHHlQie+hBJbKHHlQSVOpAJbKHHlQie+hBJbKHHlQie/i2SiHnXSWR2sqFj/tYfIzr7eiyHCL02x8Pbr07Ouejo0PaRx5K+HT0b1XJKgZUVcg2RlSVLGREVclORlSVrGVEVQVVB1SVLGdEVcl+RlSVrGhEVcmWRlSVbGlAVVeypRFVJVsaUVWypRFVJVsaUVVB1QFVJVsaUVWypRFVJVsaUVWypRFVJVsaUNVItjSiqmRLI6pKtjSiqmRLI6oqqDqgqmRLI6pKtjSiqmRLI6pKtjSiqmRLA6qayJZGVJVsaURVyZZGVJVsaURVBVUHVJVsaURVyZZGVJVsaURVyZZGVJVsaUBVM9nSiKqSLY2oKtnSiKqSLY2oqqDqgKqSLY2oKtnSiKqSLY2oKtnSiKqSLQ2oaiFbGlFVsqURVSVbGlFVsqURVRVUHVBVsqURVSVbGlFVsqURVSVbGlFVsqXxVJWFbGlEVcmWRlSVbGlEVcmWRlRVUHVAVcmWRlSVbGlEVcmWRlSVbGlEVcmWBlTVkS2NqCrZ0oiqki2NqCrZ0oiqCqoOqCrZ0oiqki2NqCrZ0oiqki2NqCrZ0oCqerKlEVUlWxpRVbKlEVUlWxpRVUHVAVUlWxpRVbKlEVUlWxpRVbKlEVUlWxpQ1UC2NKKqZEsjqkq2NKKqZEsjqiqoOqCqZEsjqkq2NKKqZEsjqkq2NKKqZEsDqipkSyOqSrZkQ1Uv644w11SVsqu6Lkv5qirZ0oiqki2NqKqg6oCqki2NqCrZ0oiqki2NqCrZ0oiqki0NqOpKtjSiqmRLI6pKtjSiqmRLI6oqqDqgqmRLI6pKtjSiqmRLI6pKtjSiqmRLA6oayZZGVJVsaURVyZZGVJVsaURVBVUHVJVsaURVyZZGVJVsaURVyZZGVJVsaUBVE9nSiKqSLY2oKtnSiKqSLY2oqqDqgKqSLY2oKtnSiKqSLY2oKtnSiKqSLQ2oaiZbGlFVsqURVSVbGlFVsqURVRVUHVBVsqURVSVbGlFVsqURVSVbGlFVsqUBVS1kSyOqSrY0oqpkSyOqSrY0oqqCqgOqSrY0oqpkSyOqSrY0oqpkSyOqSrY0nqqX/w1VB1SVbGlEVcmWRlSVbGlEVQVVB1SVbGlEVcmWRlSVbGlEVcmWRlSVbGlAVR3Z0oiqki2NqCrZ0oiqki2NqKqg6oCqki2NqCrZ0oiqki2NqCrZ0oiqki0NqKonWxpRVbKlEVUlWxpRVbKlEVUVVB1QVbKlEVUlWxpRVbKlEVUlWxpRVbKlAVUNZEsjqkq2NKKqZEsjqkq2NKKqgqoDqkq2NKKqZEsjqkq2NKKqZEsjqkq2NKCqQrY0oqpkSyOqSrY0oqpkSyOqKqg6oKpkSyOqSrY0oqpkSyOqSrY0oqpkSwOqupItjagq2dKIqpItjagq2dKIqgqqDqgq2dKIqpItjagq2dKIqpItjagq2dKAqkaypRFVJVsaUVWypRFVJVsaUVVB1QFVJVsaUVWypRFVJVsaUVWypW+rGhe3q5o+Dbwc/vXidij3qj6ogbxsNZBcqR3tl7Id7X36dPRvVcmWBlQ1kS2NqCrZ0oiqki2NqCrZ0oiqCqoOqCrZ0oiqki2NqCrZ0oiqki2NqCrZ0oCqZrKlEVUlWxpRVbKlHlWVELajJdfWBKP4j4NjvFVAiEezLLfVxuVuGMcHR7cfHf26VI52ycW9qC5zDLW/Xnbesbi70j1am8yXtdGPg7OP/v7g32VO2EaZT1DmQplT5uOXOXEsZT5BmZNPU+YTlDmBPWU+QZmzgkGZT1DmLOlQ5uOXeWGNizKfoMxZ9KPMJyhzVkEp8wnKnFVQynyCMhfKnDIfv8xZBaXMJyhzVkEp8wnKnFVQynyCMmcVlDKfoMxZBaXMhy/zuLAKSplPUOasglLmE5Q5q6CU+QRlziooZT5BmQtlTpmfLXO/pr3Mc+1Puxz3Uf/6t3w6/ncxslZJMZopRlYUKUYzxci6H8VophhZnaMYzRQja2gUo5VidKx0UYxmipH1KIrRTDGyakQxmilG1nYoRjPFKBQjxWilGFmBoRjNFCMrMBSjmWJkBYZiNFOMrMDYKMa0f7nq8s/PR//WicWJLnTy5PZ96ESk3YdOpL196EQQ2odOgk5d6ER81odOJEt96ETo0odO5BF96EQe0YVOgTyiD53II/rQiTziuzqFkPzORFZfIe8ug9nXKlxOt986x0OdFr/r5P3dsb9VIo3oQSVBpQ5UIon4rkqypH3c4iRVVIrLbWuHGz+X/ZU7yYIOd5ICHe44fx3uOHkV7oIz1+GO09bhjnPW4Y4X1uEucFfhjl/V4Y5f1eGOX9Xhjl/V4Y5f/Tb3C6yde6z+aMWHtIH3odytfeWfp8Yr7rYHlfDCPaiEc+5BJXx2DyoJKnWgEh6+B5Vw/D2oRD7Qg0qkCT2oRPbQgUqR7KEHlcgeelCJ7KEHlcgeXqWSuH2TKJHlk0q/yQvklciTEWiRx/drkcfLa5HHn2uRx3MrkU/4aC3yeGMt8vhdLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyGQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRL7gYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYXXIpwUPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te4WG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyHs8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBL5gIfVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4dVIi94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyKx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5Wi/zMHjbITj6kWDs65g18SGG9OzpfSc7sSduSnNljNiUZZ/aMbUnO7AHbkpzZ07UlObNHa0tSINmI5Mweqi3JmT1RW5J4nFYk8TitSOJxGpFMeJxWJPE4rUjicVqRxOO0IimQbEQSj9OKJB6nFUk8TiuSeJxWJPE4jUhmPE4rknicViTxOK1I4nFakRRINiKJx2lFEo/TiiQepxVJPE4rknicRiQLHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOG5J5weO0IonHaUUSj9OKJB6nFUmBZCOSeJxWJPE4rUjicVqRxOO0IonHaUTS4XFakcTjtCKJx2lFEo/TiqRAshFJPE4rknicViTxOK1I4nFakcTjNCLp8TitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJxGpEMeJxWJPE4rUjicVqRxOO0IimQbEQSj9OKJB6nFUk8TiuSeJxWJPE4jUgKHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5IrHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5IRj9OKJB6nFUk8TiuSeJxWJAWSjUjicVqRxOO0IonHaUUSj9OKJB6nEcmEx2lFEo/TiiQepxVJPE4rkgLJRiTxOK1I4nFakcTjtCKJx2lFEo/TiGTG47QiicdpRRKP04okHqcVSYFkI5J4nFYk8TitSOJxWpHE47QiicdpRLLgcVqRxOO0IonHaUUSj9OKpECyEUk8TiuSeJxWJPE4rUjicVqRxOO0IVkWPE4rknicViTxOK1I4nFakRRINiKJx2lFEo/TiiQepxVJPE4rknicRiQdHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5Iej9OKJB6nFUk8zjdJSlj8x9ES1viJ5MFIJG1I3OruRpKPxh2X/HFw9Hd/OfurRrgn+xoJGpnXCMdnXyO8pH2NcKn2NcL/2tcIZ21eo4Bnt68RaYB9jcgZ7GtEzmBfI0Ej8xqRM9jXaOqcIW9HB/Hrp6N/s5na31fYTO2rK2ym9rPP2cjUPrLCZmr/VmEztW+qsJnar1TYCGwespm6P6+woS9+zIa++DEb+uLHbOiLH7JZ6Ysfs6EvfsyGvvgxG/rix2wENg/Z0Bc/ZkNf/JgNffFjNvTFj9nQFz9kE+mLH7OhL37Mhr74MRv64sdsBDYP2dAXP2ZDX/yYDX3xYzb0xY/Z0Bc/ZJPoix+zoS9+zIa++DEb+uLHbAQ2D9nQFz9mQ1/8mA198WM29MWP2dAXP2Qz97veK2zoix+zoS9+zIa++DEbgc1DNvTFj9nQFz9mQ1/8mA198WM29MUP2cz9fvAKG/rix2zoix+zoS9+zEZg85DNzH2xhBub6r4YLm17V/jl9pd9Xg6OzTuPHErl2LILVMrnY3/rM3Nv3oM+M/uDHvSZ2aP0oM/MPsm+Pm6Z+kXnXQg0s2PsQqCZbWsXAs3snbsQSBDItkCkCMYFIkYwLtDUOULe96fN4moC+bzvOBuC3B19iGR1u/jrL2Hujr6Cnzog0AQ/tfNXBO+mdvSa4Kd26prgp3bgmuCndtaa4AXwOuCndsKa4Kd2uJrgca5K4HGuSuBxrjrgPc5VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB3zAuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqAF5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDvgV56oEHueqBB7nqgQe56oEXgCvAx7nqgQe56oEHueqBB7nqgQe56oDPuJclcDjXJXA41yVwONclcAL4HXA41yVwONclcDjXJXA41yVwONcdcAnnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+IxzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QFfcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca4q4N2Cc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UB73CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuA9zlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHfMC5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce56oAXnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+BXnqgQe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgM+4lyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41x1wCecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74jHNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAV9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrirg/YJzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QHvcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464D3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQd8wLkqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgBecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74FeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqAz7iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAJ5yrEnic60vAi0/l42gJq68c7STtf3t1d+POR7OMS/44OPp4d6z/kBRPPJykuO3hJBUkHU1SEoLhJCV7GE5SUo3hJCUvGU5SkpjRJM1kPMNJSno0nKSkR8NJSno0nKSCpKNJSnr0XUnDPhAXl1ARyftl+TjaS/gs6RU8GY8SeJIYJfDkJUrgSTV0wBeyByXwJARK4PHxSuBx20rgBfA64HGuSuBxrkrgca5K4HGuSuBxrirgw4JzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QHvcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464D3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQd8wLkqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgBecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74FeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqAz7iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAJ5yrEnicqxJ4nKsSeJyrEngBvA54nKsS+Jmda1538GWRT0df4czsLqtwZnaAVTgzu7QanDyzk6rCmdntVOHM7EiqcGZ2DVU4ApzHcGbuvqtw6JCfwKFDfgKHDvkJHDrkx3AKHfITOHTIT+DQIT+BQ4f8BI4A5zEcOuQncOiQn8ChQ34Chw75CRw65IdwZKFDfgKHDvkJHDrkJ3DokJ/AEeA8hkOH/AQOHfITOHTIT+DQIT+BQ4f8GI6jQ34Chw75CRw65Cdw6JCfwBHgPIZDh/wEDh3yEzh0yE/g0CE/gUOH/BiOp0N+AocO+QkcOuQncOiQn8AR4DyGQ4f8BA4d8hM4dMhP4NAhP4FDh/wYTqBDfgKHDvkJHDrkJ3DokJ/AEeA8hkOH/AQOHfITOHTIT+DQIT+BQ4f8GM7U7xCvwqFDfgKHDvkJHDrkJ3AEOI/h0CE/gUOH/AQOHfITOHTIT+DQIT+GM/W7iqtwZu6Qi1t3OLF2tEv542B/t+upz8vBsXnnkUOpHFvyNuRSPh97FWjmLr0LgWZ2Cl0IJDMLlLZhi5OlcrRPwW8KpXJ/tBxJdOk7No28i5+OvoKf2Qmpgp/ZZamCn9nBqYKf2R2qgp/ZeWqCn/o9xqrgp3bMmuCndsKa4Kd2uJrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgp36PsSp4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74qd8brQoe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgN+6ve5q4LHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce5qoBfF5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDniHc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UB73GuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuADzlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHvOBclcDjXJXA41yVwONclcAL4HXA41yVwONclcDjXJXA41yVwONcdcCvOFcl8DhXJfA4VyXwOFcl8AJ4HfA4VyXwOFcl8DhXJfA4VyXwOFcd8BHnqgQe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgM+4VyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41x1wGecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74gnNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3NVAR8XnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsOeIdzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QHvca5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464APOVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQe84FyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41x1wK84VyXwOFcl8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wEeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqAz7hXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAZ5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviCc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc1UBnxacqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw54h3NVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAe9xrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgA85VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB7zgXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXAT+xcxe1Hiyvx09FXOBO7yzqciR1gFc46sUurw5nYSdXhTOx26nAmdiR1OAKcx3Am7uzrcCbuvutw6JCfwKFDfgKHDvkxnEiH/AQOHfITOHTIT+DQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75MZxEh/wEDh3yEzh0yE/g0CE/gSPAeQyHDvkJHDrkJ3DokJ/AoUN+AocO+TGcTIf8BA4d8hM4dMhP4NAhP4EjwHkMhw75CRw65Cdw6JCfwKFDfgKHDvkxnEKH/AQOHfITOHTIT+DQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75IZy80CE/gUOH/AQOHfITOHTIT+AIcB7DoUN+AocO+QkcOuQncGbukMWFDU5yywGcmTvkGpyZ309ehzNzh1yFM3OHXIUzc4dchSPAeQxn5g65CmfmDrkKZ+YOuQqHDvkJHDrkx3Bmfg9yHQ4d8hM4dMhP4NAhP4EjwHkMhw75CRw65Cdw6JCfwKFDfgKHDvkxnJnft1qHQ4f8BA4d8hM4dMhP4AhwHsOhQ34Chw75CRw65Cdw6JCfwKFDfgxn5vc61uHQIT+BQ4f8BA4d8hM4ApzHcOiQn8ChQ34Chw75CRw65Cdw6JAfw5n6nXpVOHTIT+DQIT+BQ4f8BI4A5zEcOuQncOiQn8ChQ34Chw75CRw65Idwiv2APabt6DXmcA/n9wQ6CMGXm7pL/DqBJs2UD1tVhJByZQIhlmU7Ot8N6ULhY0xicEyrwTFFg2NKBseUDY6p2BtTm7yi8ZicwTF5g2MyeB9fDd7HV4P38dXgfXw1eB9fDd7HV4P38WjwPh4N3sejwft4NHgfjwbv49HgfTwavI9Hg/fxaPA+Hg3ex5PB+3gyeB9PBu/jyeB9PBm8jyeD9/Fk8D6eDN7Hk8H7eDJ4H88G7+PZ4H08G7yPZ4P38WzwPp4N3sezwft4Nngfzwbv49ngfbwYvI8Xg/fxYvA+Xgzex4vB+3gxeB8vCvfxnPajy+IOxpQMjikbHFOxNia/LIvBMTmDY/IGxxQMjkl0x+T8wZgU7uN5/7ZXKH75NKavR+f9O0853L7y5PNycOylk/849nI/+XTsda5xormmieaaJ5prmWeubplorm6iufqJ5hommqtMNNeJ+iY3Ud/kJuqb3ER9kxuqb4rbsW5Z/NfJ+qEap9pkh+qcapMdqnWqTXao3qk2WZlpsgrdU/Fpn+yaKpN9/nu+ywRi7xNIvU8g9z6B0vkEwtL7BFzvE/C9TyD0PgHpfQK9P4lD7w+yYP5B9nRrAL882MPWrWvZJuDWJLcucD24iF/yx8H3Oxus7uMS/vWXCK+/hLz+EmuLS6TNFviyfr1EbHCJsOxf5bnbHWS/RGoyC79fQr5eIr/+EuXll3jwS/yml2jx6U5+u0SSrxW1+tdfIrz+EvL6S6yvv0R8/SVafLpT3J5gqXy9Da759ZcoL79EXF5/Cff6S/jXXyK8/hLy+ku0+HRnvz27s+Svl4ivv0R6/SXy6y9RXn6JtLz+Eq7tJeLXok3+9ZcIr7+EvP4STT7du5XM5UDu3p1kMh+JJn+bgE9fJpDNR6K1CZiPRGsTMB+J1iZgPhKtTUDMT0DiPoFV7idwYI5lH4gXka+zNZ+fNp2t+WXPprM1Hy03na397qHlbO23Gg1nW+z3JS1na7+JaTlb+x3Pj2br8222Xy1Csd8etZytTDXbsXqpdd36ZL/G8PzguOwLYnFxBx/ysRqvn6BZSypP0YzVpa37dzL9mtzzg/MS9/Tv7nUAIX2QGauja0lmrO6vHRm3jNUptiQzVlfZksxYHWhLMoN1ND8hs+5LFSl+InPwhy//8/aH3Xr7w3I0QZ+33iEsnw69Eh+sUeqA+MT9lxLxifs6JeIT94s6xN3EfagS8Yn7WyXiE/fNSsTHSo97IC4QfzNxPOe7ieM5300cz/lu4njONxO3v0ODDeJL8Tvxu+8UHxLPeRvEp81wD/+wu1x7+8uXf6e7bUzK+iERHwrzEpHcWJfI/j4iSEQ2ZF4iwiTzEpE+mZdIkMi6RORb5iUiEDMvEemCeYlIF8xLRLpgXSIhXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iVbSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXKJIumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEiXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iXKpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC9YlKgN/ivLzg1Pcjk3pE/QrmIFr98+BGTiP+jNg/NJBCuRuYCpzffanr9PtIFFpOd0O0omW0+3A6becrsw13Q4caMvpduDmvj9dWUL5OFiWUip/OsjeAgbJd8OW8gGngw5QD04HXaAenA46QTU4bqhusDWcoXrH1nCG6jRbwxmqL20NR4DzGM5QPW9rOHTIT+BM0yFfpztNz3ud7jRd7O/p+mn60ut0p+k0r9Odpne8TnesbtDtCxcSnFT+dF7k4+Acbmh8Xg6OLXn7w6V8PvaKUcDYAuNYHaYaxrF6UTWMY3WtahjH6obVMI7VZWthDGN172oYx3IFahjHchtqGHExTTAKGFtgxMU0wYiLaYJxsL7RbUsN4vxBoNXDG9xbTnewPqw23cH6pdp0B+tratOVuaY7WJ9Qm+5gz/PadAdLD2vTHSzlq013rq6qhzfXtpzuXF1VD29UbTndubqqHt702XK6c3VVPbyBsuV05+qqengzYsvpztVV9fDGvpbTnaur6uFNci2nO1dX1cMbzlpOd66uqoc3b7Wc7lxdVQ9vhGo53bm6qh7eVNRyunN1VT28QafldOfqqnp4s0vL6c7VVfXwxpGW052rq+rhTRgtpztXV9XDGxpaTneurqqHNwe0nO5cXVUPO9q3nO5cXVUPO623nO5cXVUPO4C3nO5cXVWZq6sqc3VVZa6uqszVVRWZa7pzdVVlrq6qh7dYtJzuXF1VD2+caDfdMNZ7JOrTnaqrCmO9R6I+3am6qrDIXNOdqqsKg71HojrdqbqqMNi7HqrTnaurGux9DNXpztVVDfbOhOp05+qqBnuvQXW6c3VVg717oDrdubqqwd4mUJ3uXF3VYG8TqE53rq5qsLcJVKc7V1c12q7/tenO1VWNtot+bbpzdVWj7Upfm+5cXdVou7zXpjtXVzXarum16c7VVY22C3ltunN1VaPt6l2b7lxdVZirq5prb/Uw197qYa691cNce6uHufZWD3PtrR7m2ls9zLW3ephrb/Uw197qYa691cNoe6u/7D1HcTvWLb9mdXfwlSOvJGzDkXcStuHISwnbcBQ4NuHIawnbcJzmteDX6U7z+u7rdKd5zfbv6Y62BX1tutP0iNfpTtPKXac7Tcd1na7MNd1p+pfrdKd5/fF1unN1VaNtQV+b7lxd1Whb0NemO1dXNdoW9LXpztVVjbYFfW26c3VVo21BX5vuXF3VaFvQ16Y7V1c12hb0tenO1VWNtgV9bbpzdVWjbUFfm+5cXdVoW9DXpjtXVzXaFvS16c7VVY22BX1tunN1VaNtQV+b7lxd1Whb0NemO1dXNdoW9LXpztVVjbYFfW26U3VVMtoW9LXpTtVVyWhb0NemO1VXJYvMNd2puioZbQv62nSn6qpktC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurmmcL+ut05+qq5tnQ/TrdubqqebZHv053rq5qnaurmmtvdZlrb3WZa291GWxv9RjKNt28hMqf/tELF/I2w1I+H3vFOFa3poZxrC5QDeNY3eXrMD5/i4oMtnm9Hsex+mE9jmM12nocx+rg9TiOZQ30OI7lOfL+pyVLjWOK4ePglG4zFH8lM9hLClqSGctxtCQzlol4QuY63bGa/ep0Za7pDtU6r07W7WAXD+KosV59UJ/uUI1ofbpD9Yv16Q7V1lWnO9arD+rTHaoBq093qK6qPt2huqr6dGXU6XrnD6Y7bFd1PN1hu6rj6Q7bVR1Pd9iu6ni6w3ZVh9Md69UHa3JpPziXg+mO1VVVpztWV1Wd7lhdVXW6Mtd0x+qqqtMdq6uqTnesrqo63bG6qup0x+qqKtNdx3r1QX26U3VV61ivPqhPd6yuKodlO7jEXPnTl8fSHmzd5VqpHBzr0+I/DvbJ37xW/MAoYGyBcawuUA3jWN1lI4xXNGN1ok3RjNW1NkUzVofbEs1Yr6xoi2aszrkpmrG67B+huWT128GSD9BM3JHX0AhoHqGZuHOuoZm4G66hmbgbrqGZuBuuoZm4G66gGetVI23RTNwNr+veDeeDbnisV5i0RTNzN1xBI6B5hGbmbriCZuZuuIJm5m64gmbmbriCZuZu+DmasV4R0xYN3fBDNNN0w9fpTtPhXqcrc013mk70Ot1pusvrdKfpGK/THaoLjMuyDSSG6A6mO1RnV53uWK+eqU93qA6sPt2huqr6dIfqqurTlbmmO1RXVZ/uUF1VfbpDdVX16c7VVY316pnqdMd69Ux9unN1VWO9eqY+3bm6qrFePVOf7lxd1VivnqlPd66uaqxXz9SnO1dXNdarZ+rTnaurGutVLvXpztVVjfVmlPp05+qqxnrPSH26c3VVY721oz7dubqqsd6YUZ/uXF3VWO+2qE93rq5qrHdb1Kc7V1c11rst6tOdq6sa690W9enO1VWN9W6L+nTn6qrGerdFfbpzdVVjvduiPt25uqqx3m1Rn+5cXdVY77aoT3eurmqsd1vUpztXVzXWuy3q052rqxrr3Rb16c7VVY31bov6dOfqqsZ6t0V9ulN1VXGsd1vUpztVVxXHerdFfbpTdVVxkbmmO1VXFcd6p0N9ulN1VXGsdy/UpztXVzXWOxLq052rqxrrXQb16c7VVY31zoH6dOfqqsZ6N0B9unN1VWPt4V+f7lxd1Vh77denO1dXNdae+PXpztVVjbV3fX26c3VVY+0xX5/uXF3VWHvB16c7V1c11p7t9enO1VWNtbd6fbpzdVVj7a1en+5cXdVYe6vXpztXVzXX3upxrr3V41x7q8e59laPc+2tHufaWz3Otbd6nGtv9TjX3upxrr3V41x7q8e59laPc+2tHufaWz3Otbd6nGtv9TjX3upxrr3V41x7q8e59laPc+2tHgfbW13ydvClo/BfpzvY3uoh7epeTqz86bzIx8E5lP1Yn5eDY0ve/nApn4+9YhyrW1PDOFYXqIZxrO5SDaOAsQXGsbphNYxjddlqGMfq3tUwjuUK1DCO5Ta0MA72LgM1jLiYJhhxMU0w4mKaYBQwtsCIi2mCERfzPYxxO9Ytiz/giI1pwxEf04YjRqYJx8HeH6LHESvThqMMxXHNZeMYXY2jW8sStlmuxYX9+PgBZ6yH8BM41+mO9aysTneoR1pKaTs4pbvO/PhP+xTXj6N9SuH+T/9mM9YLGRqzGerR05jNUNFYYzZD5V2N2QhsHrIZKplqzGaouKkxm6G615+yKX5jk++av53NUK1uYzZT98VP2aSxXqnxMzbBL5uhCt6nr2wm7ourbCbui6tsJu6Lq2xkajbLUzYT9zdB3HZ0EL98ZTNxf1NlM3F/U2Mz1sstGrOZub8JJe9s3PL8T68lbQ+1tZSvN+6x3rHxQpBx2Z+AcTlwI2O9veM9FXkMUma+7YW9BZXV/cmP9sRZ5VmQxxU5cbAZZP82RJCSv7KZuvGvsJm68a+wmbrxf85mrPevnGez3n1Jamczc+NfYzNzL19jM3N7XmMjM1uX20BWl57/aRfz5gFdkrsdXkL6IDlzp5j27W9CKuHPeZex3vzyQpC1WGKsd8q8pyKPQc7csN7+dPjDSvzBTXIp+xe5XVi+3iTHehHOD0lmLzvJUvnTsgMR//lhc0D9FsG5S3a+Hx126jM3znrUZ27J9ajP3OzrUReoK1CfOeXXoz6z0dOjPrMr/BH1sJlCuZ/hznFmU9iQ42Avn2r6g9002KuqGsMZa9uqxnDG2oyqMRwBzmM4Y20c1RjOWNtBNYYzzfYSZ+BMsxnFGThj7cb0UzhBbnBWfwfn+Gh/d3T8I8rBXjuminLu7rspyrl79R+gFLcHOOLvvkyxgZy7r28IUgDZBuTcfqEhyLm9RUOQc/uQhiDn9iwNQeJv2oAc7PV/iiDxNo1A4mwagcTZNAIpc4N8FEQc/O28/xYhhbvfXD/42yVvk7xQv3sVr5QP8JM7IT3wkzunNuCvKCf3Ti1RTu6engbCbV7d5vY3BwTvSwWOy8u2v6jL7h5lPISz3OAs8R7OdQLe/AT8bQIH2421eV2Z5gSk9wmsvU8g9j6BZH4CEm+36Mqvxrzszwov8vXnd23eHdXNbMtMs23zHqZuZmu/e2g5W/utRsvZ2u9LWs5Wppqt/Y7nR7P1+TbbrxYh22+PWs52sF6qMtuxeql13fpkv8Y/uV1GHqvx+gma2gYYZawubXVhR5MqG0TmZfvDWe7GvP0MrIzV0bUkM1b315LMWJ1iSzICmQdkxupAW5IZrKP5CZl1G0ZO8ROZgz98+Z+3P+zudkWWown62+ZZy6dDr8QHa5TME8/LxP2XEvGJ+zol4hP3i0rEJ+5DdYi7ibu4nxBfbm9/dHffYTgknvM2iOKquwxdrr1/vSOndDvel/VDorHCzyElGiuxHVIiTJl5iXBx1iXy2D7zEuETzUuEsTQvEU7UvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEgXSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXSEgXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2ilXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iWKpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLlEiXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iTLpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLVEgXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YFyispAumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEjnTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iXypAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLlEgXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iYR0wbxEpAvmJSJdMC8R6YJ5iQSJrEtEumBeItIF8xKRLpiXiHTBvESkC9YlWkkXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2iSLpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXzEtEumBeItIF6xIl0gXzEpEumJeIdMG8RKQL5iUSJLIuEemCeYlIF8xLRLpgXiLSBfMSkS5YlyiTLpiXiHTBvESkC+YlIl0wL5EgkXWJSBfMS0S6YF4i0gXzEpEumJeIdMG6RIV0wbxEpAvmJSJdMC8R6YJ5iQSJrEtEumBeItIF8xKRLpiXiHTBvESkC7YlCstCumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEjnSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXyJMumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEgXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iUS0gXzEpEumJeIdMG8RKQL5iUSJLIuEemCeYlIF8xLRLpgXiLSBfMSkS5Yl2glXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iSLpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLlEgXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF2iTLpgXiLSBfMSkS6Yl4h0wbxEgkTWJSJdMC8R6YJ5iUgXzEtEumBeItIF6xIV0gXzEpEumJeIdMG8RKQL5iUSJLIuEemCeYlIF8xLRLpgXiLSBfMSkS4Yl8gtpAvmJSJdMC8R6YJ5iUgXzEskSGRdItIF8xKRLpiXiHTBvESkC+YlIl2wLpEjXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iTzpgnmJSBfMS0S6YF4i0gXzEgkSWZeIdMG8RKQL5iUiXTAvEemCeYlIF6xLFEgXzEtEumBeItIF8xKRLpiXSJDIukSkC+YlIl0wLxHpgnmJSBfMS0S6YF0iIV0wLxHpgnmJSBfMS0S6YF4iQSLrEpEumJeIdMG8RKQL5iUiXTAvEemCdYlW0gXzEpEumJeIdMG8RKQL5iUSJLIuEemCeYlIF8xLRLpgXiLSBfMSkS5YlyiSLpiXiHTBvESkC+YlIl0wL5EgkXWJSBfMS0S6YF4i0gXzEpEumJeIdMG6RIl0wbxEpAvmJSJdsC5RlnElys8PTnE7NqVP0K9gBjaMfw7MwDbtz4HpwBy5G5jKXJ/96et0OzAaLafbQdPecLqlgwa45XQ7aCZbTreDxqzldDtYQvnJdNft+XYRMlT+tJNStqPXuw7w8qevbAQ2D9l00AOqsemgDXwVG5/T3jTmUipHB1/yNsngbv3odnMarG3UAzlYQ6oHcrBW94UgQyw7yJzuQH49VtwOXbxLf4Dul8Ea7j6gD9b2/wz6Pklf3FI5Ou9zzOE2xcvfODi25G0YpXw+9gp9MPPRB/SJLZAedAH6+6FPbNr0oE/tBrWgT+0ctaBP7TK1oE/tSJWgu6kdqRZ0HKkCdBypAnQcqQJ0Afr7oeNIXwE9bse6ZfEH1LGkGtTxpBrUMaUa1HGlCtQ9tlSD+sy+tNwWnJcqdSdpR7m6u7+dj0YSl219Ovp4d6z/wD6zM1XEPrM3VcQuYNfAPrM/VcQ+s0FVxD5z1/5K7LIdHFf3FXsP72DvEvv+C98Y8wF2OpnvYl/dPuw1yCfsV5QCylYo6TiaoaSLaIZy5uz6h4+ofSAXlGvlEXW5fJbbUMqXr+H38DbvMcHTC+uA7+HN22OCJ8dWAj+x/wtLSDv4UhtI5TdrPbzLug+QAsg2ICd2cz8D6VxcdyYu3m0i55Zy9Nef/lDb9/C25zHBT+wUdcFP7BRfDL7dr+p7eDfz9CL18HZmKyIlv/9xV5ZQEcmntH9JK91tKbmBn9iB6oLHgSqBx7G+CHzTL0b08I5kZPI9vCcZmXwP70pGJt/D+5KRyffwzmRk8j288XUKmZ5/F7OH91VOIdPz72728M7KTmWqfRWsh3dRjoqejkwNPV2WGnrWTF72SG76PaYe3gyJUL+Ewot0IhTrMp0IxTpOJ0IJQn1TKL+sO3l/mXFFKH8R9uNw7/IdlLweHZ2W/ejk/ReZ8PddyEQW0IVM5AYKMl3RkxuooSc30EKfSQLU0OPt1dDj1tXQ479fhd7v32vwl38foBfQa6HHJauhp6/XQl/ocF6FfpVlQ7+uR+jpcNTQ0+E0QX+FKcBsB5MupCFMEvVvw/Su7DD9/T3zzM/nCxm5Eng6aSXw5OOvAt9sL4KwkKR3IBKO9JxI0X3pgMKCx2wIE9fYEKYA87swQ847TJHal/x89HvmF8Pd0WX5QI/HfAv6dIAeR/oO9OIP0ONJX4Z+H4uPcf2E/mgscdnHEu+Xn/PhPNMe8uQcKkdnv00zi/t07LUEcMfTlwA+ffYScKQA05cAGcP0JUAyMn0JkOdMXwJCCcxeAqRh45fAun3jPa/poARI5cYvAdnvAncAbyVAOjhTCcTwtQQ8uUCHJeDXsEHx6+oPZMXrdynrbav/6NYDWfHvQ8qKJx9SVkHWEWXFOw8pK354SFnxuCPKGjA4PUYX5fYN2XKUSwcMzpCyYnCGlFWQdURZMThDyorBGVJWDM6Isgotkw1Zvaw7wrxWZA0xh+3omMuBrIKsI8pKyzSkrLRMQ8pKy9ShrBL2N3pKyAffZRJ+6dijrGWP+qXkg28pCr9e7FvWdVkObsIr3zwcUlYW5oaUlYW5IWUlZRpSVkHWEWUlZRpSVlKmIWUlZRpSVlKmIWUlZRpR1kjKNKSspExDykrKNKSspExDyirIOqKspExDykrKNKSspExDykrKNKSspEwjyppImYaUlZRpSFlJmYaUFYNjQ1a3v5QquLX6Y42wyxrC0de/Ewand1nLwY81EgZnSFkxOCPKmjE4Q8qKwRlSVgzOkLKyjD6krIKsI8rKMvqQspIyDSkrKdOQspIyDSkrKdOIshZSpiFlJWUaUlZSpiFlJWUaUlZB1hFlJWUaUlZSpiFlJWUaUlZSpiFlJWUaUFZZSJmGlFWQ9Q2yJl+RNcVt8/2UbrTFf6iEX+lBJexHDyrhJl6lUkrb4T4voaJSCXlDWC6i3D2aDp9judyeY3cHH4njS3b7LBf//GDnlrSL4z5B2R6R+BSFgrmix0u8Cn32ZUe/Ll/RO9apXoY+yo7+juANPU+ob6Nfwz5uvyZXQV/S9i4kt7i7B8Nl4Ffy3Oq/TT4ubiefPg28HP71sj+T/b3JfdDv5e2toJe/XWpHO7c/RpykytG5bFCKO7rv8ciZvQQ8Udf0JcCXr4YvgVLC3gws+VMNfD04ln2WsbiKW82XLvDj4Oyj/+IoPb011fW66uKraFTX66pLqC6q62XVxUIX1fW66mKBjup6XXUR21Jdr6suommq63XVReo9c3X9roFA7E0NkHtTA6TTw9fARYZlLwJZKq2GK3H/gkspw3yxLxA2jV/oIYebmP7gbkcmRBEEopvJiqAcFAEJC0UQCEIoAiEJoQiEKITGUMhCKALhC3UUgQhFQBGQGFIEQmJIEQiJIUUgJIYUwUpYRBGshEU9FoFf9k1QvP9cBFdZiX+GlJVAZ0hZBVlHlJXQZUhZiVGGlJVgpEtZZd1lTcuBrEQdQ8rK151GlDXiW4eUlU64S1n3X6348IeRXGWlE+5R1rDun9ZPr9bYZaUTHlJWOuEhZaUTHlHWxOrskLKy3jqkrPjWIWVlvXVIWQVZO5RVwvZdJi85VI6Osr0xJcbbak+IR7PM64Yk5/Lp2Gu5kF5RLj8oF1IxyuUH5ULaRrncHVtu72RbXKkcvF5qY9PGZakcHWNY9nEEd1CLRITUopVaJNekFo3UYiaMpRat1CIJMrVopRaJvalFK7VIVk8tWqlFoRapRSO1yOoFtWilFlkaoRat1CLrLtSilVpk3YVatFKLrLtQi0ZqsbDuQi1aqUXWXahFK7XIugu1aKUWWXehFq3UolCL1OJbajGFvUrShchBLbLuQi1aqUXWXahFK7VIvkgtvqsW87rX4h3urRbXhUyHWnxTLYrf74uX8R/UolCL1KKRWuS7EdTim2oxrxuQlONRLfLdCGrxdC3Kvuv7Km45qC7cCNX1supyfH+B6npddeFeqa7T1ZX2bGTNizuoLr5jQHW9rrr41gDVdb664rJXl685TBcWv6sTlj94zCPgN+kv/46udvy67gzdGpejJzUelmo3W+37LH9Ve200TvK6D15yOlhV8aSHVPu7qt35/Y8Htx7cez33XqrRTjWSN1KNZqoxkE9SjXaqkTyTajxfjffapIPqIs+kul5XXeSZVNfrqkuoLqrrZdXFL5WortdVF789orpeV12sNVBdL6suIR+juk5XV9lf/LWWvB5UF3kX1fW66iLvorpeV13kXVTX2eqKy/7t0OjcUd8lVBfV9bLqIu+iul5XXeRdVNfrqou8i+p6XXXxXVmq63XVxXdfqa6XVddKVk91va666LuortPV5STt1XW0x9FK30V1va666LuorpdVV6TvorpeV118R4Lqel118R0Jqut11cV3JKiu89W1Hx39H34t+/Xo7GWrkuyjvw06f5SiUIqUoo1S5NsXlKKRUuSrGpSikVJkfYFSNFKKLEZQikZKkZULSvE9pejiur+25vLvu2Lc85zESgfVaKcaWRmhGu1UIyspVKOdamTlhWp8WzUmd6vGfFSNxIxU47uqMWbZqzEtB99kTiSNVOO7qjH525M6STyoRsJGqtFONZI3Uo1mqjGTN1KNdqqRvJFqtFON5I1Uo51qJG+kGu1Uo1CNVOO7qjHHWzXeAb9VI9/3phrtVCNrMVSjnWpkLYZqfFc15mXZqzE7d1CNrMVQjXaqkbUYqtFMNRbWYqjGt/WNd98oy87Xjvc36S//jq52/Hq5t27Hr2spB9XOWg/VPk+1s5ZEtc9T7axVUe3zVLtQ7VT7NNXOWhvVPk+1s5ZHtc9T7awVUu3zVDtrkVT7ONW+ry6tcVkOqp21TqrdbLXvs/xV7bXROMk3geSPf/9XtcdFqHaqfZRqX/Ot2lM+qHYyGap9nmonk6Ha56l2MhmqfZpqd3wHkmp/W7Wvd7+diUfVyHcUqUY71ch3CKlGO9XId/yoRjvVKFQj1WimGsljqUY71UheSjXaqUbyTKrRTjXyHTCq8V3VmHfel3+v6aAa+Y4W1WimGj1rMVSjnWpkLYZqtFONrMVQjX8xU41CNVKNb6rGcvtlSixRDqqR9JtqtFONJDxU49uqMd6e1CWVr9UY+NYE1fimakze7e9pvfx7PahGVgapxrdV4xpu1ZiXg2pkZZBqPF2Nfk17Neb0J46+1iJdI7VopRZZFaQW31OLLsfbL7ou/z7w08KqINVopxpZFaQa7VQjq4JUo51qJGukGu1Uo1CNVKOZamSNmmq0U42sw1CNdqqRdRiq0U41shJDNb6rGpO7CZ9Wd1CNrMVQjWaqcWUthmq0U42sxVCNdqqRtRiq0U41shZDNdqpRqEaqUYz1chaDNVopxpZi6Ea7VQjeSPV+K5qzMv+xtSc3cEvtCKemmp8VzWWu3tjCQf3xointlGNSWSvRvl89FUoQag+hMKJdSIUJqUTofguVSdC8TWjToTCERsRKt08SHJfhUp8OaUTofjeRidCEb90IhTJRCdCCUL1IRQ+yohQ5dael/hVqEzXZ0OoLFs27/MaDoSi6+tEKLq+JkJdYdKZNYQpwGwHk7WXhjBZH2kIk967IUzWGb4Ns/j9+0i+lFRppOJy2476zphk/wGedQMd8AVHqAQeh6cEHsemBB53pwSefvtV4PevQ8S73wfcwNPVvAp8vH0POn8Bnxa6mu+CDyH5nYmsvgLeXQaz7wnlcrr9DiEeLkgs2x/3yfu7Y68y0QN1IRMdUxcy0V8pyHRFL6DXQk8yr4YeX6GGntRfDT1rBGro8dOvQ7//aNm5srinjWhxaRt5cXc/Fv6QyeG+u5AJ992FTIJMPchER2ZDJr+HJMX7/EUmurcuZKLT60EmT6fXRKYrTPqxhjBZs2gIk5WFhjAFmO1gkv43hEme/22Yq7vBXO+SyhtM/GBDmLi2hjDxVu1gBhxQQ5g4oIYwcUANYeKAGsIUYLaDiQNqCBMH1BAmDqghTBzQt2HGsi9w/PoyyieYB3/dl+3XUyG42zuuP5Y4Am5JB7zgrJTA48JeBf5y/A7+01dIvh4rbhdJvPvydRPB3XUgEq7xnEj+oAMSAea3YeZyBzMewMQ1fhvmJZa8wVzdn3y44jCVwONGlcDjXF8FvmGngsu1L9KKIz4nUvy6Z/lFOGB+v53MdzAPvjm04ka/C1OWtI9bnPy5rZ3SisNUAi+A1wGPc1UCj3NVAo9z1QEf6bdfBf7pvomJd4e/DPzzfRN5F/j3wYewL1hI+MPLlr4e71Pa/vrln19+SMm7vbXA09UogaereRF4d3l+7vO83NK/oieRV0NPzq6Fnjde66Ena1dDL6B/Ffp0263w8u/yBT0dzuvQp3xDn+MX9HQ430YvN5SyevmE/gqTnqUdTN7A3BImfUVDmKzhN4RJgt0QpgCzHUyS5oYwSY8bwsQvfRtmlP0HHhJz+K+KX3p6/BU+jkkRPg5LDz5vQH4V/AuIbeA+LHdfTcgfMQ3vQNZDj9tTQ483VEMvoH8DeucP0OM71dDjUtXQ42lfhT7seYIPZf2E/uDo56/OLbjfLmTCJ3cgU15w1AoyXdHjqNXQ46jV0OOo1dAL6LXQ46jV0OOoX4V+lW2afr3ft2VHj6NWQ49LVkOP89VC7+jr1dDT4bwI/WV1zO9//f7oHT0djhr6mTucIDv6kGLl6BK3ObplucWQPi8fJGduWNqSnLn/aEpy6lem/4jk3S7mv15zdXd0/kA5c9jdGOXMTW5jlDOH0Y1RCihboZzZSjVGObM1aowSq9MMJV6nGUrMTiuUU78evTFK3E4zlLidZihxO81QCihbocTtNEOJ22mGErfTDCVupxlK3E4rlFO/srwxStxOM5S4nWYocTvfRCmL2zbHFSdygFJA2QolbqcZStzOd1G6VHaUZfmE8uBvP31HdJ765dyK2HFRKthxXK/B3uxV23nqV213IhEO8bsS+bB3PT7likSSy/a3pXhfOXpN259eyx2+j3Zq6veC96IRnta+RoJG5jXChdvXCHv/Go3KetMolq+5ytTvMFcFj8V/Efiy32gWf5Akrpj8V4H3O3jJX8FHrPurwO/DXtZ4AB5DrgQel60EHuv8XfBh3zFUwh9Q/uzoK3gBvA54TK4SeJzrS8A7Sft+Dau7343laNxx2VYkor/7y9l/iITL7UAkHHEHIuGe7YuUcNodiIQr70AkQSQDIsl2cFzdgUh0dxZEitufjjEfiER39xqRVrdPcg3ySaQreDo2HfCZLkwJPJ2VEnjWO170IN6HfQG/Vh7El8FmuQ28fPmCbmZ1pAuZBJl6kImVly5kYp2mC5mm9vJ5OzqIXz8d/RtOmdlR5P0LlaEscgBn4q5G3H60uBIP4Ex897vcoPbvFiW3HMCZ+J5ThzNxbleHM3G2Jun2lb28LJWj8z7HHG5T/PXyja/Hlv0xWMrnY39BLzO/xVoP+sSZmh70ifM0Pegz95Fq0AXo74c+cXKlB31mJ6YGfWaHpwZ9ZueoBh1H+n7oDkeqAB1HqgAdR6oAHUf6CujP3wdcnEBdgTqeVIM6plSDOq5Ugzq2VIG6n9kiVb6dUfzMVqYKZ2bLUYUzszXw+yTFSz6AI8B5DGfmRrsKZ+Z+uApn5ra1Cmfm7rIKZ+bFibBuwxZZfOXoGPdtCfKtTfcf2yWXmd/e3hbkzJ13U5Azd+lPviZ84JT3XdOdK3d/WjaSM7f0bUnO/Mu8ys9lytSvD6/CmflXaFU4M+/kUvYtEC5zrB3t0vbM9Mvt2OMAteF68dQvDu9BoKlfR96FQDPvIGNDoMp60tTvTu9DoZl3melDIUEh4wrN7GD7UGhmG92HQjN7+bLv4CpOanmaT2Hb+MenT2+MlkON1i2ru6CUT0dfwU+dE2iCn9r/K4Kf+uX0rwTv9g3As3fxAPzUfl0T/NQ2XBP81O5aE7wAXgf81F5YE/zUFlcTPM5VCTzOVQk8zlUH/NTvZlcFj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBP/W7zlXB41yVwONcXwM+7pPMKfsD8DhXJfACeB3wONfXgL9A28CX7A7A41yVwONclcDjXJXA41x1wGecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nOtLwJfFLx9HlyWsB+Bxrkrgca464AvOVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzO9UXgU9nAu6UcgMe5KoHHuSqBx7lqgJdlwbkqgce5KoHHuSqBx7kqgRfA64DHuSqBx7l+E3y4vVA3+Bwr4F26jSRFuR/2lTvGVYc7vlWHO7ZVhbvDtepwx7TqcMez6nDHsupwF7i/hPtlTW+zWZem8fmw4yUc/jg4XhT5KhLuVl+ktexW+FgknPCLRNpfCuuX4J8PW3bY4u9+VB7S4a2xuNu9sfjbsH1ZPzTFZY+nKQ5+PE1JB4bT1JM8jKcpqcZ4mpKYjKcpacx4mgqaDqcpwdB4mpIjjacpOdJ4mpIjjacpOdJwmgZypPE0JUcaT1NypPE0JUcaT1NB0+E0JUcaT1NypPE0JUcaT1NypPE0JUcaTlMhRxpPU3Kk8TQlRxpPU3Kk8TQVNB1OU3Kk8TQlRxpPU3Kk8TQlRxpPU3Kk4TRdyZHG05QcaTxNyZHG05QcaTxNBU2H05QcaTxNyZHG05QcaTxNyZHG05QcaThNIznSeJqSI42nKTnSeJqSI42nqaDpcJqSI42nKTnSeJqSI42nKTnSeJqSIw2naSJHGk9TcqTxNCVHGk9TcqTxNBU0HU5TcqTxNCVHMqBp2F58KCl/0vSqEbmQfY3IeV6ikXf7JL27G8n2vslEFqPCPZOX6HAn09DhTu7wIu4h7NxLadj7hpK3KYpz+9Fhe2JnUofRFBUUHUxREofRFCVvGE1R0onRFCXLGE1RUpLBFC3kLwYUfZ4JF7Ia+xrNnAKEvFMXv346+gpHgPMYzszetApnZpsn4QYnxcrRLm0P+ssa5H6sz8vBsXnnkUOpHFt2hUr5fOxVoJldWxcCzWzCuhBoZk9lQ6C4HeuWxX9R6PI/opBxhWZ2SH0oNPO6dx8Kzexg+1BIUMi4QjN7+ScKXeHg5Z/AwUc/gTO1h83bJEMWV7vx+bzfoUKQu6MPkVwytx28xE9HX8FP7U0VwbupLacm+Kmd5AvBr/svyMKalwPwUxtETfBT+z5N8AJ4HfBTuzRN8FM7QE3wU7tLTfA4VyXwOFcd8B7nqgQe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgM+4FyVwONclcDjXJXA41xfA76E/bfxS8kH4AXwOuBxrkrgca4vAS/+Bt6v/gA8zlUJPM5VCTzOVQe84FyVwONclcDjXJXA41yVwAvgdcDjXF8EPpUNfPgD+J8dfZUJn9uFTLjiLmTCQxuQ6fJp2f/26u7GnY9mGZdt04Po492x/kNS3Plokq74/uEkJVEYTlKyiuEkJQUZTlL8Y3+SynZwXN2BpHS8/Uka/SZpzF8ljXS8FiRd3Y5kvf/bOXzIRBfbhUx0pl3IRLfZhUyCTBbajX2SF5nWSrtxmdptKMX/kuTj+I+tJyOrfwOKitcbUFRWFgcUlXXIAUUll/muqOEGPi6hJtOTo3+DT6QnSuDJQ5TAk3C8BLz3y/Y6VC/h4AtEicxCCbwAXgc8SYESeNy8EngctxJ4XLESeJyrDviMc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBX3CuSuBxrq8Bv/rtaL8e7R1QcK6vAS+h7ODjUjk67/xyuOHzv3Yj/nJsydsUS/l87FVQHPFgggqCjiUoDn4wQUkGBhOUxGEwQUkyBhOUhGQoQS/5AIKOJSiJzmCCkhQNJihJ0WCCCoKOJShJ0WCCkhT1Jmjcfx29LP5AUaKi0RQlKxpNUcKiwRR1pEWjKUpcNJqigqIvUXSNaVe01DdCLEvY/vha7rb0jR8yTdPuXKc7TS/we7p+rAdlCXstF5HKn/YpbgPxKYX7P31lM9Yjpy2bscL+tmzGys3bshHYPGQzVprbls1YwWhbNmNFjG3ZjNW9/pBN2V6/4bOTr2zGanWbsglT98UVNhP3xeESFt+Gnb6ymbgvrrKZuC+ushHYPGQzcV8cbj+MPWYzcX9zSUW3Px0ui3hf2Uzc39TYyMT9TZXNzP1Njc3M/U0oeWfjlud/ei37OxnWUr7euGXmZugnIOOyPwHjcuBGRAD504o8Bjlzm3VbBQ9y9/bZcx/tibPKsyCPK3LiYDNIijvIkr+ymbrxr7CZuvF/zmaduvGvsJm68b+xWe++rrWzmbnxr7GZuZevsRHYPGQzc8cd/P4NyNWlyp+OefOALsndVxpD+iA5c6eY8h7ZpBL+nHdZZ24rfwKyFkusM/egJyvyEGScuWG9/enwh5X4gz+9lP1Pu7B8vUnGmdvb7Pdh51L507IDEf/5YXMwjFsE5y7Z+X502KnP3DjrUZ+5JdejLlBXoD6zjdCjPnPKr0d9ZqOnR31mV/gj6mEzhZLyQQc+sylsyDHxY/ArR9s/HU7sCNiFTOzz14VMgkwmZApyk+nulTnxwdH+7uj4RVR28BtQVHbxG1BUNvLrTtRfL3bYXfDdIvMmKTv5DScpW/mNJmlmL7/hJCW/GU5Ssp7hJCUXGk5SQdLRJCVBGk5S8qPhJCU9Gk5S0qPhJCU9MiLpoyj+4G/nsP/Iyt1p8+Bvl32WF/3vZinlWgKFtGn6EiCdGqoErqKSTw0oKgmVcVGvMuFnvyvTJaHbkQSpgP+13Ll1s2GtyiTp1ijffb3M5cPft8p2cLzbxsdl/yEpfrY/SdPGL+b1QFL87HCS4mcHkzQs+NPhJMVvdiip2yWNB5LiNoeTFK85nKSCpN1JGreoIcZ8ICnfhhhOUtKj4SQlPRpOUtKj4SQlPRpNUkd6NJykpEfDSSoTSxpklzSkWDn6V9J2E+n+6PznRXq6AhrczE7TjkjPo3U3s3fsRqSZ3WA3Is3s77oRaWbHZkikp6sOfmYP1o1IM7uqbkSaeZXdjkjPzayfed28G5EEkeyLROLQgUgkDh2IROLQgUgkDh2IROJgX6Qws09awi7SUmoDcRJlW/W7/Dvf//VycLxf87afxOWfd1By/EA/s/tRRi+g10I/s1NRRj+z/1BGP7OrUEY/s1d4Lfq0b6/lkywH6Gd2ALroZeaVRGX0M68PKqPHzaqhp69/FfpYtoFf/hkO0NPhvAp9ztvhvizrAXo6nBehv0Sit7/uD/r6lQ5HDT0djhp6OpyXoU9+/+v582P2Z0dfhSLd70QoQSgLQsW87j+qynd7L28y4S+6kIk1hi5kYj3ChkxlhxKLT19kwtl3IRMpQA8yRRKDLmQiXehCJpKILmQih+hCJkEmGzLdtnYp61eZSCG6kIkUoguZSCG6kIkUoguZSCF6kCmRQijIdEWPF3oR+up31JKAXgs9nkUNPT7kVeg/fR9ZDtDjLdTQ4xfU0OMBtNBn+vqXofc39KFmv4Iv2w9CQ3DyR/uVWV3sQiZWF7uQCUdtQ6ZL+rfLlO8zp58ce5VUkHQ0SUkAhpOUZKE7ScXtz1Lx7qukJBbDSUoSMpykJCwKkv5GX0hYXoY+ph19ygfoSU1ehj7va0ipHPziu5CEvKPqD9GTbqihF9BroceHvAp9XrdpXv55hB6/oIaevl4JvSz09Wro6etfhl78c/QC+lehf75rnyysh6ihZ91CDT19vRp6mkst9I747NvoQ1h29BcoFfQupTVsx1/+fcOyoSc+U0MvoNdCT3P5OvQp39DfvfZ7Q09zqYae5lINPaGxGnr6ei30ntBYDT2hsRp63KwaetysGnr6+m+jX9I+7ksKkCro422rmtXdhWf+Azxd/avA70fHvB6Ap6dXAk9HrwM+0M8rgaebfxl4t4OPB+Dp5ZXA08krgRfAvwh83L5sFmM+AM+alBJ4nKsSeJyrEnicqxJ4nKsOeMG5KoHHuSqBx7kqgaeP/y74EPbN4F2Q1VfAO5fzvmblynL/xtSvRxeXtpEX92VzJhG6/i5kwiPYkMm7DUrx/qtMOIouZMJ/9CDTilvpQia8jRGZgttlCl9+7LHihLqQiRW/LmQSZOpBJlKILmQihehCJlIIIzIt/taQ5y8ykUJ0IRMpRA8yRVKILmQihehCJlKILmQihehCJkGmHmQihehCJlKILmTCN31XJl/8vkOhL+VP/sQ64YReBf757x4T3kYJPG5FCTz+Qwm8AP5V4J/+4DThEZTA0/UrgWc18VXgn/80I7E+qAQe56oDPuNclcDjXJXA41yVwONclcAL4HXA08d/G3xc3A4+fRp4Ofzrxe1Q4lo52qdyeyn9H3ayvQpF329DqOy3xTCfQz4QCp/Qh1AFX9GJUPgQI0LtwH126UAofEsnQuFzOhFKEKoPoVgB7EQoVgw7EYpkohOhSCY6EYpkoguh1oVkohOhSCaMCLX/ouHyz3wgFMlEJ0KRTHQilCBUH0KRTBgRah/5RahyIBTJRCdCkUx0IhTJhBGhJO9CreFAKJKJPoRyJBOdCEUy0YlQJBOdCEUy0YlQglB9CEUy0YlQ+CgbQsV9I6bL3y61oyWE7WjJoXJ0lNvvRG4rXSEezbLkrV7ccjeM44OjXzeA0efan/6119T+85ac3fLp+Gs1YhapxrdVo9yEv7837tXoccRUo51qxPZTjXaqkWyDalSpxugPqpEAh2p8XzXKrRrTWvvrZecdy/0XDfPBwdnvfzv7u0K/HHytc6HOqfMJ6pz4kDqfoc75Xhh1PkOd87U66nyGOmc1jTqfoc5Zp6POJ6jzwAogdT5DnbO2SJ2/q86L3wFe/h0/HX+tRqEaqcZ33XXL7TtpZTn4Tlogu6Aa33ZvdDfhS3Bfq1HoSKlGM/dGoW+kGlX6xnBUjXwnjWq0U418J41qtFONQjVSjWaqke93UY1vq8Zwy9WLyEE18i0sqtFONZI3Uo12qpFvNFGNdqqR7x1RjWaqcWUthmq0U42sxVCNb6vG2jr1yloM1WinGlmLoRrtVKNQjVSjmWpkLYZqtFONrMVQjXaqkbUYqtFONbIWQzXaqUbWYqhGM9UYyRupxtPV6PajL4W51Kox+bD/8XSZwkE1kjdSjXaqUahGqvFd1RjDrRpTOahG8kaq0U41kjdSjXaqkbyRarRTjeSNVOO7qjEsuzrpUigH1UjeSDWaqcbEd7+pRjvVyHe/qca3VaPcVeO6HlQjazFUo51qZC2GarRTjUI1Uo1mqpG1GKrRTjWyFkM12qlG1mKoRjvVyFoM1fi2agz31RgPqpG1GKrRTDVm1mKoRjvVyFoM1fi2atzn+OvfB9/hyazFUI12qpG1GKrRTjUK1Ug1mqlG1mKoRjvVyFoM1WinGlmLoRrtVCNrMVTj26ox3VVjOXiXVmYthmo0U42FtRiq0U41shZDNb6rGsXtb+hI4g/24SmsxVCNdqqRtRiq0U41CtVINZqpRtZiqEY71chaDNVopxpZi6Ea7VQjazFU49uqcbmvxoN3sBbWYqhGK9UYF9ZiqEY71chaDNX4rmr0+ba3rYS1drwEtx8vRzvsxYW1G6rXbPWG9Va9q6sen9d98JJTPqh21oaodrPVvsqt2mM4qF6heqneHu7Vh9XL2hPV22/1slZF9fZbvaxtUb39Vi9rYVSv2epN8Va9xTfIKFhro9rNVnu53asvKyNfq9exNkf19nCvPq5e1vKo3n6rl7U8qrff6mVtjurtt3qF6qV6jVavuHSr3hD+fEbhWMuj2s1We7i7V8t6UL2s5VG9XdyrD6uXtTyqt9/qZS2P6u23elmbo3q7rV7P2hzVa6F6r9XIWhvVaKcaWTujGu1UI2thVOPbqnG9VaPPy0E1CtVINZqpRtaeqEY71chaEtVopxpZG6Ia7VQjaz1Uo51qZO2GajRTjYG1GKrRTjWyFkM12qlGoRqpxvdUYyxxL6pYUjmoRvJGqvFd98blJvzl3/GgGskbqUY71UjeSDXaqUbyRqrxbX1jWe6q8WBn9UDeSDWaqUYhb6Qa7VQjeSPVaKca+e431WinGvnuN9VopxqFaqQazVQjazFUo51qZC2GarRTjeSNVOPZalwvtbFp47JUjk4St799+efBdyZW0kZq0UotkjVSi1ZqkaSRWnxTLUa36Z6iTwe1SM5ILVqpRaEWqUUjtUjGSC1aqUUSRmrRSi2SL1KLb6rFNW9VktZykHVHfDS1+KZaTGUbdMrBHdQiPppatFKLQi1Si0ZqER9NLVqpRXw0tWilFvnNNLX4plrMq9trMYaDWuQX09SilVokX6QWjdRi4vuL1KKVWuT7i9SilVpk3YVatFKLrLtQi1ZqUahFatFILbLuQi1aqUXyRWrxTbV4//3Fo3WXRL5ILRqpxUy+SC1aqUXyRWrRSi2SL1KL76rFuH9P5+JTDmqR7+lQi2+qxbTzS8nJQS3io6lFK7WIj6YWjdRiwUdTi+/qF0u61eJ6UIv4aGrRSi3io6lFK7XIejS1+K5+cX+19OWfR/0ivwOkFt9Vi3e/A3ShcrSTvO5DkXyURxbySGr3TbWbXdxr92idppBHUosK99HDWiSPpBZt1GJayCOpRSu1SB5JLVqpRfJIatFKLfK7QWrRSi2SR/ZYi142hN6n5dPRV1mJ6nqUNfjtb/sg4UBWUq8hZSVAGlFWRxbT5bM132T9w0iushJrDCkrCcGQsmK2h5RVkHVEWfmq3pCykjINKSsp05CykjKNKKvHt35b1mW9yXqZcRX9kvc43t/F8Xn9QI+3VEOP/1NDL6B/FXrZ16L9Gj6hPxiLL5tQIdz9iPljCdjjubqQCQ9lQ6YQyy5TTncy/eTYq6T4p+EkxTsNJymr891JKm5/lop3XyQNrMwPJynpxnCSkpq8StJw+/5oSEtF0jVt+q/lDmD+UImApQeVBJU6UIkopgeVSGJ6UIlw5VUqyW2lUe7/+qFKsexLpLHcNXm/+Hw5OHvZeGcf/VdRiVcGFJWAZTxRhYhlQFEJWQYUlZhlQFFJZQYUVRB1PFHxqa8SdfX7wsXq10+i/ka/0qO+DL3sX11e14PvBq48n16Gfj/crzEfoOcpooaefF8NPaG9wr3+zJOBfqgTocjiTQgV87ohjDnd9nj7+BbNSrreg0wRL9KFTCTgNmQqO5RY/JevDkYy7S5kIgXoQiZBph5kIl3oQiaSiC5kIofoQiZSCCMy7cucsaxfZSKF6EGmRArRhUykEF3IRArRhUykEF3IJMj0fpmu6PFC30Xvkt//uCtLqKB3kjYobnX3P64/Gnm8fUBWd3es/5AJL2RDprQ71rweyIQX6kGmjBfqQia8UBcy4YWMyLT/dCHHA5nwQl3IJMjUg0ysyNqQKd7expsPZGJFtguZSCG6kIkUoguZSCF6kKmQQnQhEylEFzKRQnQh08S+yZfbBsqLW2oytVw/KhP7oJdifx6Nlol9jSb2iX2KJvaJfYce9rxM7CNei/1ZApyXiX2BJvaJ+3xN7BOvHr4U+1O7lBcBuwZ2XKoKdlyqCnZcqgp2XKoKdlyqBnaHS9XA7o+xp/397nfxv8/LwQXyjjyHUjm25I1KKZ+PvQ7GWRqMtzSYYGkwYmkwq6XBREuDSZYGky0NphgaTLB0Bw6W7sDhvXfguD9Vl8UfjCaYGo2YGs1qajTR1GiSpdE8eDmXlLK3lKt/3tteYphtOHLXYof0cQX38iv4l18hvPwK8vIrrC+/QvzzV1g3B5ZT/HSFA5e0lM3K+N/O6ONoOfJ2OW8vACnO1/7wxVhuf1iW2wpq2CeaZplonmWiZZKJrvX7ffo00etZ7tRZ/tRZ8dX3qTW9/Ar55Vcor75CfHlnEF/eGUQ/ycc6hlkmKrNMdJ1lovHMUyKmU2flM2cd//Am+LJZthDcbWOl+HGSO3OSP3PS4Wc/hNsaQsj3W2j99QfHXi8gr77A+uoLxD97AXG7BuLd1wukV18gv/YC5fgrLD6lbbnt8s/85aR45qR05qQHn9yfLH1djvg4eL1fC/xY+ioPFnpbXuLBombTS7jXX8I3vYQsB5cIr7+EvP4S6+svEf/8JeKy3RiijweXSK+/RH79JcrLL+GX11/Cvf4S/vWXCK+/hLz+EuvrL/H6T7d//afbv/7T7V//6Q6v/3SH13+6w+s/3aHF5+Lpz1NLaFFRT78IVcJxRa1u/4rYGuTTJX6f9mA9rXqaO3eaP3fag/vv/oW2y2lrBZ+7fKx32pfP3xdD8WhFq+1F1ndcJL7jIukNF1mXl3801xb3sKc/YCyrf/0lwusvIa+/xPr6S8TXXyK9/hItnidPfxBX1vLyS8Tl9ZdwL3/wRv/6S4TXX0Jef4n19ZeIr79Eev0lXt8txvLySxy/m2Rdt9R0zXedXiofJ8mZk9YzJx2XypL2Wf36d/ljR/LgfRJLKnsLu2QXv5yWz51WTp32YP/36mnHN8slh3A77e4lG9tp/txp4dxpcu60B7qV2+tGlsvT4o+nPdjDbrkg3k5zy/KF5IM91aqn+XOnybm5redOe/DBKSXcDXL9clo6d1o+d1o5cdq6LMu509y50/y5044/OJdDy+00f18lf/1pTV0uIu+4yPqOi8Q/f5Gna5GXS6TXXyK//hLlp5f4fdqDNcLqae7caWdukZfTwrnT5Nxp67nT4rnT0rnT8rnTyqnT/HLuNHfutAe/51j3G2tK9z9TPWpvfVr2bxgl779cIr7+Eun1l8ivv0R5+SUe/QSt5SXc6y/hX3+J8PpLyOsv8fpPd3j9pzu8/tMdXv/pDq//dMvrP93y+k+3vP7TLa//dMvrP93y40/39bR47rR07rR87rRy6rR1OXeaO3eaP3daOHeanDvtXJWs56pkPVcl67kqWc9VSTxXJfFclcRzVRLPVUk8VyXxXJXEc1USz1VJPFcl8VyVpHNVks5VSTpXJelclaRzVZLOVUk6VyXpXJWkc1WSzlVJPlcl+VyV5HNVks9VST5XJflcleRzVZLPVUk+VyX5XJWUc1VSzlVJOVcl5VyVlHNVUs5VSTlXJeVclZRzVVJOVYlblnOnuXOn+XOnhXOnybnT1nOnxXOnpXOn5XOnnasSd65K3LkqceeqxJ2rEneuSty5KnHnqsSdqxJ3rkrcuSrx56rEn6sSf65K/Lkq8eeqxJ+rEn+uSvy5KvHnqsSfq5JwrkrCuSoJ56oknKuScK5KwrkqCeeqJJyrknCuSsK5KpFzVSLnqkTOVYmcqxI5VyXnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld3Lnt157JXdy57deeyV3cue3Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JX/yB7Lfs3DC+9hDs47UGV7Fv6XZ63/tNpR1v5NnpRyGU4Yms4q63hRFvDSbaGk20Np5gazqOMX2s4ztZwvK3h2Lori627sti6K4utu7LYuiuLrbuy2Lorr7buyuu778pP33F1GY83Np5gbDxibDyrsfFEY+M53kD9smLxcdolI1gr47ks8N1epBzTl90L/PF6b+uLlDdc5Hgt+ccXCfF2kRjuLnLwi7wcto2BwnK/79NyvJ3qsu+5toTbb+9z+Ri/Mz7+decf1xC+jt93Pv7Q+fil8/GvnY8/dj7+1Pn4c+fjL32PP1l//tbG3/nzN3X+/E2dP39T58/f1PnzN3X+/E2dP39T58/f1PnzN3f+/M2dP39z58/f3PnzN3f+/M2dP39z58/f3PnzN3f+/M2dP39L58/f0vnzt3T+/C2dP39L58/f0vnzt3T+/C2dP39L58/f0vfzNyx9P3/D0vfzNyx9P3/D0vfzNyx9P3/D0vfzNyx9P3/D0vfzNyx9P3/D0vnz13X+/HWdP39d589f1/nz13X+/HWdP39d589f1/nz13X+/HWdP399589f3/nz13f+/PWdP399589f3/nz13f+/PWdP399589f3/nzN3T+/A2dP39D58/f0PnzN3T+/A2dP39D58/f0PnzN3T+/A2dP3+l8+evdP78lc6fv9L581c6f/5K589f6fz5K50/f6Xz5690/vxdO3/+rp0/f9fOn79r58/ftfPn79r583ft/Pm7dv78XTt//q6dP3/N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",
      "brillig_names": [
        "get_amount_out_for_exact_in"
      ]
    },
    {
      "name": "_swap_exact_tokens_for_tokens",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token_out_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "4669293913791681502": {
            "error_kind": "string",
            "string": "Function _swap_exact_tokens_for_tokens can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_swap_exact_tokens_for_tokens"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "4669293913791681502": {
            "error_kind": "string",
            "string": "Function _swap_exact_tokens_for_tokens can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "8349750481146185694": {
            "error_kind": "string",
            "string": "Function _swap_tokens_for_exact_tokens can only be called internally"
          },
          "13588333240659585881": {
            "error_kind": "string",
            "string": "INSUFFICIENT_1_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14234046914994891820": {
            "error_kind": "string",
            "string": "AMOUNT_0_BELOW_MINIMUM"
          },
          "14258647237672879755": {
            "error_kind": "string",
            "string": "Function _remove_liquidity can only be called internally"
          },
          "15854867267750979296": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY_MINTED"
          },
          "16715174358392770615": {
            "error_kind": "string",
            "string": "Function _add_liquidity can only be called internally"
          },
          "17059742737981442965": {
            "error_kind": "string",
            "string": "INSUFFICIENT_0_AMOUNT"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18164859091538951175": {
            "error_kind": "string",
            "string": "AMOUNT_1_BELOW_MINIMUM"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "remove_liquidity",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3fruu8kt37Lvt6X4hk8V9eJQiCTtInaKDRHXQ6BzgI+t2P1/KU7PlNyrS5SiSLNW425vq2ZJO/URZrDNnU//3b//jH//Z//ud//ad/+X/+9X//7T/95//7t3/+1//+D//+T//6L7d//d+/mfD7v/3v//UP//Lrn//73//h3/79b//Jeop//9s//sv/uP0ZjP2Pv//t//mnf/7Hv/2nHP/j7z8PtrTtB9vwODikwsFuy/7rYGd+HfHqYOOz2Y++/W0fh9tkSscHn/bDQ4yPo3Px1V1w+9Fktm9H/5e//81EkDkhk0DmhEyem4y3DzIhVMhYY8M+EkP+z8jYDWROyBiQOSFji2QomQcZ95oMGUNfB5Pxj3cI5vcbuKvfgEpvYJyl4xLlXNpev8XtcHMc7R8KZCocnHPe68Zsm6HnAZXkIv+kV/J/Hb8XPv5QHn/ajjdxz0V9G/+vs4orvzGOjnncKvcxa2+LhRH2zyS5p1XIBCquQun4JET7GJC5Qfo1ojTdiPJsI3LbdCMy043ITjciN92IaLoR+elGFKYb0XTXbNf/mm1d3JuR2wptfoyo/zXbWpuOEcXvjApEN0fH4u9rR8d8dCExZ1vpTN3Rx95m8Dh2K7YV0RxdRXRb5WgT46MOnsdRPnqzR0O9Bf/t6JtGtEGj6TXqv65byodG3vkK9WwePfSTHfzVqP84NtnDwCT7dM0oK7SmnhZ6LqWng55L6UmT62lsOtZEsuZZ0F/D97KHH2YffnbHxykH9/rjdPtU7J+mp1TVxlRsjIw7YlUbvx39C0wEmDKYBDBlMFkvGGcPMPQDjN8ApgxmdqsxDMzsPfuFYPwDTDQ/wMze/A4DQwBTBjN9f3rhcv0Exv4Ao7jzjYfZszn8AKO4830NRnHn+xqM4s736RqTf/QxYanONx3juN0m8BUyF2ZVNu0CWbdV0ye37UebZ3pNWVVYqmGHnmEpnzGLnuOy5LCUPYKegaBnQc9fZOa3dcedLZOzr7Rcx9eh49N3lm0ulmMKOxib0tPXYO4d1/yubgyX+U3dGC7ze7oxXOa3dEO4xPkd3Rgu8zujMVzmdxhjuMzfqY/hQuBS5IJ+t8wF/W6ZC/rdMhf0u2Uu6HeLXBL63TIX9LtlLuh3y1zQ75a5ELgUuaDfLXNBv1vmgn63zAX9bpkL+t0il4x+t8wF/W6ZC/rdMhf0u2UuBC5FLuh3y1zQ75a5oN8tc0G/W+aCfrfIxWxoeE/AoOM9AYOW9wQMet4TMAQwZTDoek/AoO09AbNU3/uYa3raZ/gXmN9zXaqXrcx1qf40h+dtnisV753df9F1G8bT50PPHljGLNWFQ/5P5V/Ka0D+T+VfylFB/k/lX8o3Qv5P5SfIr1n+pTIAyP+p/EslHZD/U/mXynMg/6fyLxVxQf5P5Ufqp1l+i9RPtfxI/VTLj9RPtfxI/VTLT5Bfs/xI/VTLj9RPtfxI/VTLj9RPtfxI/TTL75D6qZYfqZ9q+ZH6qZYfqZ9q+Qnya5YfqZ9q+ZH6qZYfqZ9q+ZH6qZYfqZ9m+Qmpn2r5kfqplh+pn2r5kfqplp8gv2b5kfqplh+pn2r5kfqplh+pn2r5kfpplt8j9VMtP1I/1fIj9VMtP1I/1fIT5NcsP1I/1fIj9VMtP1I/1fIj9VMtP1I/zfIHpH6q5Ufqp1p+pH6q5Ufqp1p+gvya5Ufqp1p+pH6q5Ufqp1p+pH6q5Ufqp1n+iNRPtfxI/VTLj9RPtfxI/VTLT5Bfs/xI/VTLj9RPtfxI/VTLj9RPtfxI/TTLn5D6qZYfqZ9q+ZH6qZYfqZ9q+Qnya5YfqZ9q+ZH6qZYfqZ9q+ZH6qZYfqZ9m+TNSP9XyI/VTLT9SP9XyI/VTLT9Bfs3yI/VTLT9SP9XyI/VTLT9SP9XyI/VTLL/dkPqplh+pn2r5kfqplh+pn2r5CfJrlh+pn2r5kfqplh+pn2r5kfqplh+pn2b5DVI/1fIj9VMtP1I/1fIj9VMtP0F+zfIj9VMtP1I/1fIj9VMtP1I/1fIj9dMsv0Xqp1p+pH6q5Ufqp1p+pH6q5SfIr1l+pH6q5Ufqp1p+pH6q5Ufqp1p+pH6a5XdI/VTLj9RPtfxI/VTLj9RPtfwE+TXLj9RPtfxI/VTLj9RPtfxI/VTLj9RPs/yE1E+1/Ej9VMuP1E+1/Ej9VMtPkF+z/Ej9VMuP1E+1/Ej9VMuP1E+1/Ej9NMvvkfqplh+pn2r5kfqplh+pn2r5CfJrlh+pn2r5kfqplh+pn2r5kfqplh+pn2b5A1I/1fIj9VMtP1I/1fIj9VMtP0F+zfIj9VMtP1I/1fIj9VMtP1I/1fIj9dMsf0Tqp1p+pH6q5Ufqp1p+pH6q5SfIr1l+pH6q5Ufqp1p+pH6q5Ufqp1p+pH6a5U9I/VTLj9RPtfxI/VTLj9RPtfwE+TXLj9RPtfxI/VTLj9RPtfxI/VTLj9RPs/wZqZ9q+ZH6qZYfqZ9q+ZH6qZafIL9m+ZH6qZYfqZ9q+ZH6qZYfqZ9q+ZH6KZbfbUj9VMuP1E+1/Ej9VMuP1E+1/AT5NcuP1E+1/Ej9VMuP1E+1/Ej9VMs/feqXjtf+q/y/xm9mj62sz3vZ2ODpdfkaa49at0+V4HzppbNL+9GZtvgYSCoVpEt7sTuXnw6OpYM3u3+Obt7QPR/8G/rsYdGS0GePaJaEPnswsiR0AvQLoBu/T9HdGocf0GcPAZaEPrv1Fgr9mKKzxr0+2AZrjhm6ysEmu0OYTOmHnLNbacj5/eBt21HbzVYO9oft8jk/T++38rO7aCh/lfKzG2gof5HyFtGDMOXpiNm2kP9EeeQfWpVHCCNL+Yf/sibRXxt2i3hnKTkJcq4kJyIpWXLaYxj2G+pilOIetzFdNj+0RzKmV3vEaAtr781+sPFk/6QXR+aGMnmjTBDQoUzqZeKQ5q1cJuFQ0X83Gp+WCaI/lMkbZYKccHyZ+HjMsBb6Vm7sO+SEouTku8nnCMorVR7pozDluW7yOWSPWpVH8ihL+dc3kBwSwqXkRJK3kpyExE2WnIy3+Agxml7tkY0trD3bDRlC5oYyeaNMCGWCMqmXCdK8lcuE674dIfpDmbxRJsgJh5dJdMcMY/hDR4KccCk5kRPKkpOty/OIFLUqj0BRq/KIE4Upz9WFeySEWpUnKH+B8jbSoXyqOW/GfbM8wjlRcvJ9ydIjb9OqPCI0rcojbROmPNfXaz2COaXKBwRzspR//dXNgLRtKTkRoS0lJ3IxWXIyfrk2ELRXqz1itIW1Z7thFpC5oUzeKBMEdCiTN8oEad7KZcJ1xzYg+kOZ1MskIiccXyZ8+2ZF5ISi5OS7yRcRKWpVHumjMOW5bvJFgvJKlUfyKEv51zeQIhLCpeREkreUnEjcZMnJeIsvIkZTq31CNraw9mw3ZBIyN5TJG2WCgA5l8kaZIM1buUy47tslQpmgTOplgpxweJkwbrSUkBMuJSdyQlly8nV5iBS1Ko9AUanyGXGiMOW5uvCMhFCr8tOHfiEf31GO3gtRfrO783bb9y9W/4Y+fYS2InQC9P7Qp493VoQ+fQgjEvrjOzjOxPwD+vRRyYrQp08pZEL/6OEcfLt+5umjB8j57WCun4jQNn30AOUvUn766AHKX6Q8ogdhyjP9OIg25B9alScoL0r5lz88oQ3xzlJyIjhaSk5EUrLk5PtpEG1IxvRqjxhtYe25vu5DBpkbyuSNMkFAhzJ5o0yQ5q1cJkzfNyOD6A9l8kaZEMpkeJmw7fpJBjmhKDn5bvIZRIpalUf6KEx5rpt8BtmjVuWRPMpS/vUNJIuEcCk5keQtJScSN1lyMt7is4jR9GpP0H5d7dluyFhkbiiTN8oEAR3K5I0yQZq3cplw3beziP5QJm+UCXLC4WXCt00kOeSES8mJnFCWnGxdnkOkqFV5BIpalScoL0t5ri7cISHUqjxCvyuU/+zhHGz7ZpFDOCdKTr4vWTrkbVqVR4SmVHlC2iZMea6v1xKCOa3KI5iTpfzrr24S0ral5CTIuZKcyMVkycn45VpCMqZXe8RoC2vPdsOMkLmhTN4oEwR0KJN6mXikef+ycJlw3bH1iP5QJm+UCXLC8WXCt2+WR04oSk6+m3yeoLxS5ZE+ClOe6yafR/aoVXkkj7KUf30DySMhXEpOJHkryRmQuMmSk/EWX0CMpld7ZGMLa892QyYgc0OZvFEmhDJBmdTLBGneymXCdd8uIPpDmbxRJsgJh5cJ40ZLATnhUnIiJ5QlJ1uXFxEpalUegaJW5REnClOeqwuPSAi1Kk+zK5/SPnybjX1W/vf4p0+jUrCP8bsf4589JnGb3fm7LYYf45/dv9fGP8Cw+nR80n2mb+P/PaQ83ZDSNt+QzHxDGtA/haP5s4G2n0Ny8w2J5hvSgEXkthYcy8LTZekYUphvSHG+IZ1cvbN9DCk/tYvFIXlj9y+9evcUk2dXWk4M7eN35vmVy2tP9sfBTz1dSMWeLht/NHX5iY1NpnR8OL4TZkJ8tKI2F1/dhSPoI7N9O/o3ybwUSW8fJEOokLSPYVtD/g9J5g0kmUgakGQiaask7WYql27n7AHnmWQZTkzHZf7ptgLdu+7sWMYTDy9OLrwejwn2cacj0JMbD+Y+JJpvSL77kOLTonJLIfyPIYX5hhSZhxQ283pINofDUT597N19OOWW5HZP/SmTCq4ynLAdw0lPP6ItXrTMdrRUZosLXbTyGySfwq8iydsVJx5v4sMfXLT8trGMJz2aPJv/7ArhNzPfkGz3IVWuEH5z8w2JOIYU4jGkuG2vhxT9/tGM6a8XLb/53sNJx9U5UXgeTilB9dsjQY2vL1m3192HnKw3lQtWzLQPOeZsK0e742J4c7GPY7fipTCa41IYn+5BlI828fGhis/jKB+92eOqvAX/7ejfaobuapqtrObv4ZQXaEvHb02NvY2533U8sYyH9aKZpxuS2boPqXbRNGa+IVmOIbFdx43rPRxcx6+7jhvqruar67g5aRJuxPc3uPmhitEyJvnjcJOSrVzJg9sRuWhM1a6MS1C9CcDzCk8Enld4EvC8wpOB5wUeuwHPKzwGeF7hscDzCo8Dnld4CHhe4UHX/BIPuuaXeAR0zeNuEXkroGseiYepa87HFEx2f3Lj3zueRjXTQ7Cca3eQsz++MGxyMN9CvJIE5J80+Jn5ObPAHOyIOcTjCyQmp+hezyH747Jrnr8o6G61ffvXf/u3f/rnf/6n//lf//lf//s//Ps//eu//O9fp26//seU+1mbtz2qdNvTBzHnX0RMucurnUQtJ/mWk0LLSbHlpNRyUm44qXwxqJ1kWk5qqQjXUhGupSJcS0W4lopwLRXhWirCtVQEtVQEtVQEtVQEtVQEtVQEtVQEtVQEtVQEtVQEtVSEb6kI31IRvqUifEtF+JaK8C0V4VsqwrdUhG+pCN9SEaGlIkJLRYSWiggtFRFaKiK0VERoqYjQUhGhpSJCS0XEloqILRURWyoitlREbKmI2FIRsaUiYktFxJaKiC0VkVoqIrVURGqpiNRSEeXfzbnNP76M/PyD9M3ez/JNZ4Wms2LTWanprNxyVvm3Oc5sj9/pP30l6NdZpUgnHF+/CE8/SDe/vonx42g6fr3un77pfuuF7uMxDONJ22GUk0mV8fjH10F8SE9fQ3f3AdnZBuRmGxDNNiA/24DCbAOKsw0ozTagPNeA7LbNNqDJrtR263+ljsf3Dn309DygQgLtH7/c9tG8PjgdUW96/pG3Kz8Kwx2bmpqnL4aSLX7l9NFRfTv0N0EHgn9IkEDwDwl6EPxDggEE/5BgBME/JJhA8A8JZhD8M4JmA8E/JGhA8A8JwpP8KUF4kj8lSCD4hwThSf6UIDzJnxKEJ/lTgvAkf0oQnuQPCVp4kj8lCE/ypwThSf6UIDzJnxIkEPxDgvAkf0oQnuRPCcKT/ClBeJI/JQhP8ocE3QhPYh4E02soJh3fYDXZuspLG3r8XtNH+/zSv+dqFM3VKpqrUzRXUjRXr2iuQdFco6K5JkVzzXrmSor6JlLUN5GivokU9U2kqG8iRX0TKeqbSFHfRIr6JlLUN3lFfZNX1Dd5RX2TV9Q3eUV9k1fUN3lFfZNX1Dd5RX2TV9Q3BUV9U1DUNwVFfVNQ1DcFRX1TUNQ3BUV9U1DUNwVFfVNQ1DdFRX1TVNQ3RUV9U1TUN0VFfVNU1DdFRX1TVNQ3RUV9U1TUNyVFfVNS1DclRX1TUtQ3JUV9U1LUNyVFfVNS1DclRX1TUtQ35ZX6JpvDPle3PT1Q84xMpIOMeXrtVBpJ2PYHOAb79HPHdP9ZYl6pJRuIcaVubyDGlRrJgRgJGDkwrtT+DsS4Umc9EONKTftAjCv5gYEYV7IawzC6DS6GBSNcDAtGuBgWjHAxLBhpIYy3oogHxlwbiDHRHi9u8vb86vlq7Cu5HkHYV3JJgrCv5KoEYV/JhQnCvpJrk4PdrOTyBGFfyRUKwr6SixSEfSXXKQg7AfsI7HCpQ7DDpQ7BDpc6BLtil2o3v4/E2NuMK9jtTaavw61JT1CSLx0dt+PoaB/f7Qt37Ipd6kDsVrFLHYldsUsdiV2xSx2JXbFLHYmdgH0EdsUudSR2xS51JHbFLnUkdrjUIdjhUkdgX+o5eoKww6UOwa7ZpbqUDuxEteDXhmMsNgT/ODpvpbEYu7/47V7S09EplY528Ri5y+7b0b9l0uxqBclEkEmCTJpdsyCZNLtsQTJpduWCZNLs4gXJpNn1y5FpqafGLiyT5lRBkExIIUTIhBRChEwEmSTIhBRChExIIUTIhBRChExIIUTIhBRCgkxLPYN9YZmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQKSCFECETUggRMiGFECETUggRMhFkkiATUggRMiGFECETUggRMiGFECETUggJMkWkECJkQgohQiakECJkQgohQiaCTBJkQgohQiakECJkQgohQiakECJkQgohQaaEFEKETEghRMiEFEKETEghRMhEkEmCTEghRMiEFEKETEghRMiEFEKETEghJMiUkUKIkAkphAiZkEKIkAkphAiZCDJJkAkphAiZkEKIkAkphAiZkEKIkAkphACZaEMKIUImpBAiZEIKIUImpBAiZCLIJEEmpBAiZEIKIUImpBAiZEIKIUImpBASZDJIIUTIhBRChExIIUTIhBRChEwEmSTIhBRChExIIUTIhBRChExIIUTIhBRCgkwWKYQImZBCiJAJKYQImZBCiJCJIJMEmZBCiJAJKYQImZBCiJAJKYQImZBCSJDJIYUQIRNSCBEyIYUQIRNSCBEyEWSSIBNSiItksuQPhKkmE+VDJr9t+adMSCFEyIQUQoRMSCFEyIQUQoJMhBRChExIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTI5JFCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCiJAJKYQImZBCiJAJKYQEmQJSCBEyIYUQIRNSCBEyIYUQIRNBJgkyIYUQIRNSCBEyIYUQIRNSCBEyIYWQIFNECiFCJqQQImRCCiFCJqQQImQiyCRBJqQQImRCCiFCJqQQImRCCiFCJqQQEmRKSCFEyIQUQoRMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMGSmECJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQgiQ6fbfIJMEmZBCiJAJKYQImZBCiJCJIJMEmZBCiJAJKYQImZBCiJAJKYQImZBCSJDJIIUQIRNSCBEyIYUQIRNSCBEyEWSSIBNSCBEyIYUQIRNSCBEyIYUQIRNSCAkyWaQQImRCCiFCJqQQImRCCiFCJoJMEmRCCiFCJqQQImRCCiFCJqQQImRCCiFBJocUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyERIIUTIhBRChExIIUTIhBRChEwEmSTIhBRChExIIUTIhBRChExIIUTIhBRCgkweKYQImZBCiJAJKYQImZBCiJCJIJMEmZBCiJAJKYQImZBCiJAJKYQImZBCSJApIIUQIRNSCBEyaU4hwmYOmeK3gefiq2dzQHmW6UTUtO2iRpNrR9st70dbG78d/VsmzSmEIJkIMkmQSXMKIUgmzSmEIJk0pxCCZNKcQgiSSXMKIUemqDmFECST5hRCkExIIUTIhBRChEwEmSTIhBRChExIIaaQiZzbj6ZUu6USyH4dHMJDUhdKs8yPmzXb0zDKBwdzHB2s3ypHm2jCzvv2d3a1V88H75DNUy2Wbu2k262lr4OTDfb54N91i1gGdSuxbpFToW4l1i2CO9StwLpNSDJRtxLrFtEu6lZi3SLrRt1KrFuE/6hbiXVLqFvUrcC6xe0h1K3EusX9MtStxLrF/TLUrcS6xf0y1K3EusX9MtStwLrNuF+GupVYt7hfhrqVWLe4X4a6lVi3uF+GupVYt4S6Rd0KrFvcL0PdSqxb3C9D3UqsW9wvQ91KrFvcL0PdPl7Y+njUbaq9tEnhGPWvv+nb8b+rC3e1UF1XVVfYcO8J1XVddeEOEarruurCfRxU13XVhbstqK7rqotQXaiuy6oLdy5QXddVF+4voLquqy7cBUB1XVddyOpRXddVF7J6VNdl1WWQ1aO6rqsuZPWoruuqC1n9RdUVj++m3P78fvRv8IixB4EngB8DHuHnIPDIBQeBR2Q2CDzSpEHgEbSMAW+RQQwCD3s+CDyc6yDwcK6DwBPAjwEP5zoIvGLn6lzcM2TjyNsKSnMbzBH1mhQfP8wLRfCbPcBb+3Tsb+yKfetI7Ipd60jsij0rbfEYNxmKFexhe/z0NzyOTfY3SKfYg/KCVOwpeUEq9oi8IBV7Pl6QBJA8IBV7Ml6Qij0WL0jFrokXpGIfxAsSzoYHJMHZMIGEs2ECCWfDBFKzswmUD5Ch+qVm6+JO0rr8lNanz0M3ImAfgV2zaxqIXbPHGohdsyMbiF2zfxuIXbPbG4fda/aGA7FrdpIDsWv2nQOxw6UOwU7APgI7XOoQ7HCpQ7DDpb6NncyxZQPR9g37b5Rwnmwo4Sa5UAY4RDaUcH1sKOHk2FDCnbGhJKDkQgkXxYYSzogNJdwOG0q4HTaUcDtcKCPcDhtKuB02lHA7bCjhdthQElByoYTbYUMJt8OGEm6HDSXcDhtKuB0ulAluhw0l3A4bSrgdNpRwO2woCSi5UMLtsKGE22FDCbfDhhJuhw0l3A4Xygy3w4YSbocNJdwOG0q4HTaUBJRcKOF22FDC7bChhNthQwm3w4YSbocJZdzgdthQwu2woYTbYUMJt8OGkoCSCyXcDhtKuB02lHA7bCjhdthQwu1woTRwO2wo4XbYUMLtsKGE22FDSUDJhRJuhw0l3A4bSrgdNpRwO2wo4Xa4UFq4HTaUcDtsKOF22FDC7bChJKDkQgm3w4YSbocNJdwOG0q4HTaUcDtcKB3cDhtKuB02lHA7bCjhdthQElByoYTbYUMJt8OGEm6HDSXcDhtKuB0ulAS3w4YSbocNJdwOG0q4HTaUBJRcKOF22FDC7bChhNthQwm3w4YSbocLpYfbYUO5lNtxdKB0MdSODmkn6W657dPR6Y5mKffCi2YpN8KLhoDmDM1SboEXzVLdPy+apbp5XjRLdee8aJbqtlnRhKW6Z1406IZP0aAbPkWDbvgUDQHNGRp0w6do0A2fokE3fIoG3fApGnTDZ2jWenY7Lxp0w6do0A2fokE3fIqGgOYMDbrhUzTohk/RoBs+RYNu+BQNuuEzNGs925sXDbrhUzTohk/RoBs+RUNAc4YG3fApGnTDp2jQDZ+iQTd8igbd8BmatZ79zIsG3fApGnTDp2jQDZ+iIaA5Q4Nu+BQNuuFTNOiGT9GgGz5Fg274BE1a69nAvGjQDZ+iQTd8igbd8CkaApozNOiGT9GgGz5Fg274FA264VM06IbP0Kz17FheNOiGT9GgGz5Fg274FA0BzRkadMOnaNANn6JBN3yKBt3wKRp0w2do1nq2KC8adMOnaNANn6JBN3yKhoDmDA264VM06IZP0aAbPkWDbvgUDbrhMzRrPXuSFw264VM06IZP0aAbPkVDQHOGBt3wKRp0w6do0A2fokE3fIoG3fAZmrWeTciLBt3wKRp0w6do0A2foiGgOUODbvgUDbrhUzTohk/RoBs+RYNu+AzNWs+u40WDbvgUDbrhUzTohk/RENCcoUE3fIoG3fApGnTDp2jQDZ+iQTd8hgbPojtHg274FA264VM06IZP0RDQnKFBN3yKBt3wKRp0w6do0A2fokE3fIYGz6I7R4Nu+BQNuuFTNOiGT9EQ0JyhQTd8igbd8CkadMOnaNANn6JBN3yGBs+iO0eDbvgUDbrhUzTohk/RENCcoUE3fIoG3fApGnTDp2jQDZ+iQTd8hgbPojtHg274FA264VM06IZP0RDQnKFBN3yKBt3wKRp0w6do0A2fokE3fIIm41l052jQDZ+iQTd8igbd8CkaApozNOiGT9GgGz5Fg274FA264VM06IbP0OBZdOdo0A2fokE3fIoG3fApGgKaMzTohk/R6O2GyW3262hyPnxDUxgJxR2J8eZpJKk07rClr4ODfXrlZO/Q9fbZA6Hr7eAHQtfrDcZBV/zMv4HQ9fqZgdD1OqWB0PV6sIHQCdD7Q9frGwdChyMdAB2OdAB0ONIB0OFI+0Nf7LmbaT/akfXfjv492bWcYGWyazmwymTXcj6VyZKmya7V6Vcmu1aHXZnsWp1tZbJrdZSVya7Vyb2e7GLPaqxMVlMHtdjzFCuT1dRBLfbMw8pkNXVQiz2XsDJZTR3UYs8OrExWUwe12PP9KpPV1EEt9gy+ymQ1dVCLPSevMllNHdRiz7KrTFZTB7XY8+Yqk9XUQS32TLjKZDV1UIs9t60yWU0d1GLPVqtMVlMHtdjzzyqT1dRBLfaMsspkNXVQiz1HrDJZTR3UYs/6qkxWUwe12PO4KpPV1EEt9sysymQ1dVCLPdeqMllNHdRiz56qTFZTB7XY86Eqk9XUQS32DKfKZDV1UIs9Z6kyWU0d1GLPQqpMdqkOitxjstXfBJq4/27Pbo9XtmkrHJsOHsnlyrH5IJ7z92N/AV/rmUkSgC/VSUoAvlQ3KwH4Uh21BOAE4H2BL+UsJABfyt1IAL6Uw5IAfCmXJwE4nGZX4GZb64FkIoiv5TXTscNSIlMjbtOxZ5Jz9HR0LL22N4ea/hfpp6PvJNcykSNJruUOR5IkkGQiuZafG0lyLaM2kuRaDmwkybWs1UiSa3mmgSTXehzdUJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk13r43VCS8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJNd6nNpQkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTXeuDhUJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk13ok6VCS8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJNd6aPBQkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTXeqz3UJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkEzwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSGR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8Dg9Js8HjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiaeBxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRtPA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIOngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkCR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJD4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkgMfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0QywuNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSKZ4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJHM8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxeEjaDR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJA4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4mkhcfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0TSweNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJJ8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEh6eBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQDPA4XSXgcLpLwOFwk4XG4SBJIMpGEx3mPJNmYv44m523laEPxeG1vnsadSrMMW/o6ONjwdKz90gjuaX6N4Mvm1wiOb36N4CWn1yjCpc6vEfzv/BrBWc+vETz7/BoRNJpeI+QM82uEnGF+jZAzzK8Rcob5NVKcM7hjICZsrkLd2m37OtqS+67Rb5JJcRrATFKxZ2cmqdhZM5NU7H+ZSRJIMpFU7CWZSSp2fMwkFfsyZpKK3RMzSXgcJpIZHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOD0m3weNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJp4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJG08DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEg6eBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQJHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kPj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSAx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRDIu5XGSP0jmjb4dfZ/tUj6kOtulvEJ1tkv189XZkqrZLtUXV2e7VO9ane1S/WV1tkv1gNXZLtWn1Wa71vPUq7NV1Uut9Vzy6mxV9VJrPd+7OltVvdRaz8muzlZVL7XW86ars1XVS6313ObqbFX1Ums9/7g6W1W91FrPEa7OVlUvtdbzeKuzVdVLrfVc2+psNfVStNbzYauz1dRL0VrPWa3OVlMvRRupmq2mXorWeu5ndbaaeila6/mZ1dmq6qXWeg5ldbaqeqm1nudYna2qXmqt5yJWZ6uql1rr+YLV2arqpdZ6Tl91tqp6qbWed1edrapeaq3nxlVnq6qXWuv5a9XZquql1nqOWXW2qnqptZ4HVp2tql5qredqVWerqpda6/lU1dmq6qXWes5Tdbaqeqm1npdUna2qXmqt5w5VZ6uql1rr+T3V2arqpdZ6Dk51tqp6qbWeJ1Od7VK9VDb+mG2oHW1i+jrYPu2AY9NWODYdPJLLlWNz2oec8/dj78SX6udEEF+qpxRBfKm+Nsd92GRoqxxto7M78pifj6YS8xurHbo14dvRd5JL9cwjSa71rJmhJJfq9YeSXMpHDCW5lEcZSpJAkonkWt5qJMm1PNNIkmt5oZEk4XG4SMLjMJFc61kzQ0nC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEhmkOQhudazZoaShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIrnWM6CGkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51rPZhpKEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx+Eh6dd6ZuJQkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTXepbpUJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk13rG8FCS8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJNd69vdQkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQJHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kPj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSAx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRDLC43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIpngcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkczwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XF4SIYNHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kDj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiaSFx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLB43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIknwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSHp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJAM8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkhEeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQSPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJZIbH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NDMm7wOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSBp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJC08DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkg4eh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSYLH4SK5kschcxxNJodvR99nu5IPqc92Ja9Qny2pmu1KPXd9tiv1xfXZrtS71me7Un9Zn+1KPWB1tks9q70+W1W91FLPPK/PVlUvtdSzw+uzVdVLLfUM7vpsVfVSSz3Luj5bVb3UUs+Ers9WVS+11LOV67NV1Ust9Yzi+mxV9VJLPeu3PltVvdRSz8ytz1ZVL7XUs2frs1XVSy31DNf6bFX1Uks9C7U+W1W91FLPFK3PVlUvtdSzOeuzVdVLLfWMy/psVfVSSz0rsj5bVb3UUs9crM9WVS+11LML67NV1Ust9QzA+mxV9VJLPUuvPltVvdRSz6Srz1ZVL7XUs93qs1XVSy31jLT6bFX1Uks9a6w+W029VFrqmV312WrqpdJSz74iMm6fbTRbYbZL9VLV2ZKq2S7VS1Vnu1QvVZ3tUr1UdbZL9VLV2S7VS9Vmu9SzgeqzXaqXqs5WVS+11HNw6rMlVbNV1Ust9cyX+mxV9VJLPTulPltVvdRSzyCpz1ZVL7XUszzqs1XVSy31TIz6bFX1Uks9W6I+W1W91FLPaKjPVlUvtdSzDuqzVdVLLfXMgPpsVfVSS+29X5+tql5qqT3s67NV1UsttRd8fbaqeqml9lSvz1ZVL7XWvufV2arqpdba97w6W1W91Fr7nldnq6qXWmvf8+psVfVSa+17Xp2tql5qrX3Pq7PV1EvlAXlyiPvRPiT3PNv7iAZ8trYH/y38HBEVR2TdLoRzMVVG5ELe9qPT9vwDD/p6E9/jTUKPN4k93iT1eJPc4U1OUgjmNzE93sT2eBPX4016fOKpxyeeenziqccnnnp84qnHJ973+MT7Hp943+MT73t84n2PT7zv8Yn3PT7xvscn3vf4xPsen/jQ4xMfenziQ49PfOjxiQ89PvGhxyc+9PjEhx6f+NDjEx96fOJjj0987PGJjz0+8bHHJz72+MTHHp/42OMTH3t84mOPT3zs8YlPPT7xqccnPvX4xKcen/jU4xOfenziU49PfOL4xKd4HJ03U3iT1ONNcoc3yVuPNzE93sT2eBPX402ox5t45jcxtvAmHJ/4dNz+cdlu397k59HpuMWS3OMOi01b4djbBenr2Jy/H3sffJQ8+CR58Fns4O22bZIHbyQP3koevJM8eJI8eC958HJX2Nvg5a6wt8HLXWFvg5e8wpq5V9iwH2u2zRZGP/cSWxv93GtsbfRzL7K10c+9ytZGP/cyWxs9xzqbbTxG72Nl9K+/Y3gbUZxuRGm6EeXZRmS36UZkphuRnW5EbroR0XQj8tONaLprtp3uCmn7XyFfflPdbs5NN6L+n7VoHyOy8eeI/HQjCtONKE43ojTdiAZ8+ikcI/L0PKKfB1s6BmKJ6MfwaZM9fCN7+Fb28J3s4ZPs4XvZww+yhx8nH75Nj+H/bMgoyR7+7Kvu6+H7yVdd7/eex/rgXh8cbrfrvw4Ot3z151wnX6I/mavPMb+c6+TruT+yX+ujeX1w2vYXTvT0Q2sXv6Y6+drPOVXSM9XJewrOqU7ef3BOdfJehXGqYfaV9ZOp+j13TDF8m2rhhW//eX9h4x8vTKUJ2rQveW77dugd4ewLtgCEK/UBgxCu1F8MQkhA+KcIV+qHBiFcqc8ahHCl/m0QwsnzLgkIJ8/cBCCMcCd/jBDu5I8Rwp38MUK4kz9FmLRW4ZbtgfDpq1JFhCntg/j24+DiC5vbe++vfPs7Pn0FO/sv5lrLdiRzAvPuzLXa9pHMtfr8kcy1BgMjmWtNEkYy1xo9DGSetWYVI5lrDTdGMocP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDezM3G3xof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmRv40P7M4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDuzO38KH9mcOH9mcOH9qfOXxof+YE5t2Zw4f2Zw4f2p85fGh/5vCh/ZnDh3Zn7uBD+zOHD+3PHD60P3P40P7MCcy7M4cP7c8cPrQ/c/jQ/szhQ/szhw/tznz2J5guyRw+tD9z+ND+zOFDuzMX9QzF9PrgGPZjY/xG8T5TSdX1ZzMlNTMd4egfD6j3lcG/eun7+IPw8Ufh40/Cx59lj3/I8yM5x2+mHj9tbn+AMm05V17a0dEsOEpPw6b8NVurarZO1WxJ1Wzn7hu4Zzt3l8E927l7Eu7Zzt3BcM927n6HebZx7u6Ie7aqeqkot5e6j19ud3QfPwkfv9wO5j5+uT3Jffxyu4z7+CfvG8wRKJIzVHnptNEetrvHXG3aCsfmtL9wzt+PvXOZvMMYxSVN3osM4zJ51zKMy+T9zTAuk/dNw7gQuBS5TN7nDeMyef84jMvkfekwLuh3y1zQ7xa5ZPS7ZS7od8tcaHIuZs8jydhCHpBn7zNq45+9H6iNf/Z1uzb+2dfX2vhnXwdfj99us69XtfHPvq7Uxj973lEb/+y5RG38stdfu8lef+0me/21m+z1126y11+7CV9/jfD11whff43w9dcIX3+H7O/POX7h668Rvv4a4euvEb7+GuHrrxW+/lrh668Vvv5a4evvkH2NOccvfP21wtdfK3z9tcLXXyt8/XXC118nfP11wtdfJ3z9HbKfI+f4ha+/Tvj664Svv074+uuEr78kfP0l4esvCV9/Sfj6S8LXXxK+/pLw9ZeEr78kfP0l4euvF77+euHrrxe+/nrh6++QPQc5xy98/Z18J8H6+IWvv5PvJFgfv/D1d/KdBOvjF77+zr43YHX8wtff2ffvq45f+Po7+x571fELX39n3wevOn7h6+/se9VVxy98/Z19P7nq+IWvv7PvJ1cdv/D1d/b95KrjF77+Tr+fXG38wtff6fdnq41f+Po7/X5ntfELX3+n3z+sNn7h6+/0+3HVxi98/Z1+f6va+IWvv9PvF1Ubv/D1Nwtff7Pw9Vf4/ldW+P5XVvj+V1b4/ldW+P5XVvj+V074/ldO+P5XTvj+V074/lduk73+uun3v7psX9GwH2u2X7N6OvgORu1G1zUwane6roFRu9V1DYzava4rYKbfvGwYGLlPMbmPX+7TRu7jJ+Hjl9vV3Mcvt/m4j19uj3Afv9yl/D5+uSvu7/FPv6tYbfxyn9ZwH7/w9Xf6XcVq4xe+/k6/q1ht/MLX3+l3FauNX/j6O/2uYpXxT7+rWG38wtff6XcVq41f+Po7/a5itfELX3+n31WsNn7h6+/0u4rVxi98/Z1+V7Ha+IWvv9PvKlYbv/D1d/pdxWrjF77+Tr+rWG38wtff6XcVq41f+Po7/a5itfELX3+n31WsNn7h6+/0u4rVxi98/Z1+V7Ha+IWvv9PvKlYbv/D1d/pdxWrjF77+Tr+rWG38wtff6XcVq41f+Po7/a5itfELX3+n31WsNn7h6+/0u4rVxi98/Z1+V7Ha+IWvv9PvKlYbv/D1d/pdxWrjF77+Tr+rWG38wtff6XcVq41f+Po7/a5itfELX3+n31WsNn7h6+/0u4rVxi98/Z1+V7Ha+IWvv9PvKlYbv/D1d/pdxWrjF77+Tr+rWG38wtff6XcVq41f+Po7/a5itfHLXn9p+l3FauOXvf7S9LuK1cYve/2lTfb6S4J3FbuPX/b6S4L36LqPX/b6S4J3vPo9fsEbU93HL3z9Fb7/FQnf/4qE739Fs+9/FVzex582V3npjzaWS/sMc/5+7J3L5Ov6MC6T9wvDuEzeh1zH5fUGjTT7BmPDwMy+c9k4MJO3ZOPATN7rjQMzeRM5DgzNDSYdL02JamBicF8HxxiOY8l+TXXyRpZzqpP3ppxTnbzdfDHV+/gnbwur45+8e6uNf/Lt6bwhvx9sQsGeT749XX38c7cs9fHP3VnUx0/Cxz/3ql4f/9xLdX38c6+/9fHPvf7Wxz/3+vs8fmvsz/FPvj1dffxy1t/y+OWsv+Xxy1l/y+OXs/6Wxz/5+htNPA5OuTD+ydff6vgnX3+r4598/a2Of/L1tzb+ybenq49/8vW3Ov7J19/q+Cdff6vjn3z9rY5f+Po7+fZ09fELX38n357OJ7ftB+eQKi9N+Zjs81eZYi4ca+O2P87YRvvobMMXl8nX9VFcJt9ObxyXyfsQJi73uU7es7DOdfL+hnWupGiuk/dNrHOdvMdinevk/dhHc71FbvvBlApzXal3q811pX6sMtfJt0zknetKfVNtriv1TbW5rtQ31eZKiua6Ut9Um+tKfZP3R9+UCn3T5NtM8s51qb6pMtel+qbXc518q0veuS7VN1XmulTfVJnrUn1TZa6kaK5L9U2VuSrqmybfHvTVXO/jl9sL3ccvt7/5Pf7Jtwetj19uH3Ifv9ze4j7+ufuFsG37QIILpjB+Ej7+udf1+vjnXqvr4597/a2Pf+71tz7+udff2vj95NuD1sc/9/pbH//c6299/LLXX7/JXn/95NuD1scve/31k28PWh+/7PXXT749aHX8k28PWh+/8PV38u1B6+MXvv5Ovj1offzC19/Jt/Gsj1/4+jv5tpj18QtffyffZLI+fuHr7+RbNtbHL3z9nXwDxPr4ha+/k29VWB+/8PV38v0H6+MXvv5Ovv9gffzC19/J9x+sj1/4+jv5/oP18Qtffyfff7A+fuHr7+T7D9bHL3z9nXz/wfr4ha+/k+8/WB+/8PV38v0H6+MXvv5Ovv9gffzC19/J9x+sj1/4+jv5/oP18Qtffyfff7A+fuHr7+T7D9bHL3z9nXz/wfr4ha+/k+8/WB+/8PV38v386uMXvv5OvpdeffzC19/J97yrj1/4+jv53nT18QtffyffQ64+fuHr7+R7vdXHL3z9nXxPtvr4ha+/k++dVh+/8PV38j3O6uMXvv5OvhdZffzC19/J9wyrj1/4+jv53l718Qtffyffg6s+fuHr7+R7ZdXHL3z9nXz/q/r4ha+/k+9/VR+/8PV38v2v6uMXvv4K3//KC9//ygvf/8oL3//KC9//ygvf/yoI3/8qCN//Kgjf/yoI3/8qbLLX3yB8/6sgfP+rIHz/qyB8/6sgfP+rIHz/qyB8/6sgfP+rIHz/qzD7/leU9oODN7Yw/snXXxcP/rcTKy+dNvo6OLnHs8Jt2grH5rS/cM7fj71zmXxdH8Zl8n5hGJfJ+5BhXCbvb0ZxmX3fsmFcJu/HhnGZvM8bxmXy/nEYFwKXIhf0u2Uu6HfLXNDvlrmg3y1zQb9b5DL7PoHDuKjtd8N+rNk2WwCjtuGtgVHb8dbAEMCUwajteWtg1Da9NTCTdzE+5R3M7Q5M5aWNz5vbp+uzccfx4T7b2ffwezHb+/gnXxGq45/7wh1j3A+O8amHK7+0jcF/HW1jdM8vfZ/s3Bdj5snOfYFlnuzcUQHzZOf2/8yTnXs55J3s5DsaMk92bvvNPNm5+5xPJ5vtPtn01FUck527KWKeLGma7EodlLPb3hw7a+PPya7UQVUnu1IHVZ3sSh1UdbIrdVC3yW6vJjv5nogfTpbMfrQju/2c7ErrbHWyK62z1ckutc7WJrvUOutyOiZrttcv7XPcL90+58LVbKlF+RMyYTuu82ErNKKT7z3Zp2bKZJZa7skdvQ1582efpsn3y+xDplgzk+/E+SmZ49ado5x+TnatFrEy2bVaxMpkSdNk12oRH5P1T3fFj8ku1SLWJrtU11eb7FKNXG2yS/Vm7jEQb+LrlzYh7f28ifT0Y1gX72gm34z0QzTx+Omvi9n9Wds6+TanF5KpmcDJN1DtUzNlMrQUmeOl3V9uShUuNFs+vnBm3Fa40CzVNyVLB5pceWna9kGT/X4FLmB8RBLmFt8dR7sD41Id2TiMS/V64zAu1UWOw7hUfzoM4+QbE4vBuJQlGIdxKf/wEUa32wd6nuEBZin7wAlm8h8t8f4EZfZtnJlnO/mP6plnO/lP5Zlnq+mnY3H27aeZZzv5j9WZZyv3Z4Ets5X7I8KW2dJas3X0mK23T7MtH22fjg4/2CzWebGyWaxPY2WzWFf3ARsyh/8l+3QbciezWAfISGaxbpGPzOwbqw8ks1gXykhmsY6Vkcxi3S0jGQKZEzJ6++AaGb1dcI0MeuAzMuiBz8is1gOfucTCa6fjG5nRPf3o6OS1c9onecP49DAWyneSs2+qL4jkaj02D8k7m9W6bE42q/XZLxOvk03TzbETo7M2V2Zr0rZv2mOSeWYTirPdHrPdwvNs7yOK/UdkHyP6uRlCPNkofOSI8mwjOtkce+SIzHQjsv1HROFxZal85dvScYmzRPRz+E728En28L3s4QfZw4+yh59kDz+LHj5tkw/fpsfwfzZkZGQPf/ZVtzL8yVdd7/eex/rwZz9EjDT5Ev3JXCs/LYw0+XrujTvmGiv7oqTjCcOJnsb89T3oSJOv/ZxTnbxP4Jzq5D0F51Qn7z8Yp+on71U4pzr7yvrJVP0+jBTDt6kWXvj2n4/k/GnLKypN0D5+Tb99O/SOcPYFWwDClfqAQQhX6i8GIVypbxmEcKV+aAzCuFLz8QnC7fG4APN0S6yIMKV9ENlUf9R8e+/j9l+K8XG8zf6L+eTpzpLMJ4+klmSutdsfyZzAvDtzrX5iJHOtBmQkc62OZSRzrRZnJPOVsmchzBN8aH/m8KH9mcOH9mcOH9qfOYF5d+bwof2Zw4f2Zw4f2p85fGh/5vCh3Zln+ND+zOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ3szTxt8aH/m8KH9mcOH9mcOH9qfOYF5d+bwof2Zw4f2Zw4f2p85fGh/5vCh3Zkb+ND+zOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ7szt/Ch/ZnDh/ZnDh/anzl8aH/mBObdmcOH9mcOH9qfOXxof+bwof2Zw4d2Z+7gQ/szhw/tzxw+tD9z+ND+zAnMuzOHD+3PHD60P3P40P7M4UP7M4cP7c589gfcLskcPrQ/c/jQ/szhQ/szJzDvzhw+tD9z+ND+zOFD+zOHD+3PHD60O/OlHl4uhTl8aH/m8KH9mcOH9mdOYN6dOXxof+bwof2Zw4f2Zw4f2p85fGh35gE+tD9z+ND+zOFD+zOHD+3PnMC8O3P40P7M4UP7M4cP7c8cPrQ/c/jQ7swjfGh/5vCh/ZnDh/ZnDh/anzmBeXfm8KH9mcOH9mcOH9qfOXxof+bwod2ZJ/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7M8/wof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOH9maeN/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7Mzfwof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmdu4UP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3O3MGH9mcOH9qfOXxof+bwof2ZE5h3Zw4f2p85fGh/5vCh/ZnDh/ZnDh/anTnBh/ZnDh/anzl8aH/m8KH9mROYd2cOH9qfOXxof+bwof2Zw4f2Zw4f2p25hw/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ78wAf2p85fGh/5vCh/ZnDh/ZnTmDenTl8aH/m8KH9mcOH9mcOH9qfOXxod+YRPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7ME3xof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmWf40P7M4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDOzN32wYf2p85fGh/5vCh/ZnDh/ZnTmDenTl8aH/m8KH9mcOH9mcOH9qfOXxod+YGPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7MLXxof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmTv40P7M4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDuzMn+ND+zOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ7sz9/Ch/ZnDh/ZnDh/anzl8aH/mBObdmcOH9mcOH9qfOXxof+bwof2Zw4d2Zx7gQ/szhw/tzxw+tD9z+ND+zAnMuzOHD+3PHD60P3P40P7M4UP7M4cP7c48wof2Zw4f2p85fGh/5vCh/ZkTmHdnDh/anzl8aH/m8KH9mcOH9mcOH9qdeYIP7c8cPrQ/c/jQ/szhQ/szJzDvzhw+tD9z+ND+zOFD+zOHD+3PHD60O/MMH9qfOXxof+bwof2Zw4f2Z05g3p05fGh/5vCh/ZnDh/ZnDh/anzl8aG/mZoMP7c8cPrQ/c/jQ/szhQ/szJzDvzhw+tD9z+ND+zOFD+zOHD+3PHD60O3MDH9qfOXxof+bwof2Zw4f2Z05g3p05fGh/5vCh/ZnDh/ZnDh/anzl8aHfmFj60P3P40P7M4UP7M4cP7c+cwLw7c/jQ/szhQ/szhw/tztxJ8kTp9cEx7MfG+I3i75mSJCfyZzOV1P//2UxHdN3mMdPK4F+99H38Tvj4Sfj4vfDxB+Hjj8LHnyYfv98vyyZbV3lpQznvR/unXuH20vfJZkWTHfK86WGTNQtN1qZ4tBcp58rRzua0T/JW4sfRXx9wP3uDMY7M7K3LODKkl4wL+SCT4hOZn8eSOSiSNfEHxdlbMxkUZ28QP6O4xZ1iNlvl6HTMMbnHFG+vUTg2p30YOX8/9k5x9jZVBsWVmuVxFFfqwodRDCu19+MoruUbRlFcy2OMoriWHxlFkUCRgeJa3mUURXgXDorwLhwU4V04KMK7MFCM8C5vUQz7sWbbbAEjzAsLRrgXFoywLywYCRg5MMLAsGBcysHkx12prYrRUDzYePP02qk0krDtN7GCffq2bPr6ml9cysMM5LiUixnIcSkfM45jWsrJDOS4lJUZyJHA8T2OtB8cvClwxHr9Jsfj5zkhpAJHxeu1N8ewvaNvHO9sFK/BNTZZ8bpaZaN4rayyWSrL+/C6fQzkxsZXrtu3t0/0GEr+8b3LvFScN5QkgSQTyaVCvaEkNed6vCRXcgpuc/EgmWsDqXxzP6/U+/OSWanz5yRjt5X6/s/IGBP8fvjt76ftOcyWS6/+8jdcdlvJJYwluZKnGEtyJU9xMUm2X9DZjUB9APWVvMqn1KM9XvwW5bkKdRvj8fWG+LSdzk5yJa8ylqRer8JNUq+3+ZQk5/1Nu+l1TkO5G82+bCR3zS5uJHfNnm8kd80OcSR39NgXcX/5PSNr0M9cxP3l95KsRT/zNvfKdy6sRY/CxxJ9Bx9L9BJ8LAks316nOL9fYC1y5FHk0ROPIo+cehR55NqjyCt2grebpQfKW9RMFfK3u62Pp82kJyjJF+/kbMfR0dq/cneKneBQ7opd41Duih0mI/c7S8UOk50lgSUbS8WekZ2lYhfIzlKxr2NnqdipfcrSHjc/bwH7VmAJ78XGkuCn+Fiiv+RjiXX8bZaetp2l9yWWWMf5WGIdL7O808HK/ILOUo945KejOWG05nhe5u0W8la5SlV+t7fUMyTHktTc0fGSJJB8lyTfrxqXeqalHOqavcs36sEU1nnNbqROR7O/qNPR7C9cSgcdotr3XWywR8IS3NPR+b5XvF3qiZQ9WcYCS83e5Q9Yki2w1OxePmV5jMWG4L+xLI0lbMdYwvM9qlScZzwMe0qucnSy+zQTmW/H3jXV7KNW1ZSg6XKaavaLq2qq2Y2uqqlmD72qppqd/6qaIq9YTtOlnoarRlO/fz0z+VjQFPmNQE3p+Jw+AXxoihxJtKbBFTSFP51BU+vdDuV2i9kWdILnnEOnx66owfiCTvCRMnSCN5ShE/yeCJ2Weg7wyjrBl8nQCV5Lhk7oy6fwxPnxRbdcyhiXep71yjqhL5ehE/pyETot9RzxlXVCXy5DJ/TlMnRCH3GRTpb8gTD5ik4uJLcfHVIu6IQ+QoJOTvNziUXphD5Chk7oI2bQidzxmBxyyRV0wu9sptApHzks5ZQKOhF0mksnv22l6x6+byRDJ9zXkKET7mvI0Al5hAydkEeI0Enz87hF6YQ8QoZOyCNk6IQ8QoZOBJ1E6IQ8QoZOyCNk6IQ8QoZOyCNk6IQ8QoROFnmEDJ2QR8jQCXmEDJ2QR8jQiaCTCJ2QR8jQCXmEDJ2QR4jQyaEvv0gnczwd4BZ2V7+37A6dnCt9z9KhL59Op1z43rJDXy5DJ4JOInRCXy5DJ/TlMnRCXy5DJ9wnlKET7hOK0Ilwn1CGTsgjZOiEPEKGTsgjZOhE0EmETsgjZOiEPEKGTsgjZOiEPEKGTsgjROjkkUfI0Al5hAydkEfI0Al5hAydCDqJ0Al5hAyd0Jc36RRtRacY9g1fYwzHsWTv2APa7CHY0TUPwY4m+G3sMe6H27S5Cvbs0o4w0/b82PXiWpDyYy14OjiWxpGTOWa52dcHG7PFQxzzDcrXMhPQXnNUwJ0lgeW7LJPNB0u/FVgi5n+fZaCDZQg/WUbNV3nvjnFbH02FZY77LvNmM08X19vA7yg1Xy7DZg6U8dvAc/HV87FQ2Wf3dNLVpP2pQrfXzrWjjTkuxYZi5eiUdyjZFC41UfNle1VNNaccq2qq+RsaUjXN2R0L6pa+ifrz4JCPWYZsKq4p3Vqjr4OTDfaHs4maO0iUy8flovn7KiiXj8tFczyPcvm0XJLm2wool4/LRfPtEJTLx+WiOeBDuXxcLggxUS4flAuhXFYql7uoCEgXFBUJ6YKiIseUJ+pNhu1QlbbKcm1yOG7457zMd4syQg+BlXuzB/vAXbY/r0cZ2cSKqiJCkK5qLqgKp7+iqgRVF1QVjnxFVWHJV+yW4MlXVBVfAVpRVXxTZz1VaUO2tKKqyJZWVBXZ0oqqIltaUVWkECuqihRiClXtdvzq3drvqt51Qq4gQyckBTJ0gvcXoZOBm5ehE/y5DJ3guOfQ6Xj09k2mraATPLQMnQg6idAJ/kmEThb93hw6Hd/3tu4vI7nrhH5vCp2cPz5P3zaLPnRCvydDJ/R7MnQi6CRCJ9ytkqET7j/J0An+SYZOuP8kQyfcf5pCJ3L79yMsJVc5OtC+B3gIj2zdhdIsk9+RpJS/Hftbf4ecQ7f+yE90649cZm398+NJHZvJlYO9cfttW28SVY4OwW3HOJwpFBfCJBTXZcVFKC4U11XFhdgOxXVZcSFrRHFdVlwISFFclxUXUl0U12XFhSgaxXVVcRFybhTXZcWFEB3FdVlxIaFHcV1WXEjoUVyXFRehuFBcVxUXEnoU12XFhYQexXVZcSGhR3FdVlxI6FFclxUXEnoUV2NxRXdUSbwR+VlcHgk9iuuy4kJCj+K6rLgIxYXiai2u5I/iesL9KC5EESiu1uIie1y5buMvFBcaehTXVcUVcOMaxdVaXMnvQGIKpeLCjWsU10MbOrab9WS2QrkQygXl8n654OYyyuWDcoFHQ7k8aXNYep+2wm2UgBvAKJcPygW3dFEuT9qE7SgXW/NRxm32UMdtf3FSJeAP6W9/B1M73vuDofFhKyyOEU4N5duvfI9Z/irf2mgMJX8MnlIs5O8JKRbKt7l8jT1e3BlfuDomXB1RXheWF6G8UF7XlRdyMpTXheWFXA3ldaJNLJQLcjWUywflglwN5fJBueC7UiiX98sl4+cMKJcPygU/UEC5fFAuSKVRLh+UC3IalMtDm3w8E8Tn5AvlgtwF5fJBuSB3Qbl8UC7IXVAujxfejq+/BWNKvQtyF5TL2+XiN+QuKJcPygW5C8rlg3JB7oJy+aBc8O0+lMsH5UIoF5TL++WCVBfl8n65GPQuKJfHCxuKR7kUdtjwBr0LyuWDciGUC8rl/XJB74Jy+aBccEca5fJBueCONMrlg3LBHWmUy1O5HEcH+5efpf08OlnaqyTZYB+DTl+1hdvXqK2LasviXjdq66rawo1x1NZVtYUkGrV1VW0htkZtXVVbhNpCbbXVlgn+2AD/9vdTdR0xhEUmjvK6sLyQoaO8LiwvZO4orwvLCxk9yqu9vKJ5lFcqlJdD3IXyai6vkOgor7gVvnvpkHihvJrLK9rH4hgpFMoLoRfK68LyIpQXyuu68kLuhfK6sLyQe6G8Liwv5F4orwvLC7kXyuvC8sLXU1Fe7eWVwqO8noAf5UX4hirK68LyQmqP8rqwvJDao7yayyttx5NxQzKmUF5I7VFeF5YXobxQXteVF1J7lFd77/X0hZxkbO34hsfSH8GH9zkXyhd3BVC+gssXdx1QvoLLF3c1UL6Cyxd3TVC+csvX464Myldw+eKuD8pXcPnirhLKV3D54q4Vynfi8j1uW/iwbYXyJZQvyrdb+R6z/FW+tdEYSg+B6K+vfy9fJA8o33nL16dH+cbCN6oCkgeUr+DyRfKA8hVcvkgeUL6CyxffOEP5tpevf/q2fyiVF74RhvK6sLzwjS2U14XlhW9UobwuLC/kjiiv68orIhdEeV1YXsjtUF4XlhdyNZTXheWFb9ygvJrLKx28b3/7wt7UkVBeKK/rygupPcrrwvJCao/yurC8kNqjvC4sL8SqKK/m8sqPL8eHHOhneSXEqiivC8sLwQTKq728wmNxzDEXygu3tFFereUVrTmeyXb72/8sr4ybQiiv9vLy7lFeqfBDw4ybQiivxwtbH4/ySvEPjr4XFzovFNdlxUUoLhRXW3GZFB4/+7j9XXCNGTeEUF4XlhduCKG8Liwv3BBCeV1YXsi8UF4XlhfuN6K8LiuvsOF+I8rrwvJCYo/yurC8kNijvC4sL2T2KK/m8ormIXz0plBehPJCeV1XXkjtUV4XlhdSe5TXheWF1B7ldWF5IbVHeV1YXkjtUV7XlZdBao/yurC8kNqjvC4sL0J5obxayyttx+POUjJbobzgHFFezeWVn65e2ZWuXnCOF5VXJDrKi74ffScPUzWIvIXfGEUerfgo8vhuySjy+NrFKPIE8heRj4/WOZoCedysH0Ue97FHkYdRH0UeHnYUeXjYQeQd+vmryOdHV5lDgTx6m4vIJ9qTUJu8K5BHbzOKPHqbMvk7HfQfr+igR3hBh5BFv6KDvPgVHfSAr+hozl2zPb5WYHOOlfU/bI+tJ5863mS/SBJIMpHU7B14SWr2ArwkNff2vCQ1+wBWkl5z3/chyeMmaHj6duqDJNbut0mGx5f2UoGk4rXbubizMY68rZA0t8Ecm1GYFB9faw3FxHWzR+Jq7dOxd+6KV/qh3BX3BUO5K+4iGLnfWSrOHrlZBsVJJTtLxf0tO0vFKSg7S8WZKTtLAsv3WR6/xTImb+Zl/5RN3EeezdNvoHbu8GljuMOnjeGOHncI94i+4yLu9vDH2dr0gzt6lDHcCdyHcEc/U+Z+p4Ou4xUdZLiv6CBpfUUHfeULOglp6Cs6mvNNbx50/FMu9KCj2TnU6Wju7+t0CHRe0NHcK9fpaO6V63Q098p1Opp75Todzb1ylU7W3CvX6aBXfkUHvfIrOpp75dt15aATzXc6hVe3ef/KuXPm8Xi0r5Q1E0gykdTcg/OS1Nyvf0jydvxB8tu92p/HkjmokzU/7utmzT5gHHXN/uIbdVta5zX7i5u7eqITftCJmp/67aIzDzre/NGKEzU/4JqZpGbfwktSs8f5kCTbehw3AvUB1DV7p2/Ugyms86r90OMxITc6tkBHsW+hLR7jJkN/tvtA1Pw0TWaSin0LL0nNz0hkJqnY4zCTVOxxmEkq7vs+Jflyv5uo+Xlmn5J8ud9N1Px8MnLuSGTJ/WUX8J/H2xj3V7/9+ddfcETNzxtjJql57eYlqXnt/oykicEd84yBfrJUnFCysySwZGOpuavkZqk4e2Rnic7yfZbxscvM7e/8V5aanwP0OcuYHixT+MFS8zpODzbkLX1jeaejeWWu09G81tbpaF4963Q037mr09Gc6NXpaO6lqnQ0P13pDTqa07Q6Hc2ddaDjO7cUkqt11i+Pv9PU3Fvz0yTQZKSpuXf/jOYNxD5w67anO4zpy0Nrfi4TO0vNvoCbpWYXwc1Ss+f4A5bG/mTpNTsUbpaa/Qw3S7ift1m6w0pal/03loWjXz7953a3B9yHcCdwH8Id3ouD+50lvBcfS3gvPpbwXnws4b3YWGp+oh07S3ivt1l62qdp/fPvnA+W8F58LOGn+FgSWLKxRH/JxjJiHX+X5S3Pt8erPx99sMQ6zsdyqXXc0cHydvmqHJ3DPkezbY/Qx6btC81SyzIvmqVWWV40S4WFH6F52gXx15fNn45OX2yWCv+Y2SzVbDGzWSqcY2azVNjGy2atB6Axs1mqiWZmo7cprrPR2xXX2RDYnLJBX3zOBn3xORv0xeds0Befs0FffMpmrYedMbNBX3zOBn3xORv0xedsCGxO2aAvPmeDvvicDfriczZ6+2LazL4XFxmiAhu9fXGNTVrrIV3MbPT2xWRiPtjk7Rubwmu/fFRUWuuhWwM56u23eTkSOL7Hke0RWmmtR2gJYa7XS5B1x9puY6owp5T316ZsbeVoH/eX9vkJ39406DUpA6Erdj/joCu2VcOgr/XAMSnQFRvBz6Bn/4Ae8k9LvdazyYaSVGwGPySZj8/2ZgsxjyGQfJekPUhSKpBUbPI+JXkMe/OhQBLWjYsk/BgXScUmyx27JZH7C5vPjr6TVOyceEmu9QzHoSQVe5yPSBqKx88hvXn+fXFp3K+fMJzWet6jGOqKvdNA6gTqA6gr9mQDqSv2bwOpo6++hDrtBwdvflJf61mX81AP+0uHkArU0cO8Sd2bY5Le0Tfqd5IEkkwk0WtwkUT/wEVScf774ep0DPtG0ldWp9tgEz0Gnn98+Wyt54MK4o4eeAj3tZ5pKog7cusx3NdyfWk/2pH1346+z3apzjYd3y1yeaPCbFdau8kcR5PJ4edsl3o+2e1Dftzzj2YrzHalz219tiulJPXZ0kqzjY9vr6RtqxydjjneOuDj2F9b1P48Nh8X+5y/H3unuNK1fhzFlRKMcRRXSi/GUVyqnxlGcaVkYRjFpZ5uNY7iUj37MIpLeYFhFJfyGMMoEigyUIR34aAI78JBEd6FgyK8y1sUXz+jKAWYFw6MSz3TbyBG2BcWjPAvLBhhYFgwLtV71+6aLvVgu/psl+plq7Ndque027GTiqVUmO1SrWFttks9IK4+26Uarepsl+qHqrNdqm2pzpZWmq3z+7CJNls5OoTjV3/p0dDZfXe2pR6zxktmqR6NlcxS/dyL74UVbMyxL6Ix+emlaUezVPPHimath4jVvgW81mPBqrNd6vvs1dku9evhfPwG0OVQO9rEfWWwm6tEPoz3cdZ6IJgI4kv9ZkME8aV+tTwH8UrovNYz0WQgX+qXzTKQL/WjZgnI81oPhpOBfCnDJQP5Uq4vH/tLkaFa2GGj2389buO3x1JREbrfg5S0Rfp29J3kWo5yJEkCSSaSaznAC0maY4u/ZE0okFzL2Y0kuZZhG0lyLR82kuRa9iqOI7nW49mGklzLDI0kCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudYz14aShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFx3iQZjkmmmGyBJDwOF0l4HCaSDh7nTZI57CNJOZkCSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpJrPbFwKEl4HC6S8Djvkcyb3b6Oztvz0xwPkvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJD4/DRRIe512SMe8kzZYLJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJJd6ovRYkno9jns8E8jZFCokTXyMJAZ6HvYdpF6LwwxSr8NhBkkAyQNSr79hBqnX3jCD1OtumEHqNTfMIPV6mw9B5rwfbbetMuywbfstirCZn9SXejb1NNR9PkxTmTo807vUj2fy2M3Z18Omp6cBPv08zcXi1Sibx+Uo28ewbfZfIsGPCRAJXk+ASASR5hcJHlWASPC/AkSCtxYgEny7AJGQCcwvUkKEIEAkJA4CRELiIEAkJA4CRCKINL9ISBwEiITEQYBISBwEiITEQYBISBzmFykjcRAgEhIHASIhcRAgEhIHASIRRJpfJCQOAkRC4iBAJCQOAkRC4iBAJCQOs4tE24bEQYBISBwEiITEQYBISBwEiEQQaX6RkDgIEAmJgwCRkDgIEAmJgwCRkDjML5JB4iBAJCQOAkRC4iBAJCQOAkQiiDS/SEgcBIiExEGASEgcBIiExEGASEgc5hfJInEQIBISBwEiIXEQIBISBwEiEUSaXyQkDgJEQuIgQCQkDgJEQuIgQCQkDvOL5JA4CBAJicMVIrn9sSwU0zeR7tCRIAyAjkTgPejWHJO05mkk98fb3EASQPKAhLNmAgn3ywQSDvVdkM4dIHNmbNlcTvsUyZjjaHcsY/Cn00sEdzq7RARvOr1EcKbTSwQfO71EcL3TS0SQaHaJ4NSvkOh1YEdw9QOgL2UvXTowkvXfjr7PdimnVputX8r0VGe7lH8g95htDJWjTdyXs9tdk+NYm7bCsengkVyuHJsP5Dl/P/ZOfCk7IIL4Ut29COIE4tzEw36s2TZbQL5U8y0D+VKttwzkS916k4F8Ka8jA/lShksE8rCU63uB/D5bLa7vPlstjus+27XcTtoDapfI1C4eNh2fcufo6ehYfG3rD5IUvh19J0kgyURyLXMykuRanuNCkv74Ur/zaSuQXMtKjCS5lkMYSXKtxn8gybhWPz+S5FpeYSTJtXzISJLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQSPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmP8ybJ7I6fzW05FUjC4zCRzPA4XCThcd4jSfZB0npbIAmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMfhIWk2eJx3Sca8k3R/IfnZ0XfucERjuMM/jeEOt3UFd0PHpkXGm6dxp9Isw7b/wDHYp993JPulEUGj6TWCQ5xfI3jP+TWCq51fI/jl6TUy8DETaET7wcGbgkYEjcZrFOyuUUgFjdDXXaKRNwcS//zayX1xR682hjv6rzHc0VON4Y47Fteswcckb9x9ZQ2+Te0xlGxzPI6/719kLO6GSFAJnkOCSrjTIkEl3JeRoBLpVck9SIbN1bi/OPpOUrHPZiap2Dkzk1TshT8iae22PxrHkit8y8AqdrfMJBX7VV6STrGnZCap2Pcxk1TszZhJKvZPzCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJgsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFx3iTp7X609aXfOBI8zpskyeWDZNgqR/M9G9oQvNPsCsGTTa6Qh9ebXSF4yNkVgjedXSF43tkVIig0uULw6LMrBO8/u0LIFGZXCJnC7AohU5hcoYBMYXaFkCkMVygcvxHbNluQCKHC9BIhVZheIoJEs0uEXGF6iRAsTC8RXNGbEvkQD4lyfSegvLn9xX1+2hfu67f8UW4PcB+/3AXyPv7JV4/sjvLJRJWXtjHsA7ExuueXvk928usw72Qnz0p5Jzt57Mg72cnXKtbJpsnDMN7JTp4r8U528oSGd7KT9zkfTjbv2/faZOjnZEnTZNfqoCqTXamDcnbLj2HHn5NdqYOqTnalDqo62ZU6qNpkZ39w96eT3V5OdqV19hbM7C/tyG4/J7vSOlud7ErrbHWyS62ztckutc66nI7Jmu31S/t8bKPqcy5czZZalD8hE7bjOh+2QiM6+zNvu9RMiYyd/Rm2H146jhtCjp6e5tPyabKzP2W2C5lyzawUxTiK4SCT08/JrtUiViZLmia7VotYmexaLeJjsv7p/vwx2aVaxNpkl+r6apNdqpGrTNYs1Zs5e3zLxJtYeemQ9n7eRHr62oiLX2iWakFiOhxvzO7P2lazVL/yCZmKCbSzP8qzS82UySzVCT1e2v3lplThpbd8vLRxW+FCs1TflOwx7JQrL03bfr0m+/0KXBjGI5Iwt/juONodGJfqyMZhXKrXG4dxqS5yGMbZn/goBeNSQeM4jEtZgnEYl/IPH2F0u32gmH52grM/R3AcGPxe6ddr9/4xjMWj7wZxx6YlY7jjR3cXcXf04P60OXM4Odo+HR3+qhIe2SdCJWxJIkEl7EoyXqVf36s77JWJPzTCtiTza0TQaHqNsDHJ/BrB6c+vEVKB+TVCgjC/RkgbptcIj84UoBGShvk1Qs4wv0bIGebXiKDRRRqd5aSF107u+Fa9CaH22vmY5U3Qp1lS/tIUucR6miLHmFvTu0pIMiSohCyjt0q/uWt+UKVNR8vmHFVIkj1+/ELOV7lTfLSDT99BMan4kyPaDw5PP6o3yX5ppNhXzaNR3PmF5AsaKfZVYjQiaDS9Rop9khiNFPueiTQyh0ahoJFi1yNGI8WeR4xGiu/fzqNR2D1sCOmnRpofXSlGI+QM82uEnGF+jZAzzK8RQaPpNULOML9GyBnm12gpf+To0MjFUDma3GYf1J+PTn9O/fUdobiU45mH+uvcMy7lYcRQX8qViKG+lM8QQ51A/RLqLzPe2R9HvCj1pbp7MdSXui84D/XXLmn2J0UvSh3edAD12Z+dvSh1eNMR1OFNR1CHNx1BnUB9APWl+vXNHdS3XBuIoUD7bY3b3+n51XPheOvT/qva259PUNLXb11mf9q4KJZL9dZjWc7+rHRRLJfqgwezXKq7HcxyqZ71Wpbx2ErjdkNkK7AksGRjudS9j8Esl7qjMZglfA8XS7ehv3ybZcj7wG9/ugJLrONvs0xpP/xmcXyBJdbxd1neAqjHq9tcYIl1nI8l1nE+lljH32cZ7fHq6fva89nRd/JIO0eRRzZ6DfmQ/PG1+PS0I98Xd4M+dwx3ZK5juCOfvYh7PqCEbOMP7vCAY7gTuA/hDm85hjt86Bju8KxjuMOxjuEOv3oV98fPuLP/wd3Cr47hDr86hjv86hju8KtjuBO4D+EOv8rB/c4SPfm7LKvfHbHos9lYOvTOfCzRD7/N8tt37ajAEj0uH0v0rXwsCSzZWKK/fJ+lfbB0tb7+1iHtv6K5LUr0177e4X7IGO64HzKGO7zXRdxdyAf39JwffHLsXSN4uuk1InjF+TWCBx2v0evn0juCt51fI3jm+TUiaMSg0Z0lvPj7LB9PDo8xFVjCX7/PMh2ZesyF370RPHNTXRZZwgfzsYRfZWPp0Q+/zTL5fZq3P0ss0bfysSSwZGOJ/pKPJfrL91mSfc0S6/j7LCv70Kz1/OjBLJHj8rFEf8nHksCSjaXmbMO57WDpcqiwNDF6tx9/+/uBZWepOdvgZqm5J2JmudYTZq9mGdOD5dNT13aWmnsibpaaeyJulpozN26WBJZsLDVnbtwsNWdu3Czhe/hYwvewsVzr2Y8fstyOJ6obMhQrLMPjh+PePCUb9ouk5u7yQ5Ivn2Tv1npG41CSBJJMJDX3lbwkNXeVn5I0B8lQIKm5p+Qlqbmj5CWpOUf/kOTLp/c61U/25CUJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuPwkCTNT/J07tiq0jjytkLSmJSOlN3k7fnpOT+PzibuI8/mx+4EtCnuPodyV9yrXsvdmh1KtvYnd8Wd7VDuBO5DuCvumodyV9xjX8zdmYO7yz+4K+7Ih3JXfI9iKHfFdzRGctf8RN6h3OFXx3CHX72K+2YffWT6wR1+dQx3Avch3OFXx3CHXx3DHX51DHf41THc4VeHcNf8RN6h3OFXx3AnvdxttseuODbnP/vlGGl+5uinJF/+toSs4h6bmaTirpmZpOI+mJmk4s72Y5KvfqVDmp+Ay0xScffJTFLx/Y9PSb7+pq/mZ98ykySQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQ1P3HShs0cJOO3gefiq2dzQAm+crSN+fFcvb/sQHYnr7n/vJR8snt8b5NLBfIE8oPIa+5vx5LX3A9fS347nmGXTCyQ19w/jyWvud8eS15zfz6UvNd8z2Isec33OMaSh4cdRR4edhR5AvlB5OFhR5GHh72KfHw8CzcW0gMPDzuKPDzsKPLwsIPIa35a9MXkj5HfyOcCeXjYUeThYUeRh4e9ijylg7x3BfIE8oPIw8OOIg8PO4o8POwo8vCwo8jDww4iH+FhR5FHP38R+XBsi3B77Vw7mpzbj6bkKkcHenxL+ZH8u1CaZU7Hs3q3p2GUDw7W7wCDTbWX/rXzw/Hl6pTM9u34e3kRygvl1Vxe9BD++er1KC84M5TXheUF+4nyurC84LFRXjzlFWyhvBAkoLz+oLzoUV7R1149H7xDfv42UiocnOzx2sk+Ve7t4HvhIodB4Uos3IQYC4UrsnDxTRYUrsjCxReBULgiCxf3XVC4IguXULgoXImFi3tFKFyRhYu7UCjc5sLN9gB4+zt8O/5eXkhbUV7t18X8+AZQ3grfAMpw6Civ9quXeQifnSmUF7o6lNeFVy/0Xigvnt7LlcoL3wBCeV1YXvgGEMrrwvKCc0R5XVZefsO3aVBe7eXlHoFtJiqUF77zgvK6sLyQe6G8LiwvfH8E5XVheRHKC+V1XXkhtUd5XVheSO1RXu3lVbnn6Dek9iivC8sLqT3K68LyQmqP8rquvAxSe5TXheWF1B7ldWF5IbVHeV1YXkjtUV4XlhehvFBe15UXci+U1+OFzXH0rdK2WnlF644Xj7cpFMoLuRfK68LyQu6F8movr+Ae5RXzz/KyyL1QXheWF3IvlNeF5YXcC+V1YXkh90J5NZeX2w514q1QCuVFKC+U13XlhW+rorwuLC98WxXl1V5e9FRe3hfKC6k9yuvC8kJqj/K6sLyQ2qO8risvh9Qe5XVheSG1R3ldWF5I7VFeF5YXUnuUV3t5uefyCoXyIpQXyuu68kJqj/K6sLyQ2qO82svrmOOvvwvfmHBI7VFeF5YXUnuU14XlhdQe5XVdeRFSe5TXheWF1B7ldWF5IbVHeV1YXkjtUV7t5RWfyisXnspBhPJCeV1XXkjtUV4XlhdSe5RXc3mROTYej2QLe0wQUnuU14XlhdQe5XVheSG1R3ldV14eqT3K68LyQmr/Lyiv68oLqT3K68LyQmqP8movr+25vApPRPOE8kJ5XVdeSO1RXheWF1J7lFdzedn02J2QnK8dT84cx1NxwyaPlB/l2K8cnX+UozfV45M/Bk8ppkL54i4Cyrdf+Xp6lG8oOV/cdUA5jrmalsox4C4FynGicsRdDZTjROWIuyAox4nKEXdNUI79yjGGRzlm++dOPBDKF+XbrXzz42p6i9wL5Yi7OCjHIVfTcjnirg/KcaJyxF0flONE5Yi7OCjHicoRd3FQjt3KkUx8lKNzf+7EI+76oHz7la97uppSYef1iLs+KMcxV9NiOeKuD8pxonLEXR+U40TlSChHlOM85Yi7OCjHS8rxXl64K4PyurC8cJcF5XVheeGuCcqrvbz8o7xsKmwvGXEXBOV1XXkl3KVAeV1YXrjrgPK6sLxwFwHldWF54a4AyuvC8iKUF8rruvJCao/yurC8kNqjvC4sL+ReKK/W8go5HLe0Q475Z3ll5F4or+ar1/YQ/vZ3KJQXci+U14XlhdwL5XVheSH3Qnm19155eyqvwma3mVBeKK/rygu5F8rrwvJC7oXyurC88G1VlNeF5YVvq6K8LiwvpPYor8vKK2xI7VFeF5YXUnuU14XlRSgvlNehjXF518YkqhwdKeyvffszF4oLqReK67LiQuaF4rqsuJB4obhaiyuYXfcYbCwUF/IuFNdlxYW0C8V1VXEZZF0orsuKC0kXiuuy4iIUF4qrsbh82qsk+lwIUQ3cIoqrtbhi3gcdkzOF4oJbRHFdVlxwiyiuq4rLwi2iuC4rLrhFFNdlxYXfMqK4WosreXMUV+Fp7sHil4worsuKi1BcKK6rigvf50JxXVZc+D4Xiuuy4kJCj+K6rLiQ0KO4LisuJPQorquKyyGhR3FdVlzIuVBcrcX1/H2uUkLvCMWF4rqquJBzobguKy7kXCiuy4oLOReKq7m4wvGtiBDTz+IifCsCxdVaXPHgF6OhQnHBLaK4LisuQnGhuK4qLrhFFFdzz5Xjo7h8objgFlFclxUX3CKK66ri8ri3iOJq7rmORzHe/iz0XB6//kFxNRfX069/jKscbSj5YyiUSrmYRy6GYmwtxmTCUYylRN8jF0NxcVzpisVFKC4U11XFhVwMxXVZcSEXQ3FdVlzIxVBclxUXfi2E4rqquAJysSmKy9KO0Nq4fTv6rhMioyl0cnZ/bevIFXRC+iJDJ4JOInRCJjDH+pQeOv1lJHedYK9l6ASnKkMnmD4ZOmG3BRE6RXy5SIZOyCNk6IQ8QoZOyCNk6KTZP23+odNtxlWWWzqyUvuUlSb/xVKzx+FmqdmHcLPU7BU+ZUnHzTbr3TeWhbHYvJN37ukXd1/3uJLm3n8kd829/KXcXcgH9xSfuH9y7F0jzX28FI009/BSNCJoNFwjMsd6RNb81EjzvUQpGsEHz68R/PXbGrnH97pc3Coa+bgL6vMTwPSFHVZ8CHa49hHYM0z7EOzw7EOww4a/jZ0et1Lo+dWL2G/Xkf3oW23HZ/A/D06Wdt7JBvtTJRhxCSoRVBKgEsy4BJVgxyWoBEMuQSX4dwkqwe7Pr1Lc4JfeVsnbIyb21n9T6c4Sndj7LOn40p/3W4ElrvHvszwOtz6kAktcidlYGqSpfCwRkXJcLxuurgar/ijySD6vIR+S3xHe7qs/NmgJX9wJ3IdwR088hjvyxou45wPK7WZj/MEdCeIY7vCLY7jDWw7hbuFDx3CHZx3DHY51DHf41au4HzdmQvY/uRO4D+EOvzqGO/zqGO7wq2O4w6+O4Q6/ysH9N0unuCc3txVrf3GTN1dhaSjuUIw3zz8xLI08PErYm6dj7Rd3xT35tdzjYYWSL3AncB/CXXFPPpS74p58KHfFPfnF3I8vzqZQ4K64Jx/KXXFPPpI7Kb6HdC338HhmVSpwV3wPaSh3+NUx3OFXx3AncB/CHX51DHf41THc4VeHcPcr9e82P7bV28xW486Zp/uV+vFLOb7OrfxK/fVIjiv1yyM5EjiycFypn72W48u8za/Un47kuFK/OZLjSvc7LuVY6cNXun8xkGOAn+HhCD/DwxF+hocj/AwPRwJHFo7wMywcY5GjicfD+57iUJu2whukA3lyuXJsTjuVnL8fex9MmGkwcabBpJkGkycaTPl5hqMGY2YajJ1pMG6mwdBMg5npCpxmugKnvlfgcKyq22YLo0lTjSbPNJq8TTUaM9Vo7FSjKV9tKOejpfT2dW+btv1Tm+ipxXbx6x3C5e8QL3+HdPk75IvfIW3b5e9g/vwd/O7AUgzf3qHgkra8Wxn72xl9HU0lb5fSvs9zNrb2wi7v87S0PW6euWOiVstEnZaJkpaJ1q/38dtE72eFprNiy1nGXH2dMvbyd3CXvwNd/g7+8ncIl79DVPKxNknLRLOSidpNy0RNyyphbdNZruWsk70Z7PEcaOfMY+ON8HUStZzkW04qfwXpg0danx97f4N49Rukq9+g/G0Otqd+p5OfXTK+gbn6DYoa2Nttj/3Te7vp8OOk3HBS+SvutZNOrhKf3Pq6HfF1sH++F/h16yt5e/1buOvfgq5/C8/6FrQV3iJc/xbx+rdI179F/vO3CNt+YQj251cKU9iufwtz/VvY69/CXf8WdP1b+OvfIlz/FvH6t0jXv8X1n+54/ac7Xv/pjtd/uuP1n+54/ac7Xv/pjhyfi5e/7kuJo6JefhEqnXxbwpvjK2Le0be3uJ/m2k6jttN822kn19/jC22303wFn8k2HbSzzT8MxcndeuY3ST3eJHd4k5Nb5sxv4i7/aGaOa9jL366l7K9/i3D9W8Tr3yJd/xb56rfI23b9W3CsJy9/mJU3e/1buOvfgq5eePPmr3+LcP1bxOvfIl3/FvnytzDb9W9hrn8Le/1bFIvW+z019emp04v566TYclJqOalcKls8ZvXr7/yXjiSf3ObaYj5a2O12o/jHaabtNNt2mms7rXyx3G43lB6nPW3Cvp/m204LbafFptPciW75sR39loP5cdoJyZz2bemN2bYfJB21nebbTottc0ttp518cHJ2T4P0fz2NtrbTTNtptu0013YatZ3m204rf3Buh+bHafa5Sv7+eU2V99PifpPU403yn7/J63uRuXyHkPctzPVvYT99i/tpru00ajut7RJ5cn+uelpsOy21nZabTgtb22mm7TTbdlrbQhraFtKTWx3RHxfWGJ9/plpqb23cjm8YRWt/vEW+/C1ObnWwvoW5/i3s9W/hrn8Luv4t/PVvEa5/i3j9W1z/6Y7Xf7rT9Z/udP2nO13/6U7Xf7rT9Z/udP2nO13/6U7Xf7rTx5/u+2m56bS8tZ1m2k6zbae5ttOo7TTfdlpoOy22ndZWJbmlSvy2bW2nmbbTbNtpru00ajvNt50W2k6LbaelttPaqsS0VYlpqxLTViWmrUpMW5WYtioxbVVi2qrEtFWJaasS21Yltq1KbFuV2LYqsW1VYtuqxLZViW2rEttWJbatSlxblbi2KnFtVeLaqsS1VYlrqxLXViWurUpcW5W4tiqhtiqhtiqhtiqhtiqhtiqhtiqhtiqhtiqhtiqhtirxbVXi26rEt1WJb6sS31Ylvq1KfFuV+LYq8W1V4tuqJLRVSWirktBWJaGtSkJblYS2KgltVRLaqiS0VUloq5LYViWxrUpiW5XEtiqJbVUS26oktlVJbKuS2FYlsa1KUluVpLYqSW1VktqqJLVVSWqrktRWJamtSlJblaS2KsltVZLbqiS3VUluq5LcViW5rUpyW5XktirJbVXSlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NW3Zq2nLXk1b9mraslfTlr2atuzVtGWvpi17NSfZaz6+YWgymcJpJ1VybOlncrbfTitt5cv0oJDbcOJcw0lzDSdPNZyzbHvUcMxcw7FzDcfNNRyaazh+ruHMdVVOc12V01xX5TTXVTnPdVXOc12V81xX5TzXVTn3viq/fMbVbTx+svGEycYTJxtPmmw8earx2PIdXHtrXb9Os9b4ynhuDn07hh/iX3cvuL2J6fEmtsebOJY3ceHxJsE9vUnhF3nJ7RsDue1536etvJ3qduy5trnHb+9T/ho/TT5+f/AP3rmf4/fCxx+Ejz8KH38SPv4se/xmEz5+I3z8Vvj4Z19/a+MXvv4a4euvEb7+GuHrrxG+/hrh668Vvv5a4euvFb7+WuHrrxW+/lrh668Vvv5a4euvFb7+WuHrrxO+/jrh668Tvv464euvE77+OuHrrxO+/jrh668Tvv464esvCV9/Sfj6S8LXXxK+/pLw9ZeEr78kfP0l4esvCV9/Sfj664Wvv174+uuFr79e+Prrha+/Xvj664Wvv174+uuFr79e+PobhK+/Qfj6G4Svv0H4+huEr79B+PobhK+/Qfj6G4Svv0H4+huFr79R+Pobha+/Ufj6G4Wvv1H4+huFr79R+Pobha+/Ufj6m4Svv0n4+puEr79J+PqbhK+/Sfj6m4Svv0n4+puEr79J+Pqbha+/Wfj6m4Wvv1n4+puFr79Z+Pqbha+/Wfj6m4Wvv1n2+us22euv22Svv26Tvf666fe/qo1f9vrrhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf+WE73/lhO9/5YTvf0XC978i4ftfkfD9r0j4/le0yV5/Sfj+VzT9/lePlw4xm+fxlw7eRx1SeLxwsl9znX2t5pzr7Os651xn7wEY5zr9fl2cc529t+Cc6+R9iM8+PeZqX8+VYt7HQcml42CbfXHYJh6jdnQc7Vz4YjN5jzOUDYHNKZvJe7PoyX4dHcMWXrNxbj/W0dOgbYl58PuQfdyeDnZbacw5H6+8benb0XeMk7eIUjBO3n1KwTh5YysF4+Q9sxCMs2/fJwXj5J2+FIyTmwgpGCf3G1IwEjByYISLYcEIF8OCES6GBSNcDAtGuBgOjLNvgioFI1wMC0a4GBaMcDEsGAkYOTDCxbBghIthwQgXw4IRLoYFI1wMB8bZt5KWghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgPj7BvyS8EIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBcfbHmkjBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgXH2h0NJwQgXw4IRLoYFI1wMC0YCRg6McDEsGOFiWDDCxbBghIthwQgXw4Fx9kfsScEIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBcfYHlUrBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgNHP/rhnKRjhYlgwwsWwYISLYcFIwMiBES6GBSNcDAtGuBgWjHAxLBjhYjgwzv4QeikY4WJYMMLFsGCEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WI4MFq4GBaMcDEsGOFiWDDCxbBgJGDkwAgXw4IRLoYFI1wMC0a4GBaMcDEcGB1cDAtGuBgWjHAxLBjhYlgwEjByYISLYcEIF8OCES6GBSNcDAtGuBgOjAQXw4IRLoYFI1wMC0a4GBaMBIwcGOFiWDDCxbBghIthwQgXw4IRLoYDo4eLYcEIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBMcDFsGCEi2HBCBfDghEuhgUjASMHRrgYFoxwMSwY4WJYMMLFsGCEi+HAGOFiWDDCxbBgnNzF+OzTjjGZXMEY036wS0/DdtmXhk12H4ih+KRQ6WBn0ra/tMmPg20ojdpt9sBu6IHdbbFwdDKBvo5O9kkkm0zhaIqb+zqa4q8S2V/buy9JJ3dUkPRzSQmSribp5E4Tkn4u6eSuF5J+LunkDhySfi7p5GkAJP1c0smTCUj6saRp8pQEkn4u6eSJDST9XFKkR8tJivRoOUkJkq4mKdKj5SRFerScpEiP3pOUTN5fmpKtSOo3c9wB3Sg+5hi+qCPgGUEdGcwA6hkxyQjqSDJGUEfYMII68oAR1AnUB1CHqx5BHcZ3BHV40xHU4U1HUJ/Km/4aUtimMm73IU3lau5Dmqrlvw9pqn74PiSab0hTdVL3IU3VZtyHNNUafB/SVAvUfUjzXb3NfFdvM9/V28x39TbzXb3NfFfvuZ5xfx/SfFfvuZ69fh/SfFfvuZ4J/ntIcz1f+z6k+a7ecz33+T6k+a7ecz2P+D6k+a7ecz0n9z6k+a7ecz2/9T6k+a7ecz1X9D6k+a7ecz3v8j6k+a7ecz2H8T6k+a7ecz0f8D6k+a7ecz237j6k+a7ecz1P7T6k+a7ecz3n6z6k+a7ecz1/6j6k+a7ecz0X6T6k+a7ecz2v5z6k+a7ecz1H5j6k+a7ecz3f5D6k+a7ecz134z6k+a7ecz0P4j6k+a7ecz2n4D6k+a7ec+2ffx/SfFfvufZ1vw9pvqv3XPuN34c039V7rn2w70Oa7+o91/7M9yHNd/Wea9/g+5Dmu3rPtZ/tfUjzXb3n2k/0PqT5rt5z7ed4H9J8V++59tO7D2m+q/dc+5ndhzTf1Xuu/aTuQ5rv6j3Xfj73Ic139Z5rP5X7kOa7es+1WcZ9SPNdvefaZuE+pPmu3nP9QP8+pPmu3nP9tPs+pPmu3nP9KPg+pPmu3nP9nPQ+pOmu3nG+31rG+X5rGef7rWWc77eWcZvu6h3n+61lnO+3lnG+31rG+X5rGef7rWWc77eWcb7fWsb5fmsZ5/utZZzvt5Zxvt9axvl+axnn+61lnO+3lnG+31pGph8QbfExJBOfhvT7TT7/scv9NNd2GrWd5ttOC22nxbbTUttpuem0z38McD/NtJ3WViXUViXUViXUViXUViXUViXUViXUViW+rUp8W5X4tirxbVXi26rEt1WJb6sS31Ylvq1KfFuVhLYqCW1VEtqqJLRVSWirktBWJaGtSkJblYS2KgltVRLbqiS2VUlsq5LYViWxrUpiW5XEtiqJbVUS26oktlVJaquS1FYlqa1KUluVpLYqSW1VktqqJLVVSWqrktRWJbmtSnJbleS2KsltVZLbqiS3VUluq5LcViW5rUpyU5WkbWs7zbSdZttOc22nFauEwnHat8fiPE7z5dPM4zS7/cfrTOD23l8HJ/fYptamrXBsTnugkfP3Y+/DCXMNJ841nDTXcPJUwynfnBg3HDPXcOxcw3FzDYfmGs5cV2Uz11XZzHVVNnNdlU3vq/LxmD6zbfbneOw22XjMZOOxk43HTTYemmw8H1+b76eFttNi02lMu+C9vNWXmPa1q7yJ6/Em1ONNfI83CT3ehOcbAGQeb+Lz05t8dif8PqQ035DydENi2vHtgyGRyftzacj+rCSm/d4YB2RnG1D3b27VFsD+W71VR+SnG1GYbkRxuhGl6UaUZxtR/03eqiMy043ITjei6a7Zfrpr9oD93fy27a/tKddeO/vjpXMyTxMwXxMIk08gZbcfvbnvEyg4ZGsOi2x97ejbPcn9q6a3e3G2crTzdm9wTHgcu5WOtSY/+G3529F37BHYR2BPwD4Cewb2AdgH7M4I7DfsBthHYLfAPgK7A/YR2AnYR2Cf3e8tih0udQh2uNQh2OFSh2CHSx2BPcKlDsEOlzoEO1zqEOxwqUOwE7CPwA6XOgQ7XOoQ7HCpQ7DDpV6B3aa8j9o9f+PkwA6XOgJ7gksdgh0udQh2uNQh2OFSh2AnYB+BHS51CHa41CHY4VKHYIdLHYIdLnUE9gyXOgQ7XOoQ7HCpQ7DDpQ7BTsA+Ajtc6hDscKlDsMOlDsEOlzoEO1zqAOx5g0sdgh0udQh2uNQh2OFSh2AnYB+BHS51CHa41CHY4VKHYIdLvQJ7NDsQG91WwA6XOgK7gUsdgh0udQh2uNQh2OFSh2AnYB+BHS51CHa41CHY4VJHYLf9r+3J7ZN1m3GV1/bZ70/KSFt+HJ3y1/i98PEH4eOPc48/+OOxRsG7wviT8PFn2eN3m/DxG+Hjt8LH74SPf/L1tzr+ydff6vgnX3+r4xe+/jrh668Tvv6S8PWXhK+/JHz9JeHrb/8HGzKPX/j6S8LXXxK+/pLw9ZeEr79e+Prrha+/Xvj66ydff5/yw5BiYfyTr7/V8cvJn8vjl5M/l8c/+fpbHf/k6291/JOvv7Xxh8nX3+r4J19/q+OffP2tjn/y9Td62u8Wx7CF5/EX7iy7/VhHT4O2JS7heFSyj9vTwb9uMv8c8+2u9jHmLX07+o5x8svIHBjdlvfvnLtvPIpHx2PE8TiS3J13nPyytxzvyS/Ty/GefFlZjjeWwb68Cby78p7c5i/He/JYYjnek8coy/GePPZZjjf8ZVfeCf6yL2/4y7684S/78oa/7MubwLsrb/jLvrzhL/vyhr/syxv+sivvPHs/aFM4Rv/0fNoib3Mjt48jhqcfRrviHfJt/120p+3bsXcys3du48gQyJyQmb0bGkdm9r5lHJnZO4xxZGbvBcaRmT0VHkQmbNvs+e04MrMnrePIKO6Bw77bz816VY4l63eMZBN9Mx13jnpXsnQc/Pxd2/Kx1tn9YEskZkMmkx8yPsH72pDppr7e1Rrqb5vejgTqb0Zv1wX1N6O3s4T6m9HbPUP9zehNyaH+NmCDbag/j/p673ZA/c3ovaMD9TeDrE+z+sj6NKuPrE+x+hZZn2b1kfVpVh9Zn2b1kfVpVp+gvmL1kfVpVh9Zn2b1kfVpVh9Zn2b1kfUtrL5N+89IrdvsT/Vnf8gh1L9UfWR9mtVH1qdZfWR9mtUnqK9YfWR9mtVH1qdZfWR9mtVH1qdZfWR9itWf/YHqUP9S9ZH1aVYfWZ9m9ZH1aVafoL5i9ZH1aVYfWZ9m9ZH1aVYfWZ9m9ZH1KVbfI+vTrD6yPs3qI+vTrD6yPs3qE9RXrD6yPs3qI+vTrD6yPs3qI+vTrD6yvoXVj2aHZ6PbfqofkPVpVh9Zn2b1kfVpVh9Zn2b1CeorVh9Zn2b1kfVpVh9Zn2b1kfVpVl9v1pftPsfsfeVYv8Xjwee/B3oc/fUs86g3NePlqDd/4uWoN8nh5ag4E0luP3jbQm15NOFYHq2LUpbH2na2kSC/ZvkVpyKQf4uKYxHIv0XFuQjk36LiYATyb1Hxt6Ag/5YUfw0K8m9J8fegIP+WFH8RCvJvCamfavkJ8muWH6mfavmR+qmWH6mfavmR+qmWH6mfZvkzUj/V8iP1Uy0/Uj/V8iP1Uy0/QX7N8iP1W1n+2qY3GamfavmR+qmWH6mfavmR+imW/zZxyK9ZfqR+quVH6qdafqR+quUnyK9ZfqR+quVH6qdafqR+quVH6qdafqR+muU3SP1Uy4/UT7X8SP1Uy4/UT7X8BPk1y4/UT7X8SP1Uy4/UT7X8SP1Uy4/UT7P8FqmfavmR+qmWH6mfavmR+qmWnyC/ZvmR+q0sf+VRd8Yi9VMtP1I/1fIj9VMtP1I/zfI7pH6q5Ufqp1p+pH6q5Ufqp1p+gvya5V/K9wdLh/yxqmje9qNt9q5yNG3bXi200XNp3Z+FbmipZfQjkm7bzDGQVOXu7PFJIjJSPkmVHTINLbWOQv+P9V9qIYX+H+u/1P0z6P+x/kvdQIP+H+uvt5OG/r/0X+oWGvT/WP+l7qFB/0/190vdRIP+H+u/1F006P+x/sj/dOuP/E+3/gT9VeuP/E+3/sj/dOuP/E+3/sj/dOuP/E+1/gH5n279kf/p1h/5n279kf/p1p+g/8r61/bPCMj/dOuP/E+3/sj/dOuP/E+3/sj/VOsfkf/p1h/5n279kf/p1h/5n279Cfqr1h/5n279kf/p1h/5n279kf/p1h/5n2r9E/I/3foj/9OtP/I/3foj/9OtP0F/1foj/9OtP/I/3foj/9OtP/I/3foj/1Otf0b+p1t/5H+69Uf+p1t/5H+69Sfov7L+tSdpZeR/uvVH/qdbf+R/uvVH/qdbf+R/mvW3G/I/3foj/9OtP/I/3foj/9OtP+nV32xpH4jxsXI0xbwPhBJtT0dvXyQVJ2nMJBVnUswkFac7zCQV5yQmHiStrZG0JhzrpHVRyjpZ2Sf39t+gv2b9jeKcBPrf9Feck0D/m/6KcxLof9NfcU4C/W/6E/RXrb/mdAf632YF/VXrrzlJg/43oaG/av2R/6nW3yL/060/8j/d+iP/060/8j/d+hP0V60/8j/d+iP/060/8j/d+iP/060/8j/V+jvkf0vrX9knxzrkf7r1R/6nW3/kf7r1J+ivWn/kf7r1R/6nW3/kf7r1R/6nW3/kf6r1J+R/uvVH/qdbf+R/uvVH/qdbf4L+qvVH/qdbf+R/uvVH/qdbf+R/uvVH/qdaf4/8T7f+yP9064/8T7f+yP9060/QX7X+yP9064/8T7f+yP9064/8T7f+yP9U6x+Q/y2tf+05eQH5n279kf/p1h/5n279Cfqr1h/5n279kf/p1h/5n279kf/p1h/5n2r94+T+32e/ixSTqejvYjoUTU/DdtmXhu1c3Eft0kOjVDqY3K4npSceFL8wTm6jpWAkYOTAOLmpk4Jxcm8kBePkFkMKxsk79Vkwer/P0IcSxskbXiEY0+T3jafBGLcdY8wFjJPffpWCES7mPYx5X2LC5goY4WJYMBIwfojRmAJGuBgWjHAxb2EMcQcS0lbACBfDghEu5j2MaR90yFTACBfDgTHDxbyF8XbnZR+GSQWMcDEsGOFiPsVoQwEjXAwLRgJGDoxwMe9hzPug01ZaqeFiWDDCxbyFMR0f6lRcqeFiWDDCxbyH0bkdI9kfGN0GF8OCES7mU4x+K2CEi2HBCBfzFsZs9mNzof12GwEjB0a4mPcwuh1IJlPACBfDghEu5j2Mx3d4cih9qOFiWDDCxXyKMf6MJpyBi2HBCBfzFkaz+f0rZWYLhQbcwMcwgVTsZMjuA7nhCK9BOpN2kM7kp192hdKob73kY45P34m8/aM47G3/kpCLTy3Vr6PvIhFEml8kxS5MjkiKPZ4ckRQ7SDkiKfanckRS7H7FiGQVe2s5Iil27nJEUpwKyBEJiYMAkQgizS8SEgcBIiFxECASEgcBIiFxECASEof5RXJIHASIhMRBgEhIHASIhMRBgEgEkeYXCYmDAJGQOAgQCYmDAJGQOAgQCYnD/CIREgcBIiFxECASEodLRLL2OJpSRaRkwuMBMtvj6PIjYShu+4/JKZrH3gbOuy9JkU8sJylB0tUkRfaxnKRISpaTFLnKapJ6eEdxkh4bHd7+DAVJ0fFKkzRt+6/O6XZ4QVKCpMMlneXBpiY/VH96Luz+YFPn0UujWN4uFnTpKJa3iwX9P4rl7WLB/V0Uy9vFgvvMKJZ3iyUgs0CxvF0suO+OYnm7WHD/H8XydrEgZ0WxvF0shGJBsbxbLEhwUSxvFwsSXBTL28WCBBfF8naxIMFFsbxdLEhwUSzvFktEgotiebtYkOCiWN4uFiS4KJa3iwUJLorl7WIhFAuK5d1iQYKLYnm7WJDgolh2Zax7qE62UCxIcFEsbxcLElwUy7vFkpCzoFjeLhZCsaBYvpSJZpfRRrcVigVuCMXydrHADaFY3i4WuCEUy9vFAjeEYnm7WPB9FhTLu8WS8X0WFMvbxYKcBcXydrHg+ywolreLBd9nQbG8XSyEYnmrWKzdN+dzNwtZKRYxXzrIyGRVy4+UVbX8yE1Vy48kVLX8yDYVy08b0krV8iN/VC0/EkXV8iMjVC0/QX7N8iP1Uy0/Uj/V8iP1Uy0/Uj/V8iP10yy/QeqnWn6kfqrlR+qnWn6kfqrlJ8ivWX6kfqrlR+q3svw25V1Ht9mC/Ej9VMuP1E+1/Ej9NMtvkfqplh+pn2r5kfqplh+pn2r5CfJrlh+pn2r5kfqplh+pn2r5kfqplh+pn2b5HVI/1fIj9VMtP1I/1fIj9VMtP0F+zfIj9VMtP1I/1fIj9VMtP1I/1fIj9dMsPyH1Uy0/Uj/V8iP1Uy0/Uj/V8hPk1yw/Uj/V8iP1W1n+yqOciJD6qZYfqZ9q+ZH6aZbfI/VTLT9SP9XyI/VTLT9SP9XyE+TXLD9SP9XyI/V7T35yh/yUTEV+Z7bjaENP/EpATKQdtonh6eDSo+FvVv3r2ODd86F3NRHiraQmMjlZah7ChKcF4lATEZswNbcdx/bzsxmQmL2ppskPNW1FTb8d7YrfKD6reaeOoGoEdeRDI6gjlhlBnUB9AHWEECOow/uPoA6PPoI6vPQI6vC8A6hHeNMR1OFNR1CHN72AOuWcDuo+/8fLVO2WbO4p9s0+bT8lgpGdXiKCRLNLBIs8vUTw09NLBPM9vURw6tNLBFs/u0QJGcD0EiEwmF4ipAtzSeR+SoR0YXqJCBLNLhHSheklQrowvURIF2aXKKOja5AoVCQydHwL25BLryUKG+0vHba8vT7Y3I7Yj7797cNPRdEArqYoQdHFFEV7uZqi6EZXUxTN62qK4k6aaEXzT0Vx420tRf2G+3SrKYrbeqspisxoNUWRGS2mqNW8jm7pRNE7Gs0LUgWN5it7Bc1Sl8jk6UATtxoas+1bvxjzDHIr7RND5tiOjehxhcylYy/c6M3khzBb/nb0XU+CnkvpuVSkDj3tUoE69LRLxenQ0y4VpkNPu1SUDj3dUgEA9HRLpRbQ0y0VtUBPh3xoLT0Jei6lJ/KhtfREPrSWnsiH1tIT+dBaeiIfWkpPQj60lp7Ih9bSE/nQWnoiH1pLT4KeS+mJfEiUnjbtX4C2brMFPZEPraUn8qG19EQ+tJaeyIeW0tMjH1pLT+RDa+mJfGgtPZEPraUnQc+l9EQ+tJaeyIfW0hP50Fp6Ih9aS0/kQ0vpGZAPraUn8qG19EQ+tJaeyIfW0pOg51J6Ih9aS0/kQ2vpiXxoLT2RD62lJ/KhpfSMyIfW0hP50Fp6Ih9aS0/kQ2vpSdBzKT2RD4nSM5qdtI1uK+iJfGgtPZEPraUn8qG19EQ+tJSeCfnQWnoiH1pLT+RDa+mJfGgtPQl6LqXnWvlQPl46W6ro6Y5XpqdhpPcPNfT11NO0VCiT3f6hoC3UICZr9qOT9aZSugM32kpLBS2LarRUeLKoRksFImtqlJcKORbVaKngYlGNlgojFtVoqYBhUY0IGk2v0VJBwKIaIWeYXyPkDPNrhJxhfo2QM8yuUdiQM8yvEXKG+TVCzjC/RsgZ5teIoNH0GiFnmF8j5Azza4ScYX6NkDMM16jyA8mwIWeYXiODnGF+jZAzzK8Rcob5NULOML9GBI2m1wg5w/waIWeYXyPkDPNrhJxhfo2QM0yvkUXOML9GyBnm1wg5w/waIWeYXyOCRtNrhJxhfo2QM8yvEXKG+TVCzjC/RsgZptfIIWeYXyPkDPNrhJxhfo2QM8yvEUGj6TVCzjC/RsgZ5tcIOcP8GiFnGK5RZePg4JAzTK8RIWeYXyPkDPNrhJxhfo2QM8yvEUGj6TVCzjC/RsgZ5tcIOcP0Gvmp+rr7kKZqY+5DGrtqu1olm3QUp0mUjqPJfo3fCx9/ED7+KHz8Sfj4s+zxh034+I3w8Vvh43fCxy98/Q3C198gfP0NwtffIHz9DcLX3yh8/Y3C198ofP2NwtffKHz9jd3XX2fc/qRkZ/JWeW3r7D5bS1SLi8Rs/hkDsI/AHoF9BPYE7COwZ2AfgD1twD4CuwH2EdgtsI/A7oB9BHYC9hHY4VKHYIdLHYIdLnUIdrjUIdjhUkdgz3CpQ7DDpQ7BDpc6BDtc6hDsBOwjsMOlDsEOlzoEO1zqFdhr219kuNQh2OFSB2CPG1zqEOxwqUOww6UOwQ6XOgQ7AfsI7HCpQ7DDpQ7BDpc6BDtc6hDscKkjsBu41CHY4VKHYIdLHYIdLnUIdgL2EdjhUodgh0sdgh0udQh2uNQh2OFSR2C3cKlDsMOlDsEOlzoEO1zqEOwE7COww6UOwQ6XOgQ7XOoV2Csb0UcLlzoEO1zqCOwOLnUIdrjUIdjhUodgh0sdgp2AfQR2uNQh2OFSh2Dv71KtdTt2m2wNuwkHduuiFOyVnwPH/o9lB/Zf2DOwD8De/+HpwP4LuwH2EdgtsI/A7oB9BHYC9hHYPbCPwB6AfQR2uNQh2OFSh2CHSx2B3cOlDsEOlzoEO1zqEOxwqUOwE7CPwA6XOgQ7XOoQ7HCpQ7DDpQ7BDpd6BfbazwoCXOoQ7HCpQ7DDpQ7BDpc6BDsB+wjscKlDsMOlDsEOlzoEO1zqEOxwqSOwR7jUIdjhUodgh0sdgh0udQh2AvYR2OFSh2CHSx2CHS51CHa41CHY4VJHYE9wqUOww6UOwQ6XOgQ7XOoQ7ATsI7DDpQ7BDpc6BDtc6hDscKlDsMOlXoG9tkVbhksdgh0udQh2uNQh2OFSh2AnYB+BHS51CHa41CHY4VKHYIdLHYJ9gEvN+8HOPW0N/uu1fw0pbXa+Ibn5hkS9h0Sb21+bNl/7vLw6+j4BL30CYe4JhOT3a1BI0Ty98n34Ufbwk+zh58mHn7d9SQrZxr8O32yyh29kD9/KHr6TPfzJV97a8Cdfd2vDn33VrQx/9lW3MvzZV93K8GWvulb2qmtlr7pW9qprZa+6/Z9Czzt82auulb3qWtmrrpW96lrZq66Tveo62auuk73quulXXTpiqux/Dn/6Vff18KdfdV8Pf/pV9/Xwp191Xw9/+lX35fCvfozk/U26X97s7UP9dbDbjKu8ts8+fR0db+7/ODrl0j23mPaDXXoatsu+NGw6HnFsKD5uxKbSwc6kp6cnP921DaVRu83a42hKj4FsceZ7zW7b76dbZ8y3o+/FQigWFMu7xeJRLCiWd4sloFhQLF/KVH6Yk/o/HhHFIrdYEooFxfJusWQUC4rlzWLp/wBNFIvcYjEoFhTLu8ViUSwolneLBQkuiuXtYiEUC4rl3WJBgotiebtYkOCiWN4uFuQs44vFhEexbKkiP8W8D/v252Mkzn/9mDIgDZEmaTquFvRM5CEpMgtxkh47IlBytiApkoXlJIX/X05SgqSrSQovvZykcLzLSYpvFomTdIuHpHYrSIrv/ywnKdKj1SSNSI+WkxTp0XKSIj1aTlKkR8tJSpB0MUnLjyu4zfA46zF8k9LXSdRykm85qZiEeLMXnLfu20mlCnpszpzS0265+zvEy98hXf4O+eJ3yNt2+TuYy9/BXv4O7vJ3oMvfwV/+DuHyd4iXv8PVn+lc3gnVH/s6eIo/Lpe5vAOmj8dmELQVTkot71S+5Bzrrw/086TyJoU+7cufz65wkmk5ybac5FpOopaTfMtJoeWk8kfh6E98LumUWk7KDSe57fVJYSvMqbxtlY/5OCkVTipWRDA7veBy4SRXeafS56m8MVLlQ1jejqh2UsvHvbz5i7F+n5SxoYCCTNtptu0013YatZ3m204LbafFttNS22m56TR/UiUpHqc9fbHzcZqpnxYKp9m201zbadR2WrlKbvZtP82VLjzlry/XT4ttp6W203LTaeWvZtZPM22n2bbTTnQLh9wuFlaZ8u098+jxjKfCJyCeIMnH5402XzjN1E8rfEyjbTvNtZ1GbafFptNSmeRzEONM4TTTdlqZJIXtOC0ULgrlx7Tfjn3MLRYW4Xwyt+Or8LcgqFCT2bSdZttOK1cJZTo+AVtpbtR2mm87LbSdFk8+3Ydu3hY+pjm1nZYbBhm3bWs7zbSdZttOcw3Xydtp1HaabzsttJ2WG65ccTMtV67baabtNNt0Wiz7NbtPzf98Jlzcytfk2kmm5STbcpJrOYlaTvItJ4WWk2LLSanlpJaKKK9kPu/NVXi6tfI4ybScZFtOci0nUctJvuWk0HJSbDkptZyUPz/JbFvLSablJNtyUvma/rgJZ7ZQOO3kml49rXxNvzmV/bTnW36P02zbaa7tNGo7rbwWm3AgMamE5MSi5ocfy6V3y02n2a3tNNN2mm07zbWdRm2nnfRQdns0Q7FwWmg7LbadltpOy02nlXPo+mmm7bRylfiHafQpF05zbadR22m+7bTQdlpsOy21nZabTqOz3Oo4zdnC541s22mu7TRqO823nRbaTottp6W203LTaX5rO62tSnxblZxk4O64fXv7IBcuQScZePU033ZaaDsttp2W2k7LTaeFtgYjtDUYoa3BCG0Nxsmvll4/Of72/5YFCI8sNcTSu+Wm004S9+pppu20sgAx7r//MjHbwmmu7TRqO823nRbaTottp6W203LTaSd3E6qnmbbT2qoktVVJaquS1FYlqa1KUluVlJMskx/LYral03LTaeWMySazf6/JpvD0LdriV4WTO5LX5J7uGZWPrnxD9zYkN9+QaL4h+fmGFOYbUpxvSGm+IeXZhmTLmerYIZn5hjTd1dtuHFdve3zHM5GJtaM/3H3teH4O3dKzwgRI+gS89AkE6ROI0ieQpE8gC5+A2aRPwEifgJU+AekrsZG+EhvpK7GRvhIb6Suxkb4S2+nXgZe7Md8mMPtVqObIbP+r0Cybp5v82Khh+3l/29oANGdoItCcoUlAc4YmA80JGrcBzRkaAzRnaCzQnKFxQHOGhoDmDA264VM06IZP0aAbPkWDbvgUDbrhMzSEbvgUDbrhUzTohk/RoBs+RUNAc4YG3fApGnTDp2jQDZ+i0dsN32K8Aw3ZAhq93XANjdfbDVfR6O1rqmj0rlCVH+RZr3eFqqLRu0JV0ehdoWpogt4VqopGb15TRaM3r6mi0dvXVNEQ0Jyh0ZvXVNEUu2G3HT+Adtvzs4aKkzUmmOPX2SbYGhxrj93Qbt26fxzt7NegIseg/GPfWhOeHp0hPCsp75oBOHc4GXBO4ZR3QAGcOxwDOOdwLOCcw3GAcw6HAOccjgecczgBcM7hoEN+AQcd8gs46JDP4SR0yC/goEN+AQcd8gs46JBfwCHAOYeDDvkFHHTIL+CgQ34BBx3yCziaO+Tb7Hc4bit8eypr7pCrcDR3yFU4mjvkKhzNHXIVDgHOORzNHXIVjuYOuQpHc4dchaO5Q67CQYd8Csdt6JBfwEGH/AIOOuQXcNAhv4BDgHMOBx3yCzjokF/AQYf8Ag465Bdw0CGfwzHokF/AQYf8Ag465Bdw0CG/gEOAcw4HHfILOOiQX8BBh/wCDjrkF3A0d8iVX+U6q7lDrsLR3CFX4WjukKtwNHfIVTgEOOdwNHfIVTiaO+QqHM0dchWO5g65Bkfxo4/c8XhEewtEC2j0bh5WRaN387AqGsWbolbcuOJHH1XR6N08rIpG71a6VTR6t9KtolG82XsNjeLN3itoFD/6qIpGbzdcRaO3G66iQTd8iqZ/X/PZw+tj3tHc/nxMd394vRvwqJnPJpCOSrj9mQsTSLNPwLpjAs4WJpCFT2DAw1WYJ2CkT8BKn4CTPgGafQJbPCZgt8IEvPQJzL4SVycw/Upcm8D0K3FtAtOvxJUJhOlX4toEpl+JKxMo7wgUaR9RpPDTRJT3O3mYmuxT4STXchK1nORbTgotJ8WWk1LLSUWdzHY8bsJswf84jcq/2K6fZtpOs22nubbTqO0033ZaaDsttp2W2k5rqxLTViXln6y8vnZQ+acc+bhMZVs6qeEyQOUvcNfeKbWclBtOKn8RtnaSaQBhbctJruWksk5hr4gcC2VU/gJa7aTQclLtcl08KbWAyA0nlb8VUzuppSJcS0W4lopwLZ9c51tOCi0nxZaTPq2I27/MryPLn6lojjA4PE40nor93B7verN9O/Y2svKn76OXN9v+8i7+eHl/7cuHa18+Xvvy6dqXz5e+fPnKw/fyxWtU3B4vnysvb263SfbKv/399GQ1e3NJv97CXv8W7vq3oOvfwl//FuHit7j9y/6+nhY/dN7vBjnYR/JpyJ9/kF6eUv5wvD7FfH6K/fwU9+Ept3+5X0eWf/dpzBZ3iW5/56ePfPp9Lp2fm7YjwnhqW3+FGT8ODXSM7xZCPB16m1G5Zed68fSnL5723ZVDSn998fzHL75fQOP215GXrQLLi9/+4V/Imve7CCnnt2acXTi6oPh6UNV6C78OpuL1yrtdCh+f5k7br5GV73G/PiV+fkr6/JT84Sm3f8XfF7oihOD2a2TaHldI48J5O/X6lPj5KenzU/LHp5SvwK9PKV6B07GqpKcfX+yn2M9PcZ+fQp+f4j8/JXx+Svz8lPIVNVHponE7pfDdlrBfAVyk/3ik0/eXz5e+fPlrd3wvb659eXvty7trX56ufXl/7csHxpdP7sfLx2tfPl378uW+wB59wbM/vF9Hyl/IeX2K+fwU+/kp7vNT6PNT/OenhI9PKT95/PUp6fNTPlc/fq5+/Fz9+Ln65aff2iPnsyH+tfjLz4R9fYr//JTyV0fifuvA5h+fyvJTNV+fkj4/JX98Svm5hK9PMR+ecvtXgpf4+9/yby9RpBeOLxmHvP31vco3kF6f4j4/hT4/xX9+SvjwlNu/ft0fRfWY3/cwyraf4sHP0tN19JeRv/3z//2Hf/unf/hv//yP//t2yq//9//8y3//93/613/5+ue//3//a/9//tu//dM///M//c//+r/+7V//+z/+j//zb//4X//5X//7r//vb9vX//znW4Jh/34LE91/+X1X5T9HF+Lfo0v+v/xOt27/v0m3/9+m/3IX7j/TLb3+O8X4+4TfZ2wh346I5rgx8/s4dzvKHdnir5ci83dv9pe5VYiPjwjt138y+e+WHsnYr/9k6e82P1KV3/8p/t3ZI8/49bq3CZA9Xvf2JuFw+r//U9j+Hvw+2hT/nvJxCTs/Pe//982xuXxMfvs7+UcNn59uHiCs+bu9/bf/uGn3/wM=",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "swap_tokens_for_exact_tokens",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_in_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11096770892590629967": {
            "error_kind": "string",
            "string": "TOKEN_IN_IS_INVALID"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14520021557936622750": {
            "error_kind": "string",
            "string": "SAME_TOKEN_SWAP"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18208603774526826647": {
            "error_kind": "string",
            "string": "TOKEN_OUT_IS_INVALID"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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hBRChExIIUTIhBRChExIIUTIhBRCgkwZKYQImZBCiJAJKYQImZBCiJCJIJMEmZBCiJAJKYQImZBCiJAJKYQImZBCCJCJNqQQImRCCiFCJqQQImRCCiFCJoJMEmRCCiFCJqQQImRCCiFCJqQQImRCCiFBJoMUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyGSRQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkcUggRMiGFECETUggRMiGFECETQSYJMiGFuEgmS/5AmGoyUT5k8tuWf8qEFEKETEghRMiEFEKETEghJMhESCFEyIQUQoRMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMHimECJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQKSCFECETUggRMiGFECETUggRMhFkkiATUggRMiGFECETUggRMiGFECETUggJMkWkECJkQgohQiakECJkQgohQiaCTBJkQgohQiakECJkQgohQiakECJkQgohQaaEFEKETEghRMiEFEKETEghRMhEkEmCTEghRMiEFEKETEghRMiEFEKETEghJMiUkUKIkAkphAiZkEKIkAkphAiZCDJJkAkphAiZkEKIkAkphAiZkEKIkAkphACZbv8NMkmQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkMUggRMiGFECETUggRMiGFECETQSYJMiGFECETUggRMiGFECETUggRMiGFkCCTRQohQiakECJkQgohQiakECJkIsgkQSakECJkQgohQiakECJkQgohQiakEBJkckghRMiEFEKETEghRMiEFEKETASZJMiEFEKETEghRMiEFEKETEghRMiEFEKCTIQUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyOSRQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkCUggRMiGFECGT5hQibOaQKX4beC6+ejYHlGeZTkRN2y5qNLl2tN3yfrS18dvRv2XSnEIIkokgkwSZNKcQgmTSnEIIkklzCiFIJs0phCCZNKcQcmSK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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_swap_tokens_for_exact_tokens",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "change_token_in_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8349750481146185694": {
            "error_kind": "string",
            "string": "Function _swap_tokens_for_exact_tokens can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAWARwACLQwCBSMAAAoDLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACuojAAALWiQAgA0AAAr3IwAACxAuAIADgAUBAIAFAAKADi4CgAuADiMAAAtVKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAtVIwAAC64oAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAC64oAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAADA4uAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAAC90uAIAMgAYmKgEAAQUohpKwR9z9QzwBAQImKgEAAQUuuI52ojxKqzwBAQImKgEAAQVXow5ktOTcLDwBAQImKgEAAQVkYYioxs+UyzwBAQImKgEAAQVFp8pxGUHkFTwBAQImKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAADNAjAAANQCQAgA0AAAzdIwAADPYuAIADgAUBAIAFAAKADi4CgAuADiMAAA07KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAA07IwAADZQoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAADZQoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAA34AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAA34LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAA3HAQCADIAIgAYm",
      "debug_symbols": "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",
      "brillig_names": [
        "_swap_tokens_for_exact_tokens"
      ]
    },
    {
      "name": "swap_exact_tokens_for_tokens",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11096770892590629967": {
            "error_kind": "string",
            "string": "TOKEN_IN_IS_INVALID"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14520021557936622750": {
            "error_kind": "string",
            "string": "SAME_TOKEN_SWAP"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18208603774526826647": {
            "error_kind": "string",
            "string": "TOKEN_OUT_IS_INVALID"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dB3wcxdXf051kS7awXLABU0wH026vi5DENNN7JwRy0t2ZYtwNNi6cOwZ3TA+ENFJIJYWE9N5776QnX3oPIeWbMfvunp7e7u3p3sg7WPP7PWlvZ/Y//3kz86bubMx5zj3a7jh/STx3HVMS9/63KZlG7sF/fN3OhBvD3Otm7o1j7o1n7k1WMoPcO4gJN425dzBz7xDm3pHMvelKquTeMd497GLe/xne/3Qyl8mU86mym3aLyVRvXyGbzGT7cgW34GYL2VKqkE6XC5lCvrevN5/sdTPpslvJ9qYryedcLF7HSrbkUv0mebYNnWeO3tDcJihJIK5aD//1ro9y6tdHo+s2Lww8F1e/E0ralXTE6/fBxYkOkq05d7ogVjwulzejxMpQMmlSf8cIYiUE9TfaEv0dK4jVLqi/TkH9cbZhFLINo9F1J7ruILahS/0eo2Sskm7GNrQJ582Rjpw+95LTp4vbM407zbAe9hIsV+MM6WGcp4cE0QF2MWG9xBwzNsaR5dlXA9TKGTtMypnkRFo5LlxgXfR41n087TFrjx+Se+OZmifdOmAlDrHmpbya5/YI1uLxhlpXarla5SmZ5glMmoeKicvRBK9s6crZ7dQrInbSPf8e4bSAmxg3SFiD+zVtQ8WfKNgcTRIsbKZ0qDnGhHU4SdgYSKd7vJduqW4R4Erm997C3W0wLhpXT6EknHrjRd0e2i1yTepAsoHEeTbZ+zHF+79PvEFmtlow9x16QtL0BjcOnIzGe1PQ9T7oel8yDtxP/Z6qZH8lBzDjQGkdHCiWmW7eJM+D5ApdhsurA1GeaIHrgwLyapo2QEoOUXKol1da2pzhGYaY6qlK85wmyLMD8TzMMxCHe/+P8P4f6f0/Kl6fn9XuaPV7upJjlByr5Dglxys5QYm2RK6SlJK0koySrJKckrySgpJeJScqeYGSk5S8UMmLlLxYp0/JyUpOUXKqktOUnK5kppIzlJyp5CwlZys5R8m5Ss5Tcr6SC5RcSIdlR6FBf9iuc7I15x4u3FKDuyhukPBFcXnciw13d5OtuV3pvhg1j0K4yeEsbEcYKmyXxA0SvsRAYbs04oVNp/tSywvbkYYK22Vxg4QvM1DYLo94YdPpvtxAYTPB9WKvYkj3da+I21nJjjJUya6MGyR8pYFKdlXEK5lO91WWVDJtDK4wUMmuHqbBU6s8XzJ0nhl6gxv4Ho4GuEeg66PQ9UvIwPca9fulSq5Vcl3c/EYWwdbbvUawbr5M2ODRvHkZyoOXoutr0fV1JG+K6nefkn4lpfhAPMlyqe3H1QbqZVkwr3Xa93KGZ2b4MEP2xBHlmSqYw06mYki3MOlSUXqZpeR6JTcouVHJTUpmK7lZyRwlc5XMUzJfyQIlC5UsUrJYyS1KblWyRMlSJbcpWaZkuZIVSlYquV1JVckqJauVrFGyVsk6JeuVbFByh5KNSu5UcpeSTUo200mXSnzwLtJZzL3rmXs3MPduZO7dxNybzdy7mbk3h7k3l7k3j7k3n7m3gLm3kLm3iLm3mLl3C3PvVubeEubeUubebcy9Zcy95cy9Fcy9lcy925l7VebeKubeaubeGubeWubeOubeeubeBubeHcy9jcy9O5l7dzH3NjH3NsfrRhLc0d7/Gd7/ZGtugNFsteGoCGCVK8+5WXJYpevlsHpvkMNybxTDKrs3iWH1u7PFsAruzWJYSXeOFFY56c6VwupPuvOksApJd74UlqrbC4SwygproRBWv8JaJIRVUFiLhbC0LbxFBqussW6VwerXWEtksAoaa6kM1q624zYRrPIurGUiWP27sJaLYBV2Ya0QwXqurV0pgVV+Dut2Caz+57CqEliF57BWSWB5fZPVAlglD2uNAFafh7VWACvvYa1rHau2B3d961guYG1oGatQAaw7WsfqA6yNrWNBf9W9s2WsfA3rrpaxsjWsTS1juTWszXE79lJLjB0Aa4tcmndt45OeqNIThOW4/MTdVuG8ltrS6jlX7/6pCOaNzuetBvS4zQI9SpbxiiE9bjdke6R57rCE591D55miNzQ3utihyz0samxH1zvQ9d3xgYsdO9Xve5Tcq+S+uP9iR7I15+pdg7MMlNFj280uvrbKT6d5p4F0H9dupswnhPN9p2C/4H5BmylYblxb8mK6YF48EDdTh6NULzgbez+ypQ+EtLEPqt8PKXm5kocN2li9K/t6A7bm+IjbWJ3mBw2k+wRL6vWDgnXxEUEbK1huXFvy4hjBvHhF3EwdjlK94GzsI8iWviKkjX1U/X6lklcpebVBG6vfernBgK1JRtzG6jQ/aiDdriX1+lHBuvgaQRsrWG5cW/LiWMG8eG3cTB2OUr3gbOxrkC19bUgb+5j6/Tolr1fyBoM2Vr9VeKMBW5OKuI3VaX7MQLrTltTrxwTr4hsFbaxguXFtyYvjBPPi8biZOhylesHZ2DciW/p4SBv7JvX7zUreouStBm2sfmv7JgO2JhNxG6vT/CYD6c5aUq/fJFgX3yZoYwXLjWtLXhwvmBdvj5upw1GqF5yNfRuypW8PaWOfUL/foeSdSt5l0MbqUzFmG7A1uYjbWJ3mJwykO29JvX5CsC6+W9DGCpYb15a8OEEwL56Mm6nDUaoXnI19N7KlT4a0se9Rv9+r5Ckl7zNoY/WpQzcbsDWFiNtYneb3GEh3ryX1+j2CdfH9gjZWsNy4tuRFUjAvPhA3U4ejVC84G/t+ZEs/ENLGflD9/pCSDyv5iEEbq091m2PA1pwYcRur0/xBA+l+gSX1+oOCdfGjgjZWsNy4tuSFK5gXH4ubqcNRqhecjf0osqUfC2ljP65+f0LJJ5V8yqCN1admzjVga06KuI3Vaf64gXS/0JJ6/XHBuvhpQRsrWG5cW/IiJZgXn4mbqcNRqhecjf00sqWfCWljP6t+f07J55V8waCN1acSzzNga14UcRur0/xZA+l+sSX1+rOCdfGLgjZWsNy4tuRFWjAvvhQ3U4ejVC84G/tFZEu/FNLGfln9/oqSryr5mkEbq099n2/A1syIuI3Vaf6ygXSfbEm9/rJgXfy6oI0VLDeuLXmREcyLb8TN1OEo1QvOxn4d2dJvhLSx31S/v6Xk20q+Y9DG6q9qLDBga06JuI3Vaf6mgXSfakm9/qZgXfyuoI0VLDeuLXmRFcyL78XN1OEo1QvOxn4X2dLvhbSx31e/f6Dkh0p+ZNDG6q8WLTRga06LuI3Vaf6+gXSfbkm9/r5gXXxa0MYKlhvXlrzICebFj+Nm6nCU6gVnY59GtvTHIW3sT9Tvnyr5mZKfG7Sx+qtwiwzYmpkRt7E6zT8xkO4zLKnXPxGsi78QtLGC5ca1JS/ygnnxy7iZOhylesHZ2F8gW/rLkDb2V+r3r5X8n5LfGLSx+qubiw3YmjMjbmN1mn9lIN1nWVKvfyVYF38raGMFy41rS14UBPPid3EzdThK9YKzsb9FtvR3IW3s79XvPyj5o5I/GbSx+qvGtxiwNWdH3MbqNP/eQLrPsaRe/16wLv5Z0MYKlhvXlrzoFcyLv8TN1OEo1QvOxv4Z2dK/hLSxf1W//6bk70r+YdDG6q/G32rA1pwbcRur0/xXA+k+z5J6/VfBuvhPQRsrWG5cW/LiRMG8eCZupg5HqV5wNvafyJY+E9LG/kv9flbJv5X8x6CNfUG8/l1BjNuqTs+PuI3Vaf6XgXRfYEm9/pdgXfyvoI0VLDeuLXnxAsG8+F/cTB2OUr3gbOx/kS39X0gbqy9iStqUxBPmbOxJ8fp3WjFuqzq9MOI2Vqd5l46FcS+ypF5rQKk0JxJyvATLjWtLXpwkaBfbE2bqcJTqBWdjdRkEW9qeCGdjO9TFKCWjlXQatLEvjNe/e41xW9XpxRG3sTrNHQZs7CWW1OsOwbrYJWhjBcuNa0tevFDQxo5JmKnDUaoXnI3tQnZ1TEgbO1ZddCvZS8k4gzb2RSreZQZs7KURt7E6zWMN2NjLLKnXYwXrYo+gjRUsN64tefEiQRs7PmGmDkepXnA2tgfZ1fEhbewEdTFRySQlexu0sS9W8S43YGMvj7iN1WmeYMDGXmFJvZ4gWBcnC9pYwXLj2pIXLxa0sVMSZupwlOoFZ2MnI7s6JaSN3Udd7KtkPyVTDdrYGSreFQZs7JURt7E6zfsYsLFXWVKv9xGsi/sL2ljBcuPakhczBG3sAQkzdThK9YKzsfsju3pASBt7oLo4SMk0JQcbtLEnq3hXGrCxV0fcxuo0H2jAxr7Eknp9oGBdPETQxgqWG9eWvDhZ0MYemjBTh6NULzgbewiyq4eGtLGHqYvDlRyh5EiDNvYUFe/tBmzsNRG3sTrNhxmwsS+1pF4fJlgXjxK0sYLlxrUlL04RtLFHJ8zU4SjVC87GHoXs6tEhbex0dXGMkmOVHGfQxp6q4q0asLHXRtzG6jRPN2Bjr7OkXk8XrIvHC9pYwXLj2pIXpwra2BMSZupwlOoFZ2OPR3b1hJA2NqkuXCUpJWmDNvY0Fe8qAzb2ZRG3sTrNSQM2tmjLN6QE62JG0MYKlhvXlrw4TdDGZhNm6nCU6gVnYzPIrmZD2ticusgrKSjpNWhjT1fxrjZgY/sibmN1mnMGbGy/LefpCdbFEwVtrGC5cW3Ji9MFbewLEmbqcJTqBWdjT0R29QUhbexJ6uKFSl6k5MUGbexMFe8aAza2FHEbq9N8kgEbW7bl3SLBujhD0MYKlhvXlryYKWhjT06YqcNRqhecjZ2B7OrJIW3sKeriVCWnKTndoI09Q8W71oCNrUTcxuo0n2LAxs6yZZ1FsC7OFLSxguXGtSUvzhC0sWckzNThKNULzsbORHb1jJA29kx1cZaSs5WcY9DGnqniXWfAxl4fcRur03ymARt7gyX1+kzBuniuoI0VLDeuNXkhaGPPS5ipw1GqF5yNPRfZ1fNC2tjz1cUFSi5UcpFBG3uWine9ARt7Y8RtrE7z+QZs7E2W1OvzBevixYI2VrDcuLbkxVmCNvaShJk6HKV6wdnYi5FdvSSkjb1UXVym5HIlVxi0sWereDcYsLGzI25jdZovNWBjb7akXl8qWBevFLSxguXGtSUvzha0sVclzNThKNULzsZeiezqVSFt7NXq4iVKrlHyUoM29hwV7x0GbOyciNtYnearDdjYuZbU66sl91EK2ljBcuPakhfnCNrY6xJm6nCU6gVnY69FdvW6kDb2ZeqiqKRPSb9BG3uuinejARs7L+I2Vqf5ZQZs7HxL6vXLJNefBW2sYLlxbcmLcwVtbDlhpg5HqV5wNraE7Go5pI2tqItZSq5XcoNBG3ueivdOAzZ2QcRtrE5zxYCNXWhJva5IztsJ2ljBcuPakhfnCdrYmxJm6nCU6gVnY29EdvWmkDZ2trq4WckcJXMN2tjzVbx3GbCxiyJuY3WaZxuwsYstqdezJfs7gjZWsNy4tuTF+YI2dn7CTB2OUr3gbOw8ZFfnh7SxC9TFQiWLlCw2aGMvUPFuMmBjb4m4jdVpXmDAxt5qSb1eIFgXbxG0sYLlxrUlLy4QtLG3JszU4SjVC87G3oLs6q0hbewSdbFUyW1Klhm0sReqeDcbsLFLIm5jdZqXGLCxSy2p10sE6+JyQRsrWG5cW/LiQkEbuyJhpg5HqV5wNnY5sqsrQtrYleridiVVJauQjQXXJpzPPY6cPlcmzJTtuHCapwmW7cMFsVYL6k+Xm26n3pZgJ91eS/LGfNckDBJek5DHXSto6Eyley2yKEK4uwqbrqRtjvnChitvskVnkufhcTOVYh0qt/JvwQr2mmJeoYgh0glPhsMqSWYALtjrvQq0QafJRAasM2CZ1gk3zabS3WYw3S1vSTSsw2RrztUF8w4Dw8eNws07GAWNW/VwpXWxwZAu7jSkizsDdNHyK2GGdLFs906n9DfgZ6wMLG+Pth3QDd8dBmypYH67kjrU7bGCY3ufTpM6aFSmMKYJ+y2lE9zBuiuox5hszbl3GDKImHSTnN1G8WjOdxkwDCsiMrfXTEem5XXBRDQNzIp2M+VyE2qoh5o/jXQumT+bEZabTqu6Ucq7lVIlnc33pvrcXDqXq2Qq+VwhU6pkM8VSvuxmiulUbzmfrLiFcjmfTffnc5XeUn+ugo22W0qnM6Xevn43m8oV+5KFUrqYrGTy6VSyWErnS6V0IZcrptOlXKFS6C2kUsVKupDM5vO9yVwq3ZsylT+bvfwZzpHmNEMjzS1ewdpqiwE3xW+LAWO9zVDDtc3gqEbrYqsBXWw3pIvtBkc1psrF7REf1ZgqA9WIj2qmGRrVCOa3Wx0Z1VDnbjE0qtlh46hmh+FRzQ4DhmHVHjiquTsRTQOzylCv+W7LRjU7BUc1VcFRjan82YlGNX6NQpSno0zyNNXA3GNjA3OP4QbmHgMNzGpDDUy7ME9JA3avIJbktJlkY7XakDG8N0Rj1apO70vINQoDps0i1FiZyp/7nkdTcPd7BesBbrNHsjXn+m16kNzF0/KZzYI9YRMZDzqMW6LDVrEejHh+6ArzoIFOwkOGOkwPGZyufcCQLl5uSBcvNzhda6pcrIv4dK2pMrDegunaB01s6BPsoK4fma6lbpf9ltIJ7vg9bHI0/aAhg/iwwdG05vywAcOwwZLp2gcFO0WPJKJpYDYYGmE9MgzTtZL58wrB6dr1giNgU/nzit0wAjb1usOjXsF6pS0G3BS/Rw0Y61cZarheZXBUo3XxSgO6eLUhXbza4KjGVLnYGPFRjakycKcFW+tNjGoE89u9c2RUQ537qKFRzWtsHNW8xvCo5jUGDMNde+Co5rWJaBqYuwz1ml9r2ajmMcFRzZ2CoxpT+fPYbtiEIjkdZZKnqQbmdTY2MK8z3MC8zkADs8mSTSiSBuz1kmuc7dFsrDYZMoavH4ZNKG8Q3ISyvj2ajZWp/HkDkz/SewQEN524RwqeI/VGQbuuy/RwnSP1RkON6OMJg4QfT8jjvknQMJtK95sSdQUL4Q7rOVJHWnKOlOTONlwp3pwweI7UmwSHrtiqA+nnw9bCt3gV6K0JA+dI6Qx4swHL9GbDCzVS6W4zmO5WOb4t4otdumC+zcAQ6+2GhptvN7jY9VZDunjCkC6eMLjYZapcbI34YpepMrDNgi18bzNgSwXz2902sthF3S77LaUT3MF6h8m5yLcZMojvMDgXqTm/w4Bh2G7JYtfbBDtF70xE08BsNzQ/9c5hWOySzJ93CS52bROcPzSVP+/aDVv4jjQ00ny3V7CetMWAm+L3bgPG+j2GGq73GBzVaF08aUAX7zWki/caHNWYKhd3R3xUY6oM7Iz4qOZIQ6Mawfx2d46Maqhz321oVPOUjaOapwyPap4yYBju2QNHNe9LRNPA3GOo1/w+y0Y17xcc1ewUHNWYyp/374YtfJLTUSZ5mmpgPmBjA/MBww3MBww0MPdasoVP0oB9UBBLctpMsrG615Ax/OAwbOH7kOAWvm3t0WysTOXPh55HU3Af9grWR7jNHsnWnOu36UFyF0+rWIIbR4ycWwQ6lN4jakqHrWJ9NOL5oSvMRw10Ej5mqMP0MYPTtR8xpIuPG9LFxw1O15oqFw9EfLrWVBl40ILp2o8amK4VzG/3wZHpWup22W8pneCO3ydMjqY/asggfsLgaFpz/oQBw/CQJdO1HxXsFH0yEU0D85ChEdYnh2G6VjJ/PiU4Xfug4AjYVP58ajeMgE297vBpr2B9xhYDborfpw0Y688aarg+a3BUo3XxGQO6+JwhXXzO4KjGVLl4OOKjGlNl4BELttabGNUI5rf7yMiohjr304ZGNZ+3cVTzecOjms8bMAyv2ANHNV9IRNPAvMJQr/kLlo1qvig4qnlEcFRjKn++uBs2oUhOR5nkaaqB+ZKNDcyXDDcwXzLQwDxqySYUSQP2ZUEsyWkzycbqUUPG8MvDsAnlK4KbUB5sj2ZjZSp/vmJwBuRyFclVcXkb9FXDs2AStuerzF6LZGtOsh1yvypo074W8fzQZwp+zUBb+HXhPSbS+5v0LIwkx8M9PEe2XBuZgTrC4yqd598QLOtalcN19tw3DHW8v5kwSPibCXncbwkaPlPp/tYeXsm+bWg0K21gJcvSdyLemOyn8lqSo87j71hSzifH7amTUyziuo9BruCkO+FHOXJ1arLgobjftbRj8l1DHZPvJQwS/p6Bjsn3I94x0en+/h5cWacIVtYfWFpZf2Cosv4wYZDwDw1U1h9FvLLqdP9omHoBrab/+x5X6c0i309EN7/BSRu8o51o9k6ettTgPW3I4P04YZDwjw0YvJ9E3ODpdP/Est6JZGWV7J381NLK+lNDlfVnCYOEf2agsv484pVVp/vnlvROfuJxle6d/CQRzfwOqrDSOpAcnh3tmKn8v0gYTPwvErIK+AVTqSS7q9KV65dDrwRZekNzm+DUd5fo3zHVKv4X8YbrGLrWHP6LnvuVuvi1kv9T8ptE/T446V7AdEGsXwmWp98m7OhFHSuI9WtB/f1OuDdCy/ZvE/Uy/Dt0/X/o+jekbP9eXfxByR+V/ClRf/GuA+UL52bIpCMTcwbXJ+nOhSBW0hTHmAUcp1vA8VjHjI2S5vl7E7ZUV6RRTn3rrMkEHOWYUbQjxLOcz2Szvf291mWiAZ7jLPnyX1wOa8Cb2H/2Wpi/JDzSsNdVe0xzBjrpXv2fBXsQf03Itjigh78yepDO3L8Y7v349ezx9b7xgb2fv6mLvyv5h5J/ot7PaGdYej+pmDP4ZaA9sfdjgqMJnn+zvdWWnBNh6LaMnUkmC+VsoWRdJhrg+VdLeJpqtZ/xrPS/aKv9zDC02s8IttrPGmq1n/X0oPXT6QzPisq/DKyoxBDPf0NmBzXv/0YTGjvQ/btJ8/4fHU7J//SN9sETDdKF5l+CheY/w1T7W+UZE3sNLdVnkmebAM98KpvrT5VTJnnGh84zT2+w9ai9Xl/a0LUez8N1vH1gPUqo3+1KOpSMajc/AS7YS3ET7XJ5M9rQq85RXkBoF9RfpyX6O0YQq0NQf13Cr/xS2zAa2YNOdN2FrkcR2zBG/R6rpFvJXsNgG/4t2JkaI5g34wznzTiUB2PRdTe63ovkTY/6PV7JBCUT2+vTG13OsExv5DSnDkNx0LbYhvltG0bze+Ki0TEWcPy3JbMBPYba+JqTHrQ9KzhomyR4/goe6Wvcac5zxnuMM7iRNZGRJlakbSpw0jyftaQCS07nOZyjFVhiO5pU4o8zlHjpNAtWTvd4S9LcJpjmEyxJs2BldJPDlOZka851BfXXZcnOh5RjB8+0JTwzlvDMWsIzZwnPvCU8C5bw7LWE54mW8HyBJTxPsoTnCy3h+SJLeL7YEp4zLOF5siU8T7GE56mW8DzNEp6nW8JzpiU8z7CE55mW8DzLEp5nW8LzHEt4nmsJz/Ms4Xm+JTwvsITnhZbwvMgSnhdbwvMSS3heagnPyyzhebkhnlFeF7ximNKcbM25Vwrqby9L1ouucuzgebUlPF9iCc9rLOH5Ukt4XmsJz+ss4fkyS3gWLeHZZwnPfkt4lizhWbaEZ8USnrMs4Xm9JTxvsITnjZbwvMkSnrMt4XmzJTznWMJzriU851nCc74lPBdYwnOhJTwXWcJzsSU8b7GE562W8FxiCc+llvC8zRKeyyzhudwSniss4bnSEp63W8KzagnPVZbwXG0JzzWW8FxrCc91lvBcbwnPDZbwvMMSnhst4XmnJTzvsoTnJkt4braE5xZLeG61hOc2S3hut4TnDkt43m0Jz52W8LzHEp73WsLzPkt43m8Jzwcs4fmgJTwfsoTnyy3h+bAlPB+xhOcrLOH5qCU8X2kJz1dZwvPVlvB8jSU8X2sJz8cs4fk6S3i+3hKeb7CE5xst4fm4JTzfZAnPN1vC8y2W8HyrJTzfZgnPt1vC8wlLeL7DEp7vtITnuyzh+W5LeD5pCc/3WMLzvZbwfMoSnu+zhOf7LeH5AUt4ftASnh+yhOeHLeH5EUt4ftQSnh+zhOfHLeH5CUt4ftISnp+yhOenLeH5GUt4ftYSnp+zhOfnLeH5BUt4ftESnl+yhOeXLeH5FUt4ftUSnl+zhOfXLeH5DUt4ftMSnt+yhOe3LeH5HUt4ftcSnt+zhOf3LeH5A0t4/tASnj+yhOfTlvD8sSU8f2IJz59awvNnlvD8uSU8f2EJz19awvNXlvD8tSU8/88Snr+xhOdvLeH5O0t4/t4Snn+whOcfLeH5J0t4/tkSnn+xhOdfLeH5N0t4/t0Snv+whOc/LeH5jCU8/2UJz2ct4flvS3j+xxKe/7WE5/8s4akBbeAZs4RnmyU845bwTFjCs90Snh2W8BxlCc/RlvDstIRnlyU8x1jCc6wlPLst4bmXJTzHWcKzxxKe4y3hOcESnhMt4TnJEp57W8JzsiGebYRnlL5LP8WSNB8lmOZ9LCmP+8Za11+y0Fcs5tIFk3kTF0zzfsNUHpOtOXdqTE5/v0/YUR73tyRvDhDMm3FxO9J8oGCa/5zY89rBgyxpB48WTPM0S9rBgwXKdrFSybvFfMZk3ki2g4dYYmsPFbQ7f0vYkebDBNP8L0vSfLhgmv9qSZqPEEzzM5b08Y60pE04yhKeR1vCc7olPI+xhOexlvA8zhKex1vC8wRLeCYt4elawjNlCc+0JTwzlvDMWsIzZwnPvCU8C5bw7LWE54mW8HyBJTxPsoTnCy3h+aI9cG34xXtgmmdYkmbJueaTLZlrPkVwPq6n3Y40nyqY5mctmYM8zZI24XRLeM60hOcZlvA80xKeZ1nC82xLeJ5jCc9zLeF5niU8z7eE5wWW8LzQEp4XWcLzYkt4XmIJz0st4XmZJTwvt4TnFZbwvNISnldZwvNqS3i+xBKe11jC86WW8LzWEp7XWcLzZZbwLFrCs88Snv2W8CxZwrNsCc+KJTxnWcLzekt43mAJzxst4XmTJTxnW8LzZkt4zrGE51xLeM6zhOd8S3gusITnQkt4LrKE52JLeN5iCc9bLeG5xBKeSy3heZslPJdZwnO5JTxXWMJzpSU8b7eEZ9USnqss4bnaEp5rLOG51hKe6yzhud4Snhss4XmHJTw3WsLzTkt43mUJz02W8NxsCc8tlvDcagnPbZbw3G4Jzx2W8LzbEp47LeF5jyU877WE532W8LzfEp4PWMLzQUt4PmQJz5dbwvNhS3g+YgnPV1jC81FLeL7SEp6vsoTnqy3h+RpLeL7WEp6PWcLzdZbwfL0lPN9gCc83WsLzcUt4vskSnm+2hOdbLOH5Vkt4vs0Snm+3hOcTlvB8hyU832kJz3dZwvPdlvB80hKe77GE53st4fmUJTzfZwnP91vC8wOW8PygJTw/ZAnPD1vC8yOW8PyoJTw/ZgnPj1vC8xOW8PykJTw/ZQnPT1vC8zOW8PysJTw/ZwnPz1vC8wuW8PyiJTy/ZAnPL1vC8yuW8PyqJTy/ZgnPr1vC8xuW8PymJTy/ZQnPb1vC8zuW8PyuJTy/ZwnP71vC8weW8PyhJTx/ZAnPpy3h+WNLeP7EEp4/tYTnzyzh+XNLeP7CEp6/tITnryzh+WtLeP6fJTx/YwnP31rC83eW8Py9JTz/YAnPP1rC80+W8PyzJTz/YgnPv1rC82+W8Py7JTz/YQnPf1rC8xlLeP7LEp7PWsLz35bw/I8lPP9rCc//WcLTabODZ8wSnm2W8IxbwjNhCc92S3h2WMJzlCU8R1vCs9MSnl2W8BxjCc+xlvDstoTnXpbwHGcJzx5LeI63hOcES3hOtITnJEt47m0Jz8mW8JxiCc99LOG5ryU897OE51RLeO5vCc8DLOF5oCU8D7KE5zRLeB5sCc9DLOF5qCU8D7OE5+GW8DzCEp5HWsLzKEt4Hm0Jz+mW8DzGEp7HWsLzOEt4Hm8JzxMs4Zm0hKdrCc+UJTzTlvDMWMIzawnPnCU885bwLFjCs9cSnidawvMFlvA8yRKeL7SE54ss4fliS3jOsITnyZbwPMUSnqdawvM0S3iebgnPmZbwPMMSnmdawvMsS3iebQnPcyzhea4lPM+zhOf5lvC8wBKeF1rC8yJLeF5sCc9LLOF5qSU8L7OE5+WW8LzCEp5XWsLzKkt4Xm0Jz5dYwvMaS3i+1BKe11rC8zpLeL7MEp5FS3j2WcKz3xKeJUt4li3hWbGE5yxLeF5vCc8bLOF5oyU8b7KE52xLeN5sCc85lvCcawnPeZbwnG8JzwWW8FxoCc9FlvBcbAnPWyzheaslPJdYwnOpJTxvs4TnMkt4LreE5wpLeK60hOftlvCsWsJzlSU8V1vCc40lPNdawnOdJTzXW8JzgyU877CE50ZLeN5pCc+7LOG5yRKemy3hucUSnlst4bnNEp7bLeG5wxKed1vCc6clPO+xhOe9lvC8zxKe91vC8wFLeD5oCc+HLOH5ckt4PmwJz0cs4fkKS3g+agnPV1rC81WW8Hy1JTxfYwnP11rC8zFLeL7OEp6vt4TnGyzh+UZLeD5uCc83WcLzzZbwfIslPN9qCc+3WcLz7ZbwfMISnu+whOc7LeH5Lkt4vtsSnk9awvM9lvB8ryU8n7KE5/ss4fl+S3h+wBKeH7SE54cs4flhS3h+xBKeH7WE58cs4flxS3h+whKen7SE56cs4flpS3h+xhKen7WE5+cs4fl5S3h+wRKeX7SE55cs4fllS3h+xRKeX7WE59cs4fl1S3h+wxKe37SE57cs4fltS3h+xxKe37WE5/cM8WwjPNPJXCZTzqfKbtotJlO9fYVsMpPtyxXcgpstZEupQjpdLmQK+d6+3nyy182ky24l25uueNhHCqb5+8OU5mRrzv1Bm5z+JrXbkc8JQf390JKy3S6Y5h9ZkuYOwTQ/bUmaRwmm+ceWpHm0YJp/YkmaOwXT/FNL0twlmOafWZLmMYJp/rklaR4rmOZfWJLmbsE0/9KSNO8lmOZfWZLmcYJp/rUlae4RTPP/WZLm8YJp/o0laZ4gmObfWpLmiYJp/p0laZ4kmObfW5LmvQXT/AdL0jxZMM1/tCTNUwTT/CdL0ryPYJr/bEma9xVM818sSfN+gmn+qyVpniqY5r9Zkub9BdP8d0vSfIBgmv9hSZoPFEzzPy1J80GCaX7GkjRPE0zzvyxJ88GCaX7WkjQfIpjmf1uS5kMF0/wfS9J8mGCa/2tJmg8XTPP/LEnzEYJpduJyaVZQu/b4fN1L8HFKjldygsZW4ipJ6fQrySjJKskpySspKOlVcqKSFyg5SckLlbxIyYu99J6s5BQlpyo5TcnpSmYqOUPJmUrOUnK2knOUnKvkPCXnK7lAyYVKLlJysZJLlFyq5DIllyu5QsmVSq5ScrWSlyi5RslLlVyr5DolL1NSVNKnpF9JSUlZSUXJLCXXK7lByY1KblIyW8nNSuYomatknpL5ShYoWahkkZLFSm5RcquSJUqWKrlNyTIly5WsULJSye1KqkpWKVmtZI2StUrWKVmvZIOSO5RsVHKnkruUbFKyWckWJVuVbFOyXckOJXcr2ankHiX3KrlPyf1KHlDyoJKHlLxcycNKHlHyCiWPKnmlklcpebWS1yh5rZLHlLxOyeuVvEHJG5U8ruRNSt6s5C1K3qrkbUreruQJJe9Q8k4l71LybiVPKnmPkvcqeUrJ+5S8X8kHlHxQyYeUfFjJR5R8VMnHlHxcySeUfFLJp5R8WslnlHxWyeeUfF7JF5R8UcmXlHxZyVeUfFXJ15R8Xck3lHxTybeUfFvJd5R8V8n3lHxfyQ+U/FDJj5Q8reTHSn6i5KdKfqbk50p+oeSXSn6l5NdK/k/Jb5T8VsnvlPxeyR+U/FHJn5T8WclflPxVyd+U/F3JP5T8U8kzSv6l5Fkl/1byHyX/VfI/JbpixZS0KYkrSShpV9KhZJSS0Uo6lXQpGaNkrJJuJXspGaekR8l4JROUTFQyScneSiYrmaJkHyX7KtlPyVQl+ys5QMmBSg5SMk3JwUoOUXKoksOUHK7kCCVHKjlKydFKpis5RsmxSo5TcrySE5QklbhKUkrSSjJKskpySvJKCkp6lZyo5AVKTlLyQiUvUvJiJTOUnKzkFCWnKjlNyelKZio5Q8mZSs5ScraSc5Scq+Q8JecruUDJhUouUnKxkkuUXKrkMiWXK7lCyZVKrlJytZKXKLlGyUuVXKvkOiUvU1JU0qekX0lJSVlJRcksJdcruUHJjUpuUjJbyc1K5iiZq2SekvlKFihZqGSRksVKblFyq5IlSpYquU3JMiXLlaxQslLJ7UqqSlYpWa1kjZK1StYpWa9kg5I7lGxUcqeSu5RsUrJZyRYlW5VsU7JdyQ4ldyvZqeQeJfcquU/J/UoeUPKgkoeUvFzJw0oeUfIKJY8qeaWSVyl5tZLXKHmtkseUvE7J65W8QckblTyu5E1K3qzkLUrequRtSt6u5Akl71DyTiXvUvJuJU8qeY+S9yp5Ssn7lLxfyQeUfFDJh5R8WMlHlHxUyceUfFzJJ5R8UsmnlHxayWeUfFbJ55R8XskXlHxRyZeUfFnJV5R8VcnXlHxdyTeUfFPJt5R8W8l3lHxXyfeUfF/JD5T8UMmPlDyt5MdKfqLkp0p+puTnSn6h5JdKfqXk10r+T8lvlPxWye+U/F7JH5T8UcmflPxZyV+U/FXJ35T8Xck/lPxTyTNK/qXkWSX/VvIfJf9V8j8luhMRU9KmJK4koaRdSYeSUUpGK+lU0qVkjJKxSrqV7KVknJIeJeOVTFAyUckkJXsrmaxkipJ9lOyrZD8lU5Xsr+QAJQcqOUjJNCUHKzlEyaFKDlNyuJIjlByp5CglRyuZruQYJccqOU7J8UpOUJJU4ipJKUkrySjJKskpySspKOlVcqKSFyg5SckLlbxIyYt1v0zJyUpOUXKqktOUnK5kppIzlJyp5CwlZys5R8m5Ss5Tcr6SC5RcqOQiJRcruUTJpUouU3K5kiuUXKnkKiVXK3mJkmuUvFSJ/ta8/o77y5To74/rb3vr72brb1Lr7z3rbynr7xTrbwDr7+vqb9fq78Lqb67q75nqb4Xq73Dqb1zq70fqbzPq7x7qbwrq7/Xpb+Hp78zpb7jp76Ppb4/p73rpb2bp71Hpbz3p7yhVlejv/+hv6+jv1uhvwujvrehvmejvhOhvcOjvW+hvR+jvMuhvHujvCeiz+vU5+PqMeX1+uz4bXZ87rs/01udl67Oo9TnP+gxlfT6xPvtXn6urz6zV58Hqs1b1OaaPKtHnb+qzLfW5kfpMRn3eoT5LUJ/Tp8/A0+fL6bPb9Llo+swxfZ6XPitLn0Olz3jS5yfps4n0uT/6TB19Xo0+C0afs6LPMNHng+izN/S5FvrMCH0egz7rQJ8j8GEl+v13/W65fm9bvxOt3zfW7/Lq92T1O6j6/U797qR+L1G/86ffp9Pvqun3wPQ7Vvr9Jf1ukH7vRvdR9fsi+l0M/Z6DfodA78/Xe9/1vnK9z1rvYdb7cPW+1KeV6H2Leh+f3tem93npfU96H5DeF6P3ieh9E3ofgV5X1+vMet1Vr0PqdTm9TqXXbfQ6hp7X1/Pcet5Xz4PqeUE9T6bnjfQ8ip5X0ONsPe7U4zA9LtH99LbnugGO3mes3XFO3XkmQgfb5a/35ep9qnrfpt7HqPf16X1uet+X3gel9wXpfTJ634jeR6H3Feh1dr3urNdh9bqkXqfT61Z6HUeva+h5fj3vreeB9byonifU82bTlBys5BAletytx6F6XKbHKXrv+1FKjlYyXckxSo51Brscup7i/d/7ZyfvO/+zrzsdh9s3wE/3J7RbdtoL03d/+423Y78Xe36veMOB75r6s7arsd/JAX5nBfidE+B3foDfhQF+Vwb4XR3gd12AXzHArxzgNyvAb26A3/wAv0UBfrcE+K0M8KsG+K0L8NsQ4Lc9wO/uAL+HAvweDvB7NMDvVQF+bwzwe1OA39sD/N4R4PdkgN97A/w+EuD3sQC/Twb4fTrA78sBfl8N8PtWgN93Avx+4Pk99Yllz77yOx++Cfv9zPN7X+ETZ3/7deMmY7+fe35fuPihr18+4dYe7PeLAL9fBvj90fO74LSPVi577H8PYL9nPL/7jlr9/df/9e3/xn7Pen6PbPpa+s23rfoM9tN9Te04uzs2wG9/H79x3v8JBzz3v9P77QXf1Z7ptmyG9zvZmnM7Ea40fiHZ29/pDHTC/NOdCNMAfgrwE2bwd70/ot2D1YH4Dom32/sdQ7qEZ8CvDfk95PmN9vzheql33UnwTOQ75iStt4kM/zaUNu1OrZqIO1Ur06d5+M4AbDddyKVThVwqVSoni6VcvtKbzifTfdl0b3+fm0xnU4VSvphOJsvpcn8mWcr1ZkvlYm82Xekr9uYA+3QWO13uU1DZYq7Q51aKuUqyL5MvpIuVfL5ULPWqufNssuT259z+lFspFIrZbLE/2+u6lXJvtlKoYc80opfn6op2ZxjBT2cB/0wj+Kk+wD8L4Qu+u5gE/LPN4Nds+Tlm8Gv5e64R/df5n+fhO4687s83wt3NA/4FZnSTBvwLzfCv6eciM/wzgH8xwo8Z0M8lZvBrZfNSM/i1unWZGf1XAP9yD99B2G4hnUrl03pNtVBKuplSf6qgWq++TLI/WexPlXszbm8lk8qk+0v9fWr9tehWkpVif2+l8Bw4YF9hhHu6VnauNKL7dK1dvIrRTbI1V2uzrvbHHrL6AfslDHaqmO5P9laSxWyhmC+rhfSk6ozky32FciWXKvapjkeq5LpuOaP+pMqlTG9fKef25dTqe7ZPRVfL02uqJvLUrfWhXiqMnysme8u5XM0eXyuM39eXyxeVPgH/OmH8dH+uXEnna/bgZcL4xWymUsmmi4BfFMbPuslyNpWvlc0+YfzevmQ2VyjUyk+/ML7qN6dLvcVaX7AkrZ++crK/5PbCmKzs4UMc2kHcFeG4PdcbI/E5zsAxp0Pi7yJcpft9MRIf5oP1A+M70N2s6mCuPYwftjHUL87cg3g4rGsFsa4TxMJ2gvo1i1UUxOoTxOoXxCp512brWqbWjs4ygp8uAP71RvCTZcC/wQS+W+873ojwHTn+NfybEH7MAP5sM/qv4d9sRj+1cc0cD98E9lwzuqn1weaZwa+NC+abwa/1UReYwa/ZhoVm8HsBf5EZ/FofdbEZ/Fof7xYz+LU+6q1m8EuAv8QIvlvTz1KEL2c7UzXbdpsR/HQNf5kZ/Jp9W24EP1PDX2EGvzavstIMfs0+324Gv2afq2bwa32fVUbws7Ux8moj+Lla+VljBr8257rWDH6tfK4zg18rn+vN4NfK5wYz+LX+wx1m8Gv9h41m8Gv9hzvN4Nfar7vM4Nfa901m8Gvt+2Yz+DX7tsUMfs2+bTWCn6+179vM4NfmYLebwa/Zzx1m8Gv2824z+DX7udMMfs1+3mMGv2bf7jWDX7Nv95nBr9m3+83g1+zPAx6+M3TsNL2h91vr/UiPTngOj9vHJdjXSsIeqUQ9KQPm2/V1O7ovOI4qhZlvx/F3Ea4m5ttxfMCH6gfPt2u/DoZrD+NH87CDiaeDiaeH8aN9v1awtglirRfE2iKIJZnGTYJYGwWxNgtibRDEWiqIJal7yTq0PaJYqwWxJMuEpO4ly9daQSzJui1ZJtYIYkna6J2CWFFtH6FPbbZvlcx1M3GDA79RKG7cp6IuTn5j3rqv+tiEOi4NB26sU19TXrh0Tv/5cxeVFzoBD2h3WpW/HzXlxYjf6BBpcJzGin0qhGJpBx5z6yaY+NkYgxVn7tHCjHWe8OGAMSCvaEd4hvc72ZJz02HSgeMfrkEEZyS4QQToZ5QZ/aRiBB/zGcXoh5Zhmncxp16R2xEWDj8KpRGHx9fwPL73be9/jzO4HsHm9xjjF2fugX4196+StOG8oeXUTD5k3LDlFOLvckzWm3o55coF15h1OoPzWXJDUJh85WxbJ+MHWLBBD5dTHH40SiMOj6/heXzvF97/HmdwmabltJNJD76Hy+nT3nWnT3pmeL+TLbl8nmunaD3AepLc4By2HkD8XY7JclevB1w+cfYEdNfFcO1h/OikTxcTTxcTTw/jRzuirWBtEcRaI4i1ThBre0SxNgpibRbE2iCItVQQ6y5BLMlyH0V9BbWDzWJpJ1lWdwhi3SGIJVlWJdO4WhArqnX7PkGs2wSxYPGQ9jMB33HqfSXa3s/wfidbcs+N3XB8kA58D8ffRbjK8qn3lTi9cn1a0M8YM/qp8RnD8BnD6AfycizjB1gw14LHDDj8GJRGHB5fw/P4XtLLsB6CqR0dM4xl0oPv4THD9NjAtOG8oeXUZD7g+IA3vofj73JM1ptkYLng6n+nMzifBfWTDJOvmC/kZTfjB1h7eb9xOcXhx6I04vD4Gp7H915Eyiku07ScdjPpwfdwOS2QcorzhpZTI/ngVkKXU4i/yzFZb+rllCsXYxg9djqD81lQP8kw+Yr5Ql7uxfgBFhzchMspDt+N0ojD42t4Ht87l5RTXKbpS017MenB93A5nenhdvqkZ4b3O9mSy2a4vJTDz7vdTDppPcO6livX6dD1DOLvcgaXCxP1bBzh41cOQHc9DNcexo+WkR4mnh4mnh7Gj45rWsFaJ4i1VBBrjSDWXYJYqwWxNgpibRLEkiwTawWxVglibRfC4uxzK7y2CfHSbocglmTdvk8QS9IWStbHzYJYkvl4vyCWZJmQ1L1U3XaE0yhZJrYIYkXVTkjy2hP6TCNt2u7TvWR9XC+IJZnGeyLKS7I/IZlGuj6Ax5Yx73+nM7juCY6z4Sz+WnyQDnwPx99FuMryqY+zOb2OY/QKuhvPcO1h/Og4ezwTz3gmnh7Gj7YZrWCtE8RaKoglmcaNglibBbF2CGJJ6v4+QayRfGwO635BLMkysVYQa4sglqT92i6IJal7ybIqqfuo2q+1gliS5WuTIJZkPkqWL8k6JFm+tglirRbEkkyjZFmVrI+SaZTsT0Q1H6Pal7tHECuq/RzJPuZIf+L5UYck7YQkL6nypa/pvGorvO4W4qWdpO4l+wDQ1tL9boCvndk5tFToPbZ0Ds3IHqwGc2jc3rpOZ3A5FNSPGyafMV/IywmMH2BN9H7jPWE4/HiURhweX8Pz+N4MTyk9BFM7uidsApMefA/0q/eEnej96PRJzwzvd7I1V6DzoRAHjhvrSbDchfr4AY6/yzFZ7ur1gMsnzr6A7iYyXHucwWWHloeJTDwTmXhGsKKFdYkQVpANA3/tOpnnpO0tjg/Sge/h+Lsco3bBDdIrZy9BP5PM6Ke2R3kSw2cSox/Iy70ZP8CCL+zi9giHn4TSiMPja3ge3yuR9mhvFJbWgb2Z9OB7uD26tm1g2nDe0HJqJh/Cv/MB8Xc5JutNvZxy5YKr/53O4HwW1E8yTL5ivpCXkxk/wIIP3eNyisPvjdKIw+NreB7fW0DKKS7TtJxOZtKD7+FyOtv7Mc7xr59h6jPG5ew21SF+jtYHI/ntlpNh6wPE3+WYrJ/1+rB3SL2CfiYb0U+pEqb8YL6Ql1MYP8Dax/uN6wMOPxmlEYfH1/A8vreG1Adcd2h9mMKkB9/D9WEFsds4b2g5NZIPyWQlbDmF+Lsck3ayXk65csG1f53O4HwW5FMOk6+YL+TlPowfYO3r/cblFIefgtKIw+NreB7f207KKS7T9F29fZj04Hu4nN5Fxrs0PTO838mWXNnl8lIOv5jsZHQth5/q7WTySw6/rwD4+5nBzwH+VCP4hVr+7m8EP1vTzwFm8EuAf6CZ8lPjf5AR/HQa8KcZwS/X+B9sBD9Twz/ECH5frf4eagS/t1b+DzOjn1r+Hm4Ev5IF/CPM6KfG/0gz/Gv2/2iELzkXAfjHGMFPpkEf0526izNpgvihL3IUCh/z+Q9Y1A/i6iJYpvp9XNowfzrum474YB34YU1vEquT8TORp0cHpBvH3x3AlaZDO3oGzlB1ot1aQayqINY2ISyub9sKr2WCvKYI8eL6v61g7SuIFRfC0o5+rK8VXvsJ8dLXUyOKtb8g1gGCWAcKYh0kiDVNEOtgISzt6EeaWuF1iCCvrYK8DhXipa8PE8SSajv09eGCWEcIYh0phKUdnTuNChasIZud78r0mp3vShfNzndlSmbnu7Jps/NdmbzZ+a5MP/TVoT2EOHDZwu2b3LgiE/pdUIi/i3CV5VMf3x1I+FD90P07BzFcexg/WkcPYuI5iImnh/Gje3lbwdopiLVaEOsuQayNglhrBbGWCmJtEsRaJ4i1PaJYkmV1gyCWlO65djsqZVWyPu4QxIpqfbxbEEuyDkVV93cIYknaCcm2VtJGS+peUl9RLV+SfRPJfJTU/Z5gJ+4TwtLXdAzbCq+Vgrz2FeIliaXd8qocr/0EeUnpXrtVgliSZYLOpbeCFRfC0k6qTGhXFcRaIYglWb4keUmV1SjbwrGCvCTLqmQ+StrVqOpLsqzSudWo1G1J+3W/IJZk/2u9IJbknMI6QSzJscJaQSzo38M89v7IL+b9N7sGkBzyGsD+ZvgErgHsz+iV2w8ryKcUJp8xX8jLaYwfYB3s/cZ7+3H4g1AacXh8Dc/je6/yMq6HYGpH9/ZPY9KD74F+9d7+l8cHpg3nDS2nZvIh/DdgIf4ux2i9cYPKxYGMHrlyAc/2MH60Tz+NiWcaEw+X93TvWytYWwSx1ghirRPE2h5RrI2CWJsFsTYIYi0VxNoqiCVZhyTzcacg1mpBrB2CWJJ1W7J8SdYhSbu6J+h+kyCWpI0GW8i9RyXY/0hy7zkJ4tfeOTg4QBc4froXB/y5/4BF/SCuLoIlnDY3KG1BY7eDEZ9p6NoP6+Amsbh340zk6TTHP904frPvAmZTZt8FzObMvguYqUCZPxTpM0Z0d7iRvCyEPksF4u8iXE3VqcMJH6ofOh46guHaw/jRvXtHMPEcwcTTw/jRdrsVrJ2CWKsFse4SxNooiLVWEGupINZWQaxtgliSuo9qWd0hiLVOEEuyfEnanC2CWHuC7jcJYkmmcXtEsSTr9gZBLCnd62u6LzcqZTWqfQBJrJF2e6TdNmlXR9rtkXZ7pN1+/rXb2knqK6pl9W5BLEl9SdocSd3fIYglWYck2+2o2uio9ick0yjZ95XMR0nd7wl24j4hrJgzeH9OK1jTBLGk5sn19cFCWNrRvcet8BoryGulEC/tVgliVYWw9PUhjhzW8133+pq+O9EK1r6CWPsJYWknqa/DhHhJllXtJOtQVMt9VNP4fLeFkry0G2k77G87tLtdCEtfS+55kNKXvp4qyGuFIC+ptlY7yfZRUl9RbDu0u18QS3LMt14QS3JNZ50gluT8xFpBLPp+G94bFvP+c+fF63hmeL+TrblSjMQH6cD3cPxdhKswHzdIr4czeuXOuxfk0x8j+JjPkYx+IC+PZvwAC87JxO+34fBHojTi8Pgansf3/pd47n8PwdSOvt/GnZWO74F+O5Q8kxiYNpw3tJyayYdU6PfbIP4ux2i9cYPKBVf/uXIBz3L5Rdv9sPnFYW0UxNouiLVGEGuLINZOQax1gljbIsprrSDWUkGs+wSxbhPEul8QS1JfmwWxJOvjDkEsyXIvaQsl83G9IJakzZEsE5sEsSR1v1oQS5LXVkEsyTIh2TeRbLcl8zGq9kuyfEnWx6jaaEksyfK1QRALdA/jFTy+iXn/O8lzMUd0rJeJkfggHfgejr+LcJXlUx/rcXo9ktFrM98XA65wjf1wPMP9HS/ttghirRHEWieItT2iWBsFsTYLYm0QxFoqiCX1bSTtVgtiSdbHHYJYkuVLUl93CWJJli/JOiRpVyXLhKRdjWrdlqyPknVopyCWZH3cE8rXJkEsyT4AtLXjPD/c38bnkWA/HE9Qnx8/D+G6medi3v9Owi/mSPaxe0Of1wHxdzE6MdHnnx5Sr6C7YxiuPYwf3btyDBPPMUw8PYwfbZtawdopiLVaEOsuQayNglhrBbGWCmJtFcTaJoglqfuoltUdgljrBLEky5ekzdkiiLUn6H6TIJZkGrdHFEuybm8QxJLSvb6m53VEpaxGtQ8giRXVdltS95J9AEkbLdmfiGpZHWm3d1+bNtInbw5rpE+++8rXSL9w95WvKPYLtZPUV1TL6t2CWJL6krQ5krq/QxBLsg5Jth1RtdFRbdMk0yjZ95XMR0nd7wl24j4hrJgzeI9TK7yWC/KaJsRLX48VxJJcH5LU11RBXquEeGlXFcLS14c4clhSZUI7+m5zFHQvWbel66NUHdLXBwthaSdZH/eE8kXPG2oFa19BrP2EsLST1NdhQrwkbaF2kjY6quU+qml8vre1kry0G+mb2N92aHe7EJZkf0I7KX3pa8k++QpBXlJtrXaS7aOkvqLYdmh3vyCW5JzCekEsyXWrdYJYkvNfawWx6HlDY5FfzPsP+3yxrdPxzPB+J1tybujzhiD+LmdwWyXHp77Pd7IzWK9jGb2C7qYwXHsYPzo2nsLEM4WJp4fxo2u+rWBtEcRaI4i1ThBre0SxNgpibRbE2iCItVQQa6sglmQdkszHnYJYqwWxdghiSdZtyfIlyUsyHyV5SdoJyTIhmY+bBLEk7T3YVehb0T7BDO93siWXzULfBPdlYs7AuGnfRCZutxAj8TkO36+D+LsIV1k+9X4dl29YP7Rftw/DtYfxo3m4DxPPPkw8PYwfrZutYN0piCXJa4sQlr4e5chgSadxqSDWJkGs7YJYGwSxJPW1QxDrXkGsrYJY6wSxJHW/URBrrSCWZBrvE8S6TRAL5vlo30K7Gd5/1RymC7l0qpBLpUrlZLGUy1d60/lkui+b7u3vc5PpbKpQyhfTyWQ5Xe7PJEu53mypXOzNpit9xd682b5DtrfT4dtXGXzXBfx9zeCnAH8/M/hpwJ9qBj8D+NPM4GcB/2Az+DnAP8QMfsHs2QdurfwfYwa/CPjHmsEvAf5xZvDLgH+8GfwK4J9gBD+VBPykGfyafXPN4NfsW8oMfs2+pc3g1+xbxgx+zb5lzeDX7FvODH6tfc+bwa/Zz4IZ/Jr97DWDX7OfJ5rBr9nPF5jBr9nPk8zg1+znC43gp2v280Vm8Gv288Vm8Gv2c4YZ/Jr9PNkMfs3+nGIGv2Z/TjWDX7MPp5nBr9mH083g9wH+TDP4/YB/hhn8mn070wx+zb6dZQa/Zt/ONoKfqdmfc8zg1+zPuWbwa/bnPDP4tf7b+Wbwa/23C8zg1+znhWbwa/bzIjP4tf7bxWbwa/b5EjP4Nft8qRn8mn2+zAx+zT5fbga/Zp+vMINfs89XmsGv2eerjOBna/3Pq83g1+z/S8zg1+z/NWbwa/b/pWbwa/b/WjP4Nft/nRn8mv1/mRn8mv0vmsGv2f8+p+7q2Olyn1pKyBZzhT63UsxVkn2ZfCFdrOTzpWKpN1POZ5Mltz/n9qfcSqFQzGaL/dle162Ue7OVQo17P4vdiqvP+5dM6MWt1OxCGeHHxPgXavgVI/jJWr2aZUQ/pZpdvp7J21SmlOsrJvOVfLFYqKhGNFVS/3Kq1FSyqWJvur+oSlGpr1zsS/f3pvpLqVK6XFC2ppzuzZXL9TbrBuly4yZrer/RiN7r6wk3ieu9sOuv/mbnnd4mCTg7ejaKq52k62bvN3yPVLvZ1XqY2cgfh3+s67n/Or4tXnzdKD0Oikc7SHdCPN279NobI/E5Dr8HCeLvIlxl+dT3ICUIH6ofugepneHaQ/y0o2vS7Uw87Uw8HNb9glhLBbG2CmKtE8TaLIi1VhBroyCWZBo3CGJFtXytFsTaJoi1QxBLsnxJ6usuQSzJ8iVZh7YIYkmWCUm7CnsVO53BbaFc25xLQ1uLxx3gwA+PG2LEr4zCn16th6MuTn7jNI1W8tkJdVwajvLB/aYSwvfrM2gHeuxA/pJ9HMDvNIOfBt2PdgbqlKap00dX4M/9ByzqB3F1OYP1bqJ/yKUN86f1ZTTig3XghzW6SaxOxs9EnnYEpBvH3x3AlUsHHd9w9ojrf0P4zgBeOPw4Jm54FnTYhfwEdZgK0iGuixD/WMSzVO5bPOvcubMc4uJED6C3fUi4c6t1PdAyONoHyyG/9yH34ggPO7Njxt3bDkCamm0HsG5LxG+odk87ahuozrXTef1bMrcQZ9JEy5Df3EIc+ePwfxpVj++P3vUYFOfYgDi7CW8cXrtzqwPD74XSFmfCjCUcIfzfPV46/77r5R+nO+DTSZ5/PpVlSFOzZRnnI+UGmFB2aN765Uvb6DqXH0yoc6bxdQekA373MfEB9x4SVjvI4/HovuAcV+jvpEH8XYSrcDtU68OMJ3yofsC2aB2O8a5nzy2WTi3OW7h4drmNqHIcusbwPQQOwuCw2PUgSo5POJrt2l1YHfwcdaDKdsL5EK/4aXMy1rvudvjipV2nMzjNglnUH7bIQPxdjkkzVS8y4wgfqp82oh9DRbgv5gwurnEmTuALeTme8QMsz+oMMF04PC7HODy+hufxvf288tTjDK5251UHcuCqJL4H+tXldBIpp7jc31gd6NfOxAl+HQF+owP8cJcVygD4daHnZpPnxjCYmsP1o+t4fmUN5zc09+OcwWXfzxb5Yc0kWPj58QRrQgOsCwgWfn4CwZrYAOsigoWfn0iwJjXAmkuw8POTCNbeDbDmESz8/N4Ea3IDrPkECz9Pj2+b0gBrAcHCz9PPbe3TAGshwcLP0+NN922AtYhg4efpkWv7NcBaTLDw8/R406kNsG4hWPh5euTa/g2wbiVY+Pn9CdYBDbCuJ1j4eXi2m8Gi7fOB6P7uaJ8h/i7C1VT7fKAzWK9YP3TZ8iCGaw/jR+3WQUw8BzHxcFgTBbEmCWLtLYg1WRBriiDWPoJY+wpi7SeINVUQi9qtRu31ZdXn/ge11/AcLrs4XByF4dpojOHXH4g74fsFFxLOXJxcH/Pm6kA/PIVL+4N4upH2yfFU7Hjih/uY1O7jadoJxG8M8oP04D5mO0nPTd59s9M9ySTOLz9d0XEv999xwk0HclO6QePaocaDsU6vDoxn+KdckuUw6cDxm55yAV1MDNDFJCNxZ0JPP00iuphoSBdQFhuNC+gSD9f3n8iEx9NVs8qL1KLJKUsvLc4ahYJiM0TpdJNw48nvCT60ZpBwk8hv6F5QHhgLO8ojaDqMi58zI3DdztzXjhs29ZA4uWzjTufqYZ6fHBDPxBbjmcjEY/YUlKThU0rqq67cUBWnCeIPOk0urBmAuIbrtDcubUH5zJ32FoQV9oQywDJ7sk09T4NOucPxN3vKHV69w3ZutNeX0t2gHQFTh7RZMrObJ50LWx4h/uHa+Rt25wHXtYVne4ifdvSrBtwugA4mHg5riyDW3YJYmwWx1gpiLRXEkkyjZD5KpnGNIJZkGjcJYm0VxLpLEGudINYOQayNgliSZUKyPkrWIckyIamvDYJY2wWxJHW/XhBLUvfbBLEk9SVpC1cLYknqK6q2UFJfkjZnT+gzSZYJyXZbSvf6mp68HZVyL6n7OwSxJMu9ZBol7YRkH0BSX/cJYoV5O5Yb10N47o0Cbl5qT3mjIEvCSbxRkCX34g7/RoHG/i15W52+jaCd2fnYdCpG4qNpdEj8XYSrcP7X5qy47UfcvCfobj+Gaw/jR79KzG1N2o+Jp4fxo+12K1ibBLG2CmLdJYi1ThBrhyDWRkEsyTKxWRBrqSCWZJmQ1NcGQSxJfa0XxJLU192CWJJlda0g1p6Qj9sEsST1JdkOrRbEktRXVNshSX1J2nvJ8iVpcyTro2SZkOwzSeleX9M5mKiUe0nd3yGIJVnuJdMoaSei2v+6TxAL5mC4V1XoFnluDLtvQDz4+X1DYHHjYQjPvdoSNNfDvdoCcw+GXvFIBeUH93rMUOZ6QG8uCUfnerBtm+qD5ZDfLrnnN9dD9y0t8yayQL+G9qOxW7PpfkW8Z5Tui+ReV8T3aPnFz0M4s2ls/rSBHuJXRn50q34FYeHTIqiLk984vbq8Pt3ESQQ4P0o+mO1M2Bjxg7B3dtZ5/NbjMdx5b2aucPjyfma1Ho46Lu8hvVrnf2gx7+n+V8ybex0Xz5FjP+BK79F8xM+PD4jn8BbjOZyJp5t5LubzH+Kh92g8HOeg+fahxoOxwFaYnbtvvvxTPePyT/fmVpAfPdUMn9SM14Go4+oG6ELXjfTEOi4NB87syW7Dp0P6ihjWIa7b1HE6BF2E1eE4p3Hd7mLSwbUT9J2GZtsJ/Py4gHg6W4ynk4knan2RicQPlyX6miIuS3sTP1yW6LrY9cgvRvxuQH4dxA+fOk5PwMMnhlPbgE/4btY24D7TrBDlOky7ie1/mfiNZnDNvrqWTodpX3D8XYSrLJ/6eiv3Si13YiPobm+Gaw/x025FtR6O+sWZe20BWBsFsbYLYq0RxNoiiLVTEGudINa2iPJaK4i1VBDrPkGs2wSx7hfEktTXZkEsyfq4QxBLstxL2kLJfFwviCWZj5L2S1JfWwWxVgtiSepLsg5J9ick9XWXINaIXd19dlVK9/qarrdGpdxL6v4OQSzJci+ZRkk7sUEQK6r91WWCWNBfhefwGB/PORtel0vtzjM2uDVmOqYHf+4/YFE/esbG3mbSFnjGRlA5wGtQdJ2+lTM26Lksps/YmByQbhx/dwBXLh2TBHUS5ssX3NxSs3nLnbkDzxquY7W9C5MC9ITjb+U9lRQJB+uRbc7gvJvsg+WQ3ylyz2/vApQjfLYLrG/pOeMLunjO+MhpfKbNeOSPw29AX3G82Lse5wwuT5Au7qsPcGSb2S/HND/P3078ykx6YgwWN0cOaWr2Cwf4XSb6hQPA9PvCQQfyx+Gv66pz+cF+PGYMYeJ3uujXL2AdocOppxuHoRwgfD/iAF+/oJgJn3SN9sFcispipYvHdBhMLl1dJF2UQyfhAOFvROl6Gm2QwmHgNy4nc6oDuY1h4nJ87mFs/Cz1C4q30bP6Gn/9gvrRskL1hZ/30yktKxB+YUBZ6WA44PTSfKUcaJguHw63Mhzw8X79c+ct9b5G4RBHP6rTTn7TrKRZ0MHg+DlQg35maRePg8OBo8UPL8OOZuIY7cMRP6vVA9lbKs8uLyr7KKiNgLX7RNbm8I77fADYUsNfIwv9Hib9KlyHGT6BX4Xj3lfmjrCFZ3sYP7q+HzaesQ6qz4vmLvArC7hQcmUh7hN/jHneIc/GmHuOM/CdXq7vQtPc7BcqO5n0cPH0tBhPT8h4JrYYz0QmHorF9SO1q1Tr/jj83ci+/nQ/HrPNBxM+cwHhub49t+cEwnNzE5OYNHLv1+/tNI4b65K2R5Ob5NpobmAS4cqNMcNynTnMXNub5NrJxI3bZNXo3HBLecH5cxfVTmF2GBoOuabtMQ1Dm5nRPlTHknC0G0anbaipm0B+j2H4cY4zdZRL3Gns6JbkV6Mq+gufKuo4fBWFYk+HpfhZPCyFInELEw7ivJWkB4fHcUL4JSgerut3C0k3hH+c6fr1MJyATyd5XraJz/eCDpc6gx343eYMTDv2W4bCn1ath6OOG8ZCmrQunmpiGIvzkXIDTNxk4Lz1y5cn8TCWfKgPx3er458O+B1n4qO6BH/tII+XEYwZ3u9kSy5bjJH4HIfvVkL8Xc5g3ZroVi4jfKh+ODMc8KG+pegaw19F4CAMDovdVYiS4xOOy/YpzHPUgSrbCeevotmGjxCzhas+/b4o5hBn7tHeVoLhz8XT0WI8HUw8dHeodvSDbjc7g9MKfnPQc/Tja3ORH/2g2zxncLrAb34A5oIAzIUBfosC/BYzfprTqWPrHKk55qoG/Ugczju/euCHNZNg4eeXEazlDbDoR+Lw88sJ1ooGWBcRLPz8CoK1sgEW/Ugcfn4lwbq9ARb9SBx+/naCVW2ANZ9g4eerBGtVAyz6kTj8/CqCtboBFv1IHH5+NcFa0wBrEcHCz68hWGsbYNGPxOHn1xKsdQ2w6Efi8PPrCNb6Blj0I3H4+fUEa0MDLPqROPz8BoJ1RwMs+uEm/PwdBGtjAyz6QSX8/EaCdWcAlr6mb5fg5+8kWHc1wNqXYOHn4dluBivm/Yfu1yZ0X66744be7Q/xdxGusnzq3a9NzmC9Yv3QWb3NDNcexg+3RdgPx7OZiYfDWiqItUwQa7kg1gpBrJWCWLcLYlUFsVYJYq0WxFojiLVWEGudINZ6QawNglh3CGJtFMSibVlQv15fwyJvUL8ensP2jE4PxckzODzG8Bs3xBHnZQ04TyWchzp+0NfTCNZQxw/6+mCC1cr44fzqQKyhjh/09SGE11DHD/p6OsEa6vhBXx9DsPDz1OY2Gj8sqQ7Ews83O364hmANdfygr491BmINdfygr48jWEMdP+jr4wnWUMcP+voEgjXU8YO+ThKsoY4f9LVLsFoZP6QIVtD4YVMDrDTBws9vIlibG2BlCBZ+fjPB2tIAK0uw8PNbCNbWBlg5goWf30qwtjXAyhMs/Pw2grW9AVaBYOHntxOsHQ2wegkWfn4Hwbo7AEu7M6sDsfDzdxOsnQ2wTiVY+PmdBOseJziNJzoDsfDz9xCsextgvYBg4efvJVj3NcA6iWDh5+8jWPc3wHohwcLP30+wHmiA9SKChZ9/gGA92ADrxQQLP/8gwXqoAdYMgoWff4hgvTwAS7srqgOx8PMvJ1gPN8A6g2Dh5x8mWI84wWk82RmIhZ9/hGC9ogHWKQQLP/8KgvVoAJZ2s6oDsfDzjxKsVzbgdSrhhZ9/JcF6VQOs0wgWfv5VBOvVDbBOJ1j4+VcTrNc0wJpJsPDzryFYr22AdQbBws+/lmA91gDrTIKFn3+MYL2uAdZZBAs//zqC9foALO1gV9I45vnXE6w3NOB1NuGFn38DwXpjA6xzCBZ+/o0E6/EGWOcSLPz84wTrTQ2wziNY+Pk3Eaw3N8A6n2Dh599MsN7SAOsCgoWffwvBemsDrAsJFn7+rQTrbQ2wLiJY+Pm3Eay3N8C6mGDh599OsJ5ogHUJwcLPP0Gw3tEA61KChZ9/B8F6ZwOsywgWfv6dBOtdDbAuJ1j4+XcRrHc3wLqCYOHn302wnmyAdSXBws8/SbDe0wDrKoKFn38PwXpvA6yrCRZ+/r0E66kGWC8hWPj5pwjW+xpgXUOw8PPvI1jvb4D1UoKFn4dnuxmsmPcf1p8+gO7Lrfdk3BiJD9KB7+H4uwhXWT719acPOIP1ivVD158+yHDtYfzonOMHmXg+yMTDYS0XxFohiLVSEOt2QayqINYqQazVglhrBLHWCmKtE8RaL4i1QRDrDkGsjYJYdwpibRLE2iyItUUQa6sg1jZBrO2CWDsEse4WxNopiHWPINa9glj3CWLdL4j1gCDWg4JYDwlivVwQ62FBrEcEsV4hiPWoINYrBbFeJYj1akGs1whivVYQ6zFBrNcJYr1eEOsNglhvFMR6XBDrTYJYbxbEeosg1lsFsd4miEXnHFvBekIQ6x2CWO8UxHqXINa7BbGeFMR6jyDWewWxnhLEonOOjfbJXetdB+2Tg+fwvBN9xTBOnsHhMYbfPrw44txoP951hPNQ9+Pp65cRrFb24xUJFn6+2f14UwgWtx+Pew/u5upAv5vRc/QdhjnIj75bNxf5LSV+85AfnZeej/yWEb8FyG858VuI/FYQv0XIbyXxW4z8QEf4PTh4PxJ0NNO730nSBmVwhvc72aLjvpZG9YjzLebz33EGz7FrR20A/lJGjMSzVDAejHVa9bn/UEZx+aXHD9xG4qH3aDz4+dt8sODVbO3wF9XmIH8c/mIv7zX2r/cbiMntTb4Z3Ts3IK3wLJQpatdmeL+TrTkX8FeawU8H2V+cJloHse6aKV84ri7HYduVGUK6C0ob5k/LIW4PwuwbX9EkVifjZyJPlwekm7O5HFcuHX51E8cTdDrnygBeOHxQ+ww6xG2koA5TQTrk2vihnM4JeptKwtEvi3J9HYrlkN9Tyb24w5/Oydm2Th+eEG8jO46fh3BBR1iEsRtcPBxniAefL4BPG51H3pWHcoeP/MDvteyD/HH4LRPqmAs9TO69G7+6EkPx4bMJ6FExEJ/fUTFzfPgtQe0ePalwDpPmfQI4AyY+/wFzhnMYKIcVpN9lqI1k+10Q1zjCl+YPTQuXJ7TcLWH04Kdb7XA/BfdjcPg1TfZTcPmm/RTMCZ7lxnpUD1w8Qe3kkpDxdLUYTxcTT6v9EC4ejjMdU2mH7ck2Yk+g3OG6hZ+F9+DbSfjlyJ7cHWBP6P4U2neiNpbaE4jPz57Q8gnh7w+wJ1zf/MKqP2fAxPYEc6b2BMI/TOyJof4Ta08gLq69HOPw+nCccO3lGEYPptvLMSSe5YLxYCyoK1xfjtqfZvvW+Hnal/Wrr4+P5ePk6isuu+0k/Gmovr6F1Fdc3kHnXLmhbdRyJl5aZxxn8PhMuyBbttwHK2wbBeHfHdBGBY01tAsaSwfNOeJwOEzQ/F88IA5cbvF96BvjtnMOCbuChF0eENZv3Kiv+71rs2P7fAXqAp7DBAd+VYYz+K1C4S+v1sNRFye/cZp2fTV+vzouDUf5YD1VfTA5e0FPD4c0tzG4KwkutgFUX3DOFq3/3/Tqgq7/nxvL49Fyot1VHp7Z8WshSfMXO5q/VD/UcfkLvHX+Tp1ax6XhaJw4D1cRP2yz6dlu2NYDhtb906RPELW6NJT60ow+ufrC6ZOuEXBtJ9ZnO8GId9fD/ISUdwhD2wvtoP5AnQX9JZjntaN9Pwj/C9T2zJrKxx9U3xyHtwtYD/RMxqrDc+HSXIvG0xOUR1zH5MpjxoV8XE0447jXGIo7RuJzHH6edw1SCeUDvLsYv0QLXLNuPp/KZUrZSl+ukM2WYwQfuNJ7dI6SOwtiHBMedL3OiK7TJbAB8Wodfy3Sq3YJ5LeG+LUjP+Co69CNUwfyX2uIfxj94/h7mPAzq/VwzeRlDxMPHXO0grV8iFgTnIF1gGsLcd+GtoW4/4LPAT0INRicXQyydWDbqN3H6aR2cH9i66roGcEylOH6o9TWrTYUd1hbB/F3O/5528X4tWLrStmMm6n0ZvtKlXS5lK/EnMFtQpy5R20dV273YsIbthVJztZRe5ZAfquJH7Z1wJGzdWbaxXQyjP5x/D1MeGrrwuZlDxMPtXWtYC0fIhbYulXo+ap3zdk62k9dyaQH2zo6LjuE2CQzR9/zc4TUpmK+2uEx9EqkJ6pfioPv4X4zfobO2UD46ajffmQ3zw/ScB7Dj9tThNN1bLd/uJVMON2Nh37UrPKiS64vLiiXLin3Lygvijs8PZpEmnw6nHJIOO3ol68Wkt90+uZmggNNcNgvX8F/jMVlHcamTS/YQ23CFhMTNofENQOeadFxQ0fa1JpZxkuFHlZA/F3O4CJnYvsIN7WJ9UObRzPLEqmk/vAlnfrW7obqYN1QHlBe6DZA8Of+Q3rpPdpM4LJIy02QCfQzWechk/Wi7np4agPCbNkKsxSP7+HwZeKHl85iAfh0GuQ0VI+fJlOhuKsD6ah9dBL5SdYzzWMJmmKi5Ql3o/zKP/f5BggftJVMO1hqCNpaxJUtXJagjHD5DM9wy+HdhGuzS//dTDym61Q3SQ8ux7SL1+zSI1d+Gy2hXeVTJ/2W0E5A/jh8Fi2hXUPyEz+P9bwrXdW63zDVmVSzdYbLh6A602jLPuiQW2K9sjrQj6sznF5p2bmZ4cC1c1zZgXBh+g+Yn1weuaH7DxD/cPUf5oTUK+jnNjP6SYaxEZxd45Y5qa3HdZ8blnDLcLidoMO4W7zKHrSlIKjucEvju7b/keGK6X5QUH0YajwYCz7bAl9/g7FEFfWhVnb7Pw+faulAz3DbEWh6cBnCbcMa0jbgZZKgZXk69vn3+Drm+iG29Sa3+TWy7/QTOPh5v37oGIaXvr7Ru4Y8himS7SiPt/oMw7XD+bOT5A+2hVz+QNzc8B6exbiU4/2I470BdQ9zfNAnnL6+yRkcjtoix+H7ITQP8fQEF55uC4Dwj4Tsz0N5MNs3cdn+PM5/2jcJ2x5RPeHwGANsUA8JT3WoHZSLd6Fy8TpSvzk7OtQ67NeP9LP9hqcNe8P2USD+Lsdkn6neR+E+0RdUJlYw/MtV//CNyhCE12af2vkehAXx4lfFVpJ7tI0K6tNoh23Pe7p5DJw+rl8Ex9NjjDC2v9nyzKUpCvUmTLnm4gnqMy0RjAfXZ/oalqFX6zKg+9sRT66PTLe1VVEa4gSDC0/nGyl+lYSH5xMOv80W6gNt955FNvtzpO0NSqN28DnGGMMpzoShWzpXOfW4Oc4XEc4Q/suorabb1rmxC97eRbfqQ/ivIcyf7sfzdJxwdpRbRluFwgAfbvv0avIcXq6rkng4bLpkzuGsIjg0nW3oXg+DzS0Za5nh/U626ABvjYeXQHGsZfi0k/A/JuV4vTNQp0E607KOiRcff9hD4l1H4tVlaMvUgZjADY8HcL7TPKH9VMqzQvwh/C9Rff45afdwe43bx9/59Lnx+GFNANfVDNdVKK6l1YH+EP43SF/bp/JcMR/MdffNG/J98wHzHtWB+uHsB/cKRLP2g1vSX0n8cFtM7S83NxjUxuB84MLjeQEc/hlmbBU036jxnw2Yt6BzAEtQGoLaKW68i9cf/tfN4/q99gWfZaVrXb9D8xxte/Fxa4frYGKv5uKe6RP3a1HcozzMoDkWyf4fl1d4SwXNl6B5vR7mefoqg4nXm3CcXPtM+/rNvt6En/d7VR/8tTPcnw09doX4uxidmBi7cmPLoLWWRp/opuGrTHgu3/DYFdtWh8SLx65Vci/IFjeyCwc2aRfw3DEOvxTZhYOJXcC86Otr2GZMdHgujhOcRz3M8/SYIlPjwokkPbcFpKfZdVb8/HC94jmRxONXbpKk3Az1FearUblJB5QbuibJrUFzeRBmDj4oD+aEjGdZi/GEff3z+VymThUqU2eiMjWTlClunfH5qucVgvFwcz3c8XV0yy/Xzq4MiCfo+Ci/cnPZXnycYcsNhE+icnNliHLD5YHfEUg43uHakzNc9jAIi+t7Q3iubxvUBwu7HgDlBffZoGybfe0k/H4SiL+LcJXlU+/vrnIG6+52RndjnfrcR7G80E0VTiv3L1g6bxHNDADscQYquUoAIbxDftPnNKkECXMbE4d2+JwQXJB6yPO0Q03xw3BqFLaRP1cJb/dJp+OEq4T4+WbPPKwifxx+nmfwwp7TgAtPM+c0LPfhHmfS0OXzHNU9dzbFuQFphvC3BqR5RYM0zyRp9jtvDf+m4eJMGkY7/KaKoLNkJjkDuTdbnvDzw9VZmUTi8Wvc15DGvdHZK7OQPw5/AN4cRBp3rvNtOv1+ZzLhdM1CYfzOBkkwmNrRF0Qg/FYv7YYnfth3nYLeD8Ib5bfv1Vg3QXleO1cM5fnOEHkeVH+4s8aCbIXVHRm3nAxTxnH81ndkfhQbqOQqAYTwDvlNnwvqyNCwfpW61Y4Mx8kvbLMdGTwCoB2ZZneM4OchnNndVKlBO5rxqk4Vxel30CHeYRE0gqO7ryg+bQDwy5qc7ugOCwj/etSJ2emtGnJ5tbcPP8cJl1f4+eHa3bM3icfELK52dEZjuDvrfmUQ3uBo1El6sskGEw8ScPgP9dQxnyINZthdZGFmammZd5xwM/xB9S1s/aE6SjCY2vkdUPtN0oEy82ZrNrn7Vu2yoRt/2qHjdlV0MX4tHdaTr7jJXC6frqSKhXI2R9tI4ErvhVnRO4AJb3bGKMMe1nM70qt2CeS3kvi1Iz/gyB1gYaZjlimF0T+Ov4cJTw+cbXbWWAILDp3gBuu7y5aF/XAFhP9+wIQGd4AybreC3oJeRp7jDoTWjtpE7WZ4/xuVpEoDB/FB/oxiuNA3gyDsT5Fe7ps6MC1+O38SPunFaXMYDD/d0Ti4QzyudwZyWxGCGzfxhDGW+PDUGMO1A4WLZ/8W49mficfkyheOs1F/7G9NrkjdWq374/BvRv2xf5L+GPfWEcTHTazivhC1kXTnHQ1D7Q2E/w+qV40+GIDTGVTOwn4woHZgqncyzO6c0KJpTjj13b3YPp5VHZgGCP9lLw1a/+3jmsM82wczhTBHN4l5jg/moQhzjHfNlcfJzsD4uJ2g3A73HuZ5vOsWcxHO39pHk+aZwa99YGcuowucJoifszHN2DIc13C9tc6lLSif8cfj6Mo0hzW3SaxOxs9Enga9HYnj7w7gyqWD9iu4eCYzOoHw8wN44fBQh3HZh2dBh/ijfII6TAXlN/5IIMQ/lI8mgd6mkHD0o0lY9/N8sBzyewq5F3f4jybtOoHGa8+5eZOxPpyBA71Hyz9+npZ/MzYz38/tlAZH+2KUI3Vx8hvz1vn92IQ6Lg2HMWg59vsAKWdz/TC4udxG9V47vBgBC54LF81dUL5wwQ23FBeVT7+lPGcRU35HOwPTR8sdPYluHgmL52dxOLqYOZf8XkR+L2b4UEd1gl03E87PNaofR6LrodQP/HzQ/OVBLcZzEBNPENaRDFaQ/T6ICb+n2O9DSTgYc7Vivw8l9/zs93C9MU2x8PgJNp3gukz76FeQ8ZCZvk9vGuw7tp2gM4h7vqG4YyQ+0De+h+PvZvgA7y7Gr5X56VQh7boFtYReTmaSxVIyqC7je7TuL2DCH82EB10vMqNr9oDlBUiv2iWQ33zi1478gCM3P23GPvWG0j+Ov4cJT+dLwuYlhzVziFgwP41tPNTt4bJNZm1K8/1JevoDno+hG7nweg+eS6eO64dCene9YRqiH0rXxTHvcc5gHdK8anbsy401zc5nDF9e4bpHHZdXkN5m8wrnB/A2a5uGT4fY5lDH6RDSq3X4hyZ0iMsanZPHtpZ+kDkq+o0RP7xOeHq1Ho66Rjr8bBM65Ob1485gPd3MYNHxWx/DB9K52BnIH+efdnQ9ED+/mGAtaYBFN0vj58O8+YKxLiBYQWuyyxtgXUSwuI3rgLWiAdZcguV3qjYtVxzWPILFfYgOsG5vgDWfYHFr8oBVbYC1gGDh56sEa1UDLHraIX5+FcFa3QBrEcHCz68mWGsaYC0mWPj5NT7PYfumXTdzD+q62Q+KuE1/aIsb/5hYG+D0zvVzQXdrGa49jB9ut7EfjmctEw+HNUcQa5kg1gJBrMWCWEsEsW4TxFouiLVCEGulINbtglhVQaxVglirBbHmCWItJFjc2JqzbWOd+hrIrnWAU4vzFi6eXXaIw/1JiAP/XuQTfw/zvBOAhZ8JSgvua9K5ELC/fifi0r0jEP4T3jwlPrUp6HntgvabG17rTYVtV+mau6n9ClT/WH9BLxNx80c9jB+dk7g5ZDwSZVy706t8/DHmeacBFvzm1phwXTqQYCwifOk9aiPw8xCOi+egFuM5iIknCOtABgvCc2OkoDWmoFNRDZ3aVFtj4sas3DhrKGtMoLepJBxdY+LGrhTLIb+nknuN1phwns7z4QnxNior+PmgMnlzi/HczMRDsfxe0KZrWRD+n2QtC+ternwV0kHvF5l9z6MQei3L73Q6zLuL8Uu0wLVSSCX705VyMpvu6+tPloJsRrMnfRzKhDe7h7PArmXheUrtEshvOfFrR374BHG6lmXGDhaSYfSP4+9hwtP+W7MnJkpgwVoWbkugbg+XbTJrU6K7loX39DSzPoLzg65lLWbSEdRm43tBebU4IJ7DW4zncCaebua5mM9/iIfeo/FwnLlxDH5/YFxP/RlcT/D7A/jZW6p1fxz+IfT+wISAvVV0TojWCVwGtaP1Hp9yG6Z9h/BTPE7c+wPcO1C3VP05QxwJdD/ofU4Iv7/HwWw7z78/EPR+GZ2LbPb9Mu6dXLNpzJeoXcOOs2t0rzue06J7d6rIbwHxW4X86HiXziFhvzXIbxHx4+ZywW8d8qPvwuOT3HEZpY6zzfgQoFkT67g0nEPixOWGvpPLvcvO7Rc8Al1jP+BK79Hyhp+f5/MctSOG9ya6hut0bf8/924lThPtu3PrQmHaFxzXcK3bcGkL2uuE1z3ougWHtaxJrE7Gz0SeLghIN2cTOK5cOuh4nqtnRzA6gfDLA3jh8NxBR8M9X8PpUGq+BvR2DAlH3+nAZXCZD5ZDfh9D7vnN13DvaOF+3Fk9POew53JA+NWoH3cuuqZzmRhrtjPQbzbyW+pdG97PV+DmVajulqK46RjoNiY9YdtSvGfvqSHu2cPcMCbOv1tRGL+1jqtRP/cH+/GYMYfv29O+NpSJsO/qQvhrA/raECbhk665PpiLUFks+pR1h8Hk0jWfpItymEc4QPgyShesIzmOw7azs9HvOdWB3BYwcTk+92hbsMDHLyjeRs/q61vQNdfW0/J6KwkP65R+OqVlBcLPCSgr3LtQQXulKQcaZr4PhwUMB91OjPH8++fOW+qztJRA19Q8c1lJs2AOg+PnQA06eVAdKA78Dip+3LKc43OPZgM8i8+8K5Vnlxf5rb21EbCbfSJrc3g3sg5bc0Neh53PcO1h/Gh/MWw8Q12HpWVhtk/8MeZ5hzwbY+5ppyvLnaOeu+bGonTuo9mxKFc5KJbfWRyVat0fh78D2SP6Bb95iAeHCXtWITzXLw46MLTR+BLiB11y45SguLl9vxB+eZNcubUe3OdfQLhifiua5DpzmLnOa5KrX72ENkwZ6RtuKS84f+6iMq4qlIZDrjvJPRqGbgOf70N1LAlHp73p0UW03aRt0kKGH+c400C5xJ3Gjp7nfT+qor/wqaKOE7ytiduGj7vcZ5EhF7eEFVQcwxzDg00TxqDHBEH4RwNM08oG6aZVgttOzn3gg9uaTo+tG/4PmydL3McTsQ7aq+HTy+mnyoTnjrHtIeGxrrilITpti5swfDb2OFL+uCMXg9IWtJXP++n7cVv6QUII/0RA+VvFcOCOS4Xwq5nwq1AYOoVdRX7wLFf+8CtH2iWQn2D5K3PlD+uAlr+g9HL6WcOEx0sckL89JDzWFfhxH4jl7B/oHB9txi1vx3z+A1d6L2hrwXnVgfGY+pgRLAtSe8l15fT1Cc7A8KtRvJy9pOFBz3iqhcs/+lHqz6I6toWUL9xO4+nHz/fwceP6vYzhSuP+FZrm+RKxP1z3jR6Z+1XE/cGp/s/TtgX3geiRHX5HI2L943TiPKd2DMJ/G/F8GOlYO2xL8DS6dgnkJ2hLKs22ZauQX5i2rJGtpe0VLqd+36/AWFjnfsMK7uPsGI/28X7KTPdxwz76oeIlTXIP2zdchtLxJDmiEeuSvq7B5RVn93uY51eFwFoZkN7ViDMXHtsJHP4PjO4pZrvDl6WqD+afEeavm8Sc5YP5t4D+CNd+ct+PgPDcayK4TQU+3OuCa4kf5k7bzTUofhr2BhI/9sN1mMbrBPClbW4jvtS2g9/Y8c/912XJ8a47CZ6wXUwH5eVRTHrC5mXtuzFM+ikWPJdwBpdXrg6tYfQ1ajyP2d4kZpeHg9tXrq9zc7Ue91gS9yoUjvYNtKM2cBnDC/c5go4Wpv2DCYg/1NegrbpG2123nOTaXayLdhQvtp2OE7ytAcI3GmPTPjwOf1N1oF+Yb0rheIbSrm0n7VrQcdFB8w36eh8SHtKGbTzWRQn54/CHMGUGMKsMh6D84Mp+FYUBPtxr7/Bs1MprUD+xyqR3ZQv6oeUV20167D8uL/R1WG46Nmx5xUdYryHlldtKzeUlnT+pMnxuZ9JN9dThEx7waBuaQ2XZr1+FOQS9ahF2foBr49Y4fNy4blYRPv2QLoQ/KaQ9H545Gdfl6gfWK60fQTrUrtk+YtW7Dnpdmqsfq4kfN9caxu5qF1R34Fn8MWVuDB7m0wBB84tB43LO1kP48wJsPdeWBtn6KhOeswGc7YBnd9+cAF+WsQ7C2Pqg8c4qJnwVhQmy9XTMzW09bmS7Tw0of37zPJjrnIC0he13Nbu2sTvzfjjXNmjeV5EfbTu5tS/ONnDzM7S/NdT+pnb0W9GN+pt0DhTCz26yvxlUDlcx4asoTKT7m0Moh1Umvbuzv8nZIDwfmQzx6bug8he0viVhg+IML9wWc6/RajfD+59s0QWtyZj93FgyGyPxgT7wPRx/F6NHE9u/uHzlPl9k9nNyyYw2U7Tsa3dDdbBu/OxOjDwPa2HaXYRw6HZt7pOauj5tJHNNXD8QPwtx0H7gVjR3tolgcq/Hhe3/4tcXDwwYO9Jjpbg8D/qsWxXFw4XHbRMOvzNgfLiK4cCVOwjfaM2Hfr6zivxWO3zc3H4Bri2F8A9GanyYcnf3mj1ts4LGjrgMriLxcG0Rrhe0DnB9Lq6+4k/WcXWLHqPJrdsCFh0zagfrsbRehrEVcCQltRWPNzlmHI/uNdsvpnWGGzMGxc3lUZDNwPnmZzOeCLAZVfQMNyakOoXw7wrQ6SpncLqCdCqxzyesTuk2UYgnrE4h/PtD2OGwOoXwHwrQKaejIJ2GtTNh5v4a6ZRuaebWlIN0CuE/GaBT7tiDIJ1C+M/sRp3iNK8hz2GbQY+4ofauy+e5ngDMqg8m3MfPBR0D3Gh/AODRvPxaQF5y6aqGTNcqoXStajJdEP47htK1xCddS5pMV7VBupaQdEH4H4VIl98eKjr3D+F/ErJvt6fMmdE9VFXkt4T4cfuXgsrEUMY3CTK+CTpyBH9OOWhuje7R+lPIMjA8e8L5MoDnJ2kZCHotRDtaBrh+N3e0Uw8THsbJXBnw+6w0jmcoZeB/3QPDmdpbi4+mwunG4wg8R3ERCV9F8XJ1kYaHeof31lYRZ7r/pBbee72U21vr92p/xwQ+br+6Quc0IPy+E+qYnd419zo/3f8atO+fe48E65nWWwi/F9JDUL0FXruj3uLyFcZ2B82FVJnw2HaDzjjbTe3zzQwWd2QWV8/pp1LwnBDg7trX0N2YPzeX3Gr/5wBULsKMe6oIM+mDeQgq99MmDEw/t99Jh5s+QSbuw5lyDpjc+CDoFcI1THg8Pqh610FjLppumlfTiV2oonC07sNzYfuj2I/O2QfVq1VMGqkOO5zgsT0dP7hMOQuz9yHse06N3m3pIHoOWvfh+ghB5SRsH4GbQ8PrVruer9b9gKPhOdJUs7Y4KL2cfoa6J5LqCusEYwWtPQfZYlxWAFeXlau8zODWaJeESBu3B4NbC6d1BfidheoK3TfPtf9B/XYIf26AXWw0HzTUvQTcOmc14DlunRPHNcP7n0xWWnIQ3yoPbxTDBeKl7culSI/3TeW5xgbxbc1xbWeM6AnbYEHbkIyR+Bxn8FiBtk1cezNDhE99TXYV4eNX70A/q43wcSt4TRaXX7wmi/OG6z9wcxd4PHIt6RtxNgDb0+ORPw5fQv2yog+m4zTfzuI9Xo+PHYhbZXBb2aMWtH9oFfHDz9G9wThPaBvT6N0kupcRws9GtiHoHUPgZXbveGW3740FnXF7Y/3GtRgLl4Uwa2erGHw6L3prQD80aH/u8ia5r2S403pO6861pI+K41wWIs5W9ufug/xx+FXD2G8Y2Z87OHwVhWlmfy4uL2H3527zbDf3/naYz28GrXUHnX+ir/dF/jj83QHlLyrnn4CeDJe/1O5e76BrGlXkR9dCgvZmcp8Z0uVvnlf+TOoxX0jW+rSQh/gYeuwSyB+Hf61XJrtQOuB/S59kyRfdSrpYKWaLpVKmv0iPldcO8kwfM6XLw6MT6joDPUnrTDvAbzeDX3vvN4HSGmfSBPFDWWpD4WM+/x2HH7NAXF0EKyabttqYhUsb5k/nChKED1z7YSWaxOr08Zshk+5ansYD0k3j9wsfY9IG9zsC8HF4sOu4DHcQXYwyo4tUUL51oDgh/qEcmw2/9yfh6GfOsL7bfbAc8nt/ci/u8MdmU7vU7QxONzxj2KaEPk4U4u9yjNaHmh1oJ3z86i4+TnD23GLJO+WTmjyadVidGI4mm2ZdDFFyfMLRqqUddPW4JpTyjDEYnAoAc5wzkAN+ljMlcZ94HadeXKn5aIQF1/EALn4YMYLRHYAxUnVGqg7jRqpOuKoj3RtPFQq53lRfMpMv9VdKmXSj3rh0/P19ub5Mua8/52Zy6Uyy1MxogPY28Kg7zuivnYT/WcAKVFsApnb0JFMI/8uAkTzXK+LSGcYMYD7jnMHlio4ghqs85YuFvt7+3kwxk0v2J/O5ZvKT67nGQuikncHuYZ5vD4GF83hxdWB46MF2OMGjtnYS/h8Bu0860DOAdWu1MWdcDvDIgH4kDsI/izg8SmZXsB5o04t77YJNXX+MxOc4fNML8Xc5RrsCLs0P4ONXvgyPpPpiBB/zGcXoB/JyNOMHWDDjhG0aDj8KpRGHx9fwPL7X6X3orYdgagenoMYYvzhzD/S7q45NHJg2nDcxn/+AS+9Ru4B1Q20lttN4hXKviQPTgus710cB+0Hr4gET65jjvWuuH0Pzj9p+avP9+nl+9oq2ixB+sseJ+3gKbRdxOilHHF+CiVc7aq8g/FSPg+EhAPtRS7/ZN5w+3XYFzbQE1d+gGS+oCx0+4QGvnYQ/BOUZbWNGo2fiDC/al4HwhyNM2pfpZNLF1Te438WE72TSNc4ZbJfgWW5VAnRv+CTbfm5VAuuwvdpYP6Na0A+UgR4SHuuKs22jSDyNhpZ0FZebRcO2kOu/0T4Djp9rX/E9aqfx8xCOi4fqc1RAPJyd4uodp0daR04KqHdc3w5/AHiUD4ewfTsIPwNxeHVA3w63ZadMDOZK7RoeY+HwZ6G27HTSltG8147rl8eJH85L0BG2tx0MLmc3aJng6iQOT/vaUMc6fMLj/hQOfwFTJsY5g+tt3Cc+zA/fC6obXT5YXH5qR/smEP6yAJs/huEXZ/hB+LFM+DEoDPDhdDPW4ePG6cH5ST8gDuFfwqSHa0fwCol2CeQn2I6wX/fAeqXtSJAOtaM672bCY11C+npIeKx/ro6OIX443tGEQ6MxFG1juP4TtlHcdDHWAfDsZNIrl3f9bozEB+nD93D8Xc7gMm9izBq2jIB+us3oJxlUBrsZ/QCfvYzwSaahrPQwcQNXeHMe2xUcvhvpEIfH1/A8vrecjF3HoecAv4f4aUfHy9gvztxr201YPQwW1hvkqa7H84ku6JeyuP+AS+9Rjjg/ocwH2YihxoOxoB/F1SctM7zfyZZcOgXp2ItJB8SNy5Vc3cnmw9o6iL/LMVqX3aAyjPUD+cbVfXi2xxlchpdX6+EalW8cD4e1I6JY6wSxNglibRXEktTXRkGszYJYGwSxlgpiSaZxiyCWJK81gliS9VEyH9cKYknWoe2CWJL5KFlWdwpiSZavbYJY9wpiSZb7qNocyTTeJ4h1myDW/YJYkvqS7JtIlq+o9gsly31U+3KrBbHuEsTaE/pyUS33kn2TkTatOayo9uWiagsl+3KStlAyHyX1FdX+1zJBrKj2v9YLYknWbck6JKkvyXZIsg5FVfeS9ktyXk6ybxLV8iXZ941qHzOKbYe+pmtWEm3HOB9sfB20NszFE2M4c2vKbQij0xmcXsl1ZcCfYAgf0j2e0RVOE8RP15jBn/sPWNQP4uoiWMJpc4PSFrQWjdfdsQ78sMY3idXJ+JnI056AdOP4uwO4cunoFtRJuyAW3avH1X9u/RbCT2DCc+VkHBM3PAt5OxH5CeZtKihvsY2A+Ify1jvo7XISDr5i0eYMrhvjfbAc8vtyci+O8LAbLvtOf8PeGrynF/ajcHuItMzwfidbcrlUkG01287k0jESH+jUIXqD+IfLdgfZMO3oHowwNky7ldV6uFbsjnb3CGJtFcRaJ4i1RhBrhyCWZBrXCmItFcSSLBOrBbEky8Sdglh7QpnYLIi1RRArqnVbUveS+loviCWZxrsEsSTzUbLcbxDEkiz3dwhiSZaJ+wSxJMvESP/r+WGj1wpirRLE2hNs4f2CWFI2R1/TsXYrvO6uymFJ1iFJGy3ZpkW1XxjVNi2qYytJ3UvWIUl9SdrokbbD/rZDO8mxlaQt3CaINTKnsPvqkKTuJdN4ryBWVMdDkrrfKIi1VhArqv2cETux+/oTI3Zi9+k+qnYiTP8Ln3tIzzPm1vEBa0IDrJkECz8/gWBNbIB1AcHi9jPAc5N84sFna+A9GJOYuDl8wOD2cWiZ4f1OtuTyxU4mHXL4qRKsh++N0h3z/kPck9F9ubX7TOjzViH+LsJVlk99L8Fkwofqh+4lmMJw7SF+2lWr9XDUL87cawvA2iKItUMQa50g1lJBrDsEsVYLYm0XxJLUl2QapXhxdjYqZXWbIJZk3ZYsE5sFsUbs14j9MplGSd2vEcSSLPd3C2JJ1u2o1kdJGx3VtlYyH9cKYu0J7dCekEZJXpJ2NYrttr6m4/aolC9Jfd0jiLVREEuybxLVNm2kPu6+NEa13d4TxmmSNpruHXs+lvutglhRnevYKYhlwkbT9wK1m+H9T7bk0hmYi8ZrJzFnYLy4LyI4b16OkfhAR/gejr+LcBXmU5vH59ZysH7aiH7MrHMkSzGCj/lMZvTDrSvQfuQ+3m+8joXDT0ZpxOHxNTyP733NW+iQtJP6fesveLhN1IFUf8VNZ8v5bDJXzGRLuXSqlMonS5lsxXULbqo3U0inK/2ZQqmQSldS+VR/tzM432kdMJTHmbB1gK5lGaqTgWtZk5g8anYta061Hi5K7S98jyjMOfVmykK6b6hlwfQ59VxZCDqnPmxZuL1aD9dq/kn2qSXHkncJYkn2LdYKYkn2NyX7+lGdo4vqusAmQSzJccPdglh7wppfFNfgtRtZB959uh9ZB959ul8viCVZ7qO6rjliJ3af7iXTeK8glmR/Iqq6v08Qa6QONYe1ShBrpA7tPt1Ljt3XCmLBOxR0Dkm7Gd7/ZGsu1cnEK4SdAex95LFrZ9Du2zp2id4A7P3keVcAeyqD7abTrqKTdyulSjqb7031ubl0LlfJVPK5QqZUyWaKpXzZzRTTqd5yPllxC2U1Y53uz+cqvaX+XA17f3He6SzM0+HvcePvqRe9wgnlHn8vPU6e1ddtyB+H/9TkOmbJu+5GuA7C0K6T4MUcyfnMVDJG4nMcfn4V4u8iXGX51OdX2wgfqh86vxpnuPYQP+1WVOvhqF+cuReEtVEQa7sg1hpBrC2CWDsFsdYJYm2LKK+1glhLBbFWR5TXDkEsyXIvyUtS93cJYknmo6Tu1wtiSabxPkGs2wSx7hfEktTXZkGsqNZtybYD+hPwXjfuP451BvrhvtMY4pdAfhgD+2F+iQB++PmEz3M0HdD/7SD+M7zfydacC/ijzeDXvgsxitEVThPED/3ZdhQ+5vMfsKgfxNVFsKR1F5Q2zJ+Wg1GID/1+BIc1qkmsTsbPRJ52BKQbx98dwJVLR4LohKtnMUYncH90AC8cfhwTNzwLOuxEfoI6TAXpENdFiH8o39QAvR1EwsFZHG3O4DI4ygfLIb8PIvfiCA+7cQSDs6O0Pvvlb4/P89p1B8TTzTwH6RuDOB6E/EcHpDfO3KMc8fMQjosn1mI8MSYeisXN0WhXqdb9cfgve/MyOg0/3W8g5jSGX1BdPJgJPw2FAT6cbuDZbibumM9/iMdxgsvQNBSG2qmDBeM5GIVpJ/EcIhjPISjMWBLPoYLxHIrCjEHP6d+HIT9czsCWHo385WxpqgjpnO4MduB3DLr3QLXOg7o4+Y156/rw2NQ6Lg1H4zwc+R1D/I5AfscSvyOR33HE7yjkdzzxO5rhM9R8xnl1uE+6JOLBOjqCxHOEYDxY30eSeI4UjAfnHeRVpzM473ZX+cd5C37HIj+a18chP5o/xyM/qtMTkB/eG00dV99AT7q+fTxEfdvT9cuVS3Aj+q37DVW/uF2jbkS/db8w+h2KDv/bRJuL8wrSBP1beP4wbzFcj3umTRn4PB5r0vc/DkB+5xG/Axk/jf9vbwEb+rdYD3SMgduhOHMvaIxxpA9WAmF1Iiw497CdhD/Z04fZMpnLB/VZIO7phuIO07bj+LsZPsC7i/FLtMC10l9IppO5XKmcy/RlM5WYM7juxpl7dNx1DBOe+4Yh6PpYM7pO1b5pXK3j476wdgnkN534tSM/4KjL/Y1TB/I/xhD/MPrH8fcw4S9AaWgmL01iYXsggTVqiFgTnIH1Cdscw+1iL2eDwHF1vof44TI3nvjh+kS/Y43bTDz3Rl2jdnHK/nVcGo6mA7cP030woS04DPlDW9ZOwl6E2tDzSRuKx4cXVwf64XEYxKMxrp9Sv4/j4dpj7W724VUm7ZeZOYdMietT0fbrGENxh22/6JwD5gO8uxi/VtqvPreSLif7+jKpvlI2l8sFtUf4Hm2/jmXCc+fmgq6PM6PrPq79wvM12iWQH23bcPsFHLn2y0z7m+kLo38cfw8TfjZKQzN5Cbad6zdxtuKm6kA/PP+D+9TXkzpupp+Y6uPmDh3CH+cbbR9wmaTtAx4b0fYBjz2bbR9AF822D9hO4jRhzAS6x9n4dhL+VtRGLCZtBG7TIW4d7hmSt1hPgnlbobp2GJ0k0b1m54yBd7NzxrgsJ4kfrq8u8cN5liJ+uBymid/xDJ8w7Yt2tD+I88pv7CQRD9fv5upqq/Fw9pHqWyIenHeQV2bbtebKP85b8HORH83rFPKj+ZNGflSnGeQ3BV1Tx9U33LY2M+e2p+oX79OgbkS/db+h6he3p9SN6LfuF0a/Q9FhM3PGOK9wmlrp+7yX9GPMjAWTyQkkXTiukT7USB/KL56RPtTzvw3C5/RRN9IG1f2Gql88l0ndiH7rfiN9qMFuT+hDhZ3rCdvXurT63H/a1/ovmmf69xR/XkehuKuecRzpI430kfziGekjjcwzYTfSxozMM2EXBf3itpW6Ef3W/aLQR8J51ew8k1/fZwbpx+zOeSZDZaTM9SGobnH5abYPhfNzqO93nED8TPavMJ+h9gVwXg3X+x3P176a2T0czZV/nLec/aR5LWE/m51nwvs4m2mD9lT9NjvPNFT94nj2JP0224cCPUXk/Y5I6TesDof6fgcuo7TNxXM9EA7P9VAMHIfZPAr/XSOIv8sxWSfrZ1ccRfhQ/UD7N9apv+Myq7zowsV9s2/oP6e8dOHJc0oXFhcsuqE4++RSaUF54UKcGhxDN5NaWlpoGLjuYe5jjOkNUgEnHoxzBufydIJ1TAOsmQSL63kA1rENsC4gWFzvAp47ziceHIab4cF8jmvA56KqP5/jCNbxDbDmEiz8/PEE64QGWPMIFn7+BPJc0iceHAZbwyQTN4dPy63bgPP86kDOmJdLsFINsBYQLPx8imClG2AtJFj4+TR5LuMTDw6DW9IMiifG3OP4LKr688kQrGwDrMUECz+fJVi5Bli3ECz8fI48l/eJB4fJoft5FE+MucfxubXqzweeDdPCYa6CLUrotxIg/uFq4RrplZ4SU2C49jB+uA3BfjieAhMPhzVdEOtYQaxjBLGOE8Q6QRArKYjlCmKlBbFSglgZQSywiWDTcL5OJPFwfYQTAuLBz9ORAn4u5vMf4qH3aDwcZ24mDZ+m/cV96s/gMohPasLPQlvUTsJ/br865lc8TNAlN1KCNgCXLTmbm85BunHb6hCd4PZnX3RNHTdqBN7NztTiPKJtJa7/BeKH63Mv8cN16kTil2b4DLV84bwarnJMZ6yTgvFw/WCqb4l4uD4y18fE9QT7QTz0XtDJQnTG3q/+/24fPk6/+g99v3YS/n2o/v+RrATh/qZgHc/Teowd14eiO0F6kR8tzyciP1oGX4D8cN5Sx9kN0EWzs024rYM0RUm/2jW72oV1MVQbSu0krtPUTuK88rOTOH+5NqRVW4DzasSGho8H5x3kleE+RNP2JUf8JO0L+J2E/PZD19Q16rM0s1qwp+oX21zqRvRb9xuqfun8FHaS+sX5+HzVb1gdgi6a7X/gMlpA+LQNwOFwH9JvntthMCgObRchzW3Ms/C1K26uexKJg5tvx/doGzSJ4RvUppqt38+dfo7jg3Tgezj+LkYnJuY50yH1yvVt00Tn2I/OtXHz+RkmHg6L2iWu79XpDK5jgvrKhM0/iL+L0YOJ/OPWkyYxeh2O8u2Xz8kAPlkzfGonsHHrNdz8nz5ppcNxfPuvtEz6revAPb+8wXHT9WVc1+mccLoBFl1f9kuDXx5hLLq+zOmgnfgt8ibltA6v3ndgGFgXnY3CXONdB43bDK89ha7TdO3JzBg+eO0J6weX2VFOcNnBeee3Ln88k1Zalo9rwImW5Wb3AGAsWpaD9gAkG2DRsoyfp/0CbKvpzq8Mkx7wyzL8dBmft68/fjIA3w3ATwfgB+0sxvONGeKH5zWzCH9JAH7QyfTHBeAfz+BTTLAbPcjvcOIHYZd5GLvGGd7JVZ2OybY3nebm6x2SZmxjm51rA96t7CyneYzrY5b44fpFxz2cbTA9BzZcO8uHa8c3rQ/HCcbD2Uazb6c2V/45W4TtGc1r3LbS/MH9AKpTvz0W1HH1Db8Nu/t35kZfv3jfCXWNdu2O6Lexfpt9s2yo+jVzAma09BtWh/gEzKG+nQdp0rue4Q3hWeVF55SXXl6cfUOpuOiGuXMuLs9fXF64KEFgD/ehA79p0wRFBOM4AXS1ayN+RxF/OCy1zeEdFBszU1Lmu1XAu9luFZfFXNeJdqtw80u7VWG2lmA+Q+0e4Lw6yiddEvFgHQ13d4fqWyIebit3lIYVOG85s0nzGptNmj/YbFKd4mZpf3RNXaNhTDPN0p6q32YPLhqqfs0cbh99/TbbrcIf8Nv9L5xGS79hdYhfKh3qwVC0zcV9HvigA/gdgJ6jH+c6EPnhA6Xox5bwFME0Z6DfNOR3sHfdTnhN9PZ6dJJwwuWhRKfeIA4c95GG4g7TrnJ5gPkA7y7Gr5WPSaTKff25YrGS7q8k+4uVXS9RYnzgSu/Rj0lwLznuxYQ3bFeLUF/wxyTo65EJ5Hck8WtHftim0Y9JGBpuF8PoH8ffw4Q/F6WhmbzsYeLB9bsZLPgwBZ7qhrpttr6lClyfHRy1mdo1OzYC3s2OjfBH1+lHOrDdoy+Bt/qRW8wnjC3SLqhMJHzSJREP1tHBJJ6DBePB+h7uj+8aPgyiqfLPtTv0Q3vYD0/V0/wJ+xHLZg+EG+phEHuqfqeha+ok9TsN+e1J+sX9Zuo4/U7zrkfKb90P20XqGpXRZsZG05AfpGmk/zHS//CLZ6T/8fy33/uga+pG+h91v6Hqt9mPuY/oN5r9u5H+Rz2MZP+Dcm9nwh5E/CDsDvQ68nu863HO4LbrEGeg30HI71DiN43hBH4HM5xiJA78OgyE165SHZgGCP+Ax1vr8uGpPGabDyZsUeXm+aZ59zq9/wnkJ1d++13NewkqA1inu9JbHZgm3J7HmfB0LvUIJjwur6CjHmdwPT2MYE1jsA5B92CukNMncNwd+sQcqT4Pa5Amqk9O/1hP07xrrs90AME6gMGahu4F6RM47g59TkMcqT4PbZAmqk9O/4eiMKCjHmewrg8kWJw+D0b36Fw2PN/BhMd47ST8u5DNeXq/gfyw3ZxGuB/EYGPbGyMYOB1dTDq6iR9+VuMWJw/EbXS0G80b7hUevM4JZZs7pgOeNfx6adNH2NDjLbhjqsAPv3pK13Txq6f0tQH86ik9hg+7Rq+ehulfxUg8gEttFS0zhzMc8VEn3KtR9NVCN2ScEL7RUYe0/HHlFb9WE1T+6LFX8BzuX2D+9MgWCP81VNd/6l1z9hj0ZNYeJ8ucPcZ6pfY4SIfaNVvnQWc9JDzWP/dqAa13hzOY+KgtbNPgf0tr06VS2c24+d5COZMp9WbpBxKwLsYYiD+TLeb7i3nX7c245Yw77PH3Z3N9/YpEsuzuUsdwx58t9RWS+VSxt9SfK6Wz/cMdf7kv05vv6+3PJkvJXrc33Sh+Xc8e9QKZnBvUbk71uf/QVnag5yVfzQX8UYSfEL4Lemp3BusJ4h5tJG2VSph8wPF3Ea7Cuq69Ujqa8KH6oXtZOs3op6xfWYWyh21+B6MbymMU4dhliCPXrgInbr8N8NBhPkVeQWwzxNFsHa3U9pbhviE+ii5G5jggb3C/Bpf7NuSPw3dMrWMmvOtxCBeeBzs1BvmPYvzhN+RXGxMWX9PfwJ3qFYeHMtnhk9YOklYIP9ZLn+b23Qk8JtYf5tXmgzkOYf6UjN/wWC2ozkP4MUx4XMeAzzhncN0cQ57D3DudgQ7f4/InRsLSNhjaKfyc3+9OBsePw2gGhxtPdxKuOE5aHrSjY544Ew+uU7jN72TiF2wfslxbCQ78Okh6sR9O+9XVejjquDEmpEmn97dkTIPDUT5cXZPsG8H9dnSfxhsnYTtIWNyeU521C3DsYeLpILijAvjHCE6Cea7b4esj9z8s3xjDl2trWo0HY72kOjAenM+4TcuSNg3b8Tjz7JJq3R+HPxG1aYWQbRq1JTgN11Tr96jNpv1YWifp3Adtu2gY3I7j8C9m2i5qHzCWvndyiD4C1++jfYQi0udpRJ9cH2CcM1g3tAx3krhw/xjaF6qDcxGPs6b6xwV67Q5Io753/lQ+HOaAw1EMru0EDK5ew3PjGF607lHb0REQB9eecXG0E79W84drt3Ffg+vDcP64Pcfx0HttTPhG/Y8uH2wOt4PB4ez8aOIXY/yoDcPpxTaM9k24MRm2jVy988u7oL43xz1Mv6ojgDunP2yHpOdykoWkm+zPZysVt5Qr9mUazeXA/VHVgena9R/da0fp0m40Dk/8OpFfojow/i7vdwLFg7GARzsJvwjltXYd6Bl4voeJv4PEP4A3cw+XNYoVZ+5BeJ2nN3scTczRpbK9hWJvX9JNVVKpdCHXKF85PeG5A+1A1zgvOpi0tZPwy1Gbs5Ksw7Qz8elwmwPCxXz+78Jg7iWqA+9xeYTLLoSHuLuqgzmC3xjk107iGev9xvrCWMCjnYS/k5RdXN7g+R4m/tEk/gG8mXu07I5hwo9hwuv8WUPsEU679NzfrjgJPr5HuW02WK9ymZxbKBQL/bn+Sm+mv2/Y1x56c5XedLrPTfeWyr1ubtjn/jPpvopbUfP/6UoyXXCHfe2jmEypNZ++vqxbLvb2VoY9/a7rVnKZvkKuP6WmGId97SVTyRdzlXwymyplyqlScbjjL+bLvZlcOtWfrvQWC8nCcMffV8r1J3vTbqlYzCfzucJQ1p7oHIl2MEdF50dmDJEncaGP6azZaWdwX9bEmkqc8KH6gWs6N4Wf5dbh4ByeGOMXZ+61DTNW0HyN6fnKsGUB4u9yjJZNN0ivcUavdA4QP0vHetrR/Gtn4uHm9G3Bgue14+Zwb6wO9MN5THVK6zv249axqI0LmhcJmm8CXjD25uZScVronMbnyHv4ZtZek0lq72lcmC/0u7E+tLuApAHC/xyNU75I5gq49QNOn23Ej5tT49aeaD7U+tUoDaMD0gDhv8GspXFrwZAew3usMtweK7yGhccNWoLW77Sjc8djmfBjUBg6zzQW+dH6y9V/rHM6D43nlmh4jEfn1p9GeUT3vOJy3UW447TTOag4E2/Qup/m8h9SZw3tlclz62zguhm9UVuK6wm1l3T/BPbD5QDrgLo4+Y11sWutYP86Lg0HTtJO4HdndvGrDua1O+otnnem9ZZbp8fhm1mn1w7atx5ncF7S8s21Bc3UGe3OJfFxaw64zvi1u1yfiNqLBJMW7WjbWgtP9uPQ9bUZ3u9ki45rW+l+JUN7vHLc+hG4bibd1Ebg+kNtBO2LYD9uv39YGwG6aNZGcP1Gzn5QG8Gtq3J1gNYPbj0kaN2LGzfBGWUxguk4wesa3Jpxo/E53QOgneGyH3p8DvF3OUbbzNqYrNH6ES3rQft/uDY2RvxwPKOZeDisNkEs+t4ozg9aFgzNjYQen0P8Xc5gnZooC1ydizF65eZqwuyZjjF+zc6vRB0raA4wTL5z8dDyj+PB7fuAfTr7D3wGnsPjPfwsHe9B+Cf2r2MWvGvuvWO6Nxqnf4b3P9mcy9Abhsf+RW786BB9j2HSHGPCc+058G72/Bbcno8hfrh9GEv8cFvWTfywTdyL+Jkqu+0+6ZKIh9vjF9TeDzUebv8EN/5sNR6cd3RPEteeDbVt5MYhXNuIbctl+/NxYtuCn72oWvfH4V+FbMuVZAxiaG68QMs/ds3OB9DyjG0DLYN4Xoi+04Ndoz3AzZxBgcteJ8Kn9RLHabgf3JT+tWv2jCzg3ayNxXWyk/jhsthF/Fq1zZiPhK0ImtNvNR4cZrjO4hruNsPwXGXT9oe2Mc3OR3L2h+oU1w/cJ6au0TxmM2cM7Yn6pTaZOkn9xkg6Zni/k625yOu32T45hGtWv4bmBiKl37A6BF1I9E/wex7cPnRuPA7hg9YIcHxcPxqejeoYs9l6QPufeyE/WmbGIT+sE+oajWmbOQOFG6fgcHTfeozhiMciQfPAcJ+b32ln4gziyM2NBpVXbr2Wm2+n5ZQbU2H+fmOqpzx9NFqfBz0ZXufLcut8WK/thFOQDrVrts7TfUPcu7rcXAUdC3PrbnieTXofYj7Vny2ms73J/nI2X8zlG+1DrK27V+vhBPMxBfFCfsWduj1IVOucIH7uvQwIB1w7zXBNAlfYiw51CMeJ09JGwtNr+u7Hd9D8B04jpAPfw/gQntsHj98PAI7cOxNjqs1hjSZYo1rAAl7cuwGjhsiLw+ogWM288/I5L2/81v785st/QOa0uPdag+bLIfxf0ZzW06RtklyXDZoL5PZ/0X0jQe/4OU7wvCedH8HP4XaF64/O8H4nW3Oh19Ag/i7HaL/ODWqPuD4D6GeMGT4Z4MPtX+PyWZ85s5czOM8wP8Di+iHN7hOg+2jC7BPA5R2fcRJ0Dgn3PjU370PrveME9xHp3s5nUL3v8Q6MDHoPlKu/tN5z+0rAz29fiV+eB/Whupnw3DgD4sZlojsE1qiAuPdiwncHxI154Wdp3H5ll+sLg252R18Y71OjfeGgvafahdEll489JDzWHVePg/rJY4gfN4/O1WMov7i+cH1tvAcW2mg4zxu/Q+048jYd1z9p/EIy08+d+SPIP214LS1teM9eEsrdzGodn1sbgDJ3ZrWuyzOrAzlxa5qAy617n0H88NwHYOv6DOMyfe0d4VurS2chDjHidzbyayN+51QHctfOZF6qsthrOC/TEx3//IN6cGrVSNwpwD/NDH7NTpxuBj8NY5kjPLy4T1lwSFnB96S4BK3DGV7bCb2HEuIfrnMjG/UZoX7rthjay4WL5i4ozipfXC4O+EwshuOShpOOw9Dl1xj53UZ+0/AcTpCLMbhc0k+rPvc/zPRsvAHWqQSL28IAWI2mek8nWNzSNp5WS1QHxjXDu59sweUL9akq6I7iqSrsEsgfhz/G+y09/VjJF91KulgpZoulUqa/4WvgcMS63V2yfHq4umRxM/gpw12+WpfstOpAfIfEGyfhuGe4LhmE4bpkUGd1U+itbOy6hpO/oPuEu4u023UG8qPdLtplxH64K0dfn8JdOTrFF3Z7vckjl1X3rs/ssuZzn3balcZqHR8vM2qXQH6jiV878sNLikcT/ZjYlqb0kzOpf32g/USGP57K0tcZpBPsD+GxHgzlY2/YLhbE32VUb/UuVthlQd3FmuRdzyovunBx3+wb+k8rLipeccOiOeWFC+lW4Dj5TftFtJvrd3wo5XmU95973czPAR9qEzEe7cf59fPaGFxw3JI63SqC89xvCx6t47RP5rdFEOuR2yqJ6wVwxMtW3HIS2A9u2XE4joODT2ZE+Tg4mDazoV8Ln/PZ3f3afb1ry6ca8yP92mAXtl/bSp8Vptv19TiEpx3XZzW51RD3eQzlmTvRh7920OeZ6NQd9u9wHN/5gqD2ywbbBp8h3t22DT6RN2LbAl3a8JZf13A9ZG0bVyeDbFsj+3U6wqZj7plMvCbTrMpE1nB7kZro+LcRYNugnseZsLgucEfn0z6744PB2Uf6CoCD0u2m024yWcq7lVIlnc33pvrcXDqXq2Qq+VwhU6pkM8VSvuxmiulUbzmfrLiFcjmfTffncxX9NbAKTWtbQNq6ncY2vM1Hf1G34fBJ0N1tww/2rkdseKAb6Z86I/1T4kL1T9FXJQbomR6TgHHaSVjYFqD7tBN98ML0d+M+z+ExKsVwBPXF8YgxPGzvn0/zfu9u2w5zIJbb9qLl25xyw7XN6bRqHT9omxOEo880WlMzbK+zhvWUMbkGpFwa9Ba0nQPHT+e1wZ/7D1jUj25VMVSGA7eqBB1xxH2aKAiro0ms3Zmnfp9z2xWmWvej68QJ5NdB/Nqrg9Oo+xHTUDi/cQ+31RDWnTXGMQgPb4Hl2toZ3u9kCw5stymbod1Ex7/fA/eivvYz3fsd5bWfQ73rMU69b5tGeH51BI8V4Jp7nYken2GoPqeAK7e/izuaSa8H7+1d6y135bPmnL6k3L940Q1z55xa7L++7BBHF4RjKPF+DTNOKIcRR89zzoZOccH7vbs7xVd71yN7/wNd2vBe3Kzhil7rFJ9ereNzFRzKMExQ4GvgBGGC3g+AMGehMHjTl3Zc5xr4cZMrM4kfrm9nED9s0M4kftjO4A4BGDY82cxtSosRP/x+wTBNyBd354S87e8XQIN9EspH2mDHnIH5aLJDjeNzHH5gE9VzjHWHACbh+ouzZ1+44IZbiovKMxfP6dd9ApwEDNvGJJE253j+z/EJR00ENQvUFODqj3H9nqf3gkxXzOe/wzzvOIPHc/g5up+rTSAe0+ui3OuMcRK3qU80cabdITrkPvUAftynHmIMFlc28HGSpyBcGo7ywfmA31HB6eDyixtvc59C4Uw33Dc8t2Tk8wBh8wPPEzSTH37zF7Ru0vV9W9dcT/Z+7+4hCG6KufeHYsSPOyYbwmHbzs3HQZeF6847jlwz2k74nOX912m9lHDm5gnijK7CNM04vdy8wqgQcWN9nVbl4+5weDuEj3nB4S/0/uv0X+Fdc+1enPi1MdhcnYQ0GvmEazbX15/JFpNlV/9MDfsnRLPFfH8x77q9GbeccbN7yDpXwfJ1rszIOldjNwzrXKmRda4hu5F1roB00zzdFaZa99ud61wwHbab1rkKI+tc9fAj61zPuZF1LqIAnFAOY2Sdy981O8g83ru2vFOcG3k5I9hJvZwBc9r6ehJ6nhq3OIMzTGtApl/KcJvt1MSJH+7U4EnSA4h+TA8sDJW1UBuej0I6oWWn1iCb5ZmKkfgchx9UwL0ug/mSRIOKOOHj13HQjTFs+p49t1iauWDuzQNbY5yKmE/qsD92nHZiPve1C3oNx6ZX7I/0fke5+znNu7ahp3Oc93tkm3vr+M+D0zwLI9N/IZRkfvovNzL9N2Q3Mv0XkG6ap7vCVOt+u3P6D3ak7abpv/6R6b96+JHpv+fcyPQfUQBOKIcxMv3n75rtFMN7xyNr4oHO9BH0GcPb6NlOMWdwoAzPrNZ1ObM6kBOEOQOFOQOF0W6o5wNwjfZM4oeNFV7PG+/Ur6HcP5/X86DhAYOsjfM073rO3EU3VJaePmf+4vLicum54ylh7/GpxdmzHeKaPdeb2uQEg0Mdfi6G0hB1Ww1nAEdhP6DjDDwTVVpfSfSagaFPRiXxPj2HpAXHS3XAla2Yz+828j8obCwAt5vxA0xYCsF88edd8f+9Ea6JdnWSGXw2r/ZG15NIOrG+ZwhxADyos9xe9jbiV+vwE34xeX6uQ1yciQsclJlJ6B7oczzhamqCDPBNvSoD+KYmIbgyie/RMkDbMsyJ1lNhrsXaoBtxiJM4KUcchrN5beR3gtyPhwjLlU38CVvKjz5Hz8mm9+hEjsOErw3Uvf/tPlj403o4/CgS1lQeTmQ4Aff/BwY6C7bi+AgA",
      "debug_symbols": "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JqQQImRCCiFCJoJMEmRCCiFCJqQQImRCCiFCJqQQImRCCiFBJoMUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyGSRQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkcUggRMiGFECETUggRMiGFECETQSYJMiGFuEgmS/5AmGoyUT5k8tuWf8qEFEKETEghRMiEFEKETEghJMhESCFEyIQUQoRMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMHimECJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQKSCFECETUggRMiGFECETUggRMhFkkiATUggRMiGFECETUggRMiGFECETUggJMkWkECJkQgohQiakECJkQgohQiaCTBJkQgohQiakECJkQgohQiakECJkQgohQaaEFEKETEghRMiEFEKETEghRMhEkEmCTEghRMiEFEKETEghRMiEFEKETEghJMiUkUKIkAkphAiZkEKIkAkphAiZCDJJkAkphAiZkEKIkAkphAiZkEKIkAkphACZbv8NMkmQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkMUggRMiGFECETUggRMiGFECETQSYJMiGFECETUggRMiGFECETUggRMiGFkCCTRQohQiakECJkQgohQiakECJkIsgkQSakECJkQgohQiakECJkQgohQiakEBJkckghRMiEFEKETEghRMiEFEKETASZJMiEFEKETEghRMiEFEKETEghRMiEFEKCTIQUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyOSRQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkCUggRMiGFECGT5hQibOaQKX4beC6+ejYHlGeZTkRN2y5qNLl2tN3yfrS18dvRv2XSnEIIkokgkwSZNKcQgmTSnEIIkklzCiFIJs0phCCZNKcQcmSKmlMIQTJpTiEEyYQUQoRMSCFEyESQSYJMSCFEyIQUYgqZyLn9aEq1WyqB7NfBITwkdaE0y/y4WbM9DaN8cDDH0cH6rXK0iSbsvG9/Z1d7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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AMM"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount0_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::add_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::add_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "config",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "liquidity_token",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "config::Config"
                    }
                  },
                  {
                    "name": "refund_token0_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "refund_token1_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "liquidity_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "amount0_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_add_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_add_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::swap_exact_tokens_for_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::swap_exact_tokens_for_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::remove_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::remove_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "config",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "liquidity_token",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "config::Config"
                    }
                  },
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token0_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "token1_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_remove_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_remove_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_in_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::swap_tokens_for_exact_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::swap_tokens_for_exact_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "change_token_in_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "token_out_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_swap_tokens_for_exact_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_swap_tokens_for_exact_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token0",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "liquidity_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token_out_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_swap_exact_tokens_for_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_swap_exact_tokens_for_tokens_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "130": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "133": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "136": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "140": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "141": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "179": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "183": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "185": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "186": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "194": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "201": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "218": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "220": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "263": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "278": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "281": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "291": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "297": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "298": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "307": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "354": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "395": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/amm_contract/src/lib.nr",
      "source": "/// Given an input amount of an asset and pair balances, returns the maximum output amount of the other asset.\npub fn get_amount_out(amount_in: u128, balance_in: u128, balance_out: u128) -> u128 {\n    assert(amount_in > 0 as u128, \"INSUFFICIENT_INPUT_AMOUNT\");\n    assert((balance_in > 0 as u128) & (balance_out > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // The expression below is:\n    //    (amount_in * 997 * balance_out) / (balance_in * 10000 + amount_in * 997)\n    // which is equivalent to:\n    //    balance_out * ((amount_in * 0.997) / (balance_in + amount_in * 0.997))\n    // resulting in an implicit 0.3% fee on the amount in, as the fee tokens are not taken into consideration.\n\n    let amount_in_with_fee = amount_in * 997 as u128;\n    let numerator = amount_in_with_fee * balance_out;\n    let denominator = balance_in * 1000 as u128 + amount_in_with_fee;\n    numerator / denominator\n}\n\n/// Given an output amount of an asset and pair balances, returns a required input amount of the other asset.\npub fn get_amount_in(amount_out: u128, balance_in: u128, balance_out: u128) -> u128 {\n    assert(amount_out > 0 as u128, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n    assert((balance_in > 0 as u128) & (balance_out > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // The expression below is:\n    //    (balance_in * amount_out * 1000) / (balance_out - amount_out * 997) + 1\n    // which is equivalent to:\n    //    balance_in * (amount_out / (balance_in + amount_in)) *  1/0.997 + 1\n    // resulting in an implicit 0.3% fee on the amount in, as the fee tokens are not taken into consideration. The +1\n    // at the end ensures the rounding error favors the pool.\n\n    let numerator = balance_in * amount_out * 1000 as u128;\n    let denominator = (balance_out - amount_out) * 997 as u128;\n    (numerator / denominator) + 1 as u128\n}\n\n/// Given the desired amounts and balances of token0 and token1 returns the optimal amount of token0 and token1 to be added to the pool.\npub fn get_amounts_to_add(\n    amount0_max: u128,\n    amount1_max: u128,\n    amount0_min: u128,\n    amount1_min: u128,\n    balance0: u128,\n    balance1: u128,\n) -> (u128, u128) {\n    // When adding tokens, both balances must grow by the same ratio, which means that their spot price is unchanged.\n    // Since any swaps would affect these ratios, liquidity providers supply a range of minimum and maximum balances\n    // they are willing to supply for each token (which translates to minimum and maximum relative prices of the\n    // tokens, preventing loss of value outside of this range due to e.g. front-running).\n\n    if (balance0 == 0 as u128) | (balance1 == 0 as u128) {\n        // The token balances should only be zero when initializing the pool. In this scenario there is no prior ratio\n        // to follow so we simply transfer the full maximum balance - it is up to the caller to make sure that the ratio\n        // they've chosen results in a a reasonable spot price.\n        (amount0_max, amount1_max)\n    } else {\n        // There is a huge number of amount combinations that respect the minimum and maximum for each token, but we'll\n        // only consider the two scenarios in which one of the amounts is the maximum amount.\n\n        // First we calculate the token1 amount that'd need to be supplied if we used the maximum amount for token0.\n        let amount1_equivalent = get_equivalent_amount(amount0_max, balance0, balance1);\n        if (amount1_equivalent <= amount1_max) {\n            assert(amount1_equivalent >= amount1_min, \"AMOUNT_1_BELOW_MINIMUM\");\n            (amount0_max, amount1_equivalent)\n        } else {\n            // If the max amount for token0 results in a token1 amount larger than the maximum, then we try with the\n            // maximum token1 amount, hoping that it'll result in a token0 amount larger than the minimum.\n            let amount0_equivalent = get_equivalent_amount(amount1_max, balance1, balance0);\n            // This should never happen, as it'd imply that the maximum is lower than the minimum.\n            assert(amount0_equivalent <= amount0_max);\n\n            assert(amount0_equivalent >= amount0_min, \"AMOUNT_0_BELOW_MINIMUM\");\n            (amount0_equivalent, amount1_max)\n        }\n    }\n}\n\n/// Returns the amount of tokens to return to a liquidity provider when they remove liquidity from the pool.\npub fn get_amounts_on_remove(\n    to_burn: u128,\n    total_supply: u128,\n    balance0: u128,\n    balance1: u128,\n) -> (u128, u128) {\n    // Since the liquidity token tracks ownership of the pool, the liquidity provider gets a proportional share of each\n    // token.\n    (to_burn * balance0 / total_supply, to_burn * balance1 / total_supply)\n}\n\n/// Given some amount of an asset and pair balances, returns an equivalent amount of the other asset. Tokens should be\n/// added and removed from the Pool respecting this ratio.\nfn get_equivalent_amount(amount0: u128, balance0: u128, balance1: u128) -> u128 {\n    assert((balance0 > 0 as u128) & (balance1 > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // This is essentially the Rule of Three, since we're computing proportional ratios. Note we divide at the end to\n    // avoid introducing too much error due to truncation.\n    (amount0 * balance1) / balance0\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/amm_contract/src/main.nr",
      "source": "mod lib;\nmod config;\n\nuse dep::aztec::macros::aztec;\n\n/// ## Overview\n/// This contract demonstrates how to implement an **Automated Market Maker (AMM)** that maintains **public state**\n/// while still achieving **identity privacy**. However, it does **not provide function privacy**:\n/// - Anyone can observe **what actions** were performed.\n/// - All amounts involved are visible, but **who** performed the action remains private.\n///\n/// Unlike most Ethereum AMMs, the AMM contract is not itself the token that tracks participation of liquidity\n/// providers, mostly due to Noir lacking inheritance as a feature. Instead, the AMM is expected to have mint and burn\n/// permission over an external token contract.\n///\n/// **Note:**\n/// This is purely a demonstration. The **Aztec team** does not consider this the optimal design for building a DEX.\n///\n/// ## Reentrancy Guard Considerations\n///\n/// ### 1. Private Functions:\n/// Reentrancy protection is typically necessary if entering an intermediate state that is only valid when\n/// the action completes uninterrupted. This follows the **Checks-Effects-Interactions** pattern.\n///\n/// - In this contract, **private functions** do not introduce intermediate states.\n/// - All operations will be fully executed in **public** without needing intermediate checks.\n///\n/// ### 2. Public Functions:\n/// No **reentrancy guard** is required for public functions because:\n/// - All public functions are marked as **internal** with a **single callsite** - from a private function.\n/// - Public functions **cannot call private functions**, eliminating the risk of reentering into them from private.\n/// - Since public functions are internal-only, **external contracts cannot access them**, ensuring no external\n///   contract can trigger a reentrant call. This eliminates the following attack vector:\n///   `AMM.private_fn --> AMM.public_fn --> ExternalContract.fn --> AMM.public_fn`.\n#[aztec]\npub contract AMM {\n    use crate::{\n        config::Config,\n        lib::{get_amount_in, get_amount_out, get_amounts_on_remove, get_amounts_to_add},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, utility}, storage::storage},\n        prelude::{AztecAddress, PublicImmutable},\n    };\n\n    use dep::token::Token;\n    use dep::uint_note::uint_note::PartialUintNote;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    /// Amount of liquidity which gets locked when liquidity is provided for the first time. Its purpose is to prevent\n    /// the pool from ever emptying which could lead to undefined behavior.\n    global MINIMUM_LIQUIDITY: u128 = 1000;\n    /// We set it to 99 times the minimum liquidity. That way the first LP gets 99% of the value of their deposit.\n    global INITIAL_LIQUIDITY: u128 = 99000;\n\n    // TODO(#9480): Either deploy the liquidity contract in the constructor or verify it that it corresponds to what\n    // this contract expects (i.e. that the AMM has permission to mint and burn).\n    #[public]\n    #[initializer]\n    fn constructor(token0: AztecAddress, token1: AztecAddress, liquidity_token: AztecAddress) {\n        storage.config.initialize(Config { token0, token1, liquidity_token });\n    }\n\n    /// Privately adds liquidity to the pool. This function receives the minimum and maximum number of tokens the caller\n    /// is willing to add, in order to account for changing market conditions, and will try to add as many tokens as\n    /// possible.\n    ///\n    /// `nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this specific call.\n    ///\n    /// The identity of the liquidity provider is not revealed, but the action and amounts are.\n    #[private]\n    fn add_liquidity(\n        amount0_max: u128,\n        amount1_max: u128,\n        amount0_min: u128,\n        amount1_min: u128,\n        nonce: Field,\n    ) {\n        assert(\n            (amount0_min < amount0_max) | (amount0_min == amount0_max),\n            \"INCORRECT_TOKEN0_LIMITS\",\n        );\n        assert(\n            (amount1_min < amount1_max) | (amount1_min == amount1_max),\n            \"INCORRECT_TOKEN1_LIMITS\",\n        );\n        assert((0 as u128 < amount0_max) & (0 as u128 < amount1_max), \"INSUFFICIENT_INPUT_AMOUNTS\");\n\n        let config = storage.config.read();\n\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        let sender = context.msg_sender();\n\n        // We don't yet know how many tokens the sender will actually supply - that can only be computed during public\n        // execution since the amounts supplied must have the same ratio as the live balances. We therefore transfer the\n        // maximum amounts here, and prepare partial notes that return the change to the sender (if any).\n        // TODO(#10286): consider merging these two calls\n        token0.transfer_to_public(sender, context.this_address(), amount0_max, nonce).call(\n            &mut context,\n        );\n        let refund_token0_partial_note =\n            token0.prepare_private_balance_increase(sender, sender).call(&mut context);\n\n        token1.transfer_to_public(sender, context.this_address(), amount1_max, nonce).call(\n            &mut context,\n        );\n        let refund_token1_partial_note =\n            token1.prepare_private_balance_increase(sender, sender).call(&mut context);\n\n        // The number of liquidity tokens to mint for the caller depends on both the live balances and the amount\n        // supplied, both of which can only be known during public execution. We therefore prepare a partial note that\n        // will get completed via minting.\n        let liquidity_partial_note =\n            liquidity_token.prepare_private_balance_increase(sender, sender).call(&mut context);\n\n        // We then complete the flow in public. Note that the type of operation and amounts will all be publicly known,\n        // but the identity of the caller is not revealed despite us being able to send tokens to them by completing the\n        // partial notes.\n        AMM::at(context.this_address())\n            ._add_liquidity(\n                config,\n                refund_token0_partial_note,\n                refund_token1_partial_note,\n                liquidity_partial_note,\n                amount0_max,\n                amount1_max,\n                amount0_min,\n                amount1_min,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _add_liquidity(\n        config: Config, // We could read this in public, but it's cheaper to receive from private\n        refund_token0_partial_note: PartialUintNote,\n        refund_token1_partial_note: PartialUintNote,\n        liquidity_partial_note: PartialUintNote,\n        amount0_max: u128,\n        amount1_max: u128,\n        amount0_min: u128,\n        amount1_min: u128,\n    ) {\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        // We read the current AMM balance of both tokens. Note that by the time this function is called the token\n        // transfers have already been completed (since those calls were enqueued before this call), and so we need to\n        // substract the transfer amount to get the pre-deposit balance.\n        let balance0_plus_amount0_max =\n            token0.balance_of_public(context.this_address()).view(&mut context);\n        let balance0 = balance0_plus_amount0_max - amount0_max;\n\n        let balance1_plus_amount1_max =\n            token1.balance_of_public(context.this_address()).view(&mut context);\n        let balance1 = balance1_plus_amount1_max - amount1_max;\n\n        // With the current balances known, we can calculate the token amounts to the pool, respecting the user's\n        // minimum deposit preferences.\n        let (amount0, amount1) = get_amounts_to_add(\n            amount0_max,\n            amount1_max,\n            amount0_min,\n            amount1_min,\n            balance0,\n            balance1,\n        );\n\n        // Return any excess from the original token deposits.\n        let refund_amount_token0 = amount0_max - amount0;\n        let refund_amount_token1 = amount1_max - amount1;\n\n        // We can simply skip the refund if the amount to return is 0 in order to save gas: the partial note will\n        // simply stay in public storage and not be completed, but this is not an issue.\n        if (refund_amount_token0 > 0 as u128) {\n            token0\n                .finalize_transfer_to_private(refund_amount_token0, refund_token0_partial_note)\n                .call(&mut context);\n        }\n        if (refund_amount_token1 > 0 as u128) {\n            token1\n                .finalize_transfer_to_private(refund_amount_token1, refund_token1_partial_note)\n                .call(&mut context);\n        }\n\n        // With the deposit amounts known, we can compute the number of liquidity tokens to mint and finalize the\n        // depositor's partial note.\n        let total_supply = liquidity_token.total_supply().view(&mut context);\n        let liquidity_amount = if total_supply != 0 as u128 {\n            // The liquidity token supply increases by the same ratio as the balances. In case one of the token balances\n            // increased with a ratio different from the other one, we simply take the smallest value.\n            std::cmp::min(\n                (amount0 * total_supply) / balance0,\n                (amount1 * total_supply) / balance1,\n            )\n        } else {\n            // The zero total supply case (i.e. pool initialization) is special as we can't increase the supply\n            // proportionally. We instead set the initial liquidity to an arbitrary amount.\n            // We could set the initial liquidity to be equal to the pool invariant (i.e. sqrt(amount0 * amount1)) if\n            // we wanted to collect protocol fees over swap fees (in the style of Uniswap v2), but we choose not to in\n            // order to keep things simple.\n\n            // As part of initialization, we mint some tokens to the zero address to 'lock' them (i.e. make them\n            // impossible to redeem), guaranteeing total supply will never be zero again.\n            liquidity_token.mint_to_public(AztecAddress::zero(), MINIMUM_LIQUIDITY).call(\n                &mut context,\n            );\n\n            INITIAL_LIQUIDITY\n        };\n\n        assert(liquidity_amount > 0 as u128, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n        liquidity_token.finalize_mint_to_private(liquidity_amount, liquidity_partial_note).call(\n            &mut context,\n        );\n    }\n\n    /// Privately removes liquidity from the pool. This function receives how many liquidity tokens to burn, and the\n    /// minimum number of tokens the caller is willing to receive, in order to account for changing market conditions.\n    ///\n    /// `nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this specific call.\n    ///\n    /// The identity of the liquidity provider is not revealed, but the action and amounts are.\n    #[private]\n    fn remove_liquidity(liquidity: u128, amount0_min: u128, amount1_min: u128, nonce: Field) {\n        let config = storage.config.read();\n\n        let liquidity_token = Token::at(config.liquidity_token);\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n\n        let sender = context.msg_sender();\n\n        // Liquidity tokens are burned when liquidity is removed in order to reduce the total supply. However, we lack\n        // a function to privately burn, so we instead transfer the tokens into the AMM's public balance, and then have\n        // the AMM publicly burn its own tokens.\n        // TODO(#10287): consider adding a private burn\n        liquidity_token.transfer_to_public(sender, context.this_address(), liquidity, nonce).call(\n            &mut context,\n        );\n\n        // We don't yet know how many tokens the sender will get - that can only be computed during public execution\n        // since the it depends on the live balances. We therefore simply prepare partial notes to the sender.\n        let token0_partial_note =\n            token0.prepare_private_balance_increase(sender, sender).call(&mut context);\n        let token1_partial_note =\n            token1.prepare_private_balance_increase(sender, sender).call(&mut context);\n\n        // We then complete the flow in public. Note that the type of operation and amounts will all be publicly known,\n        // but the identity of the caller is not revealed despite us being able to send tokens to them by completing the\n        // partial notees.\n        AMM::at(context.this_address())\n            ._remove_liquidity(\n                config,\n                liquidity,\n                token0_partial_note,\n                token1_partial_note,\n                amount0_min,\n                amount1_min,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _remove_liquidity(\n        config: Config, // We could read this in public, but it's cheaper to receive from private\n        liquidity: u128,\n        token0_partial_note: PartialUintNote,\n        token1_partial_note: PartialUintNote,\n        amount0_min: u128,\n        amount1_min: u128,\n    ) {\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        // We need the current balance of both tokens as well as the liquidity token total supply in order to compute\n        // the amounts to send the user.\n        let balance0 = token0.balance_of_public(context.this_address()).view(&mut context);\n        let balance1 = token1.balance_of_public(context.this_address()).view(&mut context);\n        let total_supply = liquidity_token.total_supply().view(&mut context);\n\n        // We calculate the amounts of token0 and token1 the user is entitled to based on the amount of liquidity they\n        // are removing, and check that they are above the minimum amounts they requested.\n        let (amount0, amount1) = get_amounts_on_remove(liquidity, total_supply, balance0, balance1);\n        assert(amount0 >= amount0_min, \"INSUFFICIENT_0_AMOUNT\");\n        assert(amount1 >= amount1_min, \"INSUFFICIENT_1_AMOUNT\");\n\n        // We can now burn the liquidity tokens that had been privately transferred into the AMM, as well as complete\n        // both partial notes.\n        liquidity_token.burn_public(context.this_address(), liquidity, 0).call(&mut context);\n        token0.finalize_transfer_to_private(amount0, token0_partial_note).call(&mut context);\n        token1.finalize_transfer_to_private(amount1, token1_partial_note).call(&mut context);\n    }\n\n    /// Privately swaps `amount_in` `token_in` tokens for at least `amount_out_mint` `token_out` tokens with the pool.\n    ///\n    /// `nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this specific call.\n    ///\n    /// The identity of the swapper is not revealed, but the action and amounts are.\n    #[private]\n    fn swap_exact_tokens_for_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in: u128,\n        amount_out_min: u128,\n        nonce: Field,\n    ) {\n        let config = storage.config.read();\n\n        assert((token_in == config.token0) | (token_in == config.token1), \"TOKEN_IN_IS_INVALID\");\n        assert((token_out == config.token0) | (token_out == config.token1), \"TOKEN_OUT_IS_INVALID\");\n        assert(token_in != token_out, \"SAME_TOKEN_SWAP\");\n\n        let sender = context.msg_sender();\n\n        // We transfer the full amount in, since it is an exact amount, and prepare a partial note for the amount out,\n        // which will only be known during public execution as it depends on the live balances.\n        // TODO(#10286): consider merging these two calls\n        Token::at(token_in)\n            .transfer_to_public(sender, context.this_address(), amount_in, nonce)\n            .call(&mut context);\n        let token_out_partial_note = Token::at(token_out)\n            .prepare_private_balance_increase(sender, sender)\n            .call(&mut context);\n\n        AMM::at(context.this_address())\n            ._swap_exact_tokens_for_tokens(\n                token_in,\n                token_out,\n                amount_in,\n                amount_out_min,\n                token_out_partial_note,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _swap_exact_tokens_for_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in: u128,\n        amount_out_min: u128,\n        token_out_partial_note: PartialUintNote,\n    ) {\n        // In order to compute the amount to swap we need the live token balances. Note that at this state the token in\n        // transfer has already been completed as that function call was enqueued before this one. We therefore need to\n        // subtract the amount in to get the pre-swap balances.\n        let balance_in_plus_amount_in =\n            Token::at(token_in).balance_of_public(context.this_address()).view(&mut context);\n        let balance_in = balance_in_plus_amount_in - amount_in;\n\n        let balance_out =\n            Token::at(token_out).balance_of_public(context.this_address()).view(&mut context);\n\n        // We can now compute the number of tokens to transfer and complete the partial note.\n        let amount_out = get_amount_out(amount_in, balance_in, balance_out);\n        assert(amount_out >= amount_out_min, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        Token::at(token_out).finalize_transfer_to_private(amount_out, token_out_partial_note).call(\n            &mut context,\n        );\n    }\n\n    /// Privately swaps at most `amount_in_max` `token_in` tokens for `amount_out` `token_out` tokens with the pool.\n    ///\n    /// `nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this specific call.\n    ///\n    /// The identity of the swapper is not revealed, but the action and amounts are.\n    #[private]\n    fn swap_tokens_for_exact_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_out: u128,\n        amount_in_max: u128,\n        nonce: Field,\n    ) {\n        let config = storage.config.read();\n\n        assert((token_in == config.token0) | (token_in == config.token1), \"TOKEN_IN_IS_INVALID\");\n        assert((token_out == config.token0) | (token_out == config.token1), \"TOKEN_OUT_IS_INVALID\");\n        assert(token_in != token_out, \"SAME_TOKEN_SWAP\");\n\n        let sender = context.msg_sender();\n\n        // We don't know how many tokens we'll receive from the user, since the swap amount will only be known during\n        // public execution as it depends on the live balances. We therefore transfer the full maximum amount and\n        // prepare partial notes both for the token out and the refund.\n        // Technically the token out note does not need to be partial, since we do know the amount out, but we do want\n        // to wait until the swap has been completed before committing the note to the tree to avoid it being spent too\n        // early.\n        // TODO(#10286): consider merging these two calls\n        Token::at(token_in)\n            .transfer_to_public(sender, context.this_address(), amount_in_max, nonce)\n            .call(&mut context);\n        let change_token_in_partial_note =\n            Token::at(token_in).prepare_private_balance_increase(sender, sender).call(&mut context);\n\n        let token_out_partial_note = Token::at(token_out)\n            .prepare_private_balance_increase(sender, sender)\n            .call(&mut context);\n\n        AMM::at(context.this_address())\n            ._swap_tokens_for_exact_tokens(\n                token_in,\n                token_out,\n                amount_in_max,\n                amount_out,\n                change_token_in_partial_note,\n                token_out_partial_note,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _swap_tokens_for_exact_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in_max: u128,\n        amount_out: u128,\n        change_token_in_partial_note: PartialUintNote,\n        token_out_partial_note: PartialUintNote,\n    ) {\n        // In order to compute the amount to swap we need the live token balances. Note that at this state the token in\n        // transfer has already been completed as that function call was enqueued before this one. We therefore need to\n        // subtract the amount in to get the pre-swap balances.\n        let balance_in_plus_amount_in_max =\n            Token::at(token_in).balance_of_public(context.this_address()).view(&mut context);\n        let balance_in = balance_in_plus_amount_in_max - amount_in_max;\n\n        let balance_out =\n            Token::at(token_out).balance_of_public(context.this_address()).view(&mut context);\n\n        // We can now compute the number of tokens we need to receive and complete the partial note with the change.\n        let amount_in = get_amount_in(amount_out, balance_in, balance_out);\n        assert(amount_in <= amount_in_max, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        let change = amount_in_max - amount_in;\n        if (change > 0 as u128) {\n            Token::at(token_in)\n                .finalize_transfer_to_private(change, change_token_in_partial_note)\n                .call(&mut context);\n        }\n\n        // Note again that we already knew the amount out, but for consistency we want to only commit this note once\n        // all other steps have been performed.\n        Token::at(token_out).finalize_transfer_to_private(amount_out, token_out_partial_note).call(\n            &mut context,\n        );\n    }\n\n    #[utility]\n    unconstrained fn get_amount_out_for_exact_in(\n        balance_in: u128,\n        balance_out: u128,\n        amount_in: u128,\n    ) -> u128 {\n        // Ideally we'd call the token contract in order to read the current balance, but we can't due to #7524.\n        get_amount_out(amount_in, balance_in, balance_out)\n    }\n\n    #[utility]\n    unconstrained fn get_amount_in_for_exact_out(\n        balance_in: u128,\n        balance_out: u128,\n        amount_out: u128,\n    ) -> u128 {\n        // Ideally we'd call the token contract in order to read the current balance, but we can't due to #7524.\n        get_amount_in(amount_out, balance_in, balance_out)\n    }\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "54": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "64": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "68": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "80": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "85": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "89": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "90": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "93": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "94": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    }
  }
}
