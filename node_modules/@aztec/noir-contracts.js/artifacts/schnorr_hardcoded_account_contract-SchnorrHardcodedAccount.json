{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "SchnorrHardcodedAccount",
  "functions": [
    {
      "name": "verify_private_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "19458536156181958": {
            "error_kind": "string",
            "string": "Function verify_private_authwit can only be called statically"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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kfCtfvpxb1M8mWHdt/n/nmCicdnS1C0MBne7EIOj7KU7mA2OYk3ucKkv/xeMZIpQI8lnMpI7/YyE72QwkrsUNxKs+y5BRjKFwUjuFmIklL10j+JGgmtyz/8bCdlY9wo1kpCPbg7MfKf6GQlPZWiGqYQLeJ/ipoRzeB+D0N8n4Hmnexnqvl+IwVH25QOKPxSIa/IAw1pPU7zH8d6exmTsXH05jbAvH1S8LzNtZjRnh065mZmueI/jGk9nmEPKPnxIgBc+xKCPQeJHJjwmbvjvvr4/n1bH8z6m896m816m856m8x6m8+6m826m866m8y6m886m806m846m8w6m8/am83am87am8zam89am81am85am8xam8+am82am86am8yam85jpPGo6j5jOw6bzfNN5yHT+refv8/2m832m872m8z2m892m812m829M5ztN5ztM59tN59tM51tN51tM55tN55tM5xtN5xtM5+tN5+tM52tN52tM56tN51+bzleZzleazleYzpebzpeZzr8ynS81nS8xzh+G+3UG4BHAo4CZgMcAjwNmAWYDngDMATwJeArwNGAu4BnAPMCzgOcAzwNeALwImA94CfAy4BXAq4DXAAsArwPeALxp2lPgYX0pi1PdKO+h07aHCXX8LUIddzPYU/I2833bz0j4bYZHiBcqHsax7oXMG3bqm7Uy4c06g3B93hF6s77DdLO+62ck/C7Dzfqe4jcr1v2ekIfNG/r+FBbqlEQpqO/7ZQheNULBe4Rw/j4QKngfMAneIj8j4UUMgveh4oKHdX8o5PlrFOb3GR7S+EiISNUmFKlHCfvyY6Ei9TGTSC32MxJezCBSnyguUlj3J0JECsX0IwaR+lSISNUnFKmZhH35mVCR+oxJpD73MxL+nEGkvlBcpLDuL4SIFIrppwwi9aUQkdIIReoxwr5cIlSkljCJ1FI/I+GlDCL1leIihXV/JUSkUEy/ZBCpZUJEKkwoUo8T9uVyoSK1nEmkVvgZCa9gEKmViosU1r1SiEihmC5jEKlVQkSqGaFIzSLsy6+FitTXTCK12s9IeDWDSK1RXKSw7jVCRArFdBWDSK0VIlJtCEVqNmFfrhMqUuuYRGq9n5HwegaR2qC4SGHdG4SIFIrpWgaR2ihEpDoRitQThH25SahIbWISqc1+RsKbGURqi+IihXVvESJSKKYbGURq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",
      "debug_symbols": "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vQK96+6zRYHW7jP/Q6QbC64surHgyqIu15VFXa4ri+7lOgX61O4zXxbdWHBlUZfryrJpl2v5scu1fH4oi0kWT5Yvpsutx3n7xjW3957+45WSG9dut+D7eTqxk7vLVezkFnAVO7lPW8SOXrG1ip3c8axiJ7clq9jJvcMqdiPHXvo0dnIVXukeuK6itxytYg9cV9H7ghafVfRSn4Xu6M07q9gD11X0DptV7IHrKnobzEr3wHUVvVdlFXvguoreULL4rKLXiCx0R+/6WMUeuK6it2asYg9cV9H7J1a6B66r6E0Oq9gD11X0ToTFZxW9uGChO3q7wCr2wHUV7dO/ij1wXUU73q90D1xX0d7xq9gD11W0C/vis4q2Sl/ojvYzX8UeuK6incFXsQeuq2iP7ZXugesq2q16FXvguor2fV58VtHmzAvd0Q7Kq9gD11W0F/Eq9sB1Fe3qu9I9cF1F++OuYg9cV9FOs4vPKtoOdqE72rN1FXvguop2P13FHriuon1EV7oHrqtoR85V7IHrKtrbcvFZRRtQLnRHu0SuYg9cV9F+i6vYA9dVtHPhSvfAdRXtAbiKPXBdRbvpLT6raMu7he5oX7pV7IHrKtrhbRV74LqK9kpb6R64rqJdx1axB66raP+u+We1o0225rp3tBPWKva4dbWjPaVWscetqx3tzrTSPW5d7YH9lnpgv6XO9luaf1YD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUg/st9QD+y31wH5LPbDfUmf7LS1i/8R11ezd2P/4Eeff/yP63/8j3GJSs92+quZWHr8qHe7a3zRuAZ25Pv2M1r2AztsbZ+/Enuz8/R/X37756dUPP7z69z9/ePPt17+8evP654evPB7+x7/dYuftV6ampzBreXhx/p2S6VeUj/4K++ivqB/9Fe3jvuL6S3p40L+71498++C8s7g4nc5b1czePtpqeffRh9+c8+/85v3eb95vv5Ct9z9/83H3N799Ns7jz5H798c+yTe//pIfHvTHiLXcXnE92/sfq5cv/Ond/EvOj/+S/vFfMj7yS36//vq/X//06utvfvj+ITc8/NdfX397SxXXX3/5vx9v/+WWTH786c2333/360/fP6SVp4zy8GHP42UZD78UD+/blfOsPn18Hv6vbC/zeJT+4StKfmn59hU1vaztCuoK7P8B",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "entrypoint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "app_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::app::AppPayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 4,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::fee::FeePayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 2,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_fee_payer",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cancellable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "notify_enqueued_public_function_call_wrapper",
        "call_private_function_internal",
        "debug_log_oracle_wrapper",
        "notify_set_min_revertible_side_effect_counter_oracle_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "rZLdCoMgGIbvxWMP/P/ZrYwxrGwIYmE1GNG9z8JYrNFOOhE/fXh50HcElS2Gx92FuunA5ToC35Smd01I0zhBUETnvXvct8cAzQumC9+1Jsxj15vYgwtGDFMIbKiWvSQpo3beLtMEd7xUItNqvs+sxD9QTnhGOUefWCamGwSYnWGjqFxtuD62YVRnlAm1s+Gn2Ci22mh1bCPQ+jaCiJ2NOMNGE5JpTfkfG4UyKtHXT01pfJroTOFtrlg9hHLTuP7V2q/ytbEpbTVEO9dw08C0XrGChKbYFP0G",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
      "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrHardcodedAccount::verify_private_authwit_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrHardcodedAccount::verify_private_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "app_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 4,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::app::AppPayload"
                    }
                  },
                  {
                    "name": "fee_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 2,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_fee_payer",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::fee::FeePayload"
                    }
                  },
                  {
                    "name": "cancellable",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrHardcodedAccount::entrypoint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrHardcodedAccount::entrypoint_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "270": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "287": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "288": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "305": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "363": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "374": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/schnorr/v0.1.1/src/lib.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\nuse std::hash::{blake2s, pedersen_hash};\n\npub fn verify_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) -> bool {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n    // pub_key is on Grumpkin curve\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\n        & (!public_key.is_infinite);\n\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\n        let (r_is_infinite, result) =\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n        is_ok &= !r_is_infinite;\n        for i in 0..32 {\n            is_ok &= result[i] == signature[32 + i];\n        }\n    } else {\n        is_ok = false;\n    }\n    is_ok\n}\n\npub fn assert_valid_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n\n    // assert pub_key is on Grumpkin curve\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\n    assert(public_key.is_infinite == false);\n    // assert signature is not null\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\n\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n    assert(!r_is_infinite);\n    for i in 0..32 {\n        assert(result[i] == signature[32 + i]);\n    }\n}\n\nfn calculate_signature_challenge<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    sig_s: EmbeddedCurveScalar,\n    sig_e: EmbeddedCurveScalar,\n    message: [u8; N],\n) -> (bool, [u8; 32]) {\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    let r = multi_scalar_mul([g1, public_key], [sig_s, sig_e]);\n    // compare the _hashes_ rather than field elements modulo r\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\n\n    let mut hash_input = [0; N + 32];\n    for i in 0..32 {\n        hash_input[i] = pde[i];\n    }\n    for i in 0..N {\n        hash_input[32 + i] = message[i];\n    }\n\n    let result = blake2s(hash_input);\n    (r.is_infinite, result)\n}\n\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n    let mut v: Field = 1;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..16 {\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\n    sig_s\n}\n\nmod test {\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    use super::verify_signature;\n\n    #[test]\n    fn test_zero_signature() {\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let signature: [u8; 64] = [0; 64];\n        let message: [u8; _] = [2; 64]; // every message\n        let verified = verify_signature(public_key, signature, message);\n        assert(!verified);\n    }\n\n    #[test]\n    fn smoke_test() {\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\n        let signature: [u8; 64] = [\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\n            199, 19, 84, 239, 138, 124, 12,\n        ];\n\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\n        let valid_signature = verify_signature(pub_key, signature, message);\n        assert(valid_signature);\n        super::assert_valid_signature(pub_key, signature, message);\n    }\n\n}\n\nmod bench {\n    use super::{assert_valid_signature, verify_signature};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    #[export]\n    pub fn bench_verify_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) -> bool {\n        verify_signature(public_key, signature, message)\n    }\n\n    #[export]\n    pub fn bench_assert_valid_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) {\n        assert_valid_signature(public_key, signature, message)\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_hardcoded_account_contract/src/main.nr",
      "source": "// docs:start:contract\n// Account contract that uses Schnorr signatures for authentication using a hardcoded public key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract SchnorrHardcodedAccount {\n    use dep::authwit::{\n        account::AccountActions,\n        auth_witness::get_auth_witness,\n        entrypoint::{app::AppPayload, fee::FeePayload},\n    };\n    use dep::aztec::prelude::PrivateContext;\n\n    use dep::aztec::macros::functions::{private, view};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    global public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n        x: 0x16b93f4afae55cab8507baeb8e7ab4de80f5ab1e9e1f5149bf8cd0d375451d90,\n        y: 0x208d44b36eb6e73b254921134d002da1a90b41131024e3b1d721259182106205,\n        is_infinite: false,\n    };\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    // docs:start:is-valid\n    #[contract_library_method]\n    fn is_valid_impl(_context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load auth witness and format as an u8 array\n\n        // Safety: The witness is only used as a \"magical value\" that makes the signature verification below pass.\n        // Hence it's safe.\n        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature using hardcoded public key\n        schnorr::verify_signature(public_key, signature, outer_hash.to_be_bytes::<32>())\n    }\n    // docs:end:is-valid\n}\n// docs:end:contract\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/account.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::{\n        constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::Hash,\n    },\n};\n\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth_witness.nr",
      "source": "#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",
      "source": "use dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\n#[derive(Serialize)]\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    pub nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage()\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"
    },
    "56": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr",
      "source": "use crate::entrypoint::function_call::FunctionCall;\nuse dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\n#[derive(Serialize)]\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage()\n    }\n\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "68": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
