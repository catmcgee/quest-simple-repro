{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "NFT",
  "functions": [
    {
      "name": "prepare_private_balance_increase",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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9bQFnjbnaYt52uKetoSnLelpS3na0p620NOW8bQt52lb3tO2gqdtRU/bSp62lT1tq3jaVp2KxbAa/ezqFGtQrEmxFsXaFOtQrEuxHsX6FBtQbEixEcXGFJtQbEqxGcXmFFtQbEmxFcXWFNtQbEuxHcX2FDtQ7EixE8XOFLtULobVPERW97St4Wlb09O2lqdtbU/bOp62dT1t63na1ve0beBp29DTtpGnbWNP2yaetk09bZt52jb3tG3hadvS07aVp21rT9s2nrZtPW3bedq297Tt4Gnb0dO2k6dtZ0/bLlOxGLL0szmKPEWBokhRotiVYjeK3Sn2oNiTYi+KvSn2odiXYj+K/SkOoDiQ4iCKgykOoTiU4jCKwymOoBhAcSTFURRHUxxTuRiyHiI5T1ve01bwtBU9bSVP266ett08bbt72vbwtO3padvL07a3p20fT9u+nrb9PG37e9oO8LQd6Gk7yNN2sKftEE/boZ62wzxth3vajvC0DfC0HelpO8rTdrSn7ZipWAwD6WePpTiO4niKEyhOpDiJ4mSKUyhOpTiN4nSKMyjOpDiL4myKcyjOpTiP4nyKCygupLiI4mKKSygupbiM4nKKKyiupLiqcjEM9BA51tN2nKfteE/bCZ62Ez1tJ3naTva0neJpO9XTdpqn7XRP2xmetjM9bWd52s72tJ3jaTvX03aep+18T9sFnrYLPW0Xedou9rRd4mm71NN2maftck/bFZ62Kz1tV03FYriafvYaimsprqO4nuIGihspbqK4meIWilspbqO4neIOijsp7qK4m2IQxWCKeyjupRhCcR/FUIphFMMp7qcYQfEAxYMUIysXw9UeItd42q71tF3nabve03aDp+1GT9tNnrabPW23eNpu9bTd5mm73dN2h6ftTk/bXZ62uz1tgzxtgz1t93ja7vW0DfG03edpG+ppG+ZpG+5pu9/TNsLT9oCn7UFP28ipWAyj6GcfoniYYjTFIxSPUoyhGEvxGMXjFOMonqB4kuIpiqcpnqF4luI5iucpXqB4keIlipcpXqF4leI1itcp3qB4k+ItircrF8MoD5GHPG0Pe9pGe9oe8bQ96mkb42kb62l7zNP2uKdtnKftCU/bk562pzxtT3vanvG0Petpe87T9ryn7QVP24uetpc8bS972l7xtL3qaXvN0/a6p+0NT9ubnra3PG1vRxZD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",
      "debug_symbols": "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eFML6njT63uYNOFNLajjTS2o400tqONNLagL1A2o400tqONNLajjTS2o402v96ZpwpsaUA94UwvqeFML6nhTC+p4U4MeJgjUDajjTS2o400tqONNLajjTS2o400NqEe8qQV1vKkFdbypgTeNeFML6gJ1A+p4UwvqeFML6nhTix4Gb2pBHW9qQD3hTS2o400tqONNLajjTS2oC9QNqONNLajjTQ28acKbWlDHm1pQx5saUBe8qQV1vKlBDyN4UwvqeFML6gJ1A+p4UwvqeFML6nhTC+p4UwvqeFMD6jPe1MCbznhTC+p4UwvqeFML6gJ1A+p4U4seBm9qQR1vakEdb2pBHW9qQH3Bm1pQx5taUMebWlDHm1pQF6hf700XvKkFdbypBXW8qQV1vKkFdbypQQ+z4k0tqONNLajjTS2o400tqAvUDajjTS2o400tqONNLajjTQ286Yo3NaCe8aYW1PGmFtTxphbU8aYGPUwWqBtQx5taUMebWlDHm1pQx5taUMebGlAveFML6nhTC+p4UwNvWvCmFtQF6gbU8aYW1PGmFtTxphY9DN7Ugjre9HrqMuFNLajjTS2o400tqONNLagL1A2o400tqONNr/emMuFNLajjTS2o400NqAe8qQV1vKlBDxPwphbU8aYW1AXqBtTxphbU8aYW1PGmFtTxphbU8aYG1CPe1MCbRrypBXW8qQV1vKkFdYG6AXW8qUUPgze1oI43taCON7Wgjjc1oJ7wphbU8aYW1PGmFtTxphbUBerXe9OEN7Wgjje1oI43taCON7Wgjjc16GEEb2pBHW9qQR1vakEdb2pBXaBuQB1vakEdb2pBHW9qQR1vauBNBW9qQH3Gm1pQx5taUMebWlDHmxr0MLNA3YA63tSCOt7Ugjre1II63tSCOt7UgPqCN7Wgjje1oI43NfCmC97UgrpA3YA63tSCOt7Ugjre1KKHwZta1Dre1ID6ije1oI43taCON7Wgjjc16GFWgbpBreNNLajjTS2o400tqONNLajjTQ16mIw3taCON7Wgjje1oI43fQt1idskJa4/qAvU30B9KVP4unop4Rv1nxfnKPJ1cY5L/CERRrZ5iXC9zUuERW5eIvx08xJhvluXqODUm5cIW9+8RGQAzUtEYNC8RIJErUtEutC8RKQLzUtEutC8RKQLzUtEutC4RPNEutC8RKQLzUtEutC8RKQLzUskSNS6RKQLzUtEutC8RKQLzUtEutC8RKQLrUsUSBeal4h0oXmJSBeal4h0oXmJBIlal4h0oXmJSBeal4h0oXmJSBfeIdHxSQNzIDAwoB7JACyoY+vfQ/3oN+9zxKlbUMd8W1AXqBtQxyJbUMf1WvQwGFkL6nhTC+p4U4PP9YQ3taCON7Wgjje1oI43taAuUDegjje1oI43NejXE97Ugjre1II63tSAuuBNLajjTQ16GMGbWlDHm1pQF6gbUMebWlDHm1pQx5taUMebWlDHmxpQn/GmBt50xptaUMebWlDHm1pQF6gbUMebWvQweFML6nhTC+p4UwvqeFMD6gve1II63tSCOt7Ugjre1IK6QP16b7rgTS2o400tqONNLajjTS2o400NepgVb2pBHW9qQR1vakEdb2pBXaBuQB1vakEdb2pBHW9qQR1vauBNV7ypAfWMN7Wgjje1oI43taCONzXoYbJA3YA63tSCOt7Ugjre1II63tSCOt7UgHrBm1pQx5taUMebGnjTgje1oC5QN6CON7Wgjje1oI43tehh8KYW1PGm11NfJrypBXW8qQV1vKkFdbypBXWBugF1vKkFdbzp9d50mfCmFtTxphbU8aYG1APe1II63tSghwl4UwvqeFML6gJ1A+p4UwvqeFML6nhTC+p4UwvqeFMD6hFvauBNI97Ugjre1II63tSCukDdgDre1KKHwZtaUMebWlDHm1pQx5saUE94UwvqeFML6nhTC+p4UwvqAvXrvWnCm1pQx5taUMebWlDHm1pQx5sa9DCCN7Wgjje1oI43taCON7WgLlA3oI43taCON7Wgjje1oI43NfCmgjc1oD7jTS2o400tqONNLajjTQ16mFmgbkAdb2pBHW9qQR1vakEdb2pBHW9qQH3Bm1pQx5taUMebGnjTBW9qQV2gbkAdb2pBHW9qQR1vatHD4E0tqONNDaiveFML6nhTC+p4UwvqeFML6gJ1A+p4UwvqeFMDb7riTS2o400tqONNDahnvKkFdbypQQ+T8aYW1PGmFtQF6gbU8aYW1PGmFtTxphbU8aYW1PGmBtQL3tTAmxa8qQV1vKkFdbypBXWBugF1vKlFD4M3taCON7Wgjje1oI43vZ76OuFNLajjTS2o400tqONNLagL1C/3puuEN7Wgjje1oI43taCON7Wgjjc16GEC3tSCOt7Ugjre1II63tSCukDdgDre1II63tSCOt7Ugjre1MCbBrypAfWIN7Wgjje1oI43taCONzXoYaJA3YA63tSCOt7Ugjre1II63tSCOt7UgHrCm1pQx5taUMebGnjThDe1oC5QN6CON7Wgjje1oI43tehh8KYW1PGmBtQFb2pBHW9qQR1vakEdb2pBXaBuQB1vakEdb2rgTQVvakEdb2pBHW9qQH3Gm1pQx5sa9DAz3tSCOt7UgrpA3YA63tSCOt7Ugjre1II63tSCOt7UgPqCNzXwpgve1II63tSCOt7UgrpA3YA63tSih8GbWlDHm1pQx5taUMebGlBf8aYW1PGmFtTxphbU8aYW1AXq13vTFW9qQR1vakEdb2pBHW9qQR1vatDDZLypBXW8qQV1vKkFdbypBXWBugF1vKkFdbypBXW8qQV1vKmBN814UwPqBW9qQR1vakEdb2pBHW9q0MMUgboBdbypBXW8qQV1vKkFdbypBXW86fXU84Q3taCON7Wgjje93pvmCW9qQV2gbkAdb2pBHW9qQR1vatHD4E0tqONNDagHvKkFdbypBXW8qQV1vKkFdYG6AXW8qQV1vKmBNw14UwvqeFML6nhTA+oRb2pBHW9q0MNEvKkFdbypBXWBugF1vKkFdbypBXW8qQV1vKkFdbypAfWENzXwpglvakEdb2pBHW9qQV2gbkAdb2rRw+BNLajjTS2o400tqONNDagL3tSCOt7Ugjre1II63tSCukD9em8qeFML6nhTC+p4UwvqeFML6nhTgx5mxptaUMebWlDHm1pQx5taUBeoG1DHm1pQx5taUMebWlDHmxp40xlvakB9wZtaUMebWlDHm1pQx5sa9DCLQN2AOt7Ugjre1II63tSCOt7Ugjre1ID6ije1oI43taCONzXwpive1IK6QN2AOt7Ugjre1II63tSih8GbWlDHmxpQz3hTC+p4UwvqeFML6nhTC+oCdQPqeFML6nhTA2+a8aYW1PGmFtTxpgbUC97Ugjre1KCHKXhTC+p4UwvqAnUD6nhTC+p4UwvqeFML6nhTC+p40+uplwlver03LRPe1II63tSCOt7UgrpA3YA63tSih8GbWlDHm1pQx5taUMebGlAPeFML6nhTC+p4UwvqeFML6gL1671pwJtaUMebWlDHm1pQx5taUMebGvQwEW9qUOsRb2pBHW9qQR1v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0aFXPqJDr3xER6BzQIde+YgOvfIRHXrlIzr0ykd06JUP6PDcvkM69MpHdOiVj+jQKx/REegc0KFXPqJDr3xEh175iA698hEdeuUDOjy375AOvfIRHXrlIzr0ykd0BDoHdOiVj+jQKx/RoVc+okOvfESHXvk5ncxz+w7p0Csf0aFXPqJDr3xER6BzQIde+YgOvfIRHXrlIzr0ykd06JUP6PDcvkM69MpHdOiVj+jQKx/REegc0KFXPqJDr3xEh175iA698hEdeuUDOjy375AOvfIRHXrlIzr0ykd0BDoHdOiVj+jQKx/RoVc+okOvfESHXvmADs/tO6RDr3xEh175iA698hEdgc4BHXrlIzr0ykd06JWP6NArH9GhVz6gw3P7DunQKx/RoVc+okOvfERHoHNAh175iA698hEdeuUjOvTKR3TolQ/o8Ny+Qzr0ykd06JWP6NArH9ER6BzQoVc+okOvfESHXvmIDr3yER165QM6PLfvkA698hEdeuUjOvTKR3QEOgd06JWP6NArH9GhVz6iQ698RIde+YAOz+07pEOvfESHXvmIDr3yER2BzgEdeuUjOvTKR3TolY/o0Csf0aFXPqDDc/sO6dArH9GhVz6iQ698REegc0CHXvmIDr3yER165SM69MpHdOiVD+jw3L5DOvTKR3TolY/o0Csf0RHoHNChVz6iQ698RIde+YgOvfIRHXrl53QKz+07pEOvfESHXvmIDr3yER2BzgEdeuUjOvTKR3TolY/o0Csf0aFXPqDDc/sO6dArH9GhVz6iQ698REegc0CHXvmIDr3yER165SM69MpHdOiVD+jw3L5DOvTKR3TolY/o0Csf0RHoHNChVz6iQ698RIde+YgOvfIRHXrlAzo8t++QDr3yER165SM69MpHdAQ6B3TolY/o0Csf0aFXPqJDr3xEh175gE5fz+2bp9s44jxL5ep5TV8XL+GBTJIvMl31yb8is8RwI5PlG5mf1+Z1kq+L87rO96uX/MXx+o56iWXjOKcKxxTn20t//PthBmveAxlkvnH/+Hf+dvnnfNNg8xWN+aZlvU1BJB/PN4T88No5x/uYws7laUnx6+q0hvtnZt4bSJjLfLv649/LHX0s+3ziA547nRR2X/1jLLcXlzB9u/oT5gxMPZgLMPVgrsDUg5kNYJZtwuGjKa7AXG97hKSHLnNev8Zfrh//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+f7b/KlitfE733+bP1WsNn7n+2/zp4rVxu98/23+VLHa+J3vv82fKlYbv/P9t/lTxWrjd77/Nn+qWG38vvff1PypYrXx+95/U/OnitXG73v/TZPv/Tc1f6pYbfy+99/U/KlitfH73n9T86eKVcbf/KlitfE733+bP1WsNn7n+2/zp4rVxu98/23+VLHa+J3vv82fKlYbv/P9t/lTxWrjd77/Nn+qWG38zvff5k8Vq43f+f7b/KlitfE733+bP1WsNn7n+2/zp4rVxu98/23+VLHa+J3vv82fKlYbv/P9t/lTxWrjd77/Nn+qWG38zvff5k8Vq43f+f7b/KlitfE733+bP1WsNn7n+2/zp4rVxu98/23+VLHa+J3vv82fKlYbv/P9t/lTxWrjd77/Nn+qWG38zvdfx4d/fY7f+f7r+Citz/E7338dH0z1OX7n+6/z86+S8/OvkvPzr1Lr518tqdzGn6dUeelfHSyXbzMs5fu1n1wa39fNuDTeL5hxabwPeR+X4wMaU+sHjJmBaf3kMjswjbdkdmAa7/XswDTeRNqBkbbB5O2lJUsNzLqkr4vXddmulfg11cYbWc2pNt6bak618XbzYKqf42+8LayOv/HurTb+xo+nm4PMt4vDsmPPGz+erj7+tluW+vjb7izq4xfn4297V6+Pv+2tuj7+tvff+vjb3n/r4297/30cfwzx5/gbP56uPn4/++/++P3sv/vj97P/7o/fz/67P/7G9981rNvFueyMv/H9tzr+xvff6vgb33+r4298/62MXxo/nq4+/sb33+r4G99/q+NvfP+tjr/x/bc6ft/7rzR+PF19/L73X2n8eLo5p+l2cVly5aWlbJN9/CpTWXaujet0e5xxXOO9s12+uDS+r1txafw4PTsujfchSlw+59p4z6I618b7G9W5ykBzbbxvUp1r4z2W6lwb78d+NdePyO12seSdufbUu9Xm2lM/Vplr40cm6s61p76pNtee+qbaXHvqm2pzlYHm2lPfVJtrT33TPG99U97pmxo/ZlJ3rl31TZW5dtU3Hc+18aMudefaVd9UmWtXfVNlrl31TZW5ykBz7apvqsx1oL6p8eNBj+b6OX6/vdDn+P32N3+Pv/HjQevj99uHfI7fb2/xOf62+4Vlmm4DWdISdsYvzsff9r5eH3/be3V9/G3vv/Xxt73/1sff9v5bHX/j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Qy9nvuBDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nPmKD72eOT70eub40OuZ40OvZy4wv5w5PvR65vjQ65njQ69njg+9njk+9HLmGR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzFt/wG2XzPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoVczz109vNwLc3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMAz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmUd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzNP+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nLvjQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40MvZz7jQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZz5gg+9njk+9Hrm+NDrmeNDr2cuML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5lnfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczL/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40OvZl4mfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczD/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zAXmlzPHh17PHB96PXN86PXM8aHXM8eHXs484UOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cueBDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nPmMD72eOT70eub40OuZ40OvZy4wv5w5PvR65vjQ65njQ69njg+9njk+9HLmCz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69n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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "_store_nft_set_partial_note",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACXHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADAHgIAAgEeAgADAAo4AgMEJAIABAAAAIslAAAA0icCAgABMAwAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAC/KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQWmXp71B3Vp/DwBAQIm",
      "debug_symbols": "1VXtioMwEHyX/PbHbnajm77KcRTbpkUQLdYeHKXvfkkx1npSjyKF+yNZmclMJh97UTu3OR/WRbWvT2r1cVFlvc3boq58dbkmatMUZVkc1sPfCsInMzf86ZhXoTy1edOqFZJmkyhX7cKYBPwc+6J0vkK+Jr/xoHWEA+sBGifQbCHr0Gwx7dGZnQALs3Rg4ZSH4M9ECSxj39oIR7RvtL9Q+kb69GUufTRZtI8p0XP71hB3YOt5I/uWlraP+tF+EJE3iCCk71BBnFRBaynSNIRde6piQKCD+6HMHECDcQViCEY7iDi9bu8iuzuibMbRglcC9V8yIvvg6MZLX+MRv8izUzxBjDTxU/csA1NJaInPphDwTGwg5j7zTMZ+X6F/kTFlGqfM/G/dX331lTdFvild19/252o7aHft99GNOt+xqbdud25c6IH39oehf2hJiG6XwRf+vaPUa3idHw==",
      "brillig_names": [
        "_store_nft_set_partial_note"
      ]
    },
    {
      "name": "_finalize_transfer_to_private_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finalize_transfer_to_private_unsafe"
      ]
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQAFLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFi40qC3IiUlA8AQECJg==",
      "debug_symbols": "5ZXBjoIwEIbfpWcOnc60nfoqm41BrYaEgEHcZGN8920NVUQiG2O4eCEM+Yb/7wzDnMTGr467ZVFt64NYfJ1EWa/ztqirEJ3OmVg1RVkWu2X/sZDxYvWFP+zzKoaHNm9asQBUpDPhq028R5bhHdui9CECOmePvFQq4ZJUj4YRmpy0HU0OzJW2bgRmIu5gJkN9+DsTLN9j37mEA7gZ7b+p+pqv1eep6oO2yT4YxOf2nUbqYBfyBvYdvts+qHv7UYRnEAFp5lABGFVRGkxKUxp5QsWiTqYsWpjooJIJdkrxoIMA5h+O6P7cMU/Bi3kv6iG9mOfG8ogMpBEmext4LceaCrdvAGxPIo7aY3MYZWoO64nmWKPSj8caw8/h4MPh1YhWZthLog856zlEP3lT5KvSdxtue6zWvYXX/u79YPftm3rtN8fGxy14W4AQN0hwhnQZhxCgztAGjaDzBw==",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "private_get_name",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2111772463301017956": {
            "error_kind": "string",
            "string": "Function private_get_name can only be called statically"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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8aGXM3f40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs689xNMh2SOD72eOT70eub40MuZqzpDMX1/cQzbtTF+onifqabq+rOZ+mlm2sLRPw6oXwuD/+6l7+MPyscflY8/KR9/1j3+JudHSo7fdD1+v7jtAGW/5Fx4aef3ZsH59DTsED5ma6earZtqtn6q2fbdN0jPtu8uQ3q2ffck0rPtu4ORnm3f/Y7wbGPf3ZH0bKfqpaLeXuo+fr3d0X38Xvn49XYw9/Hr7Unu49fbZdzH33nfYPZA0TvjCy+dFr+F7e4xV5vjwbU5bS+c8+dr71w67zBacUmd9yLNuHTetTTj0nl/04xL531TMy4eLodcOu/zmnHpvH9sxqXzvrQZF/rdYy70u4dcMv3uMRf63WMuvnMuZssjvbEHeUDuvc8ojb/3fqA0/t7X7dL4e19fS+PvfR38fvx26X29Ko2/93WlNP7e847S+HvPJUrj173+2kX3+msX3euvXXSvv3bRvf7aRfn6a5Svv0b5+muUr79G+frbZH9/yfErX3+N8vXXKF9/jfL11yhff63y9dcqX3+t8vXXKl9/m+xrLDl+5euvVb7+WuXrr1W+/lrl669Tvv465euvU77+OuXrb5P9HCXHr3z9dcrXX6d8/XXK11+nfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z99crXX698/V2Vr7+r8vV3Vb7+rsrX3yZ7DkqOX/n62/lOguXxK19/O99JsDx+5etv5zsJlsevfP3tfW/A4viVr7+9799XHL/y9bf3PfaK41e+/va+D15x/MrX3973qiuOX/n62/t+csXxK19/e99Prjh+5etv7/vJFcevfP3tfj+50viVr7/d789WGr/y9bf7/c5K41e+/na/f1hp/MrX3+734yqNX/n62/3+VqXxK19/u98vqjR+5etvVr7+ZuXrr/L9r6zy/a+s8v2vrPL9r6zy/a+s8v2vnPL9r5zy/a+c8v2vnPL9r9yie/113e9/ddq+omG71iyL/XTxHcy0G12XwEy703UJzLRbXZfATLvXdQFM95uXNQOj9xST+/j1njZyH79XPn69Xc19/Hqbj/v49fYI9/HrXcrv49e74v4ef/e7ipXGr/e0hvv4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjL/7XcVK41e+/na/q1hp/MrX3+53FSuNX/n62/2uYqXxK19/u99VrDR+5etv97uKlcavfP3tflex0viVr7/d7ypWGr/y9bf7XcVK41e+/na/q1hp/MrX3+53FSuNX/n62/2uYqXxK19/u99VrDR+5etv97uKlcavfP3tflex0viVr7/d7ypWGr/y9bf7XcVK41e+/na/q1hp/MrX3+53FSuNX/n62/2uYqXxK19/u99VrDR+5etv97uKlcavfP3tflex0viVr7/d7ypWGr/y9bf7XcVK41e+/na/q1hp/MrX3+53FSuNX/n62/2uYqXxK19/u99VrDR+5etv97uKlcavfP3tflex0viVr7/d7ypWGr/y9bf7XcVK41e+/na/q1hp/MrX3+53FSuNX/f667vfVaw0ft3rr+9+V7HS+HWvv37Rvf56xbuK3ceve/31ivfouo9f9/rrFe949Xv8ijemuo9f+fqrfP8rr3z/K698/yvf+/5XweVt/GlxhZd+a2O5tM0w58/X3rl0vq4349J5v9CMS+d9yHlcvt+g0fe+wVgzML3vXNYOTOctWTswnfd67cB03kS2A+P7BpP2l/bJl8DE4D4ujjHs13r7MdXOG1nJqXbem0pOtfN285up3sffeVtYHH/n3Vtp/J1vT7cav24Xm3Bgzzvfnq48/r5blvL4++4syuP3ysff96peHn/fS3V5/H2vv+Xx973+lsff9/r7PH5r7Nfxd749XXn8etbf4/HrWX+Px69n/T0ev57193j8na+/0cT94pQPxt/5+lscf+frb3H8na+/xfF3vv6Wxt/59nTl8Xe+/hbH3/n6Wxx/5+tvcfydr7/F8Stffzvfnq48fuXrb+fb063JLdvFOaTCS/u8T/b5q0w5HFxr47IdZ2yjfXS24YNL5+t6Ky6db6fXjkvnfYgQl/tcO+9ZROfaeX8jOlc/0Vw775tE59p5jyU61877sbfmeovctot9OpjrSL1baa4j9WOFuXa+ZaLsXEfqm0pzHalvKs11pL6pNFc/0VxH6ptKcx2pb1rXvW9KB31T59tMys51qL6pMNeh+qbv59r5Vpeycx2qbyrMdai+qTDXofqmwlz9RHMdqm8qzHWivqnz7UG/m+t9/Hp7ofv49fY3v8ff+fag5fHr7UPu49fbW9zH33e/EJZlG0hwwRyM3ysf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Xs8cH3o9c3zo9czxodczx4deztzgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlziw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzB0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzPv/YDbIZnjQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deznyow8u1MMeHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYRH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZJ3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZp5XvCh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nLnBh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmFh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmTt86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2fu8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72c+YoPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwDPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczj/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezjzhQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejnzjA+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjFzN2y4EOvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o5c4MPvZ45PvR65vjQ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cdK+EiftK3HSvhIn7Stx0r4SJ+0rcdK+EmftK3HWvhJn7Stx1r4SZ+0rcda+EmftK3HWvhJn7StxVr4Su0X5SuwW5SuxW5SvxK77PbaKE1C+Ejvte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57XtsOe17bDnte2w57Xtsee17bHnte2x57Xtsee17bPlF+Urste+x5bvfY+vx0iFm82kCR1dvww4pPK7N+WOyva/aopPtfYUXnWzv3YDkZLvfE0x0sr13GaKT7bwjiau3H1fHsITCZJ3bLnb+edQHl65h3ca8xuXpYh+PBp3z/srLkj5dfefYeWOkhqOHowjHzttENRw771bVcOy8EVbDsfMeWw3Hztt3LRx736NQDcfOTYcajvgZGY74GRmOHo4iHPEzMhzxMzIc8TMyHPEzMhzxMyIce9/pVQ1H/IwMR/yMDEf8jAxHD0cRjvgZGY74GRmO+BkZjvgZGY74GRGOve+XrYYjfkaGI35GhiN+Roajh6MIR/yMDEf8jAxH/IwMR/yMDEf8jAjH3k8dUMMRPyPDET8jwxE/I8PRw1GEI35GhiN+RoYjfkaGI35GhiN+RoRj72e3qOGIn5HhiJ+R4YifkeHo4SjCET8jwxE/I8MRPyPDET8jwxE/I8Kx9xOw1HDEz8hwxM/IcMTPyHD0cBThiJ+R4YifkeGIn5HhiJ+R4YifEeHY+zmCajjiZ2Q44mdkOOJnZDh6OIpwxM/IcMTPyHDE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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_get_name",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString",
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQADLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF+0Le07wSjQI8AQECJg==",
      "debug_symbols": "7VVdj4IwEPwvfeah+9F261+5XAwqGhKCBvGSi/G/XzEUkWvkYoxP90JYMsMMs2z3rDbF6rRblvV2f1SLj7Oq9uu8Lfd1qM6XTK2asqrK3XL8WOnu4swVfzzkdVce27xp1QII2WSqqDfdPYkO79iWVREq4Ev2G68RI1wzjtCQQLPXrkezBzugnU+AhVl6sLDlMfgzU6JfY9/7CAfwb7T/ovSNDOnLXPpgXLQPluixfW+Ie7APvIl9T6+2D3hvvxORN4iAtu9QAUiqoAEbaWhIZlQcmWjKkYOZDqKOYI8okw4C2D844vvv7ngIT/Ke1CN+kudTPPJCcYS1vrGMTiRIFmOCZGXUHEmOF7rhLEF/O0swOYxOSMdWiplppbMYX+2slcfgEICn4V80aKedZ/5PJpHMJVRfeVPmq6rot+f2VK9Hy7T9PhSTvXpo9utic2qKbsPelit02yk4I76OWijIZOSCRtD5AQ==",
      "brillig_names": [
        "public_get_name"
      ]
    },
    {
      "name": "transfer_in_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954044801249163952": {
            "error_kind": "string",
            "string": "NFT not found when transferring"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3bjvQ8k515L/+xDyQqtPOtDAYD79FAo3tg9xwZvvfJ2kiZ1SWKWVWRCgbjmYPBb1tfveSzgqlYS6L4v//xX//bf/7//sf/80//8t//9X/94z/+X//7H//8r//lP/3bP/3rv9z+T//7H/3w/n/3v/7f//Qvb//H//Vv/+l//ts//mMaZf4P//hv//Jfb/9z6tP/+Q//+O//9M//7R//se/l//yH71cn6bar03S/ehkPLh66dfy8eOin5fziflz77erb/073y9O6HF0/jct2+TTP+9VDf/jXh2nYrpa++3L1//0f/tELaHJoRtDk0EyVoxnTHc00FdCkPk3bSHoZ/4hmBk0OzQKaHJr1EI0s/R3NUEAjt//rz6ulH+//xLy8/Qupe/m/0B/9C/2QZP+dGoalK/wbt+v7/fJxeri6P7h6XdetePque/uD9yEdSSbjg2bL+O9nkNzPYDiewdLt/8jwWNpvM3j7z+TwP+uW8T62ZbqP7U377zPZR7au/X3x3Hi9/Qvjy/+F6eX/wvzyf2E5/hfWbv9luv2kjef/wk1tkbvay13tt9/L75ev072RWKclnV++pP03YEljX/iRnNd96czrmgpXD/sPsPQPP7/94UpIy7othKFLhav7261gR/LYKx1f3aU772n8cvWbSisq1a/S0KGSA5V6VHpWpbnfb/3z0JW4z/PecM5r+qNKCZUcqDSoqHTjsTuVblwKKsly/zW49aNSulyWab987OZCu7uMu9tb+/ncwFEB/xiECgheASMVELwCJgcVMPbzvQIeMpLDChjmLbmW4S5pP87v0509THe6F/xUKvh+SvdymGRZ/13GMyzhZrw2N+P54XHMPH3L8aQLN+PeeMZj9/Djcnj5vEd38/LwMOE9uZNU/fCXPZZeZHocPvfcv95zxdp5PaF+3x2r/zZ8MRj+2Ml0H/48PF7+NiaLRnYc1v3RzShSiBxS16f90WWXSj+YrJN/yISo7Yk6I2p7olqYjJuQy13UuTu/fFzHbb7j+tCQHbefDw9p14de9e21kLfprtVPd7o9Z/68euofHtL86j2BsQs235y7WPcl03fd8Djft//quKm//Wd753L7PwwFSt39zZ/+8RWbt5bnANJ0/53arx2GMcoPzzjA/HLmosG8X/bVnR7ehztmPo7r5kduj/bu9+P+zW0e/O3dvfS3O/nD317f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qgd/uB/uyfnDJ6/ePifx/eL7bvruy6UfCGu/YTtAKCD8K8KW+gsjhC31LUYIW+qHbBBKS83HTxB29+MC+odHYocIl2UbxNoXNzXf/u398d8yz/frh/6T+Vh5utMk88ojqSaZR+32LZlHtQeWzAXmlzOPakAsmUd1LJbMo1ocS+YtZc9emONDL2c+4UOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72c+YwPvZ45PvR65vjQ65njQ69nLjC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYLPvR65vjQ65njQ69njg+9nrnA/HLm+NDrmeNDr2eOD72eOT70eub40MuZr/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40OvZr50+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9n3uNDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nHntp/I2yRwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o58wEfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwFH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMR3zo9czxodczx4dezxwfej1zgfnlzPGh1zPHh17PHB96PXN86PXM8aGXM5/wodczx4dezxwfej1zfOj1zAXmlzPHh17PHB96PXN86PXM8aHXM8eHXs58xodezxwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o58wUfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cxXfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoVczXzt86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzPv8aHXM8eHXs8cH3o9c3zo9cwF5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOFDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nPmAD72eOT70eub40OuZ40OvZy4wv5w5PvR6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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "transfer_to_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4718290446670665014": {
            "error_kind": "string",
            "string": "NFT not found when transferring to public"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "transfer_to_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "transfer_in_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "transfer_in_public"
      ]
    },
    {
      "name": "_finish_transfer_to_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEguCIBIAAEuCIBJAAIlAAAASyUAAABvKAIAAQSASicCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAj4eAgADAB4CAAQAMzgAAwAEAAUkAgAFAAAAkyUAAAJnHgIAAwEeAgAEAAo4AwQFJAIABQAAAK8lAAACeScCAwAALQgBBCcCBQQEABABBQEnAwQEAQAoBAIFLQwFBi0OAwYAKAYCBi0OAwYAKAYCBi0OAwYrAgAFAAAAAAAAAAACAAAAAAAAAAAtCAEGJwIHBAUAEAEHAScDBgQBACgGAgctDAcILQ4DCAAoCAIILQ4DCAAoCAIILQ4DCAAoCAIILQ4FCC0IAQUAAAECAS0OBAUtCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARQAGLQgBBwAAAQIBLgqARAAHJwIIAAknAgkECi0IAAotDAULLQwEDC0MBg0tDAcOLQwIDwAQAAkAJQAAAostBAAAJwIIBAktCAAJLQwFCi0MBAstDAYMLQwHDS0MAg4AEAAIACUAAAKLLQQAAC0NBwILKAACgEQACCQCAAgAAAHmJwIJBAA8CQEJJwICBAgtCAAILQwFCS0MBAotDAYLLQwHDAAQAAIAJQAAA7QtBAAALQ0EAgEoAAKARwAFLQ0FBAo4BAMCCygAAoBEAAMkAgADAAACNyUAAATHMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAJmKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQVjmNPyHedZZDwBAQImJQAAAj4tDQMGLQ0EBwsoAAeARAAIJAIACAAAArEnAgkEADwJAQkLKAAGgEMAByQCAAcAAANAIwAAAsYtDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAAC6yUAAATZLgQABoADKACABAQABCUAAATrLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAAyslAAAFeS0OCgEtDgcCLQ4FAy0OCQQjAAADsycCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAO0LQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAE6y4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA7MmJQAAAj4uCIBFAAUjAAADxA0oAAWAQwAGJAIABgAABDQjAAAD2S0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAARSIwAABL4tDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAATrLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABL4tDAYFIwAAA8QqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUGIwAABREuAIADgAUjAAAFeC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVkLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAUzKAGABQQAAQMAgAYAAoAGIwAABXgmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3dTiM7DMffpddcxM6n91WOjlZ8lFWlqqACRzpCvPvOsJ0PiNNQT7QSGt+gFvzHmV+dxEma5HVzt715+fVzd7h/eNr8+Od1s3+4vX7ePRy6d69vV5ub426/3/36Of/1xvQ/AMK74Onx+tC/f3q+Pj5vfoBF568228Nd/9om0/2T+91+270D93aV2xvEwdw4nFkDY+3IxJO1IwijdSTGODmXTsbJBTc3/vdqAwhtyk80mAPQ3yx/I/4+jfxTjT/4OJQfgrXny0/eupMxdbrP5beudfkBP5a/9+Lwr3iJrBcgsoMMTU/0rBdvkjmZdy9TJTo8DE+QvDWf6Xr+ubtSxKlENlZK1DJe/VcYWfpQol4XUKaLRqjzPDlnxxBAF6YY8IYNmGCnZmGqKBAtW63CyRjN9I+t9YxtpDFyI9FkjZQYa+uH1tXNPj4EzhaBYCgGGqpYexzavXn09bY9xGQU4nKITiEuh0gKcTFE0khsAFEjcTFENBqJDSAmhbgYIqBCXA4xKsTFEAszGQrxIohBIS6GaHXY9yWINMyqBPAZRK/VuQFEncVZDjFodW4AUSNxOcSokdgAokZiA4g6i7McYrIKcTlEncVZDpF0FqcBRJ3FWQzRGh32NYCoszjLIYIm2znEdzBOwfBgNCnmwaAmugUwmjLwYKwmpAUw2rXzYJx21wUwOt/Fg9EVphIYjRgejK4ElcCstlfCNHwToFv2xwxMXG0bUwOjEcODWe+egRoYp2B4MKtdAamAWe+qRg2MNr4sGGe08S2AWe2QoAJmvasENTDaXRfArHaVoAJmvasENTCrXSWogLE6ui6A0e66AEYbXx6M08a3AEZH1zwYrxFTALPa7jrCWIz4aV/cZdY9xrDazv0ijBDCcFwShJhyjKvt8ZpijFqpW2BMq52SbYtxtRO4l2GMcXzCSHlPTdrFNMG42tFmW4zaUzfA6M1qxyVtMWrC0wIjaBfTBKMmPC0wrveMpLYYNeFpglETni9hJDMerk6YY7TaU7fA6Jq0jZBm1r6C0Xsahvkh4XRWOEDkQIbhO9hxNiUACf8UP3zr4nv3rYsf8HsX/ytNyEzHF9+ZwQc4jB+c5NYJ01DTkzUfzslnjE0aj/kHWzmBHyCY8TYNCM7OzbunDZ6vKvM7OEK2HzwUNn/UVHxcgx3n98Bl83shokRV+Op4TeVFKr7vhjCRTxmNWPi2nB034ncvU65yIlWSqBBFqiBRWdFzOVEJC3dzeBw/Ze9ipiqs8VZUhZpSU3mJqrDBpqYKElUS+SrULx/GbMSnbEdVJCtSJYEqFY4LqagKMxs1lRepSKJCCcNU2Hpup+zRYspVUaIq5Jw1lRepSKIqtAA1lYhGEJEPIl9RRD6KyEcR+cLpcNa5UeVjriKJqrAh5LyKCmc11VRRoiqcM19RoRGpJP0yoSTfIIsilcgXn4t2CcUwMnAh0/C91zSkJ5/74WPwvIbv7yqaeLEGDB+0NZEXiPhktyZyglFGJyORrNBDVmVJJLMyb1bmzcm8OZk3L/PmZZ9bkHkrdJU1WaGvrMrCxc0NGH4MO13AR8iJBNUT+Kz3vCcAIxE5iSgJRPzotQICBc0oWIkn/vAiGucMKOZhBHyOXBNJPPlag82KJLEXQCJKAlG0EhEJRPz+/JpI4okkzyRJFlCSLODFycJb9/a/6+Pu+ma/Pd04fP9yuJ1dQPz8/+P2013Ej8eH2+3dy3Hb30o8XUjch3B/qyuG8N40dm+7Gn7VfabvFPq/htj9lTqvneff",
      "brillig_names": [
        "_finish_transfer_to_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "cancel_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3bjuw6l535LnVdF+JBPPhVjIbhQ7VRQKHKKNsNNIx+9461Y0kRuVNKZnJNiZzkd1NYf20pgvzmyOAcQxHk//mH//ZP/+V///f/9M//+n//2//8h//wH//PP/zLv/3X//y//vnf/vXxv/7PPxj31//vf/6P//yvv/7n//xf//nf/9c//Ae7+viP//BP//rfHv8Mxv5///gP//c//8s//cN/MMb/f//4+Wrrl+1qG15Xp/XgYrfk9ffFzoT09cVmzav9ffXj3yHsl9ucjkZibNhGYvy6X+3M4au74LYX92b5cPX/9Y//YDxoztCsoDlDE0BzhiYeovHJvNC4Ahr/+H//vtqb9fUWMf31Dunyd8hH72Cc9VsRjHNpKbzH43qzX76Gt6vNwdU55008Zll+veBrSEcl8+tbzdL6txnYRf0MzPEM0rK/iXuX9q8Z/LrNHt62rGvexxbeVPur9p/Hthi7/yUvjz/r/fJff6efLk92F1Oyqyn8tcW81yDmbAtXu/0v2Zu3v2NziDSanWh0S+FqE+P+dxzfx3F89WLtC+D64epf2B3YW2D3YG+BfT3GHuzyusvbr7E/FultRGtO6etPS5PW/WMvL/H1qReeAwoCAwpL2kr10Iz9w4/v2NeIHv/jv/z7P//Lv/zzf/9PH6zR8pc/Ol5sbF625c8tH5aa8FeXcLzWFO9yVXf5qrvWqrtC1V2x6q5UdVeuucstVXdVacNVacNVacNVacNVacNVacNVacNVacNVacNXacNXacNXacNXacNXacNXacNXacNXacNXacNXaWOt0sZapY21ShtrlTbWKm2sVdpYq7SxVmljrdLGWqWNUKWNUKWNUKWNUKWNUKWNUKWNUKWNUKWNUKWNUKWNWKWNWKWNWKWNWKWNWKWNWKWNWKWNWKWNWKWNWKWNVKWNVKWNVKWNdKgNt+wm65FJvxlRk593+aq71qq7QtVdsequVHXXoTacWbYExVmbP9x1lOaH7T3Mh6cK1h0F22kPFdxbTcOzpnkRGE9a9gw5mVQYzxridvUa0iuWj8tzQKa3AdneBuR6G5DvbUBrbwMKvQ0o9jag1NuAcl8Dsktnn9SPhwS3Dyj6beFb49tTiXj4EGM128Jn12i+vjit2zBSfFsk18PH9I/wak+V3x53+KNnIza9WqoPl/5F0ELwDwk6CP4hQQ/BPyS4QvAPCQYI/iHBCME/JJgg+IcEMwT/jKBZIPiHBPEkf0oQT/KnBPEkf0rQQ/APCeJJ/pQgnuRPCeJJ/pQgnuRPCeJJ/pCgxZP8KUE8yZ8SxJP8KUE8yZ8S9BD8Q4J4kj8liCf5U4J4kj8liCf5U4ItPIl5EUxfQzFp/warydYVXtr4vP+weI32/aV/zdUtE83VTDRXO9Fc3URz9RPNdZ1ormGiucaJ5pommutEfZOfqG/yE/VNfqK+yU/UN/mJ+iY/Ud/kJ+qb/ER9k5+ob/IT9U3rRH3TOlHftE7UN60T9U3rRH3TOlHftE7UN60T9U3rRH3TOlHfFCbqm8JEfVOYqG8KE/VNYaK+KUzUN4WJ+qYwUd8UJuqbwkR9U5yob4oT9U1xor4pTtQ3xYn6pjhR3xQn6pviRH1TnKhvihP1TWmivilN1DelifqmNFHflCbqm9JEfVOaqG9KE/VNaaK+KY3UN9kctrm65e2czjMy0e9k3o44tsvJ4Ym/Lw727eeO+a+TKWweqSVriHGkbq8hxpEayYYYR+pRG2L0YJTAOFJn3RDjSE17Q4wj+YGGGEeyGg0x4mIEMLoFFyOCERcjghEXI4JxJBfzmE3cMebSQIyJdn9xk5f3Vw9XY/dgb4F9JJekCPtIrkoR9pFcmCLsI7k2RdhHcnl6sJuRXKEi7CO5SEXYR3KdirDjUptg92BvgR2X2gQ7LrUJ9oldql3WbSTGPmZcwG4fZfp9uTUpv2E/3Ck/LvvV0b6+2xee2Cd2qS2xT+xSG2K3E7vUltgndqktsU/sUltin9iltsTuwd4C+8QutSX2iV1qS+y41CbYcalNsONSW2Af6kg/RdhndqkupR2796Xg14Z9LDaE9Q17PBqLsduLPx5qvF+9Hl3t4j5yl92Hq/8q08yuVlGZZnbBisrkKZOGMs3sshWVaWZXrqhMM7t4RWWa2fUrKtPMKYGeMg114O3AZSKFUFEmUggVZSKFUFEmT5k0lIkUQkWZSCFUlIkUQkWZSCFUlIkUQkOZhjo+fuAykUKoKBMphIoykUKoKJOnTBrKRAqhokykECrKRAqhokykECrKRAqhoUyBFEJFmUghVJSJFEJFmUghVJTJUyYNZSKFUFEmUggVZSKFUFEmUggVZSKF0FCmSAqhokykECrKRAqhokykECrK5CmThjKRQqgoEymEijKRQqgoEymEijKRQmgoUyKFUFEmUggVZSKFUFEmUggVZfKUSUOZSCFUlIkUQkWZSCFUlIkUQkWZSCE0lCmTQqgoEymEijKRQqgoEymEijJ5yqShTKQQKspECqGiTKQQKspECqGiTKQQCsrkF1IIFWUihVBRJlIIFWUihVBRJk+ZNJSJFEJFmUghVJSJFEJFmUghVJSJFEJDmQwphIoykUKoKBMphIoykUKoKJOnTBrKRAqhokykECrKRAqhokykECrKRAqhoUyWFEJFmUghVJSJFEJFmUghVJTJUyYNZSKFUFEmUggVZSKFUFEmUggVZSKF0FAmRwqhokykECrKRAqhokykECrK5CnTNWWyft0RplKZfN7LtC5L/lwmUggVZSKFUFEmUggVZSKFUFEmUggNZfKkECrKRAqhokykECrKRAqhokyeMmkoEymEijKRQqgoEymEijKRQqgoEymEhjKtpBAqykQKoaJMpBAqykQKoaJMnjJpKBMphIoykUKoKBMphIoykUKoKBMphIYyBVIIFWUihVBRJlIIFWUihVBRJk+ZNJSJFEJFmUghVJSJFEJFmUghVJSJFEJDmSIphIoykUKoKBMphIoykUKoKJOnTBrKRAqhokykECrKRAqhokykECrKRAqhoUyJFEJFmUghVJSJFEJFmUghVJTJUyYNZSKFUFEmUggVZSKFUFEmUggVZSKF0FCmTAqhokykECrKRAqhokykECrK5CmThjKRQqgoEymEijKRQqgoEymEijKRQigo0+P/R5k0lIkUQkWZSCFUlIkUQkWZPGXSUCZSCBVlIoVQUSZSCBVlIoVQUSZSCA1lMqQQKspECqGiTKQQKspECqGiTJ4yaSgTKYSKMpFCqCgTKYSKMpFCqCgTKYSGMllSCBVlIoVQUSZSCBVlIoVQUSZPmTSUiRRCRZlIIVSUiRRCRZlIIVSUiRRCQ5kcKYSKMpFCqCgTKYSKMpFCqCiTp0waykQKoaJMpBAqykQKoaJMpBAqykQKoaFMnhRCRZlIIVSUiRRCRZlIIVSUyVMmDWUihVBRJlIIFWUihVBRJlIIFWUihdBQppUUQkWZSCFUlIkUQkWZSCFUlMlTJg1lIoVQUSZSCBVlIoVQUSZSCBVlIoXQUKZACqGiTDOnEGExe5nih4GHw1fPZofyVqazoqZlK2o0uXS1XfJ2tbXxw9V/lWnmFEJRmWZOIRSVyVMmDWWaOYVQVKaZUwhFZZo5hVBUpplTCEVlmjmF0FOmOHMKoahMpBAqykQKoaJMpBAqyuQpk4YykUJ0USbv3Ha1T6VHKsHb3xeH8CqpS0ezzK+HNcvbMI4vDma/Oth1KVxtogkb78e/syu9et55h2zetJgOLk6PR0u/L0422PeL/9ItsQy61ahbcip0q1G3BHfoVqNuSTLRrULdJqJddKtRt2Td6Fajbgn/0a1G3fI0BN1q1K1Ht+hWoW55XoZuNeqW52XoVqNueV6GbjXqludl6Fajbnlehm4V6jbzvAzdatQtz8vQrUbd8rwM3WrULc/L0K1G3Xp0i24V6pbnZehWo255XoZuNeqW52Xo9vXCdo27blPppU0K+6h//dt/uP4vdfFUC3Vdpy6ePaGuq9QVFp4Qoa7r1MVzHNR1nbp42oK6rlMXz0RQ13Xq8qgLdV2mLp4voK7r1MVTANR1nbrI6lHXdeoiq0dd16mLrB51XaYuQ1aPuq5TF1n9ReqK+3dTHv/8ePVf4ImxG4En4W0E3gO+DXhywUbgicwagSdNagSeoKUReDKINuAt9rwReJxrI/A410bgca6NwHvAtwE/sXN1Lm4ZsnF+tQWU5jGYPeo1Kb5+mHcMfrE7eGvfrv0L+8S+tSX2iV1rS+wTe1a/xH3c3vhYwB6W109/w+vanJ8gJ/agoiDdxJ5SFuTEHlEW5MSeTxbkxB5OFqQHpAzIiT2WLMiJXZMsyIl9kCxInI0QSJyNDEiPsxECibMRAjmzswk+7yBD8UvN1sWNpHX5ldbbxf04dPMz+6CG2D3YW2Cf2WM1xD6zI2uIfWb/1hD7zG6vIfaZvWE77OvMTrIh9pl9Z0PsuNQm2HGpTbB7sLfAjkttgh2X+m3s3uxbNni/fMD+F0qcpxhK3KQYShyiFMqA6xNDiZMTQ4k7E0OJ4xJD6UEphRJnJIYStyOGErcjhhK3I4YStyOFMuJ2xFDidsRQ4nbEUOJ2xFB6UEqhxO2IocTtiKHE7YihxO2IocTtSKFMuB0xlLgdMZS4HTGUuB0xlB6UUihxO2IocTtiKHE7YihxO2IocTtSKDNuRwwlbkcMJW5HDCVuRwylB6UUStyOGErcjhhK3I4YStyOGErcjhDKuOB2xFDidsRQ4nbEUOJ2xFB6UEqhxO2IocTtiKHE7YihxO2IocTtSKE0uB0xlLgdMZS4HTGUuB0xlB6UUihxO2IocTtiKHE7YihxO2IocTtSKC1uRwwlbkcMJW5HDCVuRwylB6UUStyOGErcjhhK3I4YStyOGErcjhRKh9sRQ4nbEUOJ2xFDidsRQ+lBKYUStyOGErcjhhK3I4YStyOGErcjhdLjdsRQ4nbEUOJ2xFDidsRQelBKocTtiKHE7YihxO2IocTtiKHE7UihXIdyO87vKF0MpatD2ki6R9j4dvX6RDOUe5FFM5QbkUUzlLuQReNBc4ZmqO5fFs1Q3bwsmqG6c1k0Q3XbsmiG6p5F0QS64VM0dMOnaOiGT9HQDZ+i8aA5Q0M3fIqGbvgUDd3wKRq64VM0dMNnaMY6i10WDd3wKRq64VM0dMOnaDxoztDQDZ+ioRs+RUM3fIqGbvgUDd3wGZqxzuqWRUM3fIqGbvgUDd3wKRoPmjM0dMOnaOiGT9HQDZ+ioRs+RUM3fIZmrLOcZdHQDZ+ioRs+RUM3fIrGg+YMDd3wKRq64VM0dMOnaOiGT9HQDZ+gSWOd9SuLhm74FA3d8CkauuFTNB40Z2johk/R0A2foqEbPkVDN3yKhm74DM1YZ8HKoqEbPkVDN3yKhm74FI0HzRkauuFTNHTDp2johk/R0A2foqEbPkMz1lmhsmjohk/R0A2foqEbPkXjQXOGhm74FA3d8CkauuFTNHTDp2johs/QjHWWpCwauuFTNHTDp2johk/ReNCcoaEbPkVDN3yKhm74FA3d8CkauuEzNGOdNSiLhm74FA3d8CkauuFTNB40Z2johk/R0A2foqEbPkVDN3yKhm74DA1n0Z2joRs+RUM3fIqGbvgUjQfNGRq64VM0dMOnaOiGT9HQDZ+ioRs+Q8NZdOdo6IZP0dANn6KhGz5F40FzhoZu+BQN3fApGrrhUzR0w6do6IbP0HAW3TkauuFTNHTDp2johk/ReNCcoaEbPkVDN3yKhm74FA3d8CkauuEzNJxFd46GbvgUDd3wKRq64VM0HjRnaOiGT9HQDZ+ioRs+RUM3fIqGbvgMDWfRnaOhGz5FQzd8ioZu+BSNB80ZGrrhUzR0w6do6IZP0dANn6KhGz5BkzmL7hwN3fApGrrhUzR0w6doPGjO0NANn6KhGz5FQzd8ioZu+BQN3fAZGs6iO0dDN3yKhm74FA3d8CkaD5ozNPN2w94t9vfV3q3hA5qDkfi4ITGreY3ELkfjDkv6fXGwb6+c8xP6vH12Q+jzdvANoc/rDRpCn9d1tIM+8WmCDaHP65QaQp/XgzWEPq+7awjdA/1+6DjSBtBxpA2g40gbQMeRNoA+liNN29XO2/XD1b8mO9hJmoXJjuXACpMdy/kUJjuW4yhM1s802bE67MJkx+psC5Mdq6MsTHasTq4w2Zk6qMFOXyxMdqYOarATEguTnamDGuwUw8JkZ+qgBjtpsDDZmTqowU4DLEx2pg5qsBP7CpOdqYMa7FS9wmRn6qAGO/muMNmZOqjBTqcrTHamDmqwE+QKk52pgxrslLfCZGfqoAY7ia0w2Zk6qMFOSytMdqYOarATzQqTnamDGuzUscJkZ+qgBjsZrDDZmTqowU7vKkx2pg5qsBO2CpOdqYMa7BSswmRn6qAGO6mqMNmZOqjBTpMqTHamDmqwE58Kk52pgxrsVKbCZGfqoAY7Oakw2Zk6qLFON/LuNdnibwJN3H63Z5fXK9scD65NO4/kcuHavBPP+eO1fwEfqotTAHysk5g0AB+qm9UAfKiOWgPwobp6DcA9wO8FPpS70QB8KIelAfhQLk8DcJzmzcBxmrcCN8tYx5z5tG+wlLwpEbdp3zLJOf92tT967dXs1VzT8uHqJ8mxPGRLkmOZw5Ykx3J9LUl6SAqRHMuntSQ5lgFrSXIsZ9WS5FiWqSXJsbxQQ5JjHV7XlCQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmxDrRrShKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiORYR7U1JYnHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRHKswxSbksTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIjnWcadNSeJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkRzrQOKmJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESI51ZHhTkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJBMeR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJjMeRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jQ9IseBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJA0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJi8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLhcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkgGPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkxONIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIpnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIZjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcGZJ2weNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRImnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIWjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIOjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMfjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESK54nGkSOJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkQx4HCmSeBwpkngcKZJ4HCmSHpLfIultzL+v9m61hauNj/trr+Y1brsczTIs6ffFwYbXK+f8u0a4p/5rhC/rv0Y4vv5rhJfsv0a41O5rFPG//dcIZ91/jfDs/deINKD/Gnlq1H2NyBn6rxE5Q/81Imfov0YT5wxuH4gJiytQtw+8v6+23n2s0ZPkxGmALMk0sWcXJjmxsxYmObH/FSY5sUsVJukhKURyYscnTHJiXyZMcmL3JEwSjyNFEo8jRDLjcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE48iQdAseR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJg8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLicaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRdHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiQ9HkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QyRWPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkwONIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiOZTHSetOMi/+w9V/zTYO5UOKsx3KKxRnO1Q/X5ztUD13cbZ+qtkO1bsWZztUf1mc7VA9YHG2Q/VpxdlO1UuNdeZ5cbZT9VJjnR1enO1UvdRYZ3AXZztVLzXWWdbF2U7VS411JnRxtlP1UmOdrVyc7VS91FhnFBdnO1UvNdZZv8XZTtVLjXVmbnG2U/VSY509W5ztTL2UH+sM1+JsZ+ql/FhnoRZnO1Mv5Rc/1Wxn6qX8WGdzFmc7Uy/lxzrjsjjbqXqpsc6KLM52ql5qrDMXi7Odqpca6+zC4myn6qXGOgOwONupeqmxztIrznaqXmqsM+mKs52qlxrrbLfibKfqpcY6I60426l6qbHOGivOdqpeaqwzu4qznaqXGuvsq+Jsp+qlxjpDqjjbqXqpsc5iKs52ql5qrDONirOdqpca62yg4myn6qXGOmOnONupeqmxzqopznaqXmqsM1+yWffZhtLVJqbfF9u3HXBsjgfXpp1HcrlwbU7bkHP+eO2T+FD9nAriQ/WUKogP1dfmuA3bG78UrrbR2Q15zO9XmyPmD1YbdGvCh6ufJIfqmZuSHKofb0lyrLNmmpIcykc0JTmUR2lKcij/05Skh6QQybE8U0uSY3mhliTxOFIk8ThSJPE4QiTHOmumKUk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZJjnWPTlCQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmxzpdqShKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiORY5741JYnHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jQ3Id6zzGpiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEiOdU5qU5J4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiTHOr+4KUk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZJjnSvelCQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEEmPx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEcsXjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESIZ8DhSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESEY8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSCY8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiGTG40iRxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJx5EhGRY8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSBo8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiKTF40iRxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEi6fA4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEh6PI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkiseR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJgMeRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRDLicaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRTHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiQzHkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4MybjgcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRNHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiQtHkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QSYfHkSKJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0TSj+RxvNmv9iaHD1c/ZzuSDynPdiSvUJ7tSP18ebZ+qtmO1BeXZztS71qe7Uj9ZXm2I/WA5dmO1KcVZzvUeerl2U7VSw11Lnl5tlP1UkOd712e7VS91FDnZJdnO1UvNdR50+XZTtVLDXVuc3m2U/VSQ51/XJ7tVL3UUOcIl2c7VS811Hm85dlO1UsNda5tebZT9VJDnQ9bnu1UvdRQ56yWZztVLzXUeaXl2U7VSw117md5tlP1UkOdn1me7VS91FDnUJZnO1UvNdR5juXZTtVLDXUuYnm2U/VSQ50vWJ7tVL3UUOf0lWc7VS811Hl35dlO1UsNdW5cebZT9VJDnb9Wnu1UvdRQ55iVZztVLzXUeWDl2c7US6WhztUqz3aoXsobt802muVgtkP1UsXZDtVLFWfrp5rtUL1UcbZD9VLF2Q7VSxVnO1QvVZztUL1UabZDnd9Tnu1UvdRQ5+CUZztVLzXUeTLl2U7VSw11Lkt5tlP1UkOdb1Ke7VS91FDnhJRnO1UvNdR5G+XZTtVLDXVuRXm2U/VSQ53/UJ7tVL3UUOcolGc7VS811HkE5dlO1UsNta9/ebZT9VJD7Y9fnu1UvdRQ+8yXZztVLzXUfu3l2U7VS42173lxtlP1UmPte16c7VS91Fj7nhdnO1UvNda+58XZTtVLjbXveXG2U/VSY+17XpztVL3UWPueF2abGySsIW5XryG599k+R9RAbcuL/xI+j8gfjsi6rRDOxVQYkQt52a5Oy+djqfJJiCT8JuGON4l3vEm6403yDW9y4suF38Tc8Sb2jjdxd7zJHX/x/o6/eH/HX7y/4y/e3/EX7+/4i1/v+Itf7/iLX+/4i1/v+Itf7/iLX+/4i1/v+Itf7/iLX+/4i1/v+IsPd/zFhzv+4sMdf/Hhjr/4cMdffLjjLz7c8Rcf7viLD3f8xYc7/uLjHX/x8Y6/+HjHX3y84y8+3vEXH+/4i493/MXHO/7i4x1/8fGOv/h0x198uuMvPt3xF5/u+ItPd/zFpzv+4tMdf/FJ4i8+xf3qvJiDN0l3vEm+4U3ycsebmDvexN7xJu6ON/F3vMkq/CbGHryJxF982h//uGyXD2/y+eq0P2JJ7vWExeZ4cO3jA+n3tTl/vPY5+Kh58Enz4LPawdtlWTQP3mgevNU8eKd58F7z4FfNg9e7wj4Gr3eFfQxe7wr7GLzmFdb0vcKG7VrzWJEORt/3Elsafd9rbGn0fS+ypdH3vcqWRt/3MlsavcQ6m23cR7/Gwui//o7hY0SxuxGl7kaUexuRXbobkeluRLa7EbnuRuS7G9Ha3Yi6+8y23X1C2vs/Ib/8prpdnOtuRPf/rUX7GpGNn0e0djei0N2IYncjSt2NqMFfvw/7iFb/PqLPF1u/D8R67z8N3y+6h290D9/qHr7TPXyve/ir7uEH3cOPnQ/fptfwPzdkPukefu+r7tfDXztfddd163nsGtzXF4fH4/rfF4dHvvp5rp0v0T+Z65pj/nKuna/n65792jWary9Oy/bCyb+iX/N4j+dUO1/7Jafq55lq5z2F5FQ77z8kp9p5ryI41dD7yvqTqa5b7phi+DDVgxc2bhuzNevrhb09ujhtS55bPlz6RNj7gq0A4Uh9QCOEI/UXjRB6EP4pwpH6oUYIR+qzGiEcqX9rhLDzvEsDws4zNwUII+7kjxHiTv4YIe7kjxHiTv4UYZpVhUu2O8K3r0odIkxpG8SHHwcfvrB5vPf2yo9/x9f1zmzMZ5VtS+Ye5rczn9W2t2Q+q89vyXzWYKAl81mThJbMZ40eGjLPs2YVLZnPGm60ZI4PvZ85PvR+5h7mtzPHh97PHB96P3N86P3M8aH3M8eH3s3cLPjQ+5njQ+9njg+9nzk+9H7mHua3M8eH3s8cH3o/c3zo/czxofczx4feztzgQ+9njg+9nzk+9H7m+ND7mXuY384cH3o/c3zo/czxofczx4fezxwfejtziw+9nzk+9H7m+ND7meND72fuYX47c3zo/czxofczx4fezxwfej9zfOjtzB0+9H7m+ND7meND72eOD72fuYf57czxofczx4fezxwfej9zfOj9zPGhtzPv/QTTIZnjQ+9njg+9nzk+9Hbmqs5QTF9fHMN2bYwfKD5nqkldfzZTP81MWzj61wH1a2HwX730c/xB+fij8vEn5ePPusff5PxIyfGbrsfvF7cdoOyXnAsv7fzeLDif3oYdwu/Z2qlm66aarZ9qtn33DdKz7bvLkJ5t3z2J9Gz77mCkZ9t3vyM829h3dyQ926l6qai3l3qOX2939By/Vz5+vR3Mc/x6e5Ln+PV2Gc/xd943mD1Q9M74wkunxW9hu3vN1eZ4cG1O2wvn/PHaJ5fOO4xWXFLnvUgzLp13Lc24dN7fNOPSed/UjIuHyyGXzvu8Zlw67x+bcem8L23GhX73mAv97iGXTL97zIV+95iL75yL2fJIb+xBHpB77zNK4++9HyiNv/d1uzT+3tfX0vh7Xwe/Hr9del+vSuPvfV0pjb/3vKM0/t5zidL4da+/dtG9/tpF9/prF93rr110r792Ub7+GuXrr1G+/hrl669Rvv422d9fcvzK11+jfP01ytdfo3z9NcrXX6t8/bXK11+rfP21ytffJvsaS45f+fprla+/Vvn6a5Wvv1b5+uuUr79O+frrlK+/Tvn622Q/R8nxK19/nfL11ylff53y9dcpX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/vfL11ytff1fl6++qfP1dla+/q/L1t8meg5LjV77+dr6TYHn8ytffzncSLI9f+frb+U6C5fErX3973xuwOH7l62/v+/cVx698/e19j73i+JWvv73vg1ccv/L1t/e96orjV77+9r6fXHH8ytff3veTK45f+frb+35yxfErX3+730+uNH7l62/3+7OVxq98/e1+v7PS+JWvv93vH1Yav/L1t/v9uErjV77+dr+/VWn8ytff7veLKo1f+fqbla+/Wfn6q3z/K6t8/yurfP8rq3z/K6t8/yurfP8rp3z/K6d8/yunfP8rp3z/K7foXn9d9/tfXbavaNiuNctiP1z8BDPtRtclMNPudF0CM+1W1yUw0+51XQDT/eZlzcDoPcXkOX69p408x++Vj19vV/Mcv97m4zl+vT3Cc/x6l/Ln+PWuuH+Nv/tdxUrj13taw3P8ytff7ncVK41f+frb/a5ipfErX3+731WsNH7l62/3u4oVxt/9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5X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D72fOT70fub40PuZ40PvZ44PvZ35UIeXa2GOD72fOT70fub40PuZe5jfzhwfej9zfOj9zPGh9zPHh97PHB96O/OAD72fOT70fub40PuZ40PvZ+5hfjtzfOj9zPGh9zPHh97PHB96P3N86O3MIz70fub40PuZ40PvZ44PvZ+5h/ntzPGh9zPHh97PHB96P3N86P3M8aG3M0/40PuZ40PvZ44PvZ85PvR+5h7mtzPHh97PHB96P3N86P3M8aH3M8eH3s4840PvZ44PvZ85PvR+5vjQ+5l7mN/OHB96P3N86P3M8aH3M8eH3s8cH3o387zgQ+9njg+9nzk+9H7m+ND7mXuY384cH3o/c3zo/czxofczx4fezxwfejtzgw+9nzk+9H7m+ND7meND72fuYX47c3zo/czxofczx4fezxwfej9zfOjtzC0+9H7m+ND7meND72eOD72fuYf57czxofczx4fezxwfej9zfOj9zPGhtzN3+ND7meND72eOD72fOT70fuYe5rczx4fezxwfej9zfOj9zPGh9zPHh97O3OND72eOD72fOT70fub40PuZe5jfzhwfej9zfOj9zPGh9zPHh97PHB96O/MVH3o/c3zo/czxofczx4fez9zD/Hbm+ND7meND72eOD72fOT70fub40NuZB3zo/czxofczx4fezxwfej9zD/PbmeND72eOD72fOT70fub40PuZ40NvZx7xofczx4fezxwfej9zfOj9zD3Mb2eOD72fOT70fub40PuZ40PvZ44PvZ15wofezxwfej9zfOj9zPGh9zP3ML+dOT70fub40PuZ40PvZ44PvZ85PvR25hkfej9zfOj9zPGh9zPHh97P3MP8dub40PuZ40PvZ44PvZ85PvR+5vjQm5m7ZcGH3s8cH3o/c3zo/czxofcz9zC/nTk+9H7m+ND7meND72eOD72fOT70duYGH3o/c3zo/czxofczx4fez9zD/Hbm+ND7meND72eOD72fOT70fub40NuZW3zo/czxofczx4fezxwfej9zD/PbmeND72eOD72fOT70fub40PuZ40NvZ+7wofczx4fezxwfej9zfOj9zD3Mb2eOD72fOT70fub40PuZ40PvZ44PvZ25x4fezxwfej9zfOj9zPGh9zP3ML+dOT70fub40PuZ40PvZ44PvZ85PvR25is+9H7m+ND7meND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698iXv8W6fq3uP6vO17/1x2v/+uO1/91x+v/uuP1f93x+r/uKPF38eWv+1KSUNSXX4RKJ9+WWM3+FbHV+Q9v8bzN1d3m625b6247+fzdv9D2uG0t4DPZpp12/uvh48eO/eRpvfCbpDveJN/wJiePzIXfxF3+p5klPsO+/O1ayuv1bxGuf4t4/Vuk698iX/0WeVmufwuJ9eTLH2blxV7/Fu76t/BXL7x5Wa9/i3D9W8Tr3yJd/xb58rcwy/VvYa5/C3v9WxyKdl231HRNb5t/5/D7plhzU6q56VgqS9xn9evf+W8dST55zLXEvLewy+NB8afbTN1ttu42V3fb8Yfl8nig9LrtbRP27ba17rZQd1usus2d1C2/tqNfcjCfbjshmdO2Lb0xy/KJpPN1t611t8W6uaW6207+cHJ2b4Nc/36bX+puM3W32brbXN1tvu62te624z+cx6X5dZt9V8k//lxTx/tpSb9JuuNN8p+/ydfPIvPxE0LZtzDXv4X96Vs8b3N1t/m62+o+Ik+ezxVvi3W3pbrbctVtYam7zdTdZutuq1tIQ91CevKoI677B2uM7z9TPWpvbVz2bxhFaz+9Rb78LU4edYi+hbn+Lez1b+Gufwt//Vus179FuP4t4vVvcf1fd7z+rztd/9edrv/rTtf/dafr/7rT9X/d6fq/7nT9X3e6/q87/fiv+3lbrrotL3W3mbrbbN1tru42X3fbWndbqLst1t1Wp5Jco5J1WZa620zdbbbuNld3m6+7ba27LdTdFutuS3W31anE1KnE1KnE1KnE1KnE1KnE1KnE1KnE1KnE1KnE1KnE1qnE1qnE1qnE1qnE1qnE1qnE1qnE1qnE1qnE1qnE1anE1anE1anE1anE1anE1anE1anE1anE1anE1anE16nE16nE16nE16nE16nE16nE16nE16nE16nE16lkrVPJWqeStU4la51K1jqVrHUqWetUstapZK1TyVqnklCnklCnklCnklCnklCnklCnklCnklCnklCnklCnklinklinklinklinklinklinklinklinklinklinklSnklSnklSnklSnklSnklSnklSnklSnklSnklSnklynklynklynklynklynklynklynklynklynkrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12aupy15NXfZq6rJXU5e9mrrs1dRlr6YuezV12as5yV7z/g1Dk705uO1EJfuWfiZn++G2o618hQ4KeQwn9jWc1NdwclfDOcu2Ww3H9DUc29dwXF/D8X0NZ+1rOH19Kqe+PpVTX5/Kqa9P5dzXp3Lu61M59/WpnPv6VM53fyp/ecbVYzxrZ+MJnY0ndjae1Nl4clfjscdPcO2jdf19m7VmLYzn4dCXffgh/n33gsebmDvexN7xJk7kTVx4vUlwb29y8Iu85LaNgdxiXOG1w7Lse64t7m3TtWWbgO98AutegLA6dzCBVfsEgvYJRO0TSNonkJVPwCzaJ2C0T8Bqn0DvK3FxAtpXYqN9JTbaV2KjfSU22ldio30lttpXYqt9JbbaV2KrfSW22ldiq30lttpXYqt9JbbaV2KrfSV22ldip30ldtpXYqd9JXbaV2KnfSV22ldip30ldtpXYqd9JfbaV2KvfSX22ldir30l9tpXYq99JfbaV2KvfSX22ldir30lXrWvxKv2lXjVvhKv2lfiVftKvGpfiVftK/GqfSVeta/Eq/aVOGhfiYP2lThoX4mD9pU4aF+Jg/aVOGhfiYP2lThoX4mD9pU4al+Jo/aVOGpfiaP2lThqX4mj9pU4al+Jo/aVOGpfiaP2lThpX4mT9pU4aV+Jk/aVOGlfiZP2lThpX4mT9pU4aV+Jk/aVOGtfibP2lThrX4mz9pU4a1+Js/aVOGtfibP2lThrX4mz8pXYLcpXYrcoX4ndonwldt3vsVWcgPKV2GnfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nfY8tp32PLad9jy2nf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",
      "brillig_names": [
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ACdQON+Z4Zp+oKWSujQuWmX9V9GGPA1hJEgp3E0anncUVyLkJ2MZ6GE0E9CuaRHq2rzzLERoudmN6XVUZ8EhSMxLdE1RUNjm9li0QhDwbMJ5rNWa1mLhwJgzXm6SjKnHfEV+BKFABfxZRPl+SkdSGzXcAALbqn64Jp4uvCGf9xjQpjgUkTMn971C3LhGN+vXd4SLztXOtKS3CDYrpZQWvHSz0n408pYwj3kF38Pc9Y426aYRC4i2cYsaiAEgl3h8PH3MSxZl/ep/WiDUYC/3HIBKD8I+MEIX5DiuHzcOs4F4ekb7icCvKAL+Gz3OoyJve2f5zYewl8UBsIyxxuekDVx6xn60VSHkkefpvm30D4amkXYuT06dCMFlJM/rNoDAmFXZIceA1KzTIjJojwzVqJUTM2ZzHi8U7Ash8spvbMpkFoG4e7LYhcpteTWhOttI9QzcXsoL+GhPPrvuRR60jzQ54gfHFQkSPSLaJQIlidWONolmkvgEvB/jVqK4BkSU8IuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsXYqnfDNtRmp7fulvSn6gWkgBHoP3nHKLOp7AU0z+pmyyfUPsGojWoKAawGMyqg4lgBF1Mm2T+y8zb3nkBYs19BRvmZw5SLpmboAG/9FSogR4ycBsLLnATlZfwQI1y18crGm7SBiGLxj7DRMFAr56TvDM0bZSquyWiJRd4Sug+EyHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0E4YWuRKVxKct3D6sKlhhIC6MZiOidcRs8oWZaDnOsVWBvsaEb9olb2naDqox0ekNEUbsxzZ25YQoHwgaEXvnRGLcrMFdZe9BEu9mhKdFVh3Fw3M7E2oKmLSawuXT81gvfOJGNQdSh46+KtppgFZ8Lrlvq7Xg9BBy6oYawEOcyjY9ZazNO4JuXiJrY0YKXLEAd1BgwTyDgitcJvsiL8C47ZU6JfLDPYXL8NZ+z16djBG3ZoCm3/bmKMA/VWH7jPdXahjEV6oCL43BQs/ne1HAKQzsQ0nfBz8d/bQH91unGSPe5Q7S7QENKADHMxchX+Etrcey0L3luyRzHEXAXQ+VdZHDbvsZAabEBv/5I94KLRVxNya0YAGePRnKUObxow4tDRdqvdjgf1Eq89mz2DXCIGFjgijWxUrbcxHTBk5MH2KQHQVSmdlK8LI5O1Oqa+UTf+4EOzCuIuAKWeGnDiUkpb/xdZKOOc8sxAqG01S3PAUg+LYcqOlveuKHsQcOujvhm/FB/8Hp71PCuxUNgozPEjD1GzMSxR4Y5xdpsAymUXlcX51BY1IUF1+Q4Bf9Y24oMQ5vG2iiQhSwKCJxOVa3gXmw7vgGOOwWCh6CGemx/gPMoPf6VRCZYIGNi2Mip8mhKM29wO1Ur6jnuT8EDKfBCBAyn8JSTuYQzf3c9dKQMkBuMh42BGLRrevlFDvHGsAWGZw1APInzwq0v8w87BJnDThnXYwdxOzRtxVerqdA/SIxO841laRXPjr9KZgsfy5UWhtwkZBNFVa451ehZjClIu5pnpypdjum21uZ3Xu41TyOOwV+oL1C6hL1yN2zOCsDriuiLCYfmpWge5EcxQRTCB5HpvxjnqQl5pKHYoAjOArcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJk1f5X0SRaj5IJYrF0/zBh2dVL8Vx1jS5lq5r9uoXSoQQeLorWboCfTqacp+f5SbYRCKZye9DfC3RZQsbgvxXgDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "private_get_symbol",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18192277837884173995": {
            "error_kind": "string",
            "string": "Function private_get_symbol can only be called statically"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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9HLmDh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmfd+gumQzPGh1zPHh17PHB96OXNVZyim7y+OYbs2xk8U7zPVVF1/NlM/zUxbOPrHAfVrYfDfvfR9/EH5+KPy8Sfl48+6x9/k/EjJ8Zuux+8Xtx2g7JecCy/t/N4sOJ+ehh3Cx2ztVLN1U83WTzXbvvsG6dn23WVIz7bvnkR6tn13MNKz7bvfEZ5t7Ls7kp7tVL1U1NtL3cevtzu6j98rH7/eDuY+fr09yX38eruM+/g77xvMHih6Z3zhpdPit7DdPeZqczy4NqfthXP+fO2dS+cdRisuqfNepBmXzruWZlw672+acem8b2rGxcPlkEvnfV4zLp33j824dN6XNuNCv3vMhX73kEum3z3mQr97zMV3zsVseaQ39iAPyL33GaXx994PlMbf+7pdGn/v62tp/L2vg9+P3y69r1el8fe+rpTG33veURp/77lEafy611+76F5/7aJ7/bWL7vXXLrrXX7soX3+N8vXXKF9/jfL11yhff5vs7y85fuXrr1G+/hrl669Rvv4a5euvVb7+WuXrr1W+/lrl62+TfY0lx698/bXK11+rfP21ytdfq3z9dcrXX6d8/XXK11+nfP1tsp+j5PiVr79O+frrlK+/Tvn665Svv175+uuVr79e+frrla+/Xvn665Wvv175+uuVr79e+frrla+/q/L1d1W+/q7K199V+frbZM9ByfErX38730mwPH7l62/nOwmWx698/e18J8Hy+JWvv73vDVgcv/L1t/f9+4rjV77+9r7HXnH8ytff3vfBK45f+frb+151xfErX39730+uOH7l62/v+8kVx698/e19P7ni+JWvv93vJ1cav/L1t/v92UrjV77+dr/fWWn8ytff7vcPK41f+frb/X5cpfErX3+739+qNH7l62/3+0WVxq98/c3K19+sfP1Vvv+VVb7/lVW+/5VVvv+VVb7/lVW+/5VTvv+VU77/lVO+/5VTvv+VW3Svv677/a9O21c0bNeaZbGfLr6DmXaj6xKYaXe6LoGZdqvrEphp97ougOl+87JmYPSeYnIfv97TRu7j98rHr7eruY9fb/NxH7/eHuE+fr1L+X38elfc3+Pvflex0vj1ntZwH7/y9bf7XcVK41e+/na/q1hp/MrX3+53FSuNX/n62/2uYoXxd7+rWGn8ytff7ncVK41f+frb/a5ipfErX3+731WsNH7l62/3u4qVxq98/e1+V7HS+JWvv93vKlYav/L1t/tdxUrjV77+dr+rWGn8ytff7ncVK41f+frb/a5ipfErX3+731WsNH7l62/3u4qVxq98/e1+V7HS+JWvv93vKlYav/L1t/tdxUrjV77+dr+rWGn8ytff7ncVK41f+frb/a5ipfErX3+731WsNH7l62/3u4qVxq98/e1+V7HS+JWvv93vKlYav/L1t/tdxUrjV77+dr+rWGn8ytff7ncVK41f+frb/a5ipfErX3+731WsNH7l62/3u4qVxq98/e1+V7HS+JWvv93vKlYav/L1t/tdxUrjV77+dr+rWGn8ytff7ncVK41f+frb/a5ipfHrXn9997uKlcave/313e8qVhq/7vXXL7rXX694V7H7+HWvv17xHl338etef73iHa9+j1/xxlT38Stff5Xvf+WV73/lle9/5Xvf/yq4vI0/La7w0m9tLJe2Geb8+do7l87X9WZcOu8XmnHpvA85j8v3GzT63jcYawam953L2oHpvCVrB6bzXq8dmM6byHZgfN9g0v7SPvkSmBjcx8Uxhv1abz+m2nkjKznVzntTyal23m5+M9X7+DtvC4vj77x7K42/8+3pVuPX7WITDux559vTlcffd8tSHn/fnUV5/F75+Pte1cvj73upLo+/7/W3PP6+19/y+Ptef5/Hb439Ov7Ot6crj1/P+ns8fj3r7/H49ay/x+PXs/4ej7/z9TeauF+c8sH4O19/i+PvfP0tjr/z9bc4/s7X39L4O9+erjz+ztff4vg7X3+L4+98/S2Ov/P1tzh+5etv59vTlcevfP3tfHu6NblluziHVHhpn/fJPn+VKYeDa21ctuOMbbSPzjZ8cOl8XW/FpfPt9Npx6bwPEeJyn2vnPYvoXDvvb0Tn6ieaa+d9k+hcO++xROfaeT/21lxvkdt2sU8Hcx2pdyvNdaR+rDDXzrdMlJ3rSH1Taa4j9U2luY7UN5Xm6iea60h9U2muI/VN67r3Temgb+p8m0nZuQ7VNxXmOlTf9P1cO9/qUnauQ/VNhbkO1TcV5jpU31SYq59orkP1TYW5TtQ3db496HdzvY9fby90H7/e/ub3+DvfHrQ8fr19yH38enuL+/j77hfCsmwDCS6Yg/F75ePv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meNDr2eOD72eOT70eub40MuZG3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ27xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5w4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5r0fcDskc3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZD3V4uRbm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMMz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aFXM88LPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczN/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztziQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzhw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzD0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzNf8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYRH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZJ3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZi5WxZ86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2du8KHXM8eHXs8cH3o9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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_private_nfts",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "page_index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              },
              {
                "kind": "boolean"
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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oyF3pB3b29FsR986c6m1Y7Jue/F0K2GnHckdaceO2pHckXZ8XztG92jHVHbakdyRduyoHT3tSDv2047kjrRjR+1I7kg7vq0d3bKpk26NstOO5I60Y0ftyLfBaceO2pFvg9OO72tH/9SOIXxtR8tdGdqxo3bkrgzt2FE7cleGduyoHbkrQzt21I6edqQd+2lH7srQjh21I3dlaMf3taN7bse4047claEdO2pH7srQjh21I3dlaMf3teNW469/73yjx3FXhnbsqB25K0M7dtSO3JWhHTtqR+7K0I4dtaOnHWnHftqRuzK0Y0ftyF0Z2vF97Zie2rEsO+3IXRnasaN25K4M7dhRO3JXhnZ8Wzt6sz3II/knebZ29NyVoR07akfuytCOHbUjd2Vox47akbsytGNH7ehpR9qxn3bkrgzt2FE7cleGdnxfOy7P7eh32pG7MrRjR+3IXRnasaN25K4M7fi2drT5sfutd6F2vHdmO97vbsAXuItD+/bbvi482jeY6vE5bBfvc8o77c5dItq933YP/tHucScZCNxVon3H+LTebV/uQtG+A7evp31p33Hbl7tctO/A7ctdMdq33/ZN8dG+xV6QVHDXjXbvt93L49P6dotkp325S0f7DvFpvd++3NWjfcdt38hdPdp34PblLh3tO3D7cpeO9u22fb1Jj/Z17s8nFZG7erR7v+3unj6t/c6TSaKnfWnfIT6td9uXu3q078Dty1092nfg9uUuHe07cPtyl4727aJ97+3IXTfasZ92TNxFox07akfuitGO72vH8GhHm3e2I07c5aIdO2pH7kLRjh21o6cdacd+2pG7RLRjR+3IXR/asaN25C4O7dhRO3JXhnbsqB25K0M79tOOmdyRdnxXO8YSt66KJZWddiR3pB3f9um4PIS//TvutKOnHWnHftqR3JF27KgdyR1px/fNjmV5asedzdczuSPt2FE7kjvSjh21I7kj7dhPOxa+DU47dtSOfBucduyoHbkrQzt21I7claEdO2pHTzvSjv20I7kj7djcjuHWHKs2JvvK0cnH9bVv/9z5AkUhdaQZu2lGMkeasZNmzAuJI834rmaMZtU9RZt2mpG8kWbsphlJG2nGbpqRrJFm7KYZPc1IM/bSjOSMNOO7mjHktUtSKF9D72xw0zTju5rxdgN6bcbszE4z4qZpxm6aETdNM3bTjLhp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",
      "brillig_names": [
        "get_private_nfts"
      ]
    },
    {
      "name": "set_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "minter",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "approve",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEgdAIBJgEkBLgiASAABLgiASQACJQAAAFIlAAAAdigCAAEEgEonAgIEADsNAAEAAigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYBAAEoAIBHBAABJiUAAAJQHgIAAwAeAgAEADM4AAMABAAFJAIABQAAAJolAAACeScCAwAFLwwAAwAEHgIAAwEKOAQDBSQCAAUAAAC8JQAAAosnAgMAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGACgGAgYtDgMGACgGAgYtDgMGKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFABABBwEnAwYEAQAoBgIHLQwHCC0OAwgAKAgCCC0OAwgAKAgCCC0OAwgAKAgCCC0OBQgtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgEUABi0IAQcAAAECAS4KgEQABycCCAAGJwIJBAotCAAKLQwFCy0MBAwtDAYNLQwHDi0MCA8AEAAJACUAAAKdLQQAACcCCAQJLQgACS0MBQotDAQLLQwGDC0MBw0tDAEOABAACAAlAAACnS0EAAAtDQcBCygAAYBEAAgkAgAIAAAB8ycCCQQAPAkBCScCAQQILQgACC0MBQktDAQKLQwGCy0MBwwAEAABACUAAAPGLQQAAC0NBAEBKAABgEcABS0NBQQKOAQDAQsoAAGARAADJAIAAwAAAkQlAAAE2RwMAgEAMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAJ4KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV51QZevnN00jwBAQImJQAAAlAtDQMGLQ0EBwsoAAeARAAIJAIACAAAAsMnAgkEADwJAQkLKAAGgEMAByQCAAcAAANSIwAAAtgtDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAAC/SUAAATrLgQABoADKACABAQABCUAAAT9LgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAAz0lAAAFiy0OCgEtDgcCLQ4FAy0OCQQjAAADxScCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPGLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAE/S4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA8UmJQAAAlAuCIBFAAUjAAAD1g0oAAWAQwAGJAIABgAABEYjAAAD6y0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAARkIwAABNAtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAT9LgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABNAtDAYFIwAAA9YqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUYIwAABSMuAIADgAUjAAAFii4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAV2LgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVFKAGABQQAAQMAgAYAAoAGIwAABYomKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3daiM7DMffJde5sGzZlvZVDoelH+kSKG1J2wOH0ndfJ5v5aEaJt/JQKKObJbPoX2l+4w9Zk9hvq9vN9euvn9uHu8fn1Y9/3lb3jzdXL9vHh3L19r5eXe+29/fbXz/H/71y+3/Ah4Pg+enqYX/9/HK1e1n9gOAxrlebh9v950Cu/JG77f2mXAG+r6f2zvvO3KEfWYNgjezy0RoZUm+dWTAmRDoaEyYcG/+7LvHTPPEzd+YA/IXxh5n4R+r5U40/xNzFDymEy/FzDHg05qI7jR9h7vjBf4z/4IW/wktEyUvwqWsbwdMAIDrJBQwRQR4FtH8oE+tMwR2tM0W4/CBy8l0cOSW6bFzi4NAHEn06fW6Rl3OvKcr32qtCALh8r9FRF335WAmo3F4HhmJwp+FkV0MfAMfhHERRIaKgEYkjaggRelHiSstwaXggMAwwkIM4HKWjsXdDpywOpYbBfZvLzIO1ZxKsQ+xmJRwN0x4kWw/c3aD3jivWsW+f4we8t90j5GAIWxFmQ9iGsNyGIWxFaK2wFSFYK2xGaK2wFaEHQ9iKMBrCRoTBGcJWhGgIWxGyIWxEiLbA+wuE3FUZE8QJwmQduRmhVWpaEWbryM0IrRW2IiRrhc0IrRW2ImSr1DQjTIawDWFwVqlpRmiVmlaEYJWaZoRoCFsRWqWmFaG31PoU4QGLvVKSsARLgUUsltZKWNCSBBGLpZ8iFpvMJSzRJmgRi9WzJCz21kjGYq1FwmJvd2QsC52JPHXv9H0YxdFhoYWOLTUs1lokLEv9jn8Ny0ILC5ex4FLfatSwLHSpWMNiQ66EBWzIFbEsNPmvYFlq5b+GxSZoCctSK/81LAut/FewLLXyX8OChkXCYhO0hCXakCtisSFXwpJsBS1isdYiYckLnaAz9GHkk9+tfc76ABENYhUipNTtDAQp0wQiLXSWmxUiW3eeAeJCi63zQlxoafZzEHPu7zDzZHaOziaWGSAudFU5K8Sl7k40L8SFrkFmhegtxZkBok0sM0C0FKcd4lL3KZoXoqU47RDRUpy/gMiu3wCe/RRitNl5BogzjIlA/RbuHmMFYozcLeYT+WGna4AsYUxdHHm08N/vZn4Inr9x8Cl/4+Bz/MbBU33goFAJHl1nDOjzBxdTawrQdUIKfuAi7lSP1J3tgDz84RDDn9jjV8fuyfexO7wcOznqd9mHUDmFAyC5/oQSSBjG5uVek/yu48O5Jmny6/Ik731VU8mvBMqc0FceASeVxyTXwKsqUqiyCypVllVpIE8TGvncCS79z/rLx6kv+ftaVVXSqORv+1RVqFFF1X0lVYTyuRhQShGdKmKeqDKoVKRRyRujVVWsUTGqVBpfdKZ/xf5gDog0+d0WAahUSaPyqFKxRhVUNELWqFDFMJ7pX0O+GzxNVVGlYo0qBZUqa1RnRoCaSkWDVORJ50tFnlXkWUOe3RnyiL0q5qkqa1SAKhVrVD5qVMGpVKRRoWZeZtTkGxydSqXyJeeiGbuULWM61YCTp6+hCsGRBFFWiOQpryaKGhErRF4DQk54K6Iz+e7llUaRZZXszCxZlSWVLOq8RZ23pPOWdN6yzlvWPTfSeTszXVZlrJLJiXZlyJHXscNBnOynItCMUyBnvhVPXhOe3KdroqQQySvYCghUDKMQNZ7kwjD3dQPOURCxQpQ0nlJtwJZEWdP2smISAkoKEYNGpJjCzxxDVxNpPGmSBa9JFrwmWfCfThbey+V/V7vt1fX95niS893rw83oYOeX/582J2c8P+0ebza3r7vN/rTn4aDnfbf0SGuf+DCelsvShdaF9OHJ7i89lstUvBbPvwE=",
      "brillig_names": [
        "set_minter"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3bjus8lqX7LnmdFyI5xUO/SmOjUaduJJCoalRVb2CjUe++vZZDsuMP2YzQT3tOkt9NYmWmZJPfmCHNMShT//cv//wv//h//tf/+Nu//s9/+4+//Lf//n//8vd/+6d/+M+//du/Xv7b//2vv/7lH//9b3//+9/+1/+4/5//svz6D+fS7xP+43//w7/++u//8Z//8O//+Zf/5hZx4a9/+Zd//eff/07+8iH/829//5fLf3PyX3/9cnzK8ePovMh+bHYHh65+/Th0XZfbx67xv/6fv16Gk1sMJ4e0DWctz4cjoXwcKjF/HU5pMpws23BKfj6cuGx0oo9fhuOXFsMp3n8cXcJaGU5ePg5Ny1exvDscTsjLht+FEmNlOL4s7uPwsHw6+uNb/Fu+JbzlW+Qt37K+5VviW74lveVb8lu+pbzjW8Lylm95y99+eMvffnjL3354y99+eMvffnjL3354y99+eMvffnjL37685W9f3vK3L2/525e3/O3LW/725S1/+/KWv315y9++vOVvX97yt7++5W9/fcvf/vqWv/31LX/761v+9te3/O2vb/nbX9/yt7++5W9/fcvffnzL3358y99+fMvffnzL3358y99+fMvffnzL3358y99+fMvffnzL3356y99+esvffnrL3356y99+esvffnrL3356y99+esvffnrL3356y99+fsvffn7L335+y99+bvK3H5Y17t9S0t3R5fot8pZvWd/yLfEt35Le8i35Ld/S5G8/XNbytm/xvnz6lq9HX6zZNqZLn363BOjD0apn3hYM13A3jnj9GymLwvjzvvJ5ud7kyvjXmPZV5JjDfnRarhNwvU/A9z6B0PsEpPcJrL1PIPY+gdT7BHLvEyh9T8Avnd+J/WL/Tpxka5zWtMr9BA7cxbo/aeXX5J4fnNdtGDndzXA9tC1uf2TNX9ZY9qPFHx2cbxbn06G/idtvHUYjbr/XGY24QPzNxO13k6MRt9/+jkbcfr8+GnH7BmM04vYd0WDEnX0LNxpxPOe7ieM5300cz/lu4gLxNxPHc76bOJ7z3cTxnO8mjud8N3E855uJezznu4njOd9NHM/5buJ4zncTF4i/mTie893E8ZzvJo7nfDdxPOe7iffgOd2NeH4O0eX9Fyeu+FD5aCdl29TOrXfbwX08kxl6cIdabHrwcVpsenBcWmx68EZabAQ2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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACYHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADBJwICAAUvDAACAAMeAgAEAQo4AwQFJAIABQAAAJElAAAA0zAMAAEAAiYoAIAEBHgADQAAAIAEgAMkAIADAAAAwCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFedUGXr5zdNI8AQECJg==",
      "debug_symbols": "5ZXBjoJADIbfhTOHdtqZ6eyrbIxBRUNC0CBusjG++84YZkQlkBjjZS+Ekr/06z+FnrNNuTrtllWz3R+zr+9zVu/XRVftGx+dL3m2aqu6rnbL4eMMwsXqq/54KJoQHrui7bIvJMU6z8pmE+5JwL9jW9Wlj5Av+bMelIpyYDVQ44iaHdhezQ5NUls3IhZm6cXChofiRZ4JvAffuShHdB/Ef5P7WpL7Muc+ahvx0RBN4ztN3Iudz3vAd/RufFT3+KGIfKAIgvlEFcSxKgRpoAiUTlkaxkrgjQjtACgc/JPaCkGvtqJx+rCtUfEzsMbItNhzOEogWpmH2UA0/6dXpcZ7JUy9spvuVYNEen87A+Tbi8aIJnjCsbPWazXECUmkXkhieCVJjydJPBHyv7GZyWCI1iIrOzMZoiSuJz8jPOMtSPIWycxNhoG0+dDw3e90cfHRT9FWxaou+028PTXrwWLufg/lw44+tPt1uTm1ZdjWt0WNwWklOdH14/IB2Zycr+Hr/AE=",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "mint"
      ]
    },
    {
      "name": "is_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "minter",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAASyUAAABvLgQAAYBJKAIAAgSASScCAwQBOw0AAgADKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAk0eAgACAB4CAAMAMzgAAgADAAQkAgAEAAAAkyUAAAJ2HgIAAgknAgMAAQo4AgMEJAIABAAAAK8lAAACiCcCAgAALQgBAycCBAQEABABBAEnAwMEAQAoAwIELQwEBS0OAgUAKAUCBS0OAgUAKAUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUAEAEGAScDBQQBACgFAgYtDAYHLQ4CBwAoBwIHLQ4CBwAoBwIHLQ4CBwAoBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgqARQAFLQgBBgAAAQIBLgqARAAGJwIHAAYnAggECS0IAAktDAQKLQwDCy0MBQwtDAYNLQwHDgAQAAgAJQAAApotBAAAJwIHBAgtCAAILQwECS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAAKaLQQAAC0NBgELKAABgEQAByQCAAcAAAHmJwIIBAA8CQEIJwIBBActCAAHLQwECC0MAwktDAUKLQwGCwAQAAEAJQAAA8MtBAAALQ0DAQEoAAGARwAELQ0EAwo4AwIBCygAAYBEAAIkAgACAAACNyUAAATWLwwAAwABHAwBAwEcDAMCABwMAgEBJigAgAQEeAANAAAAgASAAyQAgAMAAAJ1KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV0AjB8R9WsczwBAQImJQAAAk0tDQMGLQ0EBwsoAAeARAAIJAIACAAAAsAnAgkEADwJAQkLKAAGgEMAByQCAAcAAANPIwAAAtUtDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAAC+iUAAAToLgQABoADKACABAQABCUAAAT6LgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAAzolAAAFiC0OCgEtDgcCLQ4FAy0OCQQjAAADwicCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPDLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAE+i4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA8ImJQAAAk0uCIBFAAUjAAAD0w0oAAWAQwAGJAIABgAABEMjAAAD6C0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAARhIwAABM0tDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAT6LgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABM0tDAYFIwAAA9MqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUVIwAABSAuAIADgAUjAAAFhy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVzLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVCKAGABQQAAQMAgAYAAoAGIwAABYcmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3Rbts6DIbfJde5kCiJlPYqBwdD2qZDgCAt0vYAB0XffU5W20lMjw1lFAjMm6Fe9Zf0F0mk6Fh6Xzys795+/dzsHp9eFj/+eV9sn+5Xr5unXXP1/rFc3O032+3m18/T/164wz/e41Hw8rzaHa5fXlf718UPHyCm5WK9ezj8HLJr/sjjZrturnz8WA7bO4C2uYtw0tozrWNx9Nk6Fo9daypM4xxj/mycI8bTxv8uFx78NP6X0jb3vnyn/xPxT7njnyX+PlHrv8cQ/u5/SSF+Ni6N7tL/EKf238O5/wcrEb7FCrFWIHlsZZBCFqxQSK1TFMgLdMG1jQtAvqSb4AsexfP7PupIp0OlPXJKXeJ0semU7fjC1BNMjv1QMfRDt+/MngLb9VuHwPUdIITEfZCl611USt8aSmZah9TOgPFkSgDPtQVffOsGuCK0TtDOTSm4s7YHhNkZwlqE0RDWIiyGsBJhsV5YjdB6YSVCcNYLqxFmQ1iJ0IMhrEVIhrASIV9bMITXIERDWIkw2ALvCwhLW9FCnwYIkw3kaoRWqalFiDaQqxFaL6xFSNYLqxFaL6xGaJWaWoQ5GMJahFapqUVYrFJTjdAqNZUIg7MFXjVCq9TUIvSWWl8iPGKJhoXDYikwhwUsrWWxWJLAYQmWfrJYLJhzWKIFaBaL1bM4LPbUiMdivYXDYk93eCwzjUSQ22f6zQN8GGChmc4tEhbrLRyWuX7HX8ISDQuHZaZPNQQsc31SIWGxKZfBEp1NuSyWmSb/Apa5Vv4lLBagWSwzrfwLWOZa+ZewzLTyL2AJtoJmsViAZrHYlMthiTblslhsBc1hSdZbWCwzDdDUbe4CdPHe2nWtDxBxpuH8Koge0bV3iJSHEGca5SaFSDac6yHmmRZbp4U409LsdRCJujukMozOxQLLBBBnuqqcFqJF52qIyc10DTItREtx6iF6CywTQLQUpx7iXPcpmhaipTgTQLQU5wsQi+s2Gy8whBgsOtdDjBPMiT5324VDTALElEq7mMcM/T7v3hOHEdtvTdPJwt9n+OM83rDzKd6w8wi37Lw8cZwcQDDifL+jvid3ZoJxJ4fWecpJ2OqesNvmjhDz3xs3fpR+BktwdsjC4V4pfPu9Qn+vKBz6kKid91Lu34kIKfzxPd+u7/l2uSP/0sXZ2SU4eKsf+d2eRBWbCTWxuKv4+jio+GImjYqvzgkq4r/hKqoir8KOhs8DGsQn1z502yk0Pw5t8dmkpApBpSKNKnqVSnVfSeXhyIkeqRtUPkUaqrJGNTJSBBX/couoQo2KfxggqjS28sj4StjlradzVKfKGpUPGtXI2UmSCjWqoKIxcrqQpFIxHDn9J/TrjACD8ZVHTuiRVKhR8a+YiqqoUmWNilQ0SEU+q2xlFfmiIl9U5MsI+Rg7VRrMNmUkLgsq71Uq1KgAVCrSqEJSqTRxucSgUmmieUkqW3wuSrFN2SjipcY7Pnz11Z+SMiOKGlFWiPgTIiQRKkSgAcEnvJKoKFYa3o0ESVGWVbKR7i7KdNaSzlrSWUOdNdRZI93nRjprI+FSlKFKxifawpTDr2P7wzYLDEVeM0+NnBoqWAKNe/yYFkT8ElYSkQJEBI1IY4nfTad0dYNCiRGhQoQaSyhN2JyINH2PFEHI82U3SaQIrCPH0Emicr0INMkCaJIF0CQLoEkW4Opk4aO5/G+136zutuvP05of33b3J4c3v/7/vL44x/l5/3S/fnjbrw8nOveHOR9sQ8xLwHKcT5vLZggtG2jHD+nwW3JLIGisNpZ/Aw==",
      "brillig_names": [
        "is_minter"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          },
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "finalize_transfer_to_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17922298012674089187": {
            "error_kind": "string",
            "string": "Cannot complete a PartialNFTNote with a value of 0"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "finalize_transfer_to_private"
      ]
    },
    {
      "name": "owner_of",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "5V3bbuM4DP2XPOdBIkVRnF9ZLAa9pIMARVv0ssCi6L+PnakvSaSo4Xg8VvRS1AVPeQ4lUbQsy++r283124/v24e7x5fVt3/eV/ePN1ev28eH5ur9Y726ft7e329/fB//eWXaHxZwB3h5unpor19er55fV98sgqP1avNw2/6OwTT/5G57v2murPtYH9sbgM7cOBhZ24i1E8Of1k6s761ZIsbBufBpHJx3Y+N/1w3/MA1/kc7cWpmRP04Ufwp9/EMu/pa442894mn+Qug+jaXBHfJ3dmr+Fvb577zIHF7IRb0AWd/BgDBkvDBSR4qRbSa6YDpjAQiH0SX5AiO3r7vFeafEKf0x63AB4rgmhj2OaRhhZKLN6nEYvEN3toy/nPAMTmQOJeL/vBMwZg4nbg4nMoMTO4cSG2ZwApN0YRv6HNtk5z0nx9ZEYj6tfQA3yg8cy6zedomVR1m4me9a+mjKph+Kpu980fTJfoH+aDJP0B/KEctmz0mEUMCOPgfK1AnsoStQ2ftw2rjhIcNIJ/AHZQUQ/wW1MKj1mZqZuLuboDAU40i/8pSHotkXHXv+UuxxzL6FBaODURwWzJAmAsLvTXti5nAyixL5807Q4BxOeAYnFuZwMocSsHM4maQL/60ZHhGLpu9s2fSlaPqplaE9+o4vozx0Lj5UqFvLATM0FCLF+EgvlUUGa5AQsUbqSg43Wk1tbnojtmClayhobvAz1tSHhdDs2e50ch06CSrRWUl7+kra01fSnmwr0VlJe4ZKxmcIdeiUSuqhxPpBiTqle8DtLR3qJDCV6HSV6Kyk32Il7YmVtKerpD3d5dQJJ3VSJe1JlYxPT3Xo5ErqIfZ16AyXs55wWmeh43PHvdAc2nKXQue5HfdCa5GGuzeFrivtuBe69tdyt4Xm0x33cnOkL3WdZse90Fqj5Y4Fxx0L7u9uyXkGQrd0DDji0XNfcn/PcKcl9/ccd1cw9yXXYhnui34Gn+Ne8Fhd9FpFjvuS56YM91Bw3EPBOXLR6wQZ7ot+bp7jvuT71dPc2ZRbR7IpN0eyKXessi13rLItt45kKDjusOQcyf3RA8AHe53Os26V4pIz6llKrffdawXWj9506JUuOYdNqnTRu/8nVbro/f/TKl3yne15Spn7d3RYjnOvv5yMlFO65IpwWqWXk3szSnnJVc+0Si9nlskoXfSuk2mVVjPLSDVtKtXMMot+y+M8pWL6UxsFjpSGRe85mVRp4s3X8amc/mj/XEjUkDlUfKTY/nV1a91RZR4SM34GlZhTciivQSXOgbG+j4YNR9GQxN4g7DcuNr+GYxSpUKJBpU54zaBYg0KVLqdimHqroD/ryNLoRIYOlXpefhqVutvKoLwGlThiKYdiDSqofCXrnz5HjY+O6lDJXaOnUaJAWZNM/adhFnQwr4Il97dlYE4FS500PMwsCCECCyqYAx3Mq2CJHTxZmNPBdCHxugbwOm+sawDWNUDQNUDiyTw618OIj2GJqToLYw3MJrZdZ2FBBUs8iMvBEkeAZWGaCbuBiQqGqIPpvMULVXZdPcfOH4Pic9twGyAU8RTvjzmQ04DC+SCId+AcSBEIiFfDORApbkMsJGbPLMzpYKKCoc4b6rw5nTen80Y6b17Xbl7pLahgidkzC+PzUw7Eb3KHb0wIxECK4Zk4VvO0J7RWAyINSBSg+O1tJhCgSKOJEyRzoHjI+0UF4eNuhPHiOQfSeKJcwo6CNH3PgwYkChArJlYMRgMiBUhTLKCmWEBNseA0xYI7u1j4aC7/u3reXl3fbz4/UnT39nAz+mbR6/9Pm4PPFz09P95sbt+eN+2HjIZvGLXxBA5rENmV+c2lpzWbXcHUXFjitSVpfDZ+fwI=",
      "brillig_names": [
        "owner_of"
      ]
    },
    {
      "name": "public_get_symbol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString",
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACSHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAAC7HgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAAzS8MAAIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAuioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF0E3qz6yL/WM8AQECJg==",
      "debug_symbols": "vVXbisIwEP2XPPchM5PLxF9ZRKpGKZRWal1YxH/fRJpa3WAXEV9Kp5yTczqTmTmLrV+f9quq2bVHsfg6i7rdlH3VNiE6Xwqx7qq6rvar6Wch48PqK/54KJsYHvuy68UCCJUuhG+28Z1YhjN2Ve1DBOpS/MVLxASXCidoyKCVk3ZAKwdmRFuXAbNSPIBZGTUFLwvB8j32nUtwAPdB+2/KvuYx+zyXfdA22QdD9Ny+06QGsAu8B/uO3m0f8N5+FOEPiIA0n1AByKqgBpNoqIlnVCzpZMqShZkKokxgh8gPFQQw/3Ck7v878hBe5L2oR+pFnsvxFCKkFsYJS8tMBslgyiAZnhSHs+2Fdpwl6G6zBLPNaJlkKiXrmVJag+loaww/B4cEOBrvosa7ObW8hOi77KpyXfthR+xOzWayMvqfg3/YHoeu3fjtqfNxj9xWCMQZjLYgvF6oEBAVpING0PkF",
      "brillig_names": [
        "public_get_symbol"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "NFTNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "token_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "NFT"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_nfts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nft_exists",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_owners",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::NFTTransfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_store_nft_set_partial_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_store_nft_set_partial_note_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::owner_of_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::owner_of_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::prepare_private_balance_increase_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::nft_note::PartialNFTNote"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::prepare_private_balance_increase_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::is_minter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::is_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finalize_transfer_to_private_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finalize_transfer_to_private_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finish_transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finish_transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::finalize_transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::finalize_transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "approve",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_minter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::cancel_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::cancel_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_symbol_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "123": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "124": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "125": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "126": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "133": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "134": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "141": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "144": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "165": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "168": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "169": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "171": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "179": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "182": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "196": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "197": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "199": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "200": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "201": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "202": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "203": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "205": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "207": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "218": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "235": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "237": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "297": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "298": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "299": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "312": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "314": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "315": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "324": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "349": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "353": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "354": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "370": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "371": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "373": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "383": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "385": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/nft_contract/src/main.nr",
      "source": "// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal NFT implementation with `AuthWit` support that allows minting in public-only and transfers in both public\n// and private.\n#[aztec]\npub contract NFT {\n    use crate::types::nft_note::{NFTNote, PartialNFTNote};\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::aztec::{\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, utility, view},\n            storage::storage,\n        },\n        messages::logs::note::encode_and_encrypt_note,\n        note::{constants::MAX_NOTES_PER_PAGE, note_interface::NoteProperties},\n        prelude::{\n            AztecAddress, Map, NoteGetterOptions, NoteViewerOptions, PrivateContext, PrivateSet,\n            PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::traits::Serialize,\n        utils::comparison::Comparator,\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use aztec::protocol_types::traits::ToField;\n    use std::meta::derive;\n\n    // docs:end:imports\n\n    // TODO(#8467): Rename this to Transfer - calling this NFTTransfer to avoid export conflict with the Transfer event\n    // in the Token contract.\n    #[derive(Serialize)]\n    #[event]\n    struct NFTTransfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        token_id: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // The symbol of the NFT\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        // The name of the NFT\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // The admin of the contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Addresses that can mint\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // Contains the NFTs owned by each address in private.\n        private_nfts: Map<AztecAddress, PrivateSet<NFTNote, Context>, Context>,\n        // A map from token ID to a boolean indicating if the NFT exists.\n        nft_exists: Map<Field, PublicMutable<bool, Context>, Context>,\n        // A map from token ID to the public owner of the NFT.\n        public_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.admin.write(new_admin);\n    }\n    // docs:end:set_admin\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.minters.at(minter).write(approve);\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint\n    #[public]\n    fn mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not a minter\");\n        assert(storage.nft_exists.at(token_id).read() == false, \"token already exists\");\n\n        storage.nft_exists.at(token_id).write(true);\n\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:mint\n\n    #[public]\n    #[view]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid owner\");\n\n        public_owners_storage.write(to);\n    }\n    // docs:end:transfer_in_public\n\n    // Transfers token with `token_id` from public balance of message sender to a private balance of `to`.\n    // docs:start:transfer_to_private\n    #[private]\n    fn transfer_to_private(to: AztecAddress, token_id: Field) {\n        let from = context.msg_sender();\n\n        let nft = NFT::at(context.this_address());\n\n        // We prepare the private balance increase.\n        let partial_note = _prepare_private_balance_increase(to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own NFTs.\n        nft._finalize_transfer_to_private_unsafe(from, token_id, partial_note).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_private\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// `finalize_transfer_to_private` with the returned partial note.\n    // docs:start:prepare_private_balance_increase\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress) -> PartialNFTNote {\n        _prepare_private_balance_increase(to, &mut context, storage)\n    }\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> PartialNFTNote {\n        // We create a partial note with unpopulated/zero token id for 'to'\n        let partial_note = NFTNote::partial(\n            to,\n            storage.private_nfts.at(to).storage_slot,\n            context,\n            to,\n            context.msg_sender(),\n        );\n\n        NFT::at(context.this_address())._store_nft_set_partial_note(partial_note).enqueue(context);\n\n        partial_note\n    }\n    // docs:end:prepare_private_balance_increase\n\n    // docs:start:store_payload_in_transient_storage_unsafe\n    #[public]\n    #[internal]\n    fn _store_nft_set_partial_note(partial_note: PartialNFTNote) {\n        // We store the partial note in a slot equal to its commitment. This is safe because the commitment is computed\n        // using a generator different from the one used to compute storage slots, so there can be no collisions.\n        // We could consider storing all pending partial notes in e.g. some array, but ultimately this is pointless: all\n        // we need to verify is that the note is valid.\n        context.storage_write(partial_note.commitment(), true);\n    }\n    // docs:end:store_payload_in_transient_storage_unsafe\n    /// Finalizes a transfer of NFT with `token_id` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `partial_note` must be passed as an argument to this function.\n    // docs:start:finalize_transfer_to_private\n    #[public]\n    fn finalize_transfer_to_private(token_id: Field, partial_note: PartialNFTNote) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n    ) {\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid NFT owner\");\n\n        // Set the public NFT owner to zero\n        public_owners_storage.write(AztecAddress::zero());\n\n        // We verify that the partial note we're completing is valid (i.e. it uses the correct state variable's storage\n        // slot, and it is internally consistent). We *could* clear the storage since each partial note should only be\n        // used once, but since the AVM offers no gas refunds for doing so this would just make the transaction be more\n        // expensive.\n        assert(context.storage_read(partial_note.commitment()), \"Invalid partial note\");\n        partial_note.complete(token_id, context);\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let nfts = storage.private_nfts;\n\n        let notes = nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring\");\n\n        let new_note = NFTNote::new(token_id, to);\n\n        nfts.at(to).insert(new_note).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let notes = storage.private_nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring to public\");\n\n        NFT::at(context.this_address())._finish_transfer_to_public(to, token_id).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:finish_transfer_to_public\n    #[public]\n    #[internal]\n    fn _finish_transfer_to_public(to: AztecAddress, token_id: Field) {\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:finish_transfer_to_public\n\n    // Returns zero address when the token does not have a public owner. Reverts if the token does not exist.\n    #[public]\n    #[view]\n    fn owner_of(token_id: Field) -> AztecAddress {\n        assert(storage.nft_exists.at(token_id).read(), \"token does not exist\");\n        storage.public_owners.at(token_id).read()\n    }\n\n    /// Returns an array of token IDs owned by `owner` in private and a flag indicating whether a page limit was\n    /// reached. Starts getting the notes from page with index `page_index`. Zero values in the array are placeholder\n    /// values for non-existing notes.\n    // docs:start:get_private_nfts\n    #[utility]\n    unconstrained fn get_private_nfts(\n        owner: AztecAddress,\n        page_index: u32,\n    ) -> ([Field; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.private_nfts.at(owner).view_notes(options.set_offset(offset));\n\n        let mut owned_nft_ids = [0; MAX_NOTES_PER_PAGE];\n        for i in 0..options.limit {\n            if i < notes.len() {\n                owned_nft_ids[i] = notes.get_unchecked(i).token_id;\n            }\n        }\n\n        let page_limit_reached = notes.len() == options.limit;\n        (owned_nft_ids, page_limit_reached)\n    }\n    // docs:end:get_private_nfts\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/nft_contract/src/types/nft_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize},\n        utils::arrays::array_concat,\n    },\n};\n\n// NFTNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the token id).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n// docs:start:nft_note\n/// A private note representing a token id associated to an account.\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct NFTNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The ID of the token represented by this note.\n    token_id: Field,\n}\n// docs:end:nft_note\n\nimpl NoteHash for NFTNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because NFTNote has just one variant (where the token id is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            NFTPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note =\n            PartialNFTNote { commitment: private_content.compute_partial_commitment(storage_slot) };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.token_id)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { token_id, owner, randomness }\n    }\n\n    pub fn get_token_id(self) -> Field {\n        self.token_id\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the token id, since the note will be\n    /// later completed in public. This is a powerful technique for scenarios in which the token id cannot be known in\n    /// private (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialNFTNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialNFTNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = NFTPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialNFTNote { commitment }\n    }\n}\n\n/// The private content of a partial NFTNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct NFTPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of NFTNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NFTPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateNFTPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateNFTPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        NFTNote::get_id()\n    }\n}\n\n/// A partial instance of a NFTNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the token id field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the token id to the public), resulting in a NFTNote that can be used like any other one (except\n/// of course that its token id is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialNFTNote {\n    commitment: Field,\n}\n\nimpl PartialNFTNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialNFTNote {\n    /// Completes the partial note, creating a new note that can be used like any other NFTNote.\n    pub fn complete(self, token_id: Field, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(token_id != 0, \"Cannot complete a PartialNFTNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the token id). The contract will later find it by\n        //  searching for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(token_id));\n        context.push_note_hash(self.compute_complete_note_hash(token_id));\n    }\n\n    fn compute_note_completion_log(self, token_id: Field) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, token_id]\n    }\n\n    fn compute_complete_note_hash(self, token_id: Field) -> Field {\n        // Here we finalize the note hash by including the (public) token id into the partial note commitment. Note that\n        // we use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator([self.commitment, token_id], GENERATOR_INDEX__NOTE_HASH)\n    }\n}\n\nmod test {\n    use super::{\n        NFTNote, NFTPartialNotePrivateContent, PartialNFTNote,\n        PrivateNFTPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global token_id: Field = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a NFTNote has the same note hash as a PartialNFTNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = NFTNote { token_id, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialNFTNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(token_id);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular NFTNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular NFTNote.\n\n        let note = NFTNote { token_id, randomness, owner };\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialNFTNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(token_id)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in NFTNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(token_id), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "80": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "81": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    }
  }
}
