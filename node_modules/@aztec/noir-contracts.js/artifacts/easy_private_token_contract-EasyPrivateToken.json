{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "EasyPrivateToken",
  "functions": [
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "initial_supply",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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advN07a7p20PT9uenra9PG17e9r28bTt62mb4Gnbz9O2v6ftAE/bgZ62gzxtB3vaDvG0HeppO8zTdrin7YipWAxH0t89iuJoimMojqU4juJ4ihMoTqQ4ieJkilMoTqU4jeJ0ijMozqQ4i+JsinMozqU4j+J8igsoLqS4iOJiiksoLqW4jOLyysVwpIfIUZ62oz1tx3jajvW0HedpO97TdoKn7URP20metpM9bad42k71tJ3maTvd03aGp+1MT9tZnrazPW3neNrO9bSd52k739N2gaftQk/bRZ62iz1tl3jaLvW0XeZpu3wqFsMV9HevpLiK4mqKayiupbiO4nqKGyhupLiJ4maKWyhupbiN4naKOyjupLiL4m6KeyjupbiP4n6KBygepHiI4mGKRygepXiscjFc4SFypaftKk/b1Z62azxt13rarvO0Xe9pu8HTdqOn7SZP282etls8bbd62m7ztN3uabvD03anp+0uT9vdnrZ7PG33etru87Td72l7wNP2oKftIU/bw562Rzxtj3raHpuKxfA4/d0nKJ6keIriaYpnKJ6leI7ieYoXKF6keIniZYpXKF6leI3idYo3KN6keIvibYp3KN6leI/ifYoPKD6k+IjiY4pPKD6tXAyPe4g84Wl70tP2lKftaU/bM562Zz1tz3nanve0veBpe9HT9pKn7WVP2yuetlc9ba952l73tL3haXvT0/aWp+1tT9s7nrZ3PW3vedre97R94Gn70NP2kaftY0/bJ562T6diMXxGf/dzii8ovqT4iuJrim8ovqX4juJ7ih8ofqT4ieJnil8ofqX4jeJ3ij8o/qT4i+Jvin842enaazeK7hSNFE0UzRQtFK39KkB/5iHyuaftC0/bl562rzxtX3vavvG0fetp+87T9r2n7QdP24+etp88bT972n7xtP3qafvN0/a7p+0PT9ufnra/PG1/e9r+8bTxxFe2dfO0dfe0NXramjxtzZ62Fk9ba78pXwxt9Hd7UPSk6EXRTtGbog9FX4p+FDNQ9KeYkWImipkpZqGYlWIAxUCK2SgGUQymmJ1iDoohFEMphlEMp5iTYi6KERRzVy6GNg+RHp62np62Xp62dk9bb09bH09bX09bP0/bDJ62/p62GT1tM3naZva0zeJpm9XTNsDTNtDTNpunbZCnbbCnbXZP2xyetiGetqGetmGetuGe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",
      "debug_symbols": "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PnGl5q0WkCs1NzQ/XfNWK86Vmkdiz7VoTg89X3N66Pma00NP13yih56vOT30fM3poedrTg89X3ND89M1p4eerzk99HzN6aHna04PPV9zeujpms/00PM1p4eerzk99HzN6aHna25ofrrm9NDzNaeHnq85PfR8zemh52tODz1d80wPPV9zeuj5mtNDz9ecHnq+5obmp2tODz1fc3ro+ZrTQ8/XnB56vub00NM1X+ih52tODz1fc3ro+ZrTQ8/X3ND8dM3poedrTg89X3N66Pma00PP15weerbmuaOHnq85PfR8zemh52tODz1fc0Pz0zWnh56vOT30fM3poedrTg89X3N66Omaq7/tMaTm9NDzNaeHnq85PfR8zQ3NT9ecHnq+5vTQ8zWnh56vOT30fM3poadrLv/+44ia00PP15weer7m9NDzNTc0P11zeuj5mtNDz9ecHnq+5vTQ8zWnh56u+UAPPV9zeuj5mtNDz9ecHnq+5obmp2tODz1fc3ro+ZrTQ8/XnB56vub00NM1N3ro+ZrTQ8/XnB56vub00PM1NzQ/XXN66Pma00PP15weer7m9NDzNaeHnq75SA89X3N66Pma00PP15weer7mhuana04PPV9zeuj5mtNDz9ecHnq+5vTQ0zWf6KHna04PPV9zeuj5mtNDz9fc0Px0zemh52tODz1fc3ro+ZrTQ8/XnB56uuYzPfR8zemh52tODz1fc3ro+Zobmp+uOT30fM3poedrTg89X3N66Pma00NP1zzTQ8/XnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfR0zRd66Pma00PP15weer7m9NDzNTc0P11zeuj5mtNDz9ecHnq+5vTQ8zWnh56t+dLRQ8/XnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfR0zXt66Pma00PP15weer7m9NDzNTc0P11zeuj5mtNDz9ecHnq+5vTQ8zWnh56ueaKHnq85PfR8zemh52tODz1fc0Pz0zWnh56vOT30fM3poedrTg89X3N66OmaD/TQ8zWnh56vOT30fM3poedrbmh+uub00PM1p4eerzk99HzN6aHna04PPV1zo4eerzk99HzN6aHna04PPV9zQ/PTNaeHnq85PfR8zemh52tODz1fc3ro6ZqP9NDzNaeHnq85PfR8zemh52tuaH665vTQ8zWnh56vOT30fM3poedrTg89XfOJHnq+5vTQ8zWnh56vOT30fM0NzU/XnB56vub00PM1p4eerzk99HzN6aGnaz7TQ8/XnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfR0zTM99HzN6aHna04PPV9zeuj5mhuan645PfR8zemh52tODz1fc3ro+ZrTQ0/XfKGHnq85PfR8zemh52tODz1fc0Pz0zWnh56vOT30fM3poedrTg89X3N66MmaD11HDz1fc3ro+ZrTQ8/XnB56vuaG5qdrTg89X3N66Pma00PP15weer7m9NDTNe/poedrTg89X3N66Pma00PP19zQ/HTN6aHna04PPV9zeuj5mtNDz9ecHnq65okeer7m9NDzNaeHnq85PfR8zQ3NT9ecHnq+5vTQ8zWnh56vOT30fM3poadrPtBDz9ecHnq+5vTQ8zWnh56vuaH56ZrTQ8/XnB56vub00PM1p4eerzk99HTNjR56vub00PM1p4eerzk99HzNDc1P15weer7m9NDzNaeHnq85PfR8zemhp2s+0kPP15weer7m9NDzNaeHnq+5ofnpmtNDz9ecHnq+5vTQ8zWnh56vOT30dM0neuj5mtNDz9ecHnq+5vTQ8zU3ND9dc3ro+ZrTQ8/XnB56vub00PM1p4eervlMDz1fc3ro+ZrTQ8/XnB56vuaG5qdrTg89X3N66Pma00PP15weer7m9NDTNc/00PM1p4eerzk99HzN6aHna25ofrrm9NDzNaeHnq85PfR8zemh52tODz1d84Ueer7m9NDzNaeHnq85PfR8zQ3NT9ecHnq+5vTQ8zWnh56vOT30fM3poWdrfhMRzU/XnB56vub00PM1p4eer7mh+dma9zV1ovz1wfO0HjvPH1R822lNTeR3O61p/v/dTq+Yuvv7TguL/+pH/11/6ipff1/5+lPl6x8qX79Vvv5RfP3j+rHcL2ko/OjelmU9enyYFW4/+m2zU0ubnVvabA602ZTnbbzIy1I4ekhLXjc59PfJZXpXRn3AuEyZQX10uU4Z9aHohcoM07Ipk+cHZT4fa/2moqV+/qSi+mhWh4rqA+L3VOzmVcWl7wpH522PebhvMf0pnJ+OXfK6jGX5eOybioaKDipGGpavUzHSFH6dipHG++tUjNUbrlIxVse4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",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "discover_new_messages",
        "random",
        "notify_created_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "mint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9BZwcRfc1vMlakt0I7hDcoWu0B3d3d5iZnsHdPbi7u7uTQCAhgQAhQHB3d3eX796H2aR3UruROXf+975f+vndJ01NUntO1a1b53T39PZo+O9Yd0BDw8rT/nfeg6Kx8mdPioFVbR1/xs+bPX+vzdPW19PW39M2jadtRooVqtrm8vy9gZ62uT1t83jaFvS0LVT5ufGjR+XPjvZkkEmlStlEySVdPkjkCmE6SKULmdCFLh2mo0SYTJbCVJjNFXLZIOdSyZIrp3PJcvDf8U/P8X0FNR2JoiTOf6ccZ7K6gbFxyjXFsPI4/BMb947zhWPn/1b+Tse/44nqQdGTorEx1l45elaNQVDb4RYEjmdTIw5XPGe534HC4xDHXus4NAuNQ3NlHJqqxiB+9ACPSw9cX4EHLqrvgq9veMFoAU6sJM7WRplJQ+PsNeU4E9UNvgLM8+Uruq2x9l6NnQtwb/rvPhRtFO2VAszRHuPf3ZgEtR2uN3Du4nj7NgoCHtc5MDmaqgY8ft4v9vO8pGr94f2nfBbS1Q0Ty8yupEH/qswcQP89DcW0FNN5pEEjeGL7AavdAOD2Or1QdUOPH3Alu2mA4zcDuMJU5/b0sdyeIXY+bex8uqrcnpH+eyaKmSlmiVVdljjNDRMemquuBy50vCdW+4LaDrdQA34s0BgXNoCxX2N9VFhQ2+FmNIKzWXiNwj1lM7BozyrkKWeNecq+DRMWF4mJtFFsE3J9u/HSvOMaHx+z0bjMTjEHxZwUc/HcUMxNMQ/FvBTzUcxPsQDFghQLUSxMsQjFohSLUSxOsQTFkhQBhaNIUCQpUhRpigxFliKkyFEsVX1BlMH0qmqb3dM2h6dtTk/bXJ62gZ62uT1t83ja5vW0zedpm9/TtoCnbUFP20KetoU9bYt42hb1tC3maVvc07aEp21JT1vgaXOetoSnLelpS3na0p62jKct62kLPW05T9tSlbb4MXflzxUqfwa1HZ2KTq3FeDZAX6UyH4GbHdQXc5wD0td/4zVn7X0lKuPl5qq1r9S4sXcDa+sriM2jm7uWvhKdcsLNM+V9BVX55eadwr4y5Qly1c03ZX2Fnrx3809JX6F3DbkFJr+vbBfr0S04uX1lu1zbbqHJ6yvRTZ1wC09OX9lua45bZNL7Kk6kfrlFJ7Wv7ERroVts0voKJqGuusUnpa9gkmq0W2LifaUnsd67JSfWV2qS9w4XdNtXqjwZ+5Bz3fWVnaw9zSW67iuczP3RJbvoK1ee7L3Wpfx9BVOwb7u0r69gijSAy0zYl5tCPeGy1X1FU6xNXNi5r2QNOsflYn0lyjVpJrdUI8701fN+zFIwrRe5ON6lGwUBc+fVVzNqBb80bgLdMkAxLjWGjBF1W6ljDJcBL4J+DfV5CgC3eCPRqyrxsVi2ssCWq76ysWxlYuNty3kcaKPgINbqGpcFLqDlwJOLTj5eNMsCF2MH72WN7kg5WB7lojje5RsFAS8P35Fy0fLAHWkF5TvS/yYdviPlohWM7kg5GO5c0QNXZEdasbLAVqrekVb07Egr1WFHygF3pBWBC2gloclFFaAOnEjOKwOLWUMDfrdcplKA0DdJkVZgFWAx841hUNvheI5XEVAyqxhVMiGs/hSScbyrNgoCXhWuZArJVYGLfzXlSobHcDW4kikkVxNe/IgCuoryAro6eAw7DvTGi8zxNYBrr54KOIThLiQ8cEUU8JqVwrxWtQJe06OA16qDAsbtQIFbE5iUawlNLnohIjmvLayAg9oOx8VxDQH1to5y1crzso4B3lI5vg4wx9dVnuNdiRSIewT1tR54w66X28nC9pqwHMe7fqMg4PXhbicsrw+cwA2Uux0eww3gbicsb6Dc7XChW69RdzHeEFyMOw40Z2SOb2TU7WRhuMOSB66I29m4Upg3qXY7G3vcziZ1cDu4HShwGwOTchOhyUUvRCTnTZUrQS6OGwmo/s2Uux2el80M8JbK8c2AOb658hzvSqQEtR0OKVK2MHpvJwPbaxKd3mOxZaMg4C3hbicRbAlcBFspdzs8hlvB3U4i2Eq52+FCt0Wj7mK8tRG3g8zxbYy6nQwMtyt74Iq4nW0rhXm7arezrcftbFcHt4PbgQK3LTAptxOaXPRCRHLeXrkS5OK4jYDq30G52+F52cEAb6kc3wGY43nlOd6VSAlqOxxSpBSMup00bK+JOrmdYqMg4CLc7URBEbgIIuVuh8cwgrudKIiUux0udIVG3cW4ZMTtIHO8bNTtpGG4i3VzOztWCvNO1W5nR4/b2akObge3AwVuR2BS7iQ0ueiFiOS8s3IlyMWxLKD6d1HudnhedjHAWyrHdwHm+K7Kc7wrkRLUdjikSNnNqNtJwfaaTKd3YuzeKAh4d7jbybjdgYtgD+Vuh8dwD7jbyXTiHdR4+HgjCt1ujbqL8Z5G3A4yx/cy6nZSMNyZur1LZe9KYd6n2u3s7XE7+9TB7eB2oMDtDUzKfYQmF70QkZz3Va4EuTjuJaD691Pudnhe9jPAWyrH9wPm+P7Kc7wrkRLUdjikSDnAqNtJ4u7thHG8BzYKAj4Qf28nPBC4CA5S7nZ4DA/C39sJD1LudrjQHdCouxgfbMTtIHP8EKNuJwnDHWU9cEXczqGVwnxYtds51ON2DquD28HtQIE7FJiUhwlNLnohIjkfrlwJcnE8RED1H6Hc7fC8HGGAt1SOHwHM8SOV53hXIiWo7XBIkTLIqNtJwPaaVC6O96hGQcBHwd1OKncUcBEcrdzt8BgeDXc7qdzRyt0OF7pBjbqL8TFG3A4yx4816nYSMNyp0ANXxO0cVynMx1e7neM8buf4Orgd3A4UuOOASXm80OSiFyKS8wnKlSAXx2MFVP+Jyt0Oz8uJBnhL5fiJwBw/SXmOdyVSgtoOhxQpJxt1Ow621xQ6Pcl2SqMg4FPgbqfgTgEuglOVux0ew1PhbqfQiXdQ4+HjjSh0JzfqLsanGXE7yBw/3ajbcTDchbo9yXZGpTCfWe12zvC4nTPr4HZwO1DgzgAm5ZlCk4teiEjOZylXglwcTxdQ/Wcrdzs8L2cb4C2V42cDc/wc5TnelUgJajscUqSca9TtBDi3U4zjPa9REPB5eLdTPA+4CM5X7nZ4DM/Hu53i+crdDhe6cxt1F+MLjLgdZI5faNTtBDhBXPDAFXE7F1UK88XVbucij9u5uA5uB7cDBe4iYFJeLDS56IWI5HyJciXIxfFCAdV/qXK3w/NyqQHeUjl+KTDHL1Oe412JlKC2wyFFyuVG3c6SuCfZCnG8VzQKAr4C/yRb4QrgIrhSudvhMbwS/yRb4UrlbocL3eWNuovxVUbcDjLHrzbqdpbEPeyU98AVcTvXVArztdVu5xqP27m2Dm4HtwMF7hpgUl4rNLnohYjkfJ1yJcjF8WoB1X+9crfD83K9Ad5SOX49MMdvUJ7jXYmUoLbDIUXKjUbdzhKwvSbs9AbqmxoFAd8EdzthcBNwEdys3O3wGN4MdzthcLNyt8OF7sZG3cX4FiNuB5njtxp1O0vAcGfr9gbq2yqF+fZqt3Obx+3cXge3g9uBAncbMClvF5pc9EJEcr5DuRLk4nirgOq/U7nb4Xm50wBvqRy/E5jjdynP8a5ESlDb4ZAi5W6jbmdxIbczuFEQ8GABtzMYuAiGKHc7PIZDBNzOEOVuhwvd3Y26i/E9RtwOMsfvNep2FjfodoZWCvN91W5nqMft3FcHt4PbgQI3FJiU9xlxO0jO9ytXglwc7xVQ/cOUux2el2EGeEvl+DBgjg9XnuNdiZSgtsMhRcoDRt3OYrC9Jt/pnWwjGgUBj4C7nXxuBHARjFTudngMR8LdTj43Urnb4UL3QKPuYvygEbeDzPGHjLqdxWC483V7J9uoSmF+uNrtjPK4nYfr4HZwO1DgRgGT8mGhyUUvRCTnR5QrQS6ODwmo/keVux2el0cN8JbK8UeBOT5aeY53JVKC2g6HFCmPGXU7i+LcTiqOd0yjIOAxeLeTGgNcBI8rdzs8ho/j3U7qceVuhwvdY426i/ETRtwOMsefNOp2FsUJ4qQHrojbGVspzE9Vu52xHrfzVB3cDm4HCtxYYFI+JTS56IWI5Py0ciXIxfFJAdX/jHK3w/PyjAHeUjn+DDDHn1We412JlKC2wyFFynNG3c4isL0m6nRv5/lGQcDPw91OlHseuAheUO52eAxfgLudKPeCcrfDhe65Rt3F+EUjbgeZ4y8ZdTuLwHBHdbu383KlML9S7XZe9ridV+rgdnA7UOBeBiblK0KTi16ISM6vKleCXBxfElD9ryl3OzwvrxngLZXjrwFz/HXlOd6VSAlqOxxSpLxh1O0sDNtriqU43jcbBQG/CXc7xdKbwEXwlnK3w2P4FtztFEtvKXc7XOjeaNRdjN824naQOf6OUbezMAx3MfLAFXE771YK83vVbuddj9t5rw5uB7cDBe5dYFK+JzS56IWI5Py+ciXIxfEdAdX/gXK3w/PygQHeUjn+ATDHP1Se412JlKC2wyFFykdG3c5CsL3Gdbq383GjIOCP4W7H5T4GLoJPlLsdHsNP4G7H5T5R7na40H3UqLsYf2rE7SBz/DOjbmchGG5Xt3s7n1cK8xfVbudzj9v5og5uB7cDBe5zYFJ+ITS56IWI5PylciXIxfEzAdX/lXK3w/PylQHeUjn+FTDHv1ae412JlKC2wyFFyjdG3c6CsL2m0MntfNsoCPhbuNsp5L4FLoLvlLsdHsPv4G6nkPtOudvhQvdNo+5i/L0Rt4PM8R+Mup0FYbgLdXM7P1YK80/VbudHj9v5qQ5uB7cDBe5HYFL+JDS56IWI5PyzciXIxfEHAdX/i3K3w/PyiwHeUjn+CzDHf1We412JlKC2wyFFym9G3c4CsL0mDON4f28UBPw73O2E4e/ARfCHcrfDY/gH3O2E4R/K3Q4Xut8adRfjP424HWSO/2XU7SwAwx1mPXBF3M7flcL8T7Xb+dvjdv6pg9vB7UCB+xuYlP8ITS56ISI5/6tcCXJx/EtA9Tc06XY7PC+MUTtvqRyP46y1rx5NunO8K5ES1HY4pEjpCcyberqd+WF7TaqT22lsEgTMnWPdTipsBC6CJuDilBrDpia020mFTcKbBqLQ9WzSXYybwcW440BzRuZ4C3LtNdTP7cwPE4epurmd1kph7tXU0NnZtDZN6Hb4L0m7nfmBbqcVmJS9mmQmF70QkZx7K1eCXBxbBFR/H+Vuh+eljwHeUjneB5jjbcpzvCuREtR2OKRIaTfqduaD7TU5F8fbt0kQcF+428m5vsBF0E+52+Ex7Ad3O7lOvIMaDx9vRKFrb9JdjPsbcTvIHB9g1O3MB3M7ucADV8TtTFMpzNNWu51pPG5n2jq4nfmAbmcaYFJO2yQzueiFiOQ8nXIlyMVxgIDqn1652+F5md4Ab6kcnx6Y4zMoz/GuREpQ2+GQImVGo25nXthekw3ieGdqEgQ8E9ztZIOZgItgZuVuh8dwZrjbyQYzK3c7XOhmbNJdjGcx4naQOT6rUbczL8ztZMoeuCJuZ7ZKYZ692u3M5nE7s9fB7cwLdDuzAZNy9iaZyUUvRCTnOZQrQS6Oswqo/jmVux2elzkN8JbK8TmBOT6X8hzvSqQEtR0OKVIGGnU78+DeUtDpDdRzNwkCnhvudgqluYGLYB7lbofHcB642ymU5lHudrjQDWzSXYznNeJ2kDk+n1G3Mw/ui+yRB66I25m/UpgXqHY783vczgJ1cDvzAN3O/MCkXKBJZnLRCxHJeUHlSpCL43wCqn8h5W6H52UhA7ylcnwhYI4vrDzHuxIpQW2HQ4qURYy6nblhe02i072dRZsEAS8KdzuJYFHgIlhMudvhMVwM7nYSwWLK3Q4XukWadBfjxY24HWSOL2HU7cyNe0lx3e7tLFkpzEG121nS43aCOriduYFuZ0lgUgZNMpOLXohIzk65EuTiuISA6k8odzs8LwkDvKVyPAHM8aTyHO9KpAS1HQ4pUlJG3c5A3F5TjONNNwkCTsPdTlBMAxdBRrnb4THMwN1OUMwodztc6FJNuotx1ojbQeZ4aNTtDMS9wqrggSvidnKVwrxUtdvJedzOUnVwO8AdyOWASblUk8zkohcikvPSypUgF8dQQPUvo9zt8LwsY4C3VI4vA8zxZZXneFciJajtcEiRspxRtzMXbK/JdHqSbfkmQcDLw91OprQ8cBGsoNzt/G/S4W4nU1pBudvhQrdck+5ivKIRt4PM8ZWMup25cN/biTxwRdzOypXCvEq121nZ43ZWqYPbmQvodlYGJuUqTTKTi16ISM6rKleCXBxXElD9qyl3OzwvqxngLZXjqwFzfHXlOd6VSAlqOxxSpKxh1O3MCdtrXKd3sq3ZJAh4TbjbcW5N4CJYS7nb4TFcC+52XCfeQY2Hjzei0K3RpLsYr23E7SBzfB2jbmdO3JNsdXsn27qVwrxetdtZ1+N21quD25kT6HbWBSblek0yk4teiEjO6ytXglwc1xFQ/Rsodzs8LxsY4C2V4xsAc3xD5TnelUgJajscUqRsZNTtzIF7GKPT93Y2bhIEvHETvt9NlDsU5r1J0/gBBvUr4iq4oGzUpLvobWrEVSDzcjPhQo+Yk80EcryeBXV2oYK6eZMg4M0FCuoWygsq895iakGF9bWlkYKKzMutlBdUnpOtjBfU2YC/FTOOd+smQcBbCyzWrYHJto3y4sxjuI2Avd9G+fV4C4V+WyOFHpnj2ym/RMJzsp3Aetle+WVArhPbC4k4qbzcHpiXOyjPy67qWVDb4ZD1LK88x3mO8wIGDZmHvAT7Noy/FRY/0LgXapBZ5w1QnAnR+5c9YmM7sHJeoEkoUkQUJYoyxY4UO1HsTLELxa4Uu1HsTrEHxZ4Ue1HsTbEPxb4U+1HsT3EAxYEUB1EcTHEIxaEUh1EcTnEExZEUgyiOqr53WqjcJ423FT1tkaet5Gkre9p29LTt5Gnb2dO2i6dtV0/bbp623T1te3ja9vS07eVp29vTto+nbV9P236etv09bQd42g70tB3kaTvY03aIp+1QT9thnrbDPW1HeNqO9LQN8rQd1TThPfm5K3+uUPkzqO3oVHRqLZYFQOHtuL9fBPXFHCNIX/+NV6n2vhKV8XLlWvtKjRt7t2NtfQWxeXQ71dJXolNOuJ2nvK+gKr/cLlPYV6Y8Qa66Xaesr9CT9263Kekr9K4ht/vk95XtYj26PSa3r2yXa9vtOXl9JbqpE26vyekr223NcXtPel/FidQvt8+k9pWdaC10+05aX8Ek1FW336T0FUxSjXb7T7yv9CTWe3fAxPpKTfLe4Q7stq9UeTL2IXdQd31lJ2tPcwd33Vc4mfujO6SLvnLlyd5r3aH+voIp2LfdYb6+ginSAO7wCftyU6gn3BHVfUVTrE3ckZ37Stagc9ygWF+Jck2ayR0FNOn1vHtxFEzrRZ2+TXB0kyDgo5vQ3yaI3NG4CXTHAAZV8u4Fj+ExwKuxHWN4DHgR1OupcNzijer2VPixlQV2XPWVjWObJnwq/Lgm+afCcZUkcMcCF9Bx4MlFJx8vmmOBi7GD97FGd6RBsDzKRXG8xzcJAj4eviPlouOBO9IJynckHsMT4DtSLjrB6I40CIY7V/TAFdmRTqwssJOqd6QTPTvSSXXYkQYBd6QTgQvoJKHJRd8IRnI+GVjMGhrwu+UxlQKEvhGMtAKnAIuZbwyD2g7Hc3yKgJI5xaiSORJWfwrJON5TmwQBnwpXMoXkqcDFf5pyJcNjeBpcyRSSpwkvfkQBPUV5AT0dPIYdB3rjReb4GcC1V08FfCQMdyHhgSuigM+sFOazqhXwmR4FfFYdFDBuBwrcmcCkPEtoctELEcn5bGEFHNR2OC6OZwiot3OUq1ael3MM8JbK8XOAOX6u8hzvSqQgxA+qr/PAG3a93M4RsL0mLMfxnt8kCPh8uNsJy+cDJ/AC5W6Hx/ACuNsJyxcodztc6M5r0l2MLwQX444DzRmZ4xcZdTtHwHCHJQ9cEbdzcaUwX1Ltdi72uJ1L6uB2cDtQ4C4GJuUlQpOLXohIzpcqV4JcHC8SUP2XKXc7PC+XGeAtleOXAXP8cuU53pVICWo7HFKkXGH03s7hsL0m0emtD1c2CQK+Eu52EsGVwEVwlXK3w2N4FdztJIKrlLsdLnRXNOkuxlcbcTvIHL/GqNs5HIa786+cb0DirHI711YK83XVbudaj9u5rg5uB7cDBe5aYFJeJzS56IWI5Hy9ciXIxfEaAdV/g3K3w/NygwHeUjl+AzDHb1Se412JlKC2wyFFyk1G3c5hsL0m6uR2bm4SBHwz3O1Ewc3ARXCLcrfDY3gL3O1EwS3K3Q4XupuadBfjW424HWSO32bU7RwGw12sm9u5vVKY76h2O7d73M4ddXA7uB0ocLcDk/IOoclFL0Qk5zuVK0EujrcJqP67lLsdnpe7DPCWyvG7gDl+t/Ic70qkBLUdDilSBht1O4fC9ppMp3diDGkSBDwE7nYybghwEdyj3O3wGN4DdzuZTryDGg8fb0ShG9ykuxjfa8TtIHN8qFG3cygMd6Zu71K5r1KY7692O/d53M79dXA7uB0ocPcBk/J+oclFL0Qk52HKlSAXx6ECqn+4crfD8zLcAG+pHB8OzPEHlOd4VyIlqO1wSJEywqjbOQR3byeM4x3ZJAh4JP7eTjgSuAgeVO52eAwfxN/bCR9U7na40I1o0l2MHzLidpA5Psqo2zkEhjvKeuCKuJ2HK4X5kWq387DH7TxSB7eD24EC9zAwKR8Rmlz0QkRyflS5EuTiOEpA9Y9W7nZ4XkYb4C2V46OBOf6Y8hzvSqQEtR0OKVLGGHU7B8P2mlQujvfxJkHAj8PdTir3OHARPKHc7fAYPgF3O6ncE8rdDhe6MU26i/GTRtwOMsfHGnU7B8Nwp0IPXBG381SlMD9d7Xae8ridp+vgdnA7UOCeAibl00KTi16ISM7PKFeCXBzHCqj+Z5W7HZ6XZw3wlsrxZ4E5/pzyHO9KpAS1HQ4pUp436nYOgu01hU5Psr3QJAj4BbjbKbgXgIvgReVuh8fwRbjbKXTiHdR4+HgjCt3zTbqL8UtG3A4yx1826nYOguEu1O1JtlcqhfnVarfzisftvFoHt4PbgQL3CjApXxWaXPRCRHJ+TbkS5OL4soDqf1252+F5ed0Ab6kcfx2Y428oz/GuREpQ2+GQIuVNo27nQJzbKcbxvtUkCPgtvNspvgVcBG8rdzs8hm/j3U7xbeVuhwvdm026i/E7RtwOMsffNep2DsQJ4oIHrojbea9SmN+vdjvvedzO+3VwO7gdKHDvAZPyfaHJRS9EJOcPlCtBLo7vCqj+D5W7HZ6XDw3wlsrxD4E5/pHyHO9KpAS1HQ4pUj426nYOwD3JVojj/aRJEPAn+CfZCp8AF8Gnyt0Oj+Gn+CfZCp8qdztc6D5u0l2MPzPidpA5/rlRt3MA7mGnvAeuiNv5olKYv6x2O1943M6XdXA7uB0ocF8Ak/JLoclFL0Qk56+UK0Eujp8LqP6vlbsdnpevDfCWyvGvgTn+jfIc70qkBLUdDilSvjXqdvaH7TVhpzdQf9ckCPg7uNsJg++Ai+B75W6Hx/B7uNsJg++Vux0udN826S7GPxhxO8gc/9Go29kfhjtbtzdQ/1QpzD9Xu52fPG7n5zq4HdwOFLifgEn5s9DkohcikvMvypUgF8cfBVT/r8rdDs/LrwZ4S+X4r8Ac/015jnclUoLaDocUKb8bdTv7CbmdP5oEAf8h4Hb+AC6CP5W7HR7DPwXczp/K3Q4Xut+bdBfjv4y4HWSO/23U7exn0O38UynM/1a7nX88buffOrgd3A4UuH+ASfmvEbeD5NzQrFsJcnH8W0D192iW3biC2g7H88IYtfOWyvE4zlr76qk8x7sSKUFth0OKlEZg3tTT7ewL22vynd7J1tQsCJg7x7qdfK4JuAiagYtTagybm9FuJ59rFt40EIWusVl3MW4BF+OOA80ZmeOtQM71dDv7wgRxvm7vZOtVKcy9mxs6O5tezRO6Hf5L0m5nX6Db6QVMyt7NMpOLXohIzn2UK0Eujq0Cqr9NudvheWkzwFsqx9uAOd6uPMe7EilBbYdDipS+Rt3OPji3k4rj7dcsCLgf3u2k+gEXQX/lbofHsD/e7aT6K3c7XOj6NusuxgOMuB1kjk9j1O3sg3M7SQ9cEbczbaUwT1ftdqb1uJ3p6uB29gG6nWmBSTlds8zkohcikvP0ypUgF8dpBFT/DMrdDs/LDAZ4S+X4DMAcn1F5jnclUoLaDocUKTMZdTt7w/aaqNO9nZmbBQHPDHc7UW5m4CKYRbnb4TGcBe52otwsyt0OF7qZmnUX41mNuB1kjs9m1O3sDXM7Ud3u7cxeKcxzVLud2T1uZ446uJ29gW5ndmBSztEsM7nohYjkPKdyJcjFcTYB1T+XcrfD8zKXAd5SOT4XMMcHKs/xrkRKUNvhkCJlbqNuZy/YXlMsxfHO0ywIeB642ymW5gEugnmVux0ew3nhbqdYmle52+FCN3ez7mI8nxG3g8zx+Y26nb1gbqcYeeCKuJ0FKoV5wWq3s4DH7SxYB7ezF9DtLABMygWbZSYXvRCRnBdSrgS5OM4voPoXVu52eF4WNsBbKscXBub4IspzvCuREtR2OKRIWdSo29kTtte4Tvd2FmsWBLwY3O243GLARbC4crfDY7g43O243OLK3Q4XukWbdRfjJYy4HWSOL2nU7ewJczuubvd2gkphdtVuJ/C4HVcHt7Mn0O0EwKR0zTKTi16ISM4J5UqQi+OSAqo/qdzt8LwkDfCWyvEkMMdTynO8K5ES1HY4pEhJG3U7e8D2mkInt5NpFgScgbudQi4DXARZ5W6HxzALdzvUptztcKFLN+suxqERt4PM8ZxRt7MHzO0U6uZ2lqoU5qWr3c5SHrezdB3czh5At7MUMCmXbpaZXPRCRHJeRrkS5OKYE1D9yyp3OzwvyxrgLZXjywJzfDnlOd6VSAlqOxxSpCxv1O3sjnsDdRjHu0KzJGC42wnDFYCLYEXlbofHcEW42wnDFZW7HS50yzfrLsYrGXE7yBxf2ajb2R3mdsKsB66I21mlUphXrXY7q3jczqp1cDu7A93OKsCkXLVZZnLRCxHJeTXlSpCL48oCqn915W6H52V1A7ylcnx1YI6voTzHuxIpQW2HQ4qUNY26nd1ge02qk9tZq1kQ8Fpwt5MK1wIugrWVux0ew7XhbicVrq3c7XChW7NZdzFex4jbQeb4ukbdzm4wt5Oqm9tZr1KY1692O+t53M76dXA7uwHdznrApFy/WWZy0QsRyXkD5UqQi+O6Aqp/Q+Vuh+dlQwO8pXJ8Q2COb6Q8x7sSKUFth0OKlI2Nup1dYXtNzsXxbtIsCHgTuNvJuU2Ai2BT5W6Hx3BTuNvJdeId1Hj4eCMK3cbNuovxZkbcDjLHNzfqdnaFuZ1c4IEr4na2qBTmLavdzhYet7NlHdzOrkC3swUwKbdslplc9EJEct5KuRLk4ri5gOrfWrnb4XnZ2gBvqRzfGpjj2yjP8a5ESlDb4ZAiZVujbmcX2F6TDeJ4t2sWBLwd3O1kg+2Ai2B75W6Hx3B7uNvJBtsrdztc6LZt1l2MdzDidpA5njfqdnaBuZ1M2QNXxO0UKoW5WO12Ch63U6yD29kF6HYKwKQsNstMLnohIjlHypUgF8e8gOovKXc7PC8lA7ylcrwEzPGy8hzvSqQEtR0OKVJ2NOp2dsa9paDTG6h3ahYEvBPc7RRKOwEXwc7K3Q6P4c5wt1Mo7azc7XCh27FZdzHexYjbQeb4rkbdzs64txREHrgibme3SmHevdrt7OZxO7vXwe3sDHQ7uwGTcvdmmclFL0Qk5z2UK0EujrsKqP49lbsdnpc9DfCWyvE9gTm+l/Ic70qkBLUdDilS9jbqdnaC7TWJTvd29mkWBLwP3O0kgn2Ai2Bf5W6Hx3BfuNtJBPsqdztc6PZu1l2M9zPidpA5vr9Rt7MT7g3Udbu3c0ClMB9Y7XYO8LidA+vgdnYCup0DgEl5YLPM5KIXIpLzQcqVIBfH/QVU/8HK3Q7Py8EGeEvl+MHAHD9EeY53JVKC2g6HFCmHGnU7O+L2mmIc72HNgoAPg7udoHgYcBEcrtzt8BgeDnc7QfFw5W6HC92hzbqL8RFG3A4yx4806nZ2hLmdoOCBK+J2BlUK81HVbmeQx+0cVQe3A9yB3CBgUh7VLDO56IWI5Hy0ciXIxfFIAdV/jHK3w/NyjAHeUjl+DDDHj1We412JlKC2wyFFynFG3U4ZttdkOj3JdnyzIODj4W4nUzoeuAhOUO52eAxPgLudTOkE5W6HC91xzbqL8YlG3A4yx08y6nbKuO/t1O1JtpMrhfmUardzssftnFIHt1MGup2TgUl5SrPM5KIXIpLzqcqVIBfHkwRU/2nK3Q7Py2kGeEvl+GnAHD9deY53JVKC2g6HFClnGHU7Jdhe4zq9k+3MZkHAZ8LdjnNnAhfBWcrdDo/hWXC34zrxDmo8fLwRhe6MZt3F+GwjbgeZ4+cYdTsl3JNsdXsn27mVwnxetds51+N2zquD2ykB3c65wKQ8r1lmctELEcn5fOVKkIvjOQKq/wLlbofn5QIDvKVy/AJgjl+oPMe7EilBbYdDipSLjLqdCPcwRqfv7VzcLAj44mZ8v5codyjM+5Lm8QMM6lfEVXBBuahZd9G71IirQOblZcKFHjEnlwnkeD0LalGooF7eLAj4coGCeoXygsq8r5haUGF9XWmkoCLz8irlBZXn5CrjBbXQhBuPON6rmwUBXy2wWK8GJts1yoszj+E1Avb+GuXX4y0U+muNFHpkjl+n/BIJz8l1AuvleuWXAblOXC8k4qTy8npgXt6gPC+7qmdBbYdD1rMblec4z/GNAgYNmYcsCPs2jL8VFj/QuBdukFnnDVCcCdH7lz1iYzuwcn4TzefNFLdQ3EpxG8XtFHdQ3ElxF8XdFIMphlDcQ3EvxVCK+yjupxhGMZziAYoRFCMpHqR4iGIUxcMUj1A8SjGa4jGKMRSPV987valynzTedrOn7RZP262etts8bbd72u7wtN3pabvL03a3p22wp22Ip+0eT9u9nrahnrb7PG33e9qGedqGe9oe8LSN8LSN9LQ96Gl7yNM2ytP2sKftEU/bo5620Z62xzxtYzxtjzdPeE9+7sqfK1T+DGo7OhWdWovlTYDC23F//2ZQX8zxFkhf/43XrbX3laiMl7ut1r5S48be3V5bX0FsHt0dtfSV6JQT7s4p7yuoyi931xT2lSlPkKvu7inrK/TkvRs8JX2F3jXkhkx+X9ku1qO7Z3L7yna5tt29k9dXops64YZOTl/ZbmuOu2/S+ypOpH65+ye1r+xEa6EbNml9BZNQV93wSekrmKQa7R6YeF/pSaz3bsTE+kpN8t7hRnbbV6o8GfuQe7C7vrKTtae5h7ruK5zM/dGN6qKvXHmy91r3sL+vYAr2bfeIr69gijSAe3TCvtwU6gk3urqvaIq1iXusc1/JGnSOGxPrK1GuSTO5x4EmvZ53Lx6Hab2o07cJnmgWBPxEM/rbBJF7AjeB7knAoEreveAxfBJ4NbZjDJ8EL4J6PRWOW7xR3Z4KH1tZYE9VX9kY2zzhU+FPNcs/FY6rJIEbC1xAT4EnF518vGjGAhdjB++xRnekMbA8ykVxvE83CwJ+Gr4j5aKngTvSM8p3JB7DZ+A7Ui56xuiONAaGO1f0wBXZkZ6tLLDnqnekZz070nN12JHGAHekZ4EL6DmhyUXfCEZyfh5YzBoa8Lvlk5UChL4RjLQCLwCLmW8Mg9oOx3P8goCSecGoknkMVn8KyTjeF5sFAb8IVzKF5IvAxf+SciXDY/gSXMkUki8JL35EAX1BeQF9GTyGHQd640Xm+CvAtVdPBfwYDHch4YErooBfrRTm16oV8KseBfxaHRQwbgcK3KvApHxNaHLRCxHJ+XVhBRzUdjgujq8IqLc3lKtWnpc3DPCWyvE3gDn+pvIc70qkIMQPqq+3wBt2vdzOaNheE5bjeN9uFgT8NtzthOW3gRP4jnK3w2P4DtzthOV3lLsdLnRvNesuxu+Ci3HHgeaMzPH3jLqd0TDcYckDV8TtvF8pzB9Uu533PW7ngzq4HdwOFLj3gUn5gdDkohcikvOHypUgF8f3BFT/R8rdDs/LRwZ4S+X4R8Ac/1h5jnclUoLaDocUKZ8YvbfzKGyvSXR668OnzYKAP4W7nUTwKXARfKbc7fAYfgZ3O4ngM+VuhwvdJ826i/HnRtwOMse/MOp2HoXh7vwr5xuQOKvczpeVwvxVtdv50uN2vqqD28HtQIH7EpiUXwlNLnohIjl/rVwJcnH8QkD1f6Pc7fC8fGOAt1SOfwPM8W+V53hXIiWo7XBIkfKdUbfzCGyviTq5ne+bBQF/D3c7UfA9cBH8oNzt8Bj+AHc7UfCDcrfDhe67Zt3F+EcjbgeZ4z8ZdTuPwHAX6+Z2fq4U5l+q3c7PHrfzSx3cDm4HCtzPwKT8RWhy0QsRyflX5UqQi+NPAqr/N+Vuh+flNwO8pXL8N2CO/648x7sSKUFth0OKlD+Mup2HYXtNptM7Mf5sFgT8J9ztZNyfwEXwl3K3w2P4F9ztZDrxDmo8fLwRhe6PZt3F+G8jbgeZ4/8YdTsPw3Bn6vYulX87CnNLQ2dn86/H7fBfknY7uB0ocP8iC2+LzOSiFyKSc48WbPFBLzgujv8IqP6eLbIbV1Db4XheGKN23lI5HsdZa1+NynO8K5ES1HY4pEhpAuZNPd3OKNy9nTCOt7lFEDB3Dr63EzYDF0ELcHFKjWFLC9rtRGGL8KaBKHRNLbqLcSu4GHccaM7IHO8F5FxPtzMK5nairAeuiNvpXSnMfardTu+WCd1Onzq4nVFAt9MbmJR9WmQmF70QkZzblCtBLo69BFR/u3K3w/PSboC3VI63A3O8r/Ic70qkBLUdDilS+hl1Ow/B9ppULo63f4sg4P5wt5PK9QcuggHK3Q6P4QC420nlBih3O1zo+rXoLsbTGHE7yByf1qjbeQjmdlKhB66I25muUpinr3Y703nczvR1cDsPAd3OdMCknL5FZnLRCxHJeQblSpCL47QCqn9G5W6H52VGA7ylcnxGYI7PpDzHuxIpQW2HQ4qUmY26nQdhe02h05Nss7QIAp4F7nYKbhbgIphVudvhMZwV7nYKnXgHNR4+3ohCN3OL7mI8mxG3g8zx2Y26nQdhbqdQtyfZ5qgU5jmr3c4cHrczZx3czoNAtzMHMCnnbJGZXPRCRHKeS7kS5OI4u4DqH6jc7fC8DDTAWyrHBwJzfG7lOd6VSAlqOxxSpMxj1O2MxLmdYhzvvC2CgOfFu53ivMBFMJ9yt8NjOB/e7RTnU+52uNDN06K7GM9vxO0gc3wBo25nJM7tFDxwRdzOgpXCvFC121nQ43YWqoPbGQl0OwsCk3KhFpnJRS9EJOeFlStBLo4LCKj+RZS7HZ6XRQzwlsrxRYA5vqjyHO9KpAS1HQ4pUhYz6nZG4J5kK8TxLt4iCHhx/JNshcWBi2AJ5W6Hx3AJ/JNshSWUux0udIu16C7GSxpxO8gcD4y6nRG4J9nyHrgibsdVCnOi2u04j9tJ1MHtjAC6HQdMykSLzOSiFyKSc1K5EuTiGAio/pRyt8PzkjLAWyrHU8AcTyvP8a5ESlDb4ZAiJWPU7TwA22vCTm+gzrYIAs7C3U4YZIGLIFTudngMQ7jbCYNQudvhQpdp0V2Mc0bcDjLHlzLqdh6AuZ1s2QNXxO0sXSnMy1S7naU9bmeZOridB4BuZ2lgUi7TIjO56IWI5LysciXIxXEpAdW/nHK3w/OynAHeUjm+HDDHl1ee412JlKC2wyFFygpG3c5wIbezYosg4BUF3M6KwEWwknK3w2O4koDbWUm52/lfoWvRXYxXNuJ2kDm+ilG3M9yg21m1UphXq3Y7q3rczmp1cDvDgW5nVWBSrmbE7SA5r65cCXJxXEVA9a+h3O3wvKxhgLdUjq8BzPE1led4VyIlqO1wSJGyllG3Mwy21+Q7vZNt7RZBwGvD3U4+tzZwEayj3O3wGK4Ddzv53DrK3Q4XurVadBfjdY24HWSOr2fU7QyDuZ183d7Jtn6lMG9Q7XbW97idDergdoYB3c76wKTcoEVmctELEcl5Q+VKkIvjegKqfyPlbofnZSMDvKVyfCNgjm+sPMe7EilBbYdDipRNjLqd+3FuJxXHu2mLIOBN8W4ntSlwEWym3O3wGG6GdzupzZS7HS50m7ToLsabG3E7yBzfwqjbuR/ndpIeuCJuZ8tKYd6q2u1s6XE7W9XB7dwPdDtbApNyqxaZyUUvRCTnrZUrQS6OWwio/m2Uux2el20M8JbK8W2AOb6t8hzvSqQEtR0OKVK2M+p27sP9dtFO93a2bxEEvD3c7US57YGLYAflbofHcAe424lyOyh3O1zotmvRXYzzRtwOMscLRt3OfbjfLlq3ezvFSmGOqt1O0eN2ojq4nfuAbqcITMqoRWZy0QsRybmkXAlycSwIqP6ycrfD81I2wFsqx8vAHN9ReY53JVKC2g6HFCk7GXU7Q2F7TbEUx7tziyDgneFup1jaGbgIdlHudngMd4G7nWJpF+VuhwvdTi26i/GuRtwOMsd3M+p2hsLcTjHywBVxO7tXCvMe1W5nd4/b2aMObmco0O3sDkzKPVpkJhe9EJGc91SuBLk47iag+vdS7nZ4XvYywFsqx/cC5vjeynO8K5ES1HY4pEjZx6jbuRe217hO93b2bREEvC/c7bjcvsBFsJ9yt8NjuB/c7bjcfsrdDhe6fVp0F+P9jbgdZI4fYNTt3AtzO65u93YOrBTmg6rdzoEet3NQHdzOvUC3cyAwKQ9qkZlc9EJEcj5YuRLk4niAgOo/RLnb4Xk5xABvqRw/BJjjhyrP8a5ESlDb4ZAi5TCjbuce3G8X7eR2Dm8RBHw43O0UcocDF8ERyt0Oj+ERcLdTyB2h3O1woTusRXcxPtKI20Hm+CCjbuce3G8XrZvbOapSmI+udjtHedzO0XVwO/cA3c5RwKQ8ukVmctELEcn5GOVKkIvjIAHVf6xyt8PzcqwB3lI5fiwwx49TnuNdiZSgtsMhRcrxRt3OENwbqMM43hNaBAGfAHc7YXgCcBGcqNzt8BieCHc7YXiicrfDhe74Ft3F+CQjbgeZ4ycbdTtDYG4nzHrgiridUyqF+dRqt3OKx+2cWge3MwTodk4BJuWpLTKTi16ISM6nKVeCXBxPFlD9pyt3OzwvpxvgLZXjpwNz/AzlOd6VSAlqOxxSpJxp1O0Mhu01qU5u56wWQcBnwd1OKjwLuAjOVu52eAzPhrudVHi2crfDhe7MFt3F+BwjbgeZ4+cadTuDYW4nVTe3c16lMJ9f7XbO87id8+vgdgYD3c55wKQ8v0VmctELEcn5AuVKkIvjuQKq/0Llbofn5UIDvKVy/EJgjl+kPMe7EilBbYdDipSLjbqdu2F7Tc7F8V7SIgj4ErjbyblLgIvgUuVuh8fwUrjbyXXiHdR4+HgjCt3FLbqL8WVG3A4yxy836nbuhrmdXOCBK+J2rqgU5iur3c4VHrdzZR3czt1At3MFMCmvbJGZXPRCRHK+SrkS5OJ4uYDqv1q52+F5udoAb6kcvxqY49coz/GuREpQ2+GQIuVao27nLthekw3ieK9rEQR8HdztZIPrgIvgeuVuh8fwerjbyQbXK3c7XOiubdFdjG8w4naQOX6jUbdzF8ztZMoeuCJu56ZKYb652u3c5HE7N9fB7dwFdDs3AZPy5haZyUUvRCTnW5QrQS6ONwqo/luVux2el1sN8JbK8VuBOX6b8hzvSqQEtR0OKVJuN+p27sS9paDTG6jvaBEEfAfc7RRKdwAXwZ3K3Q6P4Z1wt1Mo3anc7XChu71FdzG+y4jbQeb43Ubdzp24txTU7Q3UgyuFeUi12xnscTtD6uB27gS6ncHApBzSIjO56IWI5HyPciXIxfFuAdV/r3K3w/NyrwHeUjl+LzDHhyrP8a5ESlDb4ZAi5T6jbucO2F6T6HRv5/4WQcD3w91OIrgfuAiGKXc7PIbD4G4nEQxT7na40N3XorsYDzfidpA5/oBRt3MH7g3UZQ9cEbczolKYR1a7nREetzOyDm7nDqDbGQFMypEtMpOLXohIzg8qV4JcHB8QUP0PKXc7PC8PGeAtleMPAXN8lPIc70qkBLUdDilSHjbqdm7H7TXFON5HWgQBPwJ3O0HxEeAieFS52+ExfBTudoLio8rdDhe6h1t0F+PRRtwOMscfM+p2boe5naDggSvidsZUCvPj1W5njMftPF4HtwPcgdwYYFI+3iIzueiFiOT8hHIlyMXxMQHV/6Ryt8Pz8qQB3lI5/iQwx8cqz/GuREpQ2+GQIuUpo27nNthek+n0JNvTLYKAn4a7nUzpaeAieEa52+ExfAbudjKlZ5S7HS50T7XoLsbPGnE7yBx/zqjbuQ33vZ26Pcn2fKUwv1Dtdp73uJ0X6uB2bgO6neeBSflCi8zkohcikvOLypUgF8fnBFT/S8rdDs/LSwZ4S+X4S8Acf1l5jnclUoLaDocUKa8YdTu3wvYa1+mdbK+2CAJ+Fe52nHsVuAheU+52eAxfg7sd14l3UOPh440odK+06C7GrxtxO8gcf8Oo27kV9yRb3d7J9malML9V7Xbe9Lidt+rgdm4Fup03gUn5VovM5KIXIpLz28qVIBfHNwRU/zvK3Q7PyzsGeEvl+DvAHH9XeY53JVKC2g6HFCnvGXU7t+Aexuj0vZ33WwQBv9+C7/cD5Q6FeX/QMn6AQf2KuAouKO+16C56HxpxFci8/Ei40CPm5COBHK9nQb1ZqKB+3CII+GOBgvqJ8oLKvD+ZWlBhfX1qpKAi8/Iz5QWV5+Qz4wX1pmbceMTxft4iCPhzgcX6OTDZvlBenHkMvxCw918ovx5vodB/aaTQI3P8K+WXSHhOvhJYL18rvwzIdeJrIREnlZdfA/PyG+V52VU9C2o7HLKefas8x3mOvxUwaMg8ZEHYt2H8rbD4gcbdr1FmnTdAcSZE71/2iI3twMr5dzSf31P8QPEjxU8UP1P8QvErxW8Uv1P8QfEnxV8Uf1P8Q/Ev19BW6o+iJ0UjRRNFM0ULRStFL4reFH0o2ijaKfpS9KPo39rQ+T7pd5X7pPG27z1tP3jafvS0/eRp+9nT9oun7VdP22+ett89bX942v70tP3lafvb0/aPp+1fTxtPRnVbD09bT09bo6etydPW7Glr8bS1etp6edp6e9r6eNraPG3tnra+nrZ+nrb+rRPek5+78ucKlT+D2o5ORafWYvkdoPB23N//HtQXc/wB0td/4/Vj7X0lKuPlfqq1r9S4sXc/19ZXEJtH90stfSU65YT7dcr7Cqryy/02hX1lyhPkqvt9yvoKPXnv/piSvkLvGnJ/Tn5f2S7Wo/trcvvKdrm23d+T11eimzrh/pmcvrLd1hz376T3VZxI/XK8N01SX9mJ1kLXY9L6Ciahrrqek9JXMEk12jVOvK/0JNZ71zSxvlKTvHe45m77SpUnYx9yLd31lZ2sPc21dt1XOJn7o+vVRV+58mTvta63v69gCvZt18fXVzBFGsC1TdiXm0I94dqr+4qmWJu4vp37Stagc1y/WF+Jck2ayfVvtXn3ov+k1sqJar2o07cJBrQKAubOUVe9OsAPwE2gmwYwqJJ3L3gMGSP22wRRJ95BjUc9nwrHLd6obk+FT1tZYNNVX9mYtnXCp8Kna5V/KhxXSQI3LXABTQeeXHTy8aKZFrgYO3hPa3RH6gfLo1wUxzt9qyDg6eE7Ui6aHrgjzaB8R+IxnAG+I+WiGYzuSP1guHNFD1yRHWnGygKbqXpHmtGzI81Uhx2pH3BHmhG4gGYSmlz0jWAk55mBxayhAb9bTlMpQOgbwUgrMAuwmPnGMKjtcDzHswgomVmMKpm+sPpTSMbxztoqCHhWuJIpJGcFLv7ZlCsZHsPZ4EqmkJxNePEjCugsygvo7OAx7DjQGy8yx+cArr16KuC+MNyFhAeuiAKes1KY56pWwHN6FPBcdVDAuB0ocHMCk3IuoclFL0Qk54HCCjio7XBcHOcQUG9zK1etPC9zG+AtleNzA3N8HuU53pVIQYgfVF/zgjfsermddtheE5bjeOdrFQQ8H9zthOX5gBM4v3K3w2M4P9zthOX5lbsdLnTztuouxguAi3HHgeaMzPEFjbqddhjusOSBK+J2FqoU5oWr3c5CHrezcB3cDm4HCtxCwKRcWGhy0QsRyXkR5UqQi+OCAqp/UeVuh+dlUQO8pXJ8UWCOL6Y8x7sSKUFth0OKlMWN3ttpg+01iU5vfViiVRDwEnC3kwiWAC6CJZW7HR7DJeFuJxEsqdztcKFbvFV3MQ6MuB1kjjujbqcNhrvzr5zvOCB9V7mdRKUwJ6vdTsLjdpJ1cDu4HShwCWBSJoUmF70QkZxTypUgF0cnoPrTyt0Oz0vaAG+pHE8DczyjPMe7EilBbYdDipSsUbfTB7bXRJ3cTtgqCDiEu50oCIGLIKfc7fAY5uBuJwpyyt0OF7psq+5ivJQRt4PM8aWNup0+MNzFurmdZSqFedlqt7OMx+0sWwe3g9uBArcMMCmXFZpc9EJEcl5OuRLk4ri0gOpfXrnb4XlZ3gBvqRxfHpjjKyjP8a5ESlDb4ZAiZUWjbqc3bK/JdHonxkqtgoBXgrudjFsJuAhWVu52eAxXhrudTCfeQY2Hjzei0K3YqrsYr2LE7SBzfFWjbqc3DHembu9SWa1SmFevdjuredzO6nVwO7gdKHCrAZNydaHJRS9EJOc1lCtBLo6rCqj+NZW7HZ6XNQ3wlsrxNYE5vpbyHO9KpAS1HQ4pUtY26nZ64e7thHG867QKAl4Hf28nXAe4CNZV7nZ4DNfF39sJ11XudrjQrd2quxivZ8TtIHN8faNupxcMd5T1wBVxOxtUCvOG1W5nA4/b2bAObge3AwVuA2BSbig0ueiFiOS8kXIlyMVxfQHVv7Fyt8PzsrEB3lI5vjEwxzdRnuNdiZSgtsMhRcqmRt1OK2yvSeXieDdrFQS8GdztpHKbARfB5srdDo/h5nC3k8ptrtztcKHbtFV3Md7CiNtB5viWRt1OKwx3KvTAFXE7W1UK89bVbmcrj9vZug5uB7cDBW4rYFJuLTS56IWI5LyNciXIxXFLAdW/rXK3w/OyrQHeUjm+LTDHt1Oe412JlKC2wyFFyvZG3U4LbK8pdHqSbYdWQcA7wN1Owe0AXAR55W6HxzAPdzuFTryDGg8fb0Sh275VdzEuGHE7yBwvGnU7LTDchbo9yRZVCnOp2u1EHrdTqoPbwe1AgYuASVkSmlz0QkRyLitXglwciwKqf0flbofnZUcDvKVyfEdgju+kPMe7EilBbYdDipSdjbqdZpzbKcbx7tIqCHgXvNsp7gJcBLsqdzs8hrvi3U5xV+Vuhwvdzq26i/FuRtwOMsd3N+p2mnGCuOCBK+J29qgU5j2r3c4eHrezZx3cDm4HCtwewKTcU2hy0QsRyXkv5UqQi+PuAqp/b+Vuh+dlbwO8pXJ8b2CO76M8x7sSKUFth0OKlH2Nup0m3JNshTje/VoFAe+Hf5KtsB9wEeyv3O3wGO6Pf5KtsL9yt8OFbt9W3cX4ACNuB5njBxp1O024h53yHrgibuegSmE+uNrtHORxOwfXwe3gdqDAHQRMyoOFJhe9EJGcD1GuBLk4Hiig+g9V7nZ4Xg41wFsqxw8F5vhhynO8K5ES1HY4pEg53KjbaYTtNWGnN1Af0SoI+Ai42wmDI4CL4EjlbofH8Ei42wmDI5W7HS50h7fqLsaDjLgdZI4fZdTtNMJwZ+v2BuqjK4X5mGq3c7TH7RxTB7eD24ECdzQwKY8Rmlz0QkRyPla5EuTieJSA6j9OudvheTnOAG+pHD8OmOPHK8/xrkRKUNvhkCLlBKNup6eQ2zmxVRDwiQJu50TgIjhJudvhMTxJwO2cpNztcKE7oVV3MT7ZiNtB5vgpRt1OT4Nu59RKYT6t2u2c6nE7p9XB7eB2oMCdCkzK04y4HSTn05UrQS6Opwio/jOUux2elzMM8JbK8TOAOX6m8hzvSqQEtR0OKVLOMup2esD2mnynd7Kd3SoI+Gy428nnzgYugnOUux0ew3PgbiefO0e52+FCd1ar7mJ8rhG3g8zx84y6nR4w3Pm6vZPt/EphvqDa7ZzvcTsX1MHt4HagwJ0PTMoLhCYXvRCRnC9UrgS5OJ4noPovUu52eF4uMsBbKscvAub4xcpzvCuREtR2OKRIucSo22nAuZ1UHO+lrYKAL8W7ndSlwEVwmXK3w2N4Gd7tpC5T7na40F3SqrsYX27E7SBz/AqjbqcBJ4iTHrgibufKSmG+qtrtXOlxO1fVwe3gdqDAXQlMyquEJhe9EJGcr1auBLk4XiGg+q9R7nZ4Xq4xwFsqx68B5vi1ynO8K5ES1HY4pEi5zqjb+bcFtddEne7tXN8qCPh6uNuJctcDF8ENyt0Oj+ENcLcT5W5Q7na40F3XqrsY32jE7SBz/CajbidePIOajqhu93ZurhTmW6rdzs0et3NLHdwObgcK3M3ApLylVWZy0QsRyflW5UqQi+NNAqr/NuVuh+flNgO8pXL8NmCO3648x7sSKUFth0OKlDuMup1/YHtNsRTHe2erIOA74W6nWLoTuAjuUu52eAzvgrudYuku5W6HC90drbqL8d1G3A4yxwcbdTv/wNxOMfLAFXE7QyqF+Z5qtzPE43buqYPb+QfodoYAk/KeVpnJRS9EJOd7lStBLo6DBVT/UOVuh+dlqAHeUjk+FJjj9ynP8a5ESlDb4ZAi5X6jbudv2F7jOt3bGdYqCHgY3O243DDgIhiu3O3wGA6Hux2XG67c7XChu79VdzF+wIjbQeb4CKNu52+Y23F1u7czslKYH6x2OyM9bufBOridv4FuZyQwKR9slZlc9EJEcn5IuRLk4jhCQPWPUu52eF5GGeAtleOjgDn+sPIc70qkBLUdDilSHjHqdv6C7TWFTm7n0VZBwI/C3U4h9yhwEYxW7nZ4DEfD3U4hN1q52+FC90ir7mL8mBG3g8zxMUbdzl8wt1Oom9t5vFKYn6h2O4973M4TdXA7fwHdzuPApHyiVWZy0QsRyflJ5UqQi+MYAdU/Vrnb4XkZa4C3VI6PBeb4U8pzvCuREtR2OKRIedqo2/kTtteEYRzvM62CgJ+Bu50wfAa4CJ5V7nZ4DJ+Fu50wfFa52+FC93Sr7mL8nBG3g8zx5426nT9hbifMeuCKuJ0XKoX5xWq384LH7bxYB7fzJ9DtvABMyhdbZSYXvRCRnF9SrgS5OD4voPpfVu52eF5eNsBbKsdfBub4K8pzvCuREtR2OKRIedWo2/kDttekOrmd11oFAb8Gdzup8DXgInhdudvhMXwd7nZS4evK3Q4XuldbdRfjN4y4HWSOv2nU7fwBczupurmdtyqF+e1qt/OWx+28XQe38wfQ7bwFTMq3W2UmF70QkZzfUa4EuTi+KaD631Xudnhe3jXAWyrH3wXm+HvKc7wrkRLUdjikSHnfqNv5HbbX5Fwc7wetgoA/gLudnPsAuAg+VO52eAw/hLudXCfeQY2Hjzei0L3fqrsYf2TE7SBz/GOjbud3mNvJBR64Im7nk0ph/rTa7XzicTuf1sHt/A50O58Ak/LTVpnJRS9EJOfPlCtBLo4fC6j+z5W7HZ6Xzw3wlsrxz4E5/oXyHO9KpAS1HQ4pUr406nZ+g+012SCO96tWQcBfwd1ONvgKuAi+Vu52eAy/hrudbPC1crfDhe7LVt3F+BsjbgeZ498adTu/wdxOpuyBK+J2vqsU5u+r3c53HrfzfR3czm9At/MdMCm/b5WZXPRCRHL+QbkS5OL4rYDq/1G52+F5+dEAb6kc/xGY4z8pz/GuREpQ2+GQIuVno27nV9xbCjq9gfqXVkHAv8DdTqH0C3AR/Krc7fAY/gp3O4XSr8rdDhe6n1t1F+PfjLgdZI7/btTt/Ip7S0Hd3kD9R6Uw/1ntdv7wuJ0/6+B2fgW6nT+ASflnq8zkohcikvNfypUgF8ffBVT/38rdDs/L3wZ4S+X438Ac/0d5jnclUoLaDocUKf8adTu/wPaaRKd7O+M2SQnA3DnW7SQC7hOFsUcv3W6Hx5AxYt0OJUAv2U0DUej+bdVdjHv2whbjjgPNGZnjjUDO9XQ7v+DeQF23eztNlcLc3Kuhs7Np6jWh2+G/JO12fgG6nSZgUjb3kplc9EJEcm4BFx/0guPi2NgLvzG0Cm9cQW2H43lpNcBbKsdbgTneS3mOdyVSgtoOhxQpvYF5U0+38zNurynG8fbpJQi4D9ztBMU+wEXQptzt8Bi2wd1OUGxT7na40PXupbsYtxtxO8gc72vU7fwMcztBwQNXxO30qxTm/tVup5/H7fSvg9sB7kCuHzAp+/eSmVz0QkRyHqBcCXJx7Cug+qdR7nZ4XqYxwFsqx6cB5vi0ynO8K5ES1HY4pEiZzqjb+Qm212Q6Pck2fS9BwNPD3U6mND1wEcyg3O3wGM4AdzuZ0gzK3Q4Xuul66S7GMxpxO8gcn8mo2/kJ972duj3JNnOlMM9S7XZm9ridWergdn4Cup2ZgUk5Sy+ZyUUvRCTnWZUrQS6OMwmo/tmUux2el9kM8JbK8dmAOT678hzvSqQEtR0OKVLmMOp2foTtNa7TO9nm7CUIeE6423FuTuAimEu52+ExnAvudlwn3kGNh483otDN0Ut3MR5oxO0gc3xuo27nR9yTbHV7J9s8lcI8b7Xbmcfjduatg9v5Eeh25gEm5by9ZCYXvRCRnOdTrgS5OM4toPrnV+52eF7mN8BbKsfnB+b4AspzvCuREtR2OKRIWdCo2/kB9zBGp+/tLNRLEPBCvfD9LqzcoTDvhWPKA9SviKvggrJgL91FbxEjrgKZl4sKF3rEnCwqkOP1LKjfCxXUxXoJAl5MoKAurrygMu/FpxZUWF9LGCmoyLxcUnlB5TlZ0nhB/a4FNx5xvEEvQcCBwGINgMnmlBdnHkMnYO+d8uvxFgp9wkihR+Z4UvklEp6TpMB6SSm/DMh1IiUk4qTyMgXMy7TyvOyqngW1HQ5ZzzLKc5znOCNg0JB52NTQWQzGz7O8PvkvNDbURzFmgRPaM4YzrBSaXPWNQv5gUFVbrtIWP9A3CrPAGQwnva/iRPpyOfDFcA7f3euGyRzPieFuEEzKEDgm8UW0VHUyLtVrwlVWnXjIZJkIVjcxMksBk3jpXrBkCOJjuvQkLOZaseeA44Ac02UmY0wn9rPiY7pMrGj2io1nfEyD2g73T/f9JYpll0yXsukgk0+lo0wyESWyQZRKlx0BTuRSNDTlYiqMwkSynMgmiv9g8f0vxzoKW8dG8k/D+A2Ez5elP5ejWL7Xf4WwXtddlovNuwuTiUQ2yfkRRqQcItoCEomokAqKQb6YKOVSLldOJVLJYlQsUC7lXTko54u5cvhfX3G8K/SSBOzRmrWCXwGosVdUft2Fx3BFj9asdQxXBCuC5ob6PM+2nNDjIA3Y8e2kCFaKCwD0BQHgRLr4bhAHPZmYi5OSfCtNgQmd2KCvBFzMK4PlYce4rhxTLpObCyTdXNEF5SCXCPJBtpjJFnJRohDmy8lyOhklp3RcJ5bsyHFdRWhcV6mMaz19LbIYxYvnqpUdeTVegxIFYyWBqxcrKb+SP6WLI5gM3rViXF35lS9OzNUFrmqvIVQU1uim2Aa1HW41obFYU2gs1qxh45kYZqm8GDjg/7SmTPS6mlQOzD1Adx1YrsIbXUuB8+2QY/j/yjXPVYWuea7VncMJajvc6kIFca1uHM5EupnoNVTGvJZAYZgHXBg6jqbJnLPJETK1cl67l84Cg5yLeF6u7bm2PbnzM7ExR87POvHrkskkrY0o68pROZnO5hIFl0lmMuVUOZsJU1E5ncpH2ZJL5ZOJXCkblF1Yoqu9yWI2U85FxUw5XrRdlEymolyh6NKJTL4QhFEyH5RT2SSZ3yiZjaJkmMnkk8koE5bDHBlWssFhkM5mc0EmkcwlpOZnnZjTRG0KE7uyEe/TyqawrsVNYV3hTWFdgU1hXiWbQpdJnP3fd1/LyKKzntJNYV6horMeYFOY2GU+5Pysr3RTkJqf9f8fuvy4QeXy44a+y49BbUeX1/6R90Fq7Qt4KVPkIb6OMUQ/8SA1hrX2tZHy+eAFs5HAxr6xkMjZWPCy6IZCY7GJ0FhsInhZVCov5ld+WVQqBxYwcFl0I4mHq4ECdYGpl0Wrj//Vb9SYxIXfppIOeCOhgripoANmzJsKFIYFjVwW3QgoijbrpbPALCjksDarw2VR5PxsDnTACwAdsNT8bO6ZH/QDXsj52UKofm4BGIeJXalBjsOWQuOw5SRcJte8kXvgwvI4LhK2sigSthIWCVsJiISF6iQSanw6Flrktgb2hRQJCwltQltPgkio9Slb5Pxs0wu3sSNFgtT8bCN45Wlh6mPhBnzd2Fb5Q5nMeVuBerkdIM//e+ttWYQ349tOgPf2yuebOW8vwHsH5bwZ3w4CvPPKeTO+vADvgnLejK8gwLuonDfjKwrwjpTzZnyRAO+Sct6MryTAu2xgHysL8N5ROW/Gt6MA750MzPdOArx3Vs6b8e0swHsX5bwZ3y4CvHdVzpvx7SrAezcD63s3Ad67K+fN+HYX4L2Hct6Mbw8B3nsq58349hTgvZdy3oxvLwHeexuoa3sL8N5HOW/Gt48A732V82Z8+wrw3k85b8a3nwDv/Q2s7/0FeB+gnDfjO0CA94EG5vtAAd4HKefN+A4S4H2wgfk+WID3Icp5M75DBHgfqpw34ztUgPdhynkzvsMEeB9uYH0fLsD7COW8Gd8RAryPNDDfRwrwHqScN+MbJMD7KAPzfZQA76OV82Z8RwvwPkY5b8Z3jADvY5XzZnzHCvA+zsD6Pk6A9/HKeTO+4wV4n6CcN+M7QYD3iQby/EQB3icp5834ThLgfbKB+T5ZgPcpynkzvlMEeJ9qYL5PFeB9mnLejO80Ad6nK+fN+E4X4H2Gct6M7wwB3mcq5834zhTgfZZy3ozvLAHeZxuo52cL8D5HOW/Gd44A73OV82Z85wrwPk85b8Z3ngDv8w2s7/MFeF+gnDfju0CA94UG5vtCAd4XKefN+C4S4H2xct6M72IB3pco5834LhHgfaly3ozvUgHelxmoa5cJ8L5cOW/Gd7kA7ysMzPcVAryvVM6b8V0pwPsq5bwZ31UCvK82kOdXC/C+RjlvxneNAO9rlfNmfNcK8L5OOW/Gd50A7+uV82Z81wvwvkE5b8Z3gwDvG5XzZnw3CvC+STlvxneTAO+blfNmfDcL8L7FgG65RYD3rcp5M75bBXjfppw347tNgPftBvL8dgHedyjnzfjuEOB9p3LejO9OAd53KefN+O4S4H23gfV9twDvwcp5M77BAryHGJjvIQK871HOm/HdI8D7XuW8Gd+9AryHGsjzoQK871POm/HdJ8D7fgPzfb8A72HKeTO+YQK8hxuY7+ECvB9QzpvxPSDAe4Ry3oxvhADvkcp5M76RArwfVM6b8T0owPsh5bwZ30MCvEcZqOejBHg/rJw343tYgPcjynkzvkcEeD9qIM8fFeA9WjlvxjdagPdjynkzvscEeI9RzpvxjRHg/bhy3ozvcQHeTyjnzfieEOD9pHLejO9JAd5jDexjYwV4P6WcN+N7SoD308p5M76nBXg/o5w343tGgPezynkzvmcFeD9noK49J8D7eeW8Gd/zArxfUM6b8b0gwPtFA3n+ogDvl5TzZnwvCfB+2cB8vyzA+xXlvBnfKwK8X1XOm/G9KsD7NQN5/poA79eV82Z8rwvwfsPAfL8hwPtN5bwZ35sCvN9SzpvxvSXA+20Def62AO93lPNmfO8I8H7XwHy/K8D7PeW8Gd97ArzfV86b8b0vwPsDA3n+gQDvD5XzZnwfCvD+SDlvxveRAO+PlfNmfB8L8P5EOW/G94kA70+V82Z8nwrw/kw5b8b3mQDvz5XzZnyfC/D+wsD+/YUA7y+V82Z8Xwrw/srAfH8lwPtr5bwZ39cCvL9RzpvxfSPA+1vlvBnftwK8v1POm/F9J8D7e+W8Gd/3Arx/UM6b8f0gwPtH5bwZ348CvH8ysH//JMD7Z+W8Gd/PArx/Uc6b8f0iwPtXA3n+qwDv35TzZny/CfD+XTlvxve7AO8/DOT5HwK8/1TOm/H9KcD7LwPz/ZcA77+V82Z8fwvw/kc5b8b3jwDvf5XzZnz/CvBu6K2bN+PjQPPuoZw34+shwLunct5cz3sK8G5UzpvxNQrwblLOm/E1CfBuNpDnzQK8W5TzZnwtArxbDcx3qwDvXsp5M75eArx7G5jv3gK8+yjnzfj6CPBuU86b8bUJ8G43kOftArz7KufN+PoK8O6nnDfj6yfAu79y3oyvvwDvAQbW9wAB3tMo5834phHgPa1y3oxvWgHe0xnI8+kEeE+vnDfjm16A9wzKeTO+GQR4z6icN+ObUYD3TMp5M76ZBHjPrJw345tZgPcsynkzvlkEeM9qYB+bVYD3bMp5M77ZBHjPbmC+ZxfgPYdy3oxvDgHecyrnzfjmFOA9l3LejG8uAd4DDazvgQK851bOm/HNLcB7HgPzPY8A73mV82Z88wrwns/AfM8nwHt+5bwZ3/wCvBcwMN8LCPBeUDlvxregAO+FDMz3QgK8F1bOm/EtLMB7EeW8Gd8iArwXNZDniwrwXkw5b8a3mADvxZXzZnyLC/BeQjlvxreEAO8llfNmfEsK8A6U82Z8gQBvZ6CeOwHeCeW8GV9CgHdSOW/GlxTgnVLOm/GlBHinDazvtADvjHLejC8jwDurnDfjywrwDpXzZnyhAO+cct6MLyfAeynlvBnfUgK8lzZQz5cW4L2Mct6MbxkB3ssamO9lBXgvp5w341tOgPfyBuZ7eQHeKyjn/T98ArxXNDDfKwrwXkk5b8a3kgDvlZXzZnwrC/BeRTlvxreKAO9VDazvVQV4r6acN+NbTYD36gbme3UB3mso58341hDgvaZy3oxvTQHeaxnI87UEeK+tnDfjW1uA9zoG5nsdAd7rKufN+NYV4L2egfleT4D3+sp5M771BXhvoJw349tAgPeGynkzvg0FeG9kYH1vJMB7Y+W8Gd/GArw3Uc6b8W0iwHtTA3m+qQDvzZTzZnybCfDe3MB8by7AewvlvBnfFgK8tzQw31sK8N5KOW/Gt5UA762V82Z8Wwvw3kY5b8a3jQDvbZXzZnzbCvDeTntdI3zbCfDe3kA9316A9w7KeTO+HQR455XzZnx5Ad4F5bwZX0GAd9HA+i4K8I6U82Z8kQDvknLejK8kwLusnDfjKwvw3lE5b8a3owDvnQzUtZ0EeO+snDfj21mA9y7KeTO+XQR472ogz3cV4L2bct6MbzcB3rsr5834dhfgvYdy3oxvDwHeeyrnzfj2FOC9l3LejG8vAd57G6jnewvw3kc5b8a3jwDvfQ3M974CvPdTzpvx7SfAe38D872/AO8DlPNmfAcI8D7QwHwfKMD7IOW8Gd9BArwPNjDfBwvwPkQ5b8Z3iADvQ5XzZnyHCvA+TDlvxneYAO/DlfNmfIcL8D5COW/Gd4QA7yMN1PMjBXgPUs6b8Q0S4H2Ugfk+SoD30cp5M76jBXgfY2C+jxHgfaxy3ozvWAHexxmY7+MEeB+vnDfjO16A9wkG5vsEAd4nKufN+E4U4H2Sct6M7yQB3icbyPOTBXifopw34ztFgPepynkzvlMFeJ9mIM9PE+B9unLejO90Ad5nGJjvMwR4n6mcN+M7U4D3Wcp5M76zBHifrZw34ztbgPc5Btb3OQK8z1XOm/GdK8D7POW8Gd95ArzPV86b8Z0vwPsCA+v7AgHeFyrnzfguFOB9kYH5vkiA98XKeTO+iwV4X2Jgvi8R4H2pct6M71IB3pcZmO/LBHhfrpw347tcgPcVBub7CgHeVyrnzfiuFOB9lYH5vkqA99XKeTO+qwV4X6OcN+O7RoD3tcp5M75rBXhfp5w347tOgPf1ynkzvusFeN+gnDfju0GA943KeTO+GwV436ScN+O7SYD3zcp5M76bBXjfopw347tFgPetynkzvlsFeN+mnDfju02A9+3KeTO+2wV436GcN+O7Q4D3ncp5M747BXjfpZw347tLgPfdynkzvrsFeA9WzpvxDRbgPUQ5b8Y3RID3Pcp5M757BHjfq5w347tXgPdQ5bwZ31AB3vcp58347hPgfb9y3ozvfgHew5TzZnzDBHgPV86b8Q0X4P1Ab1xfTdRHe4x7/ECPxwPA+YrjHdFbEPCI3vh+RwInUIr3yN7jBxjUr9hNSYmbsQ+Ci0vH0bOafyYRplJhIlnIZxMunypkM+VcVMyXE2EhEeWDUhhkomwinwzzYcoVivkwKET5RDob5VOljEsgc+mhWF/0E4tBrhzk02E+W6KOglJAJ4WwVM4k8oViKkhEzrlSiv4vUYpSuUKUcYUM/fR0wdG/8811olDMZbJZ+pfFqJBKuXQukY8KLuuYfKocZpMFV0gS1GQ2XU6UyqkgR4NBNMs0BMlC6epKXk4whqlcvkTdFpKZZKlAYMuJdCafo39VzJSSmVSBxzedTJQzqSSNWyJIpvLlYiodBrlEWEylrgaO4SjlmxLjGyWwXh5WzpvxPSzA+xHlvBnfIwK8H1XOm/E9KsB7tHLejG+0AO/HlPNmfI8J8B6jnDfjGyPA+3HlvBnf4wK8n1DOm/E9IcD7SeW8Gd+TArzHKufN+MYK8H5KOW/G95QA76eV82Z8TwvwfkY5b8b3jADvZ5XzZnzPCvB+TjlvxvecAO/nlfNmfM8L8H5BOW/G94IA7xeV82Z8Lwrwfkk5b8b3kgDvl5XzZnwvC/B+RTlvxveKAO9XlfNmfK8K8H5NOW/G95oA79eV82Z8rwvwfsPoTd03hG7qvtlbEPCbAjd131J+U5d5v9V7/ACD+hXByjdfHxJYZG/X6aZurTc6kbn0Tm/cjVLfXLtyuVjORtlSOZlIFLPZQjZZTKcLxSLdsC4UHDVFYY4GgFqDLP2URDYTJsNksRgUXCYq/++G6Vuem7ouyGTTmVy+TD+AxiQROJcslcvEn/qLUvlMkC6kE4VMMsqEZaLlijQCUTqbKKdKuYRLjAKO4bvKNyXG967AenlPOW/G954A7/eV82Z87wvw/kA5b8b3gQDvD5XzZnwfCvD+SDlvxveRAO+PlfNmfB8L8P5EOW/G94kA70+V82Z8nwrw/kw5b8b3mQDvz5XzZnyfC/D+QjlvxveFAO8vlfNmfF8K8P5KOW/G95UA76+V82Z8Xwvw/kY5b8b3jQDvb5XzZnzfCvD+TjlvxvedAO/vlfNmfN8L8P5BOW/G94MA7x+V82Z8Pwrw/kk5b8b3kwDvn5XzZnw/C/D+RTlvxveLAO9fjd7c/FXo5uZvvQUB/yZwc/N35Tc3mffvvccPMKhfEax8E/IdgUX2R51ubtZ6ww+ZS3/2xt0w9M51uhyUy4VsvlQspUvJvMsU0qlEOpUPM6VUIQzzURAl6W+UCuVErpRIpLOOflA6ncyG2WKxFL5bycsJbhDns8lUqVBIJjLJlCuV8y5XCJIZF+VcMihGqWwhkSlkU2FIN2ajRKZUKlJjme7ZhlkaEZd/FziGfynflBjfXwLr5W/lvBnf3wK8/1HOm/H9I8D7X+W8Gd+/Arwb+ujmzfg40Lx7KOfN+HoI8O6pnDfj6ynAu1E5b8bXKMC7STlvxtckwLtZOW/G1yzAu0U5b8bXIsC7VTlvxtcqwLuXct6Mr5cA797KeTO+3gK8+yjnzfj6CPBuU86b8bUJ8G5XzpvxtQvw7qucN+PrK8C7n3LejK+fAO/+ynkzvv4CvAco5834BgjwnkY5b8Y3jQDvaZXzZnzTCvCero/Nm3zTAecrjnf6PoKAp++D73cG4ARK8Z6hz/gBBvUrgpVvxv0pcDF3RnBx6Tiqb1DVeuMLmUsz9cHdOPPNNd2pTOUT+UKa/mqqnM4m6b6mox8RlOl2JoNJRukonwtShWQmlSsXEtlCMUgWAv555UI+yzenmO8EY1jMlfOFYjZMpaN0QDTTiVIiHySzrkgD4soulS4FUSFMlEKik8u4YiJddqUk3TIt8AD9BbzJN7PyTYnxzSywKc2inDfjm0WA96zKeTO+WQV4z6acN+ObTYD37Mp5M77ZBXjPoZw345tDgPecynkzvjkFeM+lnDfjm0uA90DlvBnfQAHecyvnzfjmFuA9j3LejG8eAd7zKufN+OYV4D2fct6Mbz4B3vMr58345hfgvYBy3oxvAQHeCyrnzfgWFOC9kHLejG8hAd4LK+fN+BYW4L2Ict6MbxEB3osq5834FhXgvZhy3oxvMQHeiyvnzfgWF+C9hNGbXUsI3exaso8g4CUFbnYFym92Me+gz/gBBvUrgpVvSs0ksMhcnW521XoDCJlLiT64G0i+uU6U0sl0EJTDTLYY0V2yFN80y6TSxXQ6KmQTycjRvbVEEKYzUSHKZl1YyqUKQUgDky0n6Q7fzJW8nOBmV8IF5VImmc4XUsVsKqK7cIViORsUigm6e5jMpTNhQKiDRCKKcjlXptuJUSodZPIFak/nopmBY5hUvikxvqTAekkp5834UgK808p5M760AO+Mct6MLyPAO6ucN+PLCvAOlfNmfKEA75xy3owvJ8B7KeW8Gd9SAryXVs6b8S0twHsZ5bwZ3zICvJdVzpvxLSvAeznlvBnfcgK8l1fOm/EtL8B7BeW8/4dPgPeKynkzvhUFeK+knDfjW0mA98rKeTO+lQV4r6KcN+NbRYD3qsp5M75VBXivppw341tNgPfqynkzvtUFeK9h9KbPGkI3fdbsIwh4TYGbPmspv+nDvNfqM36AQf2KYOWbMwmBRbZ2vW761HgjBJlL6/TB3UjxzTWBKLhyopgoJ8MioSrl8+Vsplwup/NBlEllk0WXK+ZSSbqplA9TUTpHP9hlk1EqKmUKhTCVrORl9Ri6fJRLlFMZ6jyMcnkayHxQLBHvQikIEy5dKrq8Kwc00LlSqVCgW2WZKCqlM/mEy9E4lpLAMVxX+abE+NYVWC/rKefN+NYT4L2+ct6Mb30B3hso5834NhDgvaFy3oxvQwHeGynnzfg2EuC9sXLejG9jAd6bKOfN+DYR4L2pct6Mb1MB3psp5834NhPgvbly3oxvcwHeWyjnzfi2EOC9pXLejG9LAd5bKefN+LYS4L21ct6Mb2sB3tso5834thHgva1y3oxvWwHe2ynnzfi2E+C9vXLejG97Ad47KOfN+HYQ4J03evMjL3Tzo9BHEHBB4OZHUfnND+Zd7DN+gEH9imDlmxTrCCyyqE43P2q9IYDMpVIf3A0F31y7RDZTTJUTyWSQLiYD4pkoJYN8tlwohelCFBTLyVIpEQX5crrskgTAuVw2CqJykpDko/K6lbycYAyjUhTmwiBfShSiyOVTiQQhDKjTXFguhsV0WE4H6Wy2mE/n08VSspAohtkwTJeLUVBIJ5LrAsewrHxTYnxlgfWyo3LejG9HAd47KefN+HYS4L2zct6Mb2cB3rso5834dhHgvaty3oxvVwHeuynnzfh2E+C9u3LejG93Ad57KOfN+PYQ4L2nct6Mb08B3nsp58349hLgvbdy3oxvbwHe+yjnzfj2EeC9r3LejG9fAd77KefN+PYT4L2/ct6Mb38B3gco5834DhDgfaBy3ozvQAHeBynnzfgOEuB9sNGbAAcL3QQ4pI8g4EMEbgIcqvwmAPM+tM/4AQb1K4KVL9aXBBbZYfW6CVDjhXFkLh3eB3dh3TvX+TTdN4hclE0kiuViJse/3SZfLmb5xkc6ncsWCCL9lFxULCYLZfq7OfqwlM8Vi9R5vlCu5GX1GCYyLpGO8i7IB6UoyCQT2XQQ5gv5IBM5GsxkvphxGWqOCqUomcqV00liE+Vz6WQymQ3T2TJwDI9QvikxviME1suRynkzviMFeA9SzpvxDRLgfZRy3ozvKAHeRyvnzfiOFuB9jHLejO8YAd7HKufN+I4V4H2cct6M7zgB3scr5834jhfgfYJy3ozvBAHeJyrnzfhOFOB9knLejO8kAd4nK+fN+E4W4H2Kct6M7xQB3qcq5834ThXgfZpy3ozvNAHepyvnzfhOF+B9hnLejO8MAd5nGr0YfqbQxfCz+ggCPkvgYvjZyi+GM++z+4wfYFC/Ilj5ovXhAovsnDpdDK/1AjEyl87tg7vA7J3rUpDMZFMluniejtJRNpMpRoUEXf3Pl+k2QCpbzpZcLggy5UwmkcilM6VsMZUrulRYKga5ZCp9RCUvJ7gYnsgERDsVplIFujifSLswkUumk7lMWErlXJruMyTSYcqFyXQ2lU3SxXsX0ciWMy5ZzhQL0RHAMTxP+abE+M4TWC/nK+fN+M4X4H2Bct6M7wIB3hcq5834LhTgfZFy3ozvIgHeFyvnzfguFuB9iXLejO8SAd6XKufN+C4V4H2Zct6M7zIB3pcr5834LhfgfYVy3ozvCgHeVyrnzfiuFOB9lXLejO8qAd5XK+fN+K4W4H2Nct6M7xoB3tcq5834rhXgfZ1y3ozvOgHe1xu9KHy90EXhG/oIAr5B4KLwjcovCjPvG/uMH2BQvyJY+eLtuQKL7KZ6XRSu8UIpMpdu7oO70Oqba5cJMzlXTOYz+VSaOkoXU6ViqZAvForZcj4oZxLFZLqcymXogxxda6Zr4IVkukQwkolkOZE4r5KX1WPoclFEIMvJfBilMkWXLgYumykXCulCLl1KRcV0NgjDcpmgpSJXiMJUMVMo59PZqBgVaQLOA47hLco3JcZ3i8B6uVU5b8Z3qwDv25TzZny3CfC+XTlvxne7AO87lPNmfHcI8L5TOW/Gd6cA77uU82Z8dwnwvls5b8Z3twDvwcp5M77BAryHKOfN+IYI8L5HOW/Gd48A73uV82Z89wrwHqqcN+MbKsD7PuW8Gd99ArzvV86b8d0vwHuYct6Mb5gA7+FGL44OF7o4+kAfQcAPCFwcHaH84ijzHmHk4ihfxLxZYJGNrNPF0VovGCJz6cE+uAuOvrl21FEiCLPJXJr+YiJD/7JcCEvlXD6boIu/eaIUlAu5ciJJPMph0hXprxLlhMsG+ayLbqnk5QRjWCiHiYgGLRtlU7mARoywFYt0ITkoZRxdZE67RKmYp0vL6XTCBaVENlOi8QiLpbCcDkvpW4Bj+JDyTYnxPSSwXkYp5834Rgnwflg5b8b3sADvR5TzZnyPCPB+VDlvxveoAO/RynkzvtECvB9TzpvxPSbAe4xy3oxvjADvx5XzZnyPC/B+QjlvxveEAO8nlfNmfE8K8B6rnDfjGyvA+ynlvBnfUwK8n1bOm/E9LcD7GeW8Gd8zAryfNXqR8Fmhi4TP9REE/JzARcLnlV8kZN7PG7lIyBfzHhRYZC/U6yJhjRfOkLn0Yh/chTffXCfK2XSOegyz+XIhUUqlk4V0mCmHdC20nC2kS85lCmGYoE7DVDnhktlEtpzJlZ1L098spgoPVfKy5wQ5VCoVEsVCOhe6UpRKZ1K5fKFUiEpB6KIiXcjMFMNM4KJSKpnKlrJR5DKJsJBPRPl8MZUsZB8CjuFLyjclxveSwHp5WTlvxveyAO9XlPNmfK8I8H5VOW/G96oA79eU82Z8rwnwfl05b8b3ugDvN5TzZnxvCPB+UzlvxvemAO+3lPNmfG8J8H5bOW/G97YA73eU82Z87wjwflc5b8b3rgDv95TzZnzvCfB+Xzlvxve+AO8PjF4s+0DoYtmHfQQBfyhwsewj5RfLmPdHRi6W8UWtFwUW2cd1ulhW6wUkZC590gd3Aco718lUmA+DZJgtlYvJXFjIRPyMYNFlc+lEMYwSmSBXKLlCMswnI7qAmMvno1wxl8m7KOeSQfalSl5OMIaRK+QzGaKSImw5F7gs/a+cz+RKxUQhCoJEIk//i1I0avkgyOX5e9phOUqVEplSsVx4CTiGnyrflBjfpwLr5TPlvBnfZwK8P1fOm/F9LsD7C+W8Gd8XAry/VM6b8X0pwPsr5bwZ31cCvL9WzpvxfS3A+xvlvBnfNwK8v1XOm/F9K8D7O+W8Gd93Ary/V86b8X0vwPsH5bwZ3w8CvH9Uzpvx/SjA+yejF41+Erpo9HMfQcA/C1w0+kX5RSPm/YuRi0Z8cecTgUX2a50uGtV6IQWZS7/1wV2I8c51ohiVw4RzyXS2UMiHuVzgyslyKZvMp+iSWSpLJPO5TDagK1XFNJ8ms+Vk5MJSmMy5bPRpJS8nvGiUy6QzaVeMolwpFTpXTpXSrhAGUVTM0+gWUoSuVHLZVCLI50uZPF3ZClwxkXHZYqYUpj8FjuHvyjclxve7wHr5QzlvxveHAO8/lfNmfH8K8P5LOW/G95cA77+V82Z8fwvw/kc5b8b3jwDvf5XzZnz/CvBuaNPNm/FxoHn3UM6b8fUQ4N1TOW/G11OAd6Ny3oyvUYB3k3LejK9JgHdzm82LJ83A+YrjbWkTBNzShu+3FTiBUrxb28YPMKhfEax8keM3AfHQC1xcOo4JLp7UeEEBmUu923AXJHxznSiXU/lkIpcIi9myK2YLYTKRzpdKQVgslV3JpdMuW05l0qUC/UEUyrlkRFdmMulUin8lboJNP/OdYAyDTDlfSBHfTI6gJAJ+EihfDLNhIZHJZAtR0hXKyVIiLCXpck82k8rn+S9HuUIhos86XfCodQz7KN+UGF8fgU2pTTlvxtcmwLtdOW/G1y7Au69y3oyvrwDvfsp5M75+Arz7K+fN+PoL8B6gnDfjGyDAexrlvBnfNAK8p1XOm/FNK8B7OuW8Gd90ArynV86b8U0vwHsGoxcRZhC6iDBjmyDgGQUuIsyk/CIC857JyEUENvu9BRbZzHW6iFCrsUbm0ixtOGPum+tENpnIhlExSNLlhrLLFzLZRDadSoSpRIaYJwsulciWQhfkC+koFYWJbC4fBglXKheiRKEY9qnk5QQXEXJJ/hWFmaiUKEcuKBPUKAqyyTKNVC7I57KZssvkivRHkCR8OVdMZbPpLHFKJaJUMt8HOIazKt+UGN+sAutlNuW8Gd9sArxnV86b8c0uwHsO5bwZ3xwCvOdUzpvxzSnAey7lvBnfXAK8ByrnzfgGCvCeWzlvxje3AO95lPNmfPMI8J5XOW/GN68A7/mMmun5hMz0/G2CgOcXMNMLKDfTzHsBI2aaTe8sAotswXqZ6RoNJjKXFmrDGVTfXCfIjruwVEplM8VcoVwKUvzbqaJSVEwVyvlSIVPOEiVy4ulEKlsuZrLJKJsr5vLZXCYducT/jOoCPjOdyOaT6TCVyxWJcKJQSFFLOcrm08l0Osq6Qlh0iaLLZlO5VDko5qMgyKfDMnHI5ROlUmJW4BgurHxTYnwLC6yXRZTzZnyLCPBeVDlvxreoAO/FlPNmfIsJ8F5cOW/Gt7gA7yWU82Z8SwjwXlI5b8a3pADvQDlvxhcI8HbKeTM+J8A7YdRUJoRMZbJNEHBSwFSmlJtK5p0yYirZ/C0ksMjS9TKVNRotZC5l2nBGzTfXiRzBTxVc1rlcuci/1CTnwlxI/7acK2WyuVKJWJXCbBSUMrmwlEm6UpguFxLJZOTy5F4XruTlBKYyQ743R2ACl82nEkGpUCgVioQ5CLNZV0om+c2VuWKQDyO6mZwvOFfO5dIlR3+nlM65xMLAMcwq35QYX1ZgvYTKeTO+UIB3TjlvxpcT4L2Uct6MbykB3ksr5834lhbgvYxy3oxvGQHeyyrnzfiWFeC9nHLejG85Ad7LGzVXywuZqxXaJAELmKsVlZsr5r2iEXPFJigjsMhWqpe5qtFwIHNp5TacYfHNdcKlMhmXTpbyqXw2KEaFMEfqL08urpRJu1I2FQTJQinIZKMUYXOFQj5PdwHLiXxYLuXDZCpbycsJzFXZkRulm5gZIl9OF8o0kIliUIqiXIF6S5fCZJDIp1y5mA0JbDrMJfPZct6liFw6WyxlgWO4ivJNifGtIrBeVlXOm/GtKsB7NeW8Gd9qArxXV86b8a0uwHsN5bwZ3xoCvNdUzpvxrSnAey3lvBnfWgK81zZqMtYWMhnrtAkCXkfAZKyr3GQw73WNmAw2AysLLLL16mUyahTeyFxavw0n3H1znQgLyTDnXLLgIldMpIrZYj6RzhRKiRTd/ckXixlily6nXCITZkuZIFtIlXJ856iQzvOvqF+lkpcTmIxsISimM2S6XCpMBXRHKczQva18rpzMlMsE12VzqUQ6RbCDciIZFAlsxuVcln5sNp/NrAIcww2Ub0qMbwOB9bKhct6Mb0MB3hsp5834NhLgvbFy3oxvYwHemyjnzfg2EeC9qXLejG9TAd6bGRXbmwmJ7c3bBAFvLiC2t1Autpn3FkbENovi9QUW2Zb1Ets1ClBkLm3VhhOwvrl2uWzkgmw6SQ4il6H/CKmzlMvlcomQVHoU5DNhLlFKFhPFbCJFdxIyUTJPdzOS6UyilC3/Tyhu4RHbjgxBMipHeX6TRi7nonK6WKLbEXTvI0ccAxcVC+l0JlXIlHmAczm6PUKmoFjI5yIaGrcBcAy3Vr4pMb6tBdbLNsp5M75tBHhvq5w349tWgPd2ynkzvu0EeG+vnDfj216A9w5GRecOQqIz3yYIOC8gOgvKRSfzLhgRnSwOtxJYZMU6ic5ahRgyl6I2nJDzzbUrpopJktQkX3O5IE1Xj4NkJp8KkllqzmfyJRdGLkqk0omIOo5IZqeK5XxYikrZoBwVw60reTnBGKboJ6ZSUboQhEG5mGftHhWymVSuQPgJXyafKRYSqUSmlEykCqWokEuRbk47F5aDRDK/NXAMS8o3JcZXElgvZeW8GV9ZgPeOynkzvh0FeO+knDfj20mA985GxdfOQuJrlzZBwLsIiK9dlYsv5r2rEfHFIikSWGS71Ut81ShIkLm0extO0PjmOpHJkVrMF+laYoYuJ2YTLgoT6Xwuyc8Cp+nKZ9EVXDJRLGcSdDUzy9cZ6RJjKiikUvlSlEyUKnk5we31XDFN/yxD/Au5ZMSPRYcJ0pKpbDEoJPK5XJEGkX+JTzIslejKarJUilL0T5KFQtolok6CqdYx3EP5psT49hBYL3sq58349hTgvZdy3oxvLwHeexsVIXsLiZB92gQB7yMgQvZVLkKY975GRAiLhd0FFtl+9brtWOPGjMyl/dtwG7t3rukqEvELivlMuhSQbCnQz89kg1KRVBdd7ApLxXSpmMlmEpl8NlWmK1/FYqlQpH9QJsTl7B6VvJxgDF0QJuhurSNZVCinSq6YKdEw0aWqKEoHYTGXy0Rl+ll0T7RULuTCgnNp4kfyiQYsExT2AI7hAco3JcZ3gMB6OVA5b8Z3oADvg4xuxgcJbcYHtwkCPlhgMz5E+WbMvA8xshnzprm/wCI7tE6bca0bFDKXDmvDbXDeuU4ng4h+rguzdOkg4J5T+WyYKeUjl8klMlE64u4IbT6RyYSZfDmdSoUpuhuVSuRdmDigkpcTbMaFZDIbEURSLqlyIlEqEsFSopyjHkp0dyudyCSyyUymHLpskA9Iy4R0VSOVJ50TpUthpw201jE8XPmmxPgOF1gvRxjdlI4Q2pSObBMEfKTApjRI+abEvAcZ2ZR48zhMYJEdVa9NqcZCjcylo9twhX5S5rqQLKaibC5KuXzOZdNhsZDKFZNply3StpbKpxO085ZdIpkJwnIxVyweXsnLnhOZ6yAVFjIlR8SiMOVoCIqlfCJVzpQjQlwoFRNJfgFilnrN0j2BZOZw4BgeY7Q4HyNUnI9tEwR8rEBxPk55cWbexxkpzlxEjxYozsfXqzhXHZNbsJC5dEIbruD55hoxJycIzPWJ8XunYTJBuw7/vTAKXCoqJsJEIiqkArqcWkyUcimXK6cSqWQxKhaoz7wrB+V8MVcO/+urngX1RKGCelKbIOCTBArqycoLKvM+WaCgcrI1N4wvKr6j42fVmtgS49KxoNHjEk/mU2L5Bq8cJ+NWoGNsjRWMHaCbYm1dcQhqO8QmIZ6Up1b6P415SUzCKQJV5RThiz8o3hOTFJN5dOJdK8bTlV9A48Q8XUBSnAHemjuKAPc7qNIveixOExqLM4XG4kzBsZCSmmcprylS62HhAf+nvIsTwSeW+4sM0F3/mPNZAnsIcL4dcgxZUHFMimKeWF8Ty6l4nxL7FmpM4uLy7O7UclDb4U4X2gjioCcTs5vYz2HMZwsUhsXAhaHjaJrMOZscAVcr53PadBYY5FzE8/KcmECZ0vmZ2Jgj5+fc+HWwZJLWRpR15aicTGdziYLL8L2YVDmbCVMR3SLKR9mSS+WTiRx/nYF/UVQ2neRf5ZuLiplyvGi7KJlMRblC0dEtnXwhCKNkPiinsslEkI/oFlCUDDOZfDIZZcJymKOrEvlyMgzS2WwuyCSSuYTU/JzrmZ/J3QgndtkEOT/nCdXP8wDjMLHLS8hxOF9oHM6vjEN3IkHzRu6BC8vjuEi4wKJIuEBYJFwgIBIWr5NImJh7qmeRuxDYF1IkLC60CV04CSJhYuPg+MuULigHOdpRg2wxky3kokQhpH20nE5GSeT8XNSG29iRIkFqfi6q4SrTxNZNxxXcRux6nJz7YRPtC3k1+OI27IbUMUcX1zBHExMuUzhHE12Tk3PPcmJ9Iefokjbc2MXn6JKYuKq+pdUwhXM3MXjIq61xMXhp5XbWZb7bWUFth+vqtg7yXmWtfQFvjXlf9RPUdrgpXbT/V2NYa1+XK58PXjCXCwjkK4TMwhWCt5YuExqLK4XG4spuxqJWzFJ5saTy201SORAov910VoU3+nYTcL5dMPV2U/Xxv/qNGpO48LtK8krS5UIF8SrBK0mM+SqBwuCM3G66HCiKrm7TWWCc0JWKq+twuwk5P9cAbzcFwCtJUvNzzSTcXmiYzPmalKd2Ow4rm8K1FjeFa4U3hWsFNoWEkk2hyyTOlv93IIvOdUo3hYRQ0bkOsClM7DIfcn6uV7opSM3P9bFNoV7fG4pfFq3xayEujveGNkHAN3hsY63gbwAWgxuBi0BqDG/0bCK1juGNwk80B7Ud/9vwbxS4FIwsesjcuQl8KbjjQN+OOAvI+WblT9V3lYNBbQdSzELr1y3g+UBfLuTcA2J0vOZuFhDot4LNSq+G8TnI/70wxT+Vc/5Z/2DH+X8/s2fs54W9xv+8XOX8Nvq5t1Pc0SEeYn8fOed3AMeSxVrf2FhK4r5NyQOC3R8Jub7d+KsD/OfAyvmdNC53UdxNMZhiCMU9FPdSDKW4j+J+imEUwykeoBhBMZLiQYqHKEZRPEzxCMWjFKMpHqMYQ/E4xRMUT1KMpXiK4mmKZyiebauA6VDxDKZXVdtdnra7PW2DPW1DPG33eNru9bQN9bTd52m739M2zNM23NP2gKdthKdtpKftQU/bQ562UZ62hz1tj3jaHvW0jfa0PeZpG+Npe9zT9oSn7UlP21hP21Oetqc9bc942p6ttMWPuSt/rlD5M6jt6FR0at3E7gT0VfrfdaDA3QXqizneDenrv/EaXHtfiY77eENq7Ss1/p7gPbX1FcTvL95bS1+Jzvcqh055X0H1fc/7prAvukg0wT3U+6esr9B3P3bYlPQV+u/tDp/8vrJd3Sd+YHL7ynZ9z3nE5PWV6O7+9cjJ6Svb/b3wBye9r4k+q/HQpPaVnWgtdKMmra9gEuqqe3hS+gomqUa7RybeV3oS6717dGJ9pSZ573Cju+2L32A76X091l1f2cna09yYrvsKJ3N/dI930VeuPNl7rXvC31cwBfu2e9LXVzBFGsCNnbAvN4V6wj1V3Vc0xdrEPd25r2QNOsc9E+srUa5JM7lngaaPdSP7lYGV/p6tmJinK6ZmbMXkPFExPWMqJmh0xRQ9UjFJoyqm6cGKiRpRMVXDKybr/orpGloxYfdUTNngiklj7cZakI963u14FqY/o053O55rEwTMnaOuuHaAfw6XVO55oEGQGkPGiLoi1zGGzwMXJi+Cfg31+ZoprqBEold64mPxQmWBvVh9teWFysTG2170uGL05XZcJQncC8AF9CJ4ctHJx4vmBeBi7OD9Angx1mtHegaWR7kojvelNkHAL8F3pFz0EnBHeln5jsRj+DJ8R8pFLxvdkZ6B4c4VPXBFdqRXKgvs1eod6RXPjvRqHXakZ4A70ivABfSq0OSiH0JAcn4NWMwaGvC75fOVAoS+mY60Aq8Di5lvDIPaDsdz/LqAknndqJJ5GlZ/Csk43jfaBAG/AVcyheQbwMX/pnIlw2P4JlzJFJJvCi9+RAF9XXkBfQs8hh0HeuNF5vjbwLVXTwX8NAx3IeGBK6KA36kU5nerFfA7HgX8bh0UMG4HCtw7wKR8V2hy0QsRyfk9YQUc1HY4Lo5vC6i395WrVp6X9w3wlsrx94E5/oHyHO9KpCDED6qvD8Ebdr3czlOwvSYsx/F+1CYI+CO42wnLHwEn8GPlbofH8GO42wnLHyt3O1zoPmzTXYw/ARfjjgPNGZnjnxp1O0/BcIclD1wRt/NZpTB/Xu12PvO4nc/r4HZwO1DgPgMm5edCk4teiEjOXyhXglwcPxVQ/V8qdzs8L18a4C2V418Cc/wr5TnelUgJajscUqR8bfTezljYXpPo9Hqfb9oEAX8DdzuJ4BvgIvhWudvhMfwW7nYSwbfK3Q4Xuq/bdBfj74y4HWSOf2/U7YyF4XZlD1wRt/NDpTD/WO12fvC4nR/r4HZwO1DgfgAm5Y9Ck4teiEjOPylXglwcvxdQ/T8rdzs8Lz8b4C2V4z8Dc/wX5TnelUgJajscUqT8atTtPAnba6JObue3NkHAv8HdThT8BlwEvyt3OzyGv8PdThT8rtztcKH7tU13Mf7DiNtB5vifRt3OkzDcxbq5nb8qhfnvarfzl8ft/F0Ht4PbgQL3FzAp/xaaXPRCRHL+R7kS5OL4p4Dq/1e52+F5+dcAb6kc/xcpqNp153hXIiWo7XBIkdIDN4Z1dTtPwPaaTKd3YvRsFwTMnWPdTsb1BC6CxnbdbofHkDFi3U6mE++gxsPHG1HoerTrLsZN4GI8bkGCOSNzvBnIuZ5u5wmYWMjU7V0qLZXC3Nqxw3Q4m5b2Cd0O/yVpt/ME0O20AJOytV1mctELEcm5l3IlyMWxuR2/MfQW3riC2g7H89LbAG+pHO8NzPE+ynO8K5ES1HY4pEhpM+p2Hsfd2wnjeNvbBQG3w91OFLYDF0Ff5W6Hx7Av3O1EYV/lbocLXVu77mLcz4jbQeZ4f6Nu53GY24myHrgibmdApTBPU+12BnjczjR1cDuPA93OAGBSTtMuM7nohYjkPK1yJcjFsb+A6p9OudvheZnOAG+pHJ8OmOPTK8/xrkRKUNvhkCJlBqNuZwxsr0nl4nhnbBcEPCPc7aRyMwIXwUzK3Q6P4Uxwt5PKzaTc7XChm6FddzGe2YjbQeb4LEbdzhiY20mFHrgibmfWSmGerdrtzOpxO7PVwe2MAbqdWYFJOVu7zOSiFyKS8+zKlSAXx1kEVP8cyt0Oz8scBnhL5fgcwByfU3mOdyVSgtoOhxQpcxl1O4/B9ppCpyfZBrYLAh4IdzsFNxC4COZW7nZ4DOeGu51CJ95BjYePN6LQzdWuuxjPY8TtIHN8XqNu5zGY2ynU7Um2+SqFef5qtzOfx+3MXwe38xjQ7cwHTMr522UmF70QkZwXUK4EuTjOK6D6F1TudnheFjTAWyrHFwTm+ELKc7wrkRLUdjikSFnYqNsZjXM7xTjeRdoFAS+CdzvFRYCLYFHlbofHcFG82ykuqtztcKFbuF13MV7MiNtB5vjiRt3OaJzbKXjgiridJSqFeclqt7OEx+0sWQe3MxrodpYAJuWS7TKTi16ISM6BciXIxXFxAdXvlLsdnhdngLdUjjtgjieU53hXIiWo7XBIkZI06nYexT3JVojjTbULAk7hn2QrpICLIK3c7fAYpvFPshXSyt0OF7pku+5inDHidpA5njXqdh7FPcmW98AVcTthpTDnqt1O6HE7uTq4nUeBbicEJmWuXWZy0QsRyXkp5UqQi2NWQPUvrdzt8LwsbYC3VI4vDczxZZTneFciJajtcEiRsqxRt/MIbK8JO72Berl2QcDLwd1OGCwHXATLK3c7PIbLw91OGCyv3O1woVu2XXcxXsGI20Hm+IpG3c4jMLeTrdsbqFeqFOaVq93OSh63s3Id3M4jQLezEjApV26XmVz0QkRyXkW5EuTiuKKA6l9VudvheVnVAG+pHF8VmOOrKc/xrkRKUNvhkCJldaNu52Eht7NGuyDgNQTczhrARbCmcrfDY7imgNtZU7nb4UK3ervuYryWEbeDzPG1jbqdhw26nXUqhXndarezjsftrFsHt/Mw0O2sA0zKdY24HSTn9ZQrQS6Oawuo/vWVux2el/UN8JbK8fWBOb6B8hzvSqQEtR0OKVI2NOp2RsH2mnynd7Jt1C4IeCO428nnNgIugo2Vux0ew43hbief21i52+FCt2G77mK8iRG3g8zxTY26nVEwt5Ov2zvZNqsU5s2r3c5mHrezeR3cziig29kMmJSbt8tMLnohIjlvoVwJcnHcVED1b6nc7fC8bGmAt1SObwnM8a2U53hXIiWo7XBIkbK1UbfzEM7tpOJ4t2kXBLwN3u2ktgEugm2Vux0ew23xbie1rXK3w4Vu63bdxXg7I24HmePbG3U7D+HcTtIDV8Tt7FApzPlqt7ODx+3k6+B2HgK6nR2ASZlvl5lc9EJEci4oV4JcHLcXUP1F5W6H56VogLdUjheBOR4pz/GuREpQ2+GQIqVk1O08iPvtop3u7ZTbBQGX4W4nypWBi2BH5W6Hx3BHuNuJcjsqdztc6ErtuovxTkbcDjLHdzbqdh7E/XbRut3b2aVSmHetdju7eNzOrnVwOw8C3c4uwKTctV1mctELEcl5N+VKkIvjzgKqf3flbofnZXcDvKVyfHdgju+hPMe7EilBbYdDipQ9jbqdkbC9pliK492rXRDwXnC3UyztBVwEeyt3OzyGe8PdTrG0t3K3w4Vuz3bdxXgfI24HmeP7GnU7I2Fupxh54Iq4nf0qhXn/arezn8ft7F8HtzMS6Hb2Aybl/u0yk4teiEjOByhXglwc9xVQ/Qcqdzs8Lwca4C2V4wcCc/wg5TnelUgJajscUqQcbNTtjIDtNa7TvZ1D2gUBHwJ3Oy53CHARHKrc7fAYHgp3Oy53qHK3w4Xu4HbdxfgwI24HmeOHG3U7I2Bux9Xt3s4RlcJ8ZLXbOcLjdo6sg9sZAXQ7RwCT8sh2mclFL0Qk50HKlSAXx8MFVP9Ryt0Oz8tRBnhL5fhRwBw/WnmOdyVSgtoOhxQpxxh1Ow/gfrtoJ7dzbLsg4GPhbqeQOxa4CI5T7nZ4DI+Du51C7jjlbocL3THtuovx8UbcDjLHTzDqdh7A/XbRurmdEyuF+aRqt3Oix+2cVAe38wDQ7ZwITMqT2mUmF70QkZxPVq4EuTieIKD6T1HudnheTjHAWyrHTwHm+KnKc7wrkRLUdjikSDnNqNsZjnsDdRjHe3q7IODT4W4nDE8HLoIzlLsdHsMz4G4nDM9Q7na40J3WrrsYn2nE7SBz/Cyjbmc4zO2EWQ9cEbdzdqUwn1Ptds72uJ1z6uB2hgPdztnApDynXWZy0QsRyflc5UqQi+NZAqr/POVuh+flPAO8pXL8PGCOn688x7sSKUFth0OKlAuMup1hsL0m1cntXNguCPhCuNtJhRcCF8FFyt0Oj+FFcLeTCi9S7na40F3QrrsYX2zE7SBz/BKjbmcYzO2k6uZ2Lq0U5suq3c6lHrdzWR3czjCg27kUmJSXtctMLnohIjlfrlwJcnG8RED1X6Hc7fC8XGGAt1SOXwHM8SuV53hXIiWo7XBIkXKVUbdzP2yvybk43qvbBQFfDXc7OXc1cBFco9zt8BheA3c7uU68gxoPH29EobuqXXcxvtaI20Hm+HVG3c79MLeTCzxwRdzO9ZXCfEO127ne43ZuqIPbuR/odq4HJuUN7TKTi16ISM43KleCXByvE1D9Nyl3OzwvNxngLZXjNwFz/GblOd6VSAlqOxxSpNxi1O3cB9trskEc763tgoBvhbudbHArcBHcptzt8BjeBnc72eA25W6HC90t7bqL8e1G3A4yx+8w6nbug7mdTNkDV8Tt3FkpzHdVu507PW7nrjq4nfuAbudOYFLe1S4zueiFiOR8t3IlyMXxDgHVP1i52+F5GWyAt1SODwbm+BDlOd6VSAlqOxxSpNxj1O0Mxb2loNMbqO9tFwR8L9ztFEr3AhfBUOVuh8dwKNztFEpDlbsdLnT3tOsuxvcZcTvIHL/fqNsZintLQd3eQD2sUpiHV7udYR63M7wObmco0O0MAybl8HaZyUUvRCTnB5QrQS6O9wuo/hHK3Q7PywgDvKVyfAQwx0cqz/GuREpQ2+GQIuVBo27nXthek+h0b+ehdkHAD8HdTiJ4CLgIRil3OzyGo+BuJxGMUu52uNA92K67GD9sxO0gc/wRo27nXtwbqOt2b+fRSmEeXe12HvW4ndF1cDv3At3Oo8CkHN0uM7nohYjk/JhyJcjF8REB1T9GudvheRljgLdUjo8B5vjjynO8K5ES1HY4pEh5wqjbuQe31xTjeJ9sFwT8JNztBMUngYtgrHK3w2M4Fu52guJY5W6HC90T7bqL8VNG3A4yx5826nbugbmdoOCBK+J2nqkU5mer3c4zHrfzbB3cDnAHcs8Ak/LZdpnJRS9EJOfnlCtBLo5PC6j+55W7HZ6X5w3wlsrx54E5/oLyHO9KpAS1HQ4pUl406naGwPaaTKcn2V5qFwT8EtztZEovARfBy8rdDo/hy3C3kym9rNztcKF7sV13MX7FiNtB5virRt3OENz3dur2JNtrlcL8erXbec3jdl6vg9sZAnQ7rwGT8vV2mclFL0Qk5zeUK0Eujq8KqP43lbsdnpc3DfCWyvE3gTn+lvIc70qkBLUdDilS3jbqdgbD9hrX6Z1s77QLAn4H7nacewe4CN5V7nZ4DN+Fux3XiXdQ4+HjjSh0b7frLsbvGXE7yBx/36jbGYx7kq1u72T7oFKYP6x2Ox943M6HdXA7g4Fu5wNgUn7YLjO56IWI5PyRciXIxfF9AdX/sXK3w/PysQHeUjn+MTDHP1Ge412JlKC2wyFFyqdG3c7duIcxOn1v57N2QcCfteP7/Vy5Q2Hen7ePH2BQvyKuggvKp+26i94XRlwFMi+/FC70iDn5UiDH61lQ7xIqqF+1CwL+SqCgfq28oDLvr6cWVFhf3xgpqMi8/FZ5QeU5+dZ4Qb2zDTcecbzftQsC/k5gsX4HTLbvlRdnHsPvBez998qvx1so9D8YKfTIHP9R+SUSnpMfBdbLT8ovA3Kd+ElIxEnl5U/AvPxZeV52Vc+C2g6HrGe/KM9xnuNfBAwaMg/rKQhvjwlCFyYTiWySMYVR4FJRMREmElEhFRSDfDFRyqVcrpxKpJLFqFgg/HlXDsr5Yq4c/tdXHO+v7YKAf/UsglrB/wpc/L8pF4Q8hr95FkGtY/gb+Lp9c0N9brTf3iaz2TVgx7eT4/o9Nn9wpQKcSBe/4R8HPZmYi5OSfL9Pwe44sUH/HbiY/wAukPi4cr+DpjAXHI1d0QXlIJcI8kG2mMkWclGiEObLyXI6GSWndFwnluzIcf1TaFz/rIxrU6yt+tBcjOLF86/Kjvw3r0GJgvG7gKz6XfklhildHMFk8K4V4z/KJTkn5j8CdvtfoaLwbzfFNqjtcH8LjUVDX5mx4H67GotaMUvlxaoD/k9rSnEi+MRyYLUBuusAb3z/CNRS4Hw75BiyqODwOZyGyRyDieVUvE+J+o0ak7jA6tG3G4cT1Ha4f4Q2hzjoycTsJvZz/lcU+uILw+rgwtBxNE3mnE2OkKmVc8++OgsMci7iedkztlFP6fxMbMyR89MYmx+XTNLaiLKuHJWT6WwuUXCZZCZTTpWzmTAVldOpfJQtuVQ+mciVskHZhaVSNp0sZjPlXFTMlONF20XJZCrKFYouncjkC0EYJfNBOZVNkvmNktkoSoaZTD6ZjDJhOcyRYSUbHAbpbDYXZBLJXEJqfhr7jneaqE1hYlc24n1a2RSaLG4KTcKbQpPAprCGkk2hyyTO/u9LOWVk0WlWuimsIVR0mgGbwsQu8yHnp0XppiA1Py19/9+5/Nja978/e/X1XH4Maju6vPaPvA9Sa1/AS5kiTxd0jGGjkTGsta/efXXPBy+Y3gIbex+hS4F9+spdFu0lNBZtQmPRJnhZVCov1lJ+WVQqB9Y2cFmUeaMviwLn26099bJo9fG/+o0ak7jwa5d0wL2FCmK7oANmzO0ChWEdI5dF43NWK+e+fXUWmHWEHFbfOlwWRc5PP6ADXhvogKXmp59nftAPeCHnp79Q/ewPGIeJXalBjsMAoXEYMAmXyTVv5B64sDyOi4RpLIqEaYRFwjQCImHdOomEGp+OhRa5aYF9IUXCukKb0LSTIBJqfcoWOT/T9cVt7EiRIDU/0wlebXm24r7Rr6V7FvZautAhc2d6WG0PO80R98uv+uMNu61hwgM0ruNqKFwENOrHOANSqEydKDmMM06dqMC1GJiomaSkP3qbmhkHNGE1oWbuqx/jLFYSalYc0KTVhJrVQELNZiWhZscBTVlNqNkNJNQcVhJqThzQtNWEmtNAQs1lJaEG4oBmrCbUQAMJNbeVhJoHBzRrNaHmMZBQ81pJqPlwQEOrCTWfgYSa30pCLYADmrOaUAsYSKgFrSTUQjigeasJtZCBhFrYSkItggNasJpQixhIqEWtJNRiOKBFqwm1mIGEWtxKQi2BAxpZTaglDCTUklYSKsABLVlNqMBAQjkrCZXAAS1bTaiEgYRKWkmoFAyoC6wmVMpAQqWtJFQGl1DOakJlDCRU1kpChbiEMvs8VGggoXJWEmopXEKZfR5qKQMJtbSVhFoGl1Bmn4daxkBCLWsloZbDJZTZ56GWM5BQy1tJqBVwCWX2eagVDCTUilYSaiVcQpl9HmolAwm1spWEWgWXUGafh1rFQEKtaiWhVsMllNnnoVYzkFCrW0moNXAJZfZ5qDUMJNSaVhJqLVxCmX0eai0DCbW2lYRaB5dQZp+HWsdAQq1rJaHWwyWU2eeh1jOQUOtbSagNcAll9nmoDQwk1IZWEmojXEKZfR5qIwMJtTESI7+Iin8D7sBKh/wOHn69C7+Rg1+iwN97568q87dL+QuB/B0u/toNf1OCH27n55H5EVJ+6o8f1OJna/hxCL6DzTcd+T4RX9rnq7F8AY2vebBNZWfBYpD3by65vEqYWMfRE5zcHS8sQ00C98Uvlvr/ywvQNoGNXfi/Z9vaGyY8UGMotfAsvEMLN0+Vd2gJTtT/r9+htenUibLxbqrNpk6UjXc+bT51omy8S2mLqRNl4x1FW06dKBvv/tlq6kTZeKfO1lMnysa7araZOlE23gGz7dSJsvFule2mTpSNd5ZsP3WibLwLZIepE2XjHRv5qRNl490VhakTZeOdEMWpE2XjXQvR1Imy8Q6D0tSJsvFugPLUibLxnfsdp06Uje+y7zR1omx8R3znqRNl47vXu0ydKBvfad516kTZ+K7wblMnysZ3cHefOlE2vtu6x9SJsvGd0T2nTpSN72LuNXWibHzHce+pE2Xju4P7TJ0oG9/J2xeJsYk6aWkY/90yBjt31aT1BBOQ+t5ZUNPx33fFkDwZ2zMArh3fi+P++Ks8mr8eJDGGT4PHcDOBMdxM+Rg+BR7DzQXGcHPlYzgWPIZbCIzhFsrH8EnwGG4pMIZbKh/DJ8BjuJXAGG6lfAwfB4/h1gJjuLXyMRwDHsNtBMZwG+Vj+Bh4DLcVGMNtlY/haPAYbicwhtspH8NHwWO4vcAYbq98DB8Bj+EOAmO4g/IxfBg8hnmBMcwrH8NR4DEsCIxhQfkYPgQew6LAGBaVj+GD4DGMBMYwUj6GI8FjWBIYw5LyMRwBHsOywBiWlY/hA+Ax3FFgDHdUPobDwWO4k8AY7qR8DIeBx3BngTHcWfkY3g8ew10ExnAX5WN4H3gMdxUYw12Vj+FQ8BjuJjCGuykfw3vBY7i7wBjurnwM7wGP4R4CY7iH8jEcAh7DPQXGcE/lYzgYPIZ7CYzhXsrH8G7wGO4tMIZ7Kx/Du8BjuE9f3U8rSozhneAx3Lev8gcJqw5Mv8lMg+fA9J1wcn2PzymeswGV8/1ovPenOIDiQIqDKA6mOITiUIrDKA6nOILiSIpBFEdRHE1xTN//+ji2b6XTxsqf3OnAqrb9PW0HeNoO9LQd5Gk72NN2iKftUE/bsZU2PtAL7ZmqX7SAesCyCYnT/fcLIWrFyA+8hpXighq/TYFjdxwIF3EM4vlzXCx/GiTyyHXGXus4HA8sqvFxOF5wHT0tsI74gVj0LywBPmTrjgfyPUFozk+oQ+6fAByHE4XG4UTB3H9KIPc3F8h94MPR7kQg35OE5vwk6dyncdhP6ThwH01grk8ifykV1Y2xoHXz3xd5/tM1W4DX4ZbodUi8gQ/Yd3rQvFa+Jwutw5PrsAedDByHU4TG4RTBPegJgT1oK4E9CPhQvzsFyPdUoTk/tQ65fypwHE4TGofTBHP/cYHc31og94FfxnCnAfmeLjTnp9dBf+2vdBy4D7T+egysv8YI6K9twOtwWwH9BfxCT6cvttTK9wyhdXhGHfagM4DjcKbQOJwpuAeNFtiDthPYg4BfInJnAvmeJTTnZ9Uh988CjsPZQuNwtmDuPyqQ+9sL5D7wy1/ubCDfc4Tm/Jw66K8DlI4D94HWXw+D9dcjAvprB/A6zAvoL+AXCDt9ka5WvucKrcNz67AHnQsch/OExuE8wT1olMAeVBDYg4BfWnTnAfmeLzTn59ch988HjsMFQuNwgWDuPySQ+0WB3Ad+2dRdAOR7odCcX1gH/XWg0nHgPtD6ayRYfz0ooL8i8DosCegv4BeWO31xt1a+Fwmtw4vqsAddBByHi4XG4WLBPWiEwB5UFtiDgF+SdhcD+V4iNOeX1CH3LwGOw6VC43CpYO4/IJD7OwrkPvDL7e5SIN/LhOb8sjror4OUjgP3gdZfw8D6a7iA/toJvA53FtBfwBckdHpRQK18Lxdah5fXYQ+6HDgOVwiNwxWCe9D9AnvQLgJ7EPClDO4KIN8rheb8yjrk/pXAcbhKaByuEsz9+wRyf1eB3Ae+TMNdBeR7tdCcX10H/XWw0nHgPtD6616w/hoqoL92A6/D3QX0F/CFLJ1eTFIr32uE1uE1ddiDrgGOw7VC43Ct4B50j8AetIfAHgR8CYy7Fsj3OqE5v64OuX8dcByuFxqH6wVzf4hA7u8pkPvAl/e464F8bxCa8xvqoL8OUToO3Adaf90N1l+DBfTXXuB1uLeA/gK+AKrTi5Bq5Xuj0Dq8sQ570I3AcbhJaBxuEtyD7hLYg/YR2IOAL51yNwH53iw05zfXIfdvBo7DLULjcItg7t8pkPv7CuQ+8GVh7hYg31uF5vzWOuivQ5WOQ5xzDzDnwwCcC/n/+pLEebiR8TzCCM4jjeAcZATnUUZwHm0E5zFAnOxdWxs6/1LtAQ2dDzT+/QTGGY1xfwMYDzCA8UADGA8ygPFgAxgPMYDxUKEaj8CYzIQi/Urhndrv/1v94vpOJAT7dh01Ia5VbqN1fTvFHRR3UtxFcTfFYIohFPdQ3EsxlOI+ivsphlEMp3igb0PnF0Hf1nfCl0Pf7mm7w9N2p6ftLk/b3Z62wZ62IZ624Z62ByptLOj6NYy/ABA/0MX0nr7qk9Hx/8XHYkTf//4cWT3p/EG18kVfmboHdBeG+xoBvCIz0ojzsYLzXiM4hxrBeZ8RnPcbwTnMCE5EvSzk/qeqO12Brb46Xmv9BF7RcLcJzQ2aM/AKibvdCGfgFRd3hxHOwCs47k4jnIFXhNxdRjgDrzC5u41wBl6xcoONcAZeAXND6sQ5mLLDdZwMB3qlB4Xu4sf7BY9Dx+EeAM79g6gnCkvlXJxzD3C+jwJw9l2ZReN8GIAzkw9ypUwmK4nzEQDOQiGTzZfCtCTORxHzXsyUyslsQhLnaADOfDpVLqeTeUmcjwFwpl1QSieyZUmcYwA4c4UgnQnDoiTOxwE4XTlMRrl8QRLnE4h5L5SCYuRyjG26hgl/G2T8t0DGf/tj/Lc+xn/bY/y3PMZ/u2P8tzqOip23Nk75efxi+wOx84dj54/Ezh+NnY+OnT8WOx8TO388dv5E5fxJ+nMsxVMUT1M8Q/EsxXMUz/f97yI/X79ubJjwQF+DeVL/RX4+UmJ9u/90WsfYdnzb4wUalxcpXqJ4ufpmAn/Yq6rtRU/bS562lytt8aMZO1idJrXWAvECSgiWA/ci8AbJS5C+/huvl8GPXNVr8Y6duni9i/cVGpdXKV6jeL168b7iWZSvetpe87S9XofFOxa4eF8BLt5XgYv3NeDifd3o4n1q6uL1Lt43aFzepHiL4u3qxfuGZ1G+6Wl7y9P2dh0W71PAxfsGcPG+CVy8bwEX79tGF+/TUxevd/G+Q+PyLsV7FO9XL953PIvyXU/be5629+uweJ8GLt53gIv3XeDifQ+4eN83unifmbp4vYv3AxqXDyk+ovi4evF+4FmUH3raPvK0fVyHxfsMcPF+AFy8HwIX70fAxfux0cX77NTF6128n9C4fErxGcXn1Yv3E8+i/NTT9pmn7fM6LN5ngYv3E+Di/RS4eD8DLt7PjS7e56YuXu/i/YLG5UuKryi+rl68X3gW5Zeetq88bV/XYfE+B1y8XwAX75fAxfsVcPF+bXTxPj918XoX7zc0Lt9SfEfxffXi/cazKL/1tH3nafu+Dov3eeDi/Qa4eL8FLt7vgIv3e+Ai6EimKxvAiUpHr6n9Te1van9T+5va39T+pvY3tb+p/anvj/XgUo3jfUAudh7GzrOx80zsPB07T8XOk7HzROzcxc6D2PmSsfMlYueLx84Xi50vGjtfJHa+cOx8odj5grHzBWLn88fO54udzxs7nyd2PnfsfGDsfK7Y+Zyx8zli57PHzmeLnR/VNP58UOz8yNj5EbHzw2Pnh8XOD42dHxI7Pzh2flDs/MDY+QGx8/1j5/vFzveNne8TO987dr5X7HzP2PkesfPdY+e7xc53jZ3vEjvfOXa+U+x8x9h5OXZeip1HsfNi7LwQO3+8efz5mNj5Y7Hz0bHzR2Pnj8TOH46dj4qdPxQ7fzB2PjJ2PiJ2/kDsfHjsfFjs/P7Y+X2x86Gx83tj5/fEzofEzgfHzu+Ond8VO78zdn5H7Pz22PltsfNbY+e3xM5vjp3fFDvv3zr+vF/svG/svD123hY77xM77x077xU7b42dt8TOm2PnTbHzxth5z9h5j9h5Q+z835bx5//Ezv+Onf8VO/8zdv5H7Pz32PlvsfNfY+e/xM5/jp3/FDv/MXb+Q+z8+9j5d7Hzj2PXgeK3UuO3WuO3Yj+Pncfv3sTv7sTv/nwdO49fMI5fUI5fcP4+dh6/RhW/hhW/xvVy7Dz++HP88ej449Ovx87jT1zGn8iMP7H5duw8/pBX/CGw+ENi78fO48+VxJ876Xgu5c6G/44f6L9/pPiJ4meKXyh+pfiN4neKPyj+pPiL4m+Kfyj+5Qt//ag/ip4UjRRNFM0ULRStFL0oelP0oWijaKfoS9GPoj/FAIppKKalmI5ieooZKGakmIliZopZKGalmI1idoo5KOakmItiIMXcFPNQzEsxH8X8FAtQLEixEMXCFItQLEqxGMXiFEtQLEkRUDiKBEWSIkWRpshQZClCihzFUhRLUyxDsSzFchTLU6xAsSLFShQrU6xCsSrFahSrU6xBsSbFWhRrU6xDsS7FehTrU2xAsSHFRhQbU2xCsSnFZhSbU2xBsSXFVhRbU2xDsS3FdhTbU+xAkacoUBQpIooSRZliR4qdKHam2IViV4rdKHan2INiT4q9KPam2IdiX4r9KPanOIDiQIqDKA6mOITiUIrDKA6nOILiSIpBFEdRHE1xDMWxFMdRHE9xAsWJFCdRnExxCsWpFKdRnE5xBsWZFGdRnE1xDsW5FOdRnE9xAcWFFBdRXExxCcWlFJdRXE5xBcWVFFf1q9TEhs4viVqh8mdQ49EL2l8hmFr3/u/rXsd7sa6m3LmG4lqK6yiup7iB4kaKmyhupriF4laK2yhup7iD4k6Ku/r9d0OkVyznesT+nLlyfjf9vcEUQyjuobiXYijFfRT3UwyjGE7xAMUIipEUD1I8RDGK4mGKRygepRhN8RjFGIrHKZ7oV/lh497C1i8mJCp/Dva0DfG03eNpu9fTNtTTdp+n7X5P2zBP23BP2wOethGetpGetgc9bQ952kZ52h72tD3iaXvU0zba0/aYp22Mp+1xT9sTlTZOst4N/iSbq3L+JP3dsRRPUTxN8QzFsxTPUTxP8QLFixQvUbxM8QrFqxSvUbxO8QbFmxRvUbxN8Q7FuxTvUbxP8QHFhxQfUXxM8QnFpxSfVSfgkx4iYz1tT3nanva0PeNpe9bT9pyn7XlP2wuethc9bS952l72tL3iaXvV0/aap+11T9sbnrY3PW1vedre9rS942l719P2nqftfU/bB562Dz1tH3naPva0feJp+9TT9tlkLIbP6e9+QfElxVcUX1N8Q/EtxXcU31P8QPEjxU8UP1P8QvErxW8Uv1P8QfEnxV8Uf1P8Q/EvJ3t/+lkUPSkaKZoomilaKFr7V4H+3EPkC0/bl562rzxtX3vavvG0fetp+87T9r2n7QdP24+etp88bT972n7xtP3qafvN0/a7p+0PT9ufnra/PG1/e9r+8bT962njia9u6+Fp6+lpa/S0NXnamj1tLZ621v6Tvhh60d/tTdGHoo2inaIvRT+K/hQDKKahmJZiOorpKWagmJFiJoqZKWahmJViNorZKeagmJNiLoqBFHNTzEMxL8V8FPNTLFC9GHp5iPT2tPXxtLV52to9bX09bf08bf09bQM8bdN42qb1tE3naZve0zaDp21GT9tMnraZPW2zeNpm9bTN5mmb3dM2h6dtTk/bXJ62gZ62uT1t83ja5vW0zedpm9/TtsBkLIYF6e8uRLEwxSIUi1IsRrE4xRIUS1IEFI4iQZGkSFGkKTIUWYqQIkexFMXSFMtQLEuxHMXyFCtQrEixEsXKFKtQrFq9GBb0EFnI07awp20RT9uinrbFPG2Le9qW8LQt6WkLPG3O05bwtCU9bSlPW9rTlvG0ZT1toact52lbytO2tKdtGU/bsp625Txty3vaVvC0rehpW8nTtrKnbRVP26qTsRhWo7+7OsUaFGtSrEWxNsU6FOtSrEexPsUGFBtSbESxMcUmFJtSbEaxOcUWFFtSbEWxNcU2FNtSbEexPcUOFHmKAkWRIqpeDKt5iKzuaVvD07amp20tT9vanrZ1PG3retrW87St72nbwNO2oadtI0/bxp62TTxtm3raNvO0be5p28LTtqWnbStP29aetm08bdt62rbztG3vadvB05b3tBU8bUVPWzQZi6FEf7dMsSPFThQ7U+xCsSvFbhS7U+xBsSfFXhR7U+xDsS/FfhT7UxxAcSDFQRQHUxxCcSjFYRSHUxxBcSTFIIqjKI6mOKZ6MZQ8RMqeth09bTt52nb2tO3iadvV07abp213T9senrY9PW17edr29rTt42nb19O2n6dtf0/bAZ62Az1tB3naDva0HeJpO9TTdpin7XBP2xGetiM9bYM8bUd52o72tB0zGYvhWPq7x1EcT3ECxYkUJ1GcTHEKxakUp1GcTnEGxZkUZ1GcTXEOxbkU51GcT3EBxYUUF1FcTHEJxaUUl1FcTnEFxZUUV1FcXb0YjvUQOc7Tdryn7QRP24metpM8bSd72k7xtJ3qaTvN03a6p+0MT9uZnrazPG1ne9rO8bSd62k7z9N2vqftAk/bhZ62izxtF3vaLvG0Xeppu8zTdrmn7QpP25Wetqs8bVdPxmK4hv7utRTXUVxPcQPFjRQ3UdxMcQvFrRS3UdxOcQfFnRR3UdxNMZhiCMU9FPdSDKW4j+J+imEUwykeoBhBMZLiQYqHKEZVL4ZrPESu9bRd52m73tN2g6ftRk/bTZ62mz1tt3jabvW03eZpu93Tdoen7U5P212etrs9bYM9bUM8bfd42u71tA31tN3nabvf0zbM0zbc0/aAp22Ep22kp+1BT9tDnrZRk7EYHqa/+wjFoxSjKR6jGEPxOMUTFE9SjKV4iuJpimconqV4juJ5ihcoXqR4ieJlilcoXqV4jeJ1ijco3qR4i+Jtinco3qV4r3oxPOwh8oin7VFP22hP22OetjGetsc9bU942p70tI31tD3laXva0/aMp+1ZT9tznrbnPW0veNpe9LS95Gl72dP2iqftVU/ba5621z1tb3ja3vS0veVpe9vT9o6n7V1P23uxxdCnoT6/dgrYl+hvL1kYiLNHDOf7/SsD3jZ1wDvhRA54g+/oCQY8ayPwlST9cbjiK5z7HTiRcagVO3JMF2mQSQI05x5Azosa4dwTyHkxI5wbgZwXrxPnoLbDLQEcv4ZGG5vPkg02cAZGcDojOBNGcCaN4EwZwZk2gjNjBGfWCM7QCM6cEZxLGcG5tBGcyxjBuawRnMsZwbm8EZwrGMG5ohGcKxnBubIRnKsYwbmqEZyrGcG5uhGcaxjBuaYRnGsZwbm2EZzrGMG5rhGc6xnBub4RnBsYwbmhEZwbGcG5sRBOzfcFN6kT56C2w20KHL8mI/eLNmuwgXNzIzi3MIJzSyM4tzKCc2sjOLcxgnNbIzi3M4JzeyM4dzCCM28EZ8EIzqIRnJERnCUjOMtGcO5oBOdORnDubATnLkZw7moE525GcO5uBOceRnDuaQTnXkZw7m0E5z5GcO5rBOd+RnDubwTnAUZwHmgE50FGcB5sBOchRnAeagTnYUZwHm4E5xFGcB5pBOcgIziPMoLzaCM4jzGC81gjOI8zgvN4IzhPMILzRCM4TzKC82QjOE8xgvNUIzhPM4LzdCM4zzCC80wjOM8ygvNsIzjPMYLzXCM4zzOC83wjOC8wgvNCIzgvMoLzYiM4LzGC81IjOC8zgvNyIzivMILzSiM4rzKC82ojOK8xgvNaIzivM4LzeiM4bzCC80YjOG8ygvNmIzhvMYLzViM4bzOC83YjOO8wgvNOIzjvMoLzbiM4BxvBOcQIznuM4LzXCM6hRnDeZwTn/UZwDjOCc7gRnA8YwTnCCM6RRnA+aATnQ0ZwjjKC82EjOB8RwtkTjPPRWF+1viNpxkYbnEcDOTcbeS/UYw02cI4xgvNxIzifMILzSSM4xxrB+ZQRnE8bwfmMEZzPGsH5nBGczxvB+YIRnC8awfmSEZwvG8H5ihGcrxrB+ZoRnK8bwfmGEZxvGsH5lhGcbxvB+Y4RnO8awfmeEZzvG8H5gRGcHxrB+ZERnB8bwfmJEZyfGsH5mRGcnxvB+YURnF8awfmVEZxfG8H5jRGc3xrB+Z0RnN8bwfmDEZw/GsH5kxGcPxvB+YsRnL8awfmbEZy/G8H5hxGcfxrB+ZcRnH8bwfmPEZz/GsHJHVrA2cMIzp5GcDYawdlkBGezEZwtRnC2GsHZywjO3kZw9jGCs80IznYjOPsawdnPCM7+RnAOMIJzGiM4pzWCczojOKc3gnMGIzhnNIJzJiM4ZzaCcxYjOGc1gnM2IzhnN4JzDiM45zSCcy4jOAcawTm3EZzzGME5rxGc8xnBOb8RnAsYwbmgEZwLGcG5sBGcixjBuagRnIsZwbm4EZxLGMG5pBGcgRGczgjOhBGcSSM4U0Zwpo3gzBjBmTWCMzSCM2cE51JGcC5tBOcyRnAuawTnckZwLm8E5wpGcK5oBOdKRnCubATnKkZwrmoE52pGcK5uBOcaRnCuaQTnWkZwrm0E5zpGcK5rBOd6RnCubwTnBkZwbmgE50ZGcG5sBOcmRnBuagTnZkZwbm4E5xZGcG5pBOdWRnBubQTnNkZwbmsE53ZGcG5vBOcORnDmjeAsGMFZNIIzMoKzZARn2QjOHY3g3MkIzp2N4NzFCM5djeDczQjO3Y3g3MMIzj2N4NzLCM69jeDcxwjOfY3g3M8Izv2N4DzACM4DjeA8yAjOg43gPMQIzkON4DzMCM7DjeA8wgjOI43gHGQE51FGcB5tBOcxRnAeawTncUZwHm8E5wlGcJ5oBOdJRnCebATnKUZwnmoE52lGcJ5uBOcZRnCeaQTnWUZwnm0E5zlGcJ5rBOd5Qjh7gnGeH8OZDDKpVCmbKLmkyweJXCFMB6l0IRO60KXDdJQIk8lSmAqzuUIuG+RcKlly5XQuWa509n5/G5wvAHJetpcM54Fgzhd2zkcX1HBs1Gsyxy/b5fi5H/pO9lxku+rrx75TMK+hv6+f+k5RjoS+vn6esr5ymfKEff3Sd4pzN6ju69e+NayDROe+futb05oK4n393rfG9Zka39cffWte64mOvv6sva9k6b/O3F+Qvsrcm/sb1Bf15v4B9NVRG/+t7iua4r7c1f0mwOWmtK9r+nk4BlPW17X9vOMVTElf1/n7crny5Pd1fb8u5zGc3L5u6NdNTmQnr68bu+srTJUnp6+b+k0kV1OT3tfN/Saa9+lJ7euWfpOwhoJJ6+vWfpO0HoNJ6eu2SevLpbMT7+v2Se0rTBcn1tcdk95XlMh239edk9NXmEx019ddnftK1lALXUPsGFj5s6PvoLbDXdQDiLMfrmb3ANbsnsCa3Qis2U3Amt0MrNktwJrdCqzZvYA1uzewZvcB1uw2YM1uB9bsvsCa3Q9Ys/sDa/aAyeurW286zeT21Y03nXby++rSm043JX114U2nn7K+vN50hinsy+dNZ5zyvibwpjPV0leVN525tr46edNZau0r5k1nrb2vcd50Nkhf/3nT2UF9sTedA9BXhzeds5+N63YXA7XdXEBtNxCo7eYGart5gNpuXqC2mw+o7eYHarsFgNpuQaC2Wwio7RYGartFgNpuUaC2Wwyo7RYHarslgNpuSaC2C4DazgG1XQKo7ZJAbZcCars0UNtlgNouC9R2IVDb5YDabimgtlsaqO2WAWq7ZY1ou0uA2m45oLZbHqjtVgBquxWB2m4loLZbGajtVgFqu1WB2m41oLZbHajt1gBquzWB2m4toLZbG6jt1gFqu3WB2m49oLZbH6jtNgBquw2B2m4joLbbGKjtNgFqu02B2m4zoLbbHKjttgBquy2B2m4roLbbGqjttjGi7S4FarttgdpuO6C22x6o7XYAars8UNsVgNquCNR2EVDblYDargzUdjsCtd1OQG23M1Db7QLUdrsCtd1uQG23O1Db7QHUdnsCtd1eQG23N1Db7QPUdvsCtd1+QG23P1DbHQDUdgcCtd1BQG13MFDbHQLUdoca0XaXAbXdYUBtdzhQ2x0B1HZHArXdIKC2Owqo7Y4GartjgNruWKC2Ow6o7Y4HarsTgNruRKC2Owmo7U4GartTgNruVKC2Ow2o7U4HarszgNruTKC2Owuo7c4GartzgNruXKC2Ow+o7c4HarsLgNruQqC2uwio7S42ou0uB2q7S4Da7lKgtrsMqO0uB2q7K4Da7kqgtrsKqO3uBmq7wUBtNwSo7e4Bart7gdpuKFDb3QfUdvcDtd0woLYbDtR2DwC13QigthsJ1HYPArXdQ0BtNwqo7R4GartHgNruUaC2Gw3Udo8Btd0YoLZ7HKjtnjCi7a4AarsngdpuLFDbPQXUdk8Dtd0zQG33LFDbPQfUds8Dtd0LQG33IlDbvQTUdi8Dtd0rQG33KlDbvQbUdq8Dtd0bQG33JlDbvQXUdm8Dtd07QG33LlDbvQfUdu8Dtd0HQG33IVDbfQTUdh8Dtd0nQG33KVDbfWZE210J1HafA7XdF0Bt9yVQ230F1HZfA7XdN0Bt9y1Q230H1HbfA7XdD0Bt9yNQ2/0E1HY/A7XdL0Bt9ytQ2/0G1Ha/A7XdH0Bt9ydQ2/0F1HZ/A7XdP0Bt9y9Q2zX0x2m7HrX11Unb9ay1r5i2a+yP0FD/9dXUH6PHuK/m/jht1wLoq0Pbtfa3oe2uAmq7Xv1x2q53f5y269Mfp+3a+uO0XXt/nLbr2x+n7fr1x2m7/v1x2m5Af5y2m6Y/TttN2x+n7abrj9N20/fHabsZ+uO03Yz9cdpupv44bTdzf5y2m6U/TtvN2h+n7Wbrj9N2s/fHabs5+uO03Zz9cdpuLqC2GwjUdnMDtd08QG03L1DbzQfUdvMDtd0CRrTd1UBttyBQ2y0E1HYLA7XdIkBttyhQ2y0G1HaLA7XdEkBttyRQ2wVAbeeA2i4B1HZJoLZLAbVdGqjtMkBtlwVquxCo7XJAbbcUUNstDdR2ywC13bJAbbccUNstD9R2KwC13YpAbbcSUNutDNR2qwC13apGtN01QG23GlDbrQ7UdmsAtd2aQG23FlDbrQ3UdusAtd26QG23HlDbrQ/UdhsAtd2GQG23EVDbbQzUdpsAtd2mQG23GVDbbQ7UdlsAtd2WQG23FVDbbQ3UdtsAtd22QG23HVDbbQ/UdjsAtV0eqO0KQG1XBGq7yIi2uxao7UpAbVcGarsdgdpuJ6C22xmo7XYBartdgdpuN6C22x2o7fYAars9gdpuL6C22xuo7fYBart9gdpuP6C22x+o7Q4AarsDgdruIKC2Oxio7Q4BartDgdruMKC2Oxyo7Y4AarsjgdpuEFDbHQXUdkcDtd0xRrTddUBtdyxQ2x0H1HbHA7XdCUBtdyJQ250E1HYnA7XdKUBtdypQ250G1HanA7XdGUBtdyZQ250F1HZnA7XdOUBtdy5Q250H1HbnA7XdBUBtdyFQ210E1HYXA7XdJUBtdylQ210G1HaXA7XdFUBtdyVQ210F1HZXG9F21wO13TVAbXctUNtdB9R21wO13Q1AbXcjUNvdBNR2NwO13S1AbXcrUNvdBtR2twO13R1AbXcnUNvdBdR2dwO13WCgthsC1Hb3ALXdvUBtNxSo7e4Darv7gdpuGFDbDQdquweA2m4EUNuNBGq7B4Ha7iGgthtlRNvdANR2DwO13SNAbfcoUNuNBmq7x4DabgxQ2z0O1HZPALXdk0BtNxao7Z4CarungdruGaC2exao7Z4DarvngdruBaC2exGo7V4CaruXgdruFaC2exWo7V4DarvXgdruDaC2exOo7d4Caru3gdruHaC2exeo7d4T0nY9K3+icI5uwOnEG3vUh3NQ2+Fu6oEbv1kbZTj3AHO+uYcNnLcYwXmrEZy3GcF5uxGcdxjBeacRnHcZwXm3EZyDjeAcYgTnPUZw3msE51AjOO8zgvN+IziHGcE53AjOB4zgHGEE50gjOB80gvMhIzhHGcH5sBGcjxjB+agRnKON4HzMCM4xRnA+bgTnE0ZwPmkE51gjOJ8ygvNpIzifMYLzWSM4nzOC83kjOF8wgvNFIzhfMoLzZSM4XzGC81UjOF8zgvN1IzjfMILzTSM43zKC820jON8xgvNdIzjfM4LzfSM4PzCC80MjOD8ygvNjIzg/MYLzUyM4PzOC83MjOL8wgvNLIzi/MoLzayM4vzGC81sjOL8zgvN7Izh/MILzRyM4fzKC82cjOH8xgvNXIzh/M4LzdyM4/zCC808jOP8ygvNvIzj/MYLzXyM4G3rawNnDCM6eRnA2GsHZZARnsxGcLUZwthrB2csIzt5GcPYxgrPNCM52Izj7GsHZzwjO/kZwDjCCcxojOKc1gnM6IzinN4JzBiM4ZzSCcyYjOGc2gnMWIzhnNYJzNiM4ZzeCcw4jOOc0gnMuIzgHGsE5txGc8xjBOa8RnPMZwTm/EZwLGMG5oBGcCxnBubARnIsYwbmoEZyLGcG5uBGcSxjBuaQRnIERnM4IzoQRnEkjOFNGcKaN4MwYwZk1gjM0gjNnBOdSRnAubQTnMkZwLmsE53JGcC5vBOcKRnCuaATnSkZwrmwE5ypGcK5qBOdqRnCubgTnGkZwrmkE51pGcK5tBOc6RnCuawTnekZwrm8E5wZGcG5oBOdGRnBubATnJkZwbmoE52ZGcG5uBOcWRnBuaQTnVkZwbm0E5zZGcG5rBOd2RnBubwTnDkZw5o3gLBjBWTSCMzKCs2QEZ9kIzh2N4NzJCM6djeDcxQjOXY3g3M0Izt2N4NzDCM49jeDcywjOvY3g3McIzn2N4NzPCM79jeA8wAjOA43gPMgIzoON4DzECM5DjeA8zAjOw43gPMIIziON4BxkBOdRRnAebQTnMUZwHmsE53FGcB5vBOcJRnCeaATnSUZwnmwE5ylGcJ5qBOdpRnCebgTnGUZwnmkE51lGcJ5tBOc5RnCeawTneUZwnm8E5wVGcF5oBOdFRnBebATnJUZwXmoE52VGcF5uBOcVRnBeaQTnVUZwXm0E5zVGcF5rBOd1RnBebwTnDUZw3mgE501GcN5sBOctRnDeagTnbUZw3m4E5x1GcN5pBOddRnDebQTnYCM4hxjBeY8RnPcawTnUCM77jOC83wjOYUZwDjeC8wEjOEcYwTnSCM4HjeB8yAjOUUZwPmwE5yNGcD5qBOdoIzgfM4JzjBGcjxvB+YQRnE8awTnWCM6njOB82gjOZ4zgfNYIzueM4HzeCM4XjOB80QjOl4zgfNkIzleM4HzVCM7XhHD2rMKZDDKpVCmbKLmkyweJXCFMB6l0IRO60KXDdJQIk8lSmAqzuUIuG+RcKlly5XQuWa70vSCQ8+t14hzUdrg3euLG74P+Nua5CTh+bxrJ7WYg57eMcG4Bcn7bCOdWIOd3jHDuBeT8rhHOvYGc3zPCuQ+Q8/tGOLcBOX9ghHM7kPOHRjj3BXL+yAjnfkDOHxvh3B/I+RMjnAcAOX9qhPM0QM6fGeE8LZDz50Y4Twfk/IURztMDOX9phPMMQM5fGeE8I5Dz10Y4zwTk/I0RzjMDOX9rhPMsQM7fGeE8K5Dz90Y4zwbk/IMRzrMDOf9ohPMcQM4/GeE8J5Dzz0Y4zwXk/IsRzgOBnH81wnluIOffjHCeB8j5dyOc5wVy/sMI5/mAnP80wnl+IOe/jHBeAMj5byDnxob/nvF5qUJ4EYpFKRajWJxiCYol+edQOIoEjwVFiiJNkaHIUoQUOYqlKJamWIZiWYrlKJavcF+RYiWKlSlWoViVYjWK1SnWoFiTYi2KtSnWoViXYj2K9Sk2oNiQYiOKjSk2odiUYjOKzSm2oNiSYiuKrSm2odiWYjuK7Sl2oMhTFCiKFBFFiaJMsSPFThQ7U+xCsSvFbhS7U+xBsSfFXhR7U+xDsS/FfhT7UxxAcSDFQRQHUxxCcSjFYRSHUxxBcSTFIIqjKI6mOIbiWIrjKI6nOIHiRIqTKE6mOIXiVIrTKE6nOIPiTIqzKM6mOIfiXIrzKM6nuIDiQoqLKC6muITiUorLKC6nuILiSoqrKK6muIbiWorrKK6nuIHiRoqbKG6muIXiVorbKG6nuIPiToq7KO6mGEwxhOIeinsphlLcR3E/xTCK4RQPUIygGEnxIMVDFKMoHqZ4hOJRitEUj1GMoXic4gmKJynGUjxF8TTFMxTPUjxH8TzFCxQvUrxE8TLFKxSvUrxG8TrFGxRvUrxF8TbFOxTvUrxH8T7FBxQfUnxE8THFJxSfUnxG8TnFFxRfUnxF8TXFNxTfUnxH8T3FDxQ/UvxE8TPFLxS/UvxG8TvFHxR/UvxF8TfFPxT/UvAi60HRk6KRoomimaKFopWiF0Vvij4UbRTtFH0p+lH0pxhAMQ3FtBTTUUxPMQPFjBQzUcxMMQvFrBSzUcxOMQfFnBRzUQykmJtiHop5KeajmJ9iAYoFKRaiWJhiEYpFKRajWJxiCYolKQIKR5GgSFKkKNIUGYosRUiRo1iKYmmKZSiWpViOYnmKFShWpFiJYmWKVShWpViNYnWKNSjWpFiLYm2KdSjWpViPYn2KDSg2pNiIYmOKTSg2pdiMYnOKLSi2pNiKYmuKbSi2pdiOYnuKHSjyFAWKIkVEUaIoU+xIsRPFzhS7UOxKsRvF7hR7UOxJsRfF3hT7UOxLsR/F/hQHUBxIcRDFwRSHUBxKcRjF4RRHUBxJMYjiKIqjKY6hOJbiOIrjKU6gOJHiJIqTKU6hOJXiNIrTKc6gOJPiLIqzKc6hOJfiPIrzKS6guJDiIoqLKS6huJTiMorLKa6guJLiKoqrKa6huJbiOorrKW6guJHiJoqbKW6huJXiNorbKe6guJPiLoq7KQZTDKG4h+JeiqEU91HcTzGMYjjFAxQjKEZSPEjxEMUoiocpHqF4lGI0xWMUYygep3iC4kmKsRRPUTxN8QzFsxTPUTxP8QLFixQvUbxM8QrFqxSvUbxO8QbFmxRvUbxN8Q7FuxTvUbxP8QHFhxQfUXxM8QnFpxSfUXxO8QXFlxRfUXxN8Q3FtxTfUXxP8QPFjxQ/UfxM8QvFrxS/UfxO8QfFnxR/UfxN8Q/FvxQsKHpQ9KRopGiiaKZooWil6EXRm6IPRRtFO0Vfin4U/SkGUExDMS3FdBTTU8xAMSPFTBQzU8xCMSvFbBSzU8xBMSfFXBQDKeammIdiXor5KOanWIBiQYqFKBamWIRiUYrFKBanWIJiSYqAwlEkKJIUKYo0RYYiSxFS5CiWoliaYhmKZSmWo1ie9QrFihQrUaxMsQrFqhSrUaxOsQbFmhRrUaxNsQ7FuhTrUaxPsQHFhhQbUWxMsQnFphSbUWxOsQXFlhRbUfDvmuff486/I51//zj/bu8dKPh3UvPve+bfpcy/p5h/BzD/fl3+3bX8e2H5d67y7zPl3xXKv4eTf8cl//5I/t2M/HsP+XcK8u/r49+Fx79njn+HG/9+NP7dY/x7vfh3ZvHvo+Lf9cS/R4l/RxH//h/+3TqDKPh3wvDvW+HfZcK/J4R/Bwf/fgv+3RH8exn4dx7w7xPgd/Xze/D5HfP8/nZ+Nzq/d5zf6c3vy+Z3UfN7nvkdyvx+Yn73L79Xl99Zy++D5Xet8ntM+R2h/P5NfrfllRT8TkZ+3yG/S5Df08fvwOP3y/G72/i9aPzOMX6fF78ri99Dxe944vcn8buJ+L0//E4dfl8NvwuG37PC7zDh94Pwuzf4vRb8zgh+HwO/64DfI8Df0efvv/N3yx+i4O9E8/eN+bu8/D1Z/g4qf7+TvzvJ30vk7/zx9+n4u2r8PTD+jhV/f4m/G8Tfu+HvtPD3Rfi7GKxX+TsE/Hw+P/vOz5Xzc9b8DDM/h8vPpfJzmvzcIj/H9x4FP+fFzz3xc0D8XAw/J8LPTfBzBHxfne8z831Xvg/J9+X4PhXft+H7GHxdn69z83Vfvg7K1wX5OhlfN+LrKHxdgX02+072YexLWKf3/G/rb+DnjPlYpGH8USkLDY2Vz/m5XH5OlZ/b5OcY+bk+fs6Nn/vi56D4uSB+ToafG+HnKPi5Ar7Pzved+T4s35fk+3R834rv4/B9Db7Oz9e9+TowXxfl64R83WwgxdwU81Cw72Yfyr6MfQo/+74QxcINEx5R7Hzayp8zfLTiLHs/ecOq8b83fTefzVb587JpDxi04B48U+OP+br5d9nW//684qY575nto55bxT8Lu/ls2W4+W76bz1bv5rM1u/ls3W4+W7+bzzbv5rMtu/lsu24+26Gbz6JuPit389ke3Xy2Vzef7dPNZ/t189nB3Xx2aDefje3T9WdPd/PZK9189lo3n73RzWdvdfPZ+9189mE3n33czWefdvPZl9189nU3n/3czWe/dvPZX9189k83n7W2/ffn8fP+MO2dN104f/yzF9u7/ncvd/PZ69189mY3n33YzWcfd/PZF9189lU3n33XzWc/dPPZH9189lc3n/3TzWf/23i6+Ky5m89au/msd+UzX50/oJvPDqp8NvbcZx+78cR8fDtqOKSbf3dYN//uiG7+3VHdfHZMN30e182/O6Gbf3dSN//u1G4+O72bPs/s5t+d3c2/O7ebf3dBN59d1E2fl3Tz7y7r5t9d0c2/u7qbz67tps/ru/l3N3bz727u5t/d1s1nd3TT513d/LvB3fy7e7r5d/d189mwbvp8oJt/N7Kbf/dQN//ukW4+G91Nn2O6+XdPdPPvxnbz737s5t/t3t//7yrNDTPO+d+fvSv/3SFeWcuzjl+h8t9BbYfrHesX3X8Y5KLeDZ0PMP5k71ifAv0nOvpvkuk/qMjKhksGde6/oern9q38d4/YWHb8m47P4gbn0spnvRrGbav/Oz+kct67qj+JeY9jQo/bdB78PWPc+Fh5kMTPThQ7+l+l0n9Dp75dMswkE2EmkYhKQT7KZMu5ZDZIFtLJXLHggmQ6EUbZfDIISslSMRVEmVw6KuVz6WS5kM9lOvpe1dt3slSgrtL5TFhw5XymHBRS2TCZL2ezUT7K0X3DdBC5YsYVE64chvl0Ol9M55wrl3Lpcjiu79VExuW/tcLH6jL9j6tVa4j0n0x39L9mrH/g97aDjv7Xkul/3PisLdP/uPldp9J/g8DYrDtIJHeSHf2vJ9K/G4d/fRn8qY7+N4j130NgfDaU6X9cbm4k0/+43NxYZvzLHf1vUum/Ida3C5OJRDbJz2OEUeBSUTERUvUvpIJikC8mSrmUy5VTiVSyGBULYSrMu3JQzhdz5fC/zjv63lQEe3Jc7mwmMzbjNN7mIv27cbmzxSCJ3EmO2xe3HNQwwdwGtR3j9pStuu57itOno++tPX0n8slikCsH+XSYz5bCNMmNgE4KYamcSeQLJDwSkXOulKL/S5SiVK4QZVwhU8om0gX6ceNycptBInM6TkNtC+4/kw9ypUwm29H/duD+C4VMNk/j2dH/9uD+k8VMqZzMjqtnO4D7z6dT5XI6me/oPw/uP+2CUjqRHZebBXD/uUKQzoThuPwpgvsn3ZyMcvlCR/8RenwKpaAYuVyHJytV+u/4GXx0/Owy+GdXjlyPqp/X0NDZczZU/fw+VVjRur5H1c+L44mPT4e/6xi7HQdNiHWA57N4jan+rNHT1vFzfH1tB+xre2BfOwD7ygP7KgD7KgL7iirnsmstNW4f3VGk/2TY0f9OIv0HpY7+d5bo343XvrvE+m/A4R/X/66x/nsI9L+bzPiP6393mfEZp633qPQv0feeMmM/ztfsJTP24zTe3jL9j/Md+8j0P04D7ysz/uNqz34y+Mf1v79M/7mO/g+Q6X+cxj5Qpv9xGvUgmf7HaeyDRfp34/AfMkgiPxPjauehIvgT4+rbYSL4k+PwHy7T/zj8R4j0nxrX/5Ey/Y+r/4Nk+h9X/4+S6X9c/T9apv9x2u0Ykf7T4zz+sSL9Z8blz3Ey/Y+75n28TP/j8vMEmf7H5eeJMv2Py8+TZPofp09Olul/nH44Rab/cfrhVJn+x+2Pp8n0P25/P12m/3H3Bc6Q6X9cfTtTpv9x9e0skf6z4/b3s2X6H3cN+RyZ/sfVz3Nl+h9XP8+T6X9c/Txfpv9x9fMCmf7H1bcLZfofV98ukul/XH27WKb/iB/r5meeXp3mv/58z4oB9VDQ8RxWxzNbHT8j/rObY+1ALxVNyjX9+M/vU4VV4pp+/Od14Kken/g1ff6sxYN1gOez6jls8fycFs/PGeD5rFqf1dLX2cC+TgT2dSawLyTH04F9nQLs6wxgXycB+zoE2Bdy7JFr6BylfR0L7AuZE8ixR+bX8cC+kGsbmRPHAftC1ujzgX1p3R87dK+stgoyfT0/u+Po+Kw19rPjmqr6aKz67zhu1qpvTzO+3+q/13G0N4y/b73vwXsU19tzv9K+Dd38Az5WGeRv1zZ4Pao+6zUJHBoaJj6w30/CwFYL+Di2vlV9xv9tD09fjZ626mSOj3lTFxjifXTMVbUQXqHy30FNh0tOCo/4z6+XifAVCZ+J6BifVpnxSfSo6j+Op9UzPtU5XD13PRrGL+TmWF/xv98a4xj/+/Hzjn8fb3u98ueAhgnXUccD/D08nzV62jrGl7G/WMUtPjfVeSozDyk3qXna8fP7NEium/F56ssL32bWu2HCeUY+dDQp8+qrbb09n3X01fEQYDxP43+/V4xj/O/Hzzv+fbzt08qfAxomzOnqPO3t4RNvi+fp+5Xz3l3wWaHy30FNRzbr26eq10F8nJAPUU/qOuj4+X0aJPNu/DrwzZOvnnSMXR8P1gGez6ov+vTx/Jw+np8zwPNZtRCtpa8zgX0dB+zrBGBf5yjt6xRgX2cA+zoJ2NchwL5OA/aFzHuN49XdPji5ffGBzNVzgX2dDOwLmatIjscC+9K6ti8C9nUYsK+OG3zVOrOj/4aG8Vqper9fofLfQU3Hf94t/vM6eMTb4j+/TxVWLJ7xWsk3rj5N2zE+bTLjMw5PmwdPm2d8Ouay3fNZR18d11riniH+99tiHON/P37e8e/jbR0GcEBVn3xUe4Z2D594W9wzLNqjM7f43FTnqeQ8xH9eB+54W/zn92mQXDdBt3nhW/+9GyacZ+D4BJMyr3G8HXPZ1/NZR1/9Kv8dz9P432+PcYz//fh5x7+Pty1flafxnK7O074ePvG2eJ7mqvI0PjfVeSoyD648yXna8fP7NEium/F56suLNs849m6YcJ6B4xNMyrzG8XbMZT/PZx19dbwcKp6n8b/fN8Yx/vfj5x3/Pt62blWexnO6+otT/Tx84m3xPF290m/vLvisUPnvoKYjnfLNJa7/rOvr4Vm9zuJjjcvr5CSvs46f36dhwryQWGf9q/B0lQcdYzfAg3WA57PqHBng+TkDPD9ngOezal9TS18nAPs6BNjXccC+TgP2dSywr1OAfZ0O7AuZE8cD+zoG2Nc5oL589bkWXGeDcPFxLrAv5Nq+CNgXshYi1+MZwL6Q83gxsC9kTiDHHrW2G8AckTlxJrAvrXUCiev/D5pp6p72fzf2yPV4IrAvJMcLlOJC6gkkx+r7A3Fv2aPyZ++GCdce0GeXelT9vA4e8bb4z+9ThRWLZ7zP9o1rf8+4dozdNB6sAzyfVfvsaTw/ZxrPzxng+ax6z6ilrxOAfR0C7AvJ8RRgX2cA+zoX2Bdy7C8C9jV1Hievr4uBfSFz4nhgX2cC+0LWr3OAfSHHHpmryLHXWr+QuYrMr9OBfSHnEZlfyDWEzK+zgX0dC+wLyVGrlkNyROqJY4F9/f9By10A7EurzkFqzKl64v+NNXQssC8kLlR+8Xn1ddVacJ03CNfXscC+kBqgY6+tft6to38+ZK+hJSb5Gdvqa2giz2BN5Bqa79m63g0T5iFwfNykzHMcb8dcTuv5rKOv6Sr/HX8mLP73p4lxjP/9+HnHv4+3rVgZlAFVffJR/UzYtB4+8baO8eVnwpbu2ZlbfG7+v/beBEiS67oOzZrqnpnumcb0LNi3AYcAQYIAa+mVlOShiYUbCG4CSZEi1Us1MOBgsA2AmcFWJBsbQewLCVAUJVGSKUqiNmq1/Wk7vsKSbNmy9S1bDi/h/6Xwt77DYX1/hZewwh85zFt16vTJl1ld9/XUAP0iOjor381z77vvvvvuW/Il22nMekB+JjfeQ/7jScx2UwvahZpDH0vW1rOjfmpl6hXltbrcK/IMyz7UjnaK9HugjEiP1/Y83ruB7BRtmu10rygP3kM7fQ/ZKdYN22mceii/F9z4jycx203XTpVdqH5qLFlbz476qZWpV5TX6nKfyDOsM7PfaKdIvxfKiPR4bc/jvR8mO0WbZjvdJ8qD99BOP5b92JXkt89+/bSKx1iH+By3hyj1XW/VyrYH4z+exGyf3fawt6ReTT/7ouhneaWM/aC8VpdnijzDOiv7je0B6fdBGZEer+15vHeE2gO2HW4PZ4ry4D1sDzeT38a6YTuNUg+12kpZOzX+40lMP9m1U2UXqv8bS9bWs6M8rTL1ivJaXZ4l8gzr7Ow32inSnwllRHq8tufx3v1kp2jT/A7PWaI8eA/t9J7sx1hOeQ5mv2sDpVZd1aUf/kJtTOjaD78xPybqyw9/cc7wz4mDP2P450bBn+vU73lR8Kc7+jk/Dn7nQ+EXxLGfjvwXRsFvdj5Af1EU/FZH/ouj4E918PdHwV/stN9LouDPd+z/DXH006nfA1HwV6YN/41x9NOR/9I48nf8/5sA33MuwvDfHAW/1jR9XJ50U1WUyfhbLHIZ0Fdy/hsW5xmvccKKFfepsqH8PO67HORBHeRhXd4n1pjIi1GnbwqUG/lPBGTlcqSJz8ZYr07S9Igj1ucdsZ5zwlKx7SByPeAo15lOcqn4dxCssx2xqk5YaeIPbQ0i1zlOcqXX5w4p1nmOWOc7Yl3giHWhI9ZFjlgXO2GliT+wMohc+x3letZRrkuc5Eqv3+CI5dV3pNcHHLHe6Ih1qRNWmnjudFiwPpRhxZ3vmpqPO9/VXIg73zW1HHe+a7oZd75rajbufNfUksXq1h8aD7Qt7N/8xhVTpd8RM/7jJKuvPN3x3QUkD+vH2qXp7kIh66TI4zZ6oeBzoeAzKfJ4j98gWC85Yq06Yj3piPWEI9YjjlgnHLGecsR61BHr+SHFWnXEetwRy0v3qt8eFlv1bI8vOGINa3t80RHLsw0Nq+6/6Ii16ojl2dd6+mhP3a86Yg2rfXnGJp71uOqI9XrwEy87YaXXPIYdRK62o1xnO8nliZWmB9t+cp3jKJeX7tP0BUcsT5vgufRBsKpOWGnysok0fd4R6yFHLE/78pTLy1aH2RfudJTL01Y969HTrw6rvjxtledWh6Vte/qvVxyxPOOvxxyxPOcUPGNyz7GC59yjxfc2j30e5FWy/3HXAGrrXgM4L448wTWA84Re1X5YR3mWy9Qzymt1eZHIMyxby8e9/Uh/IZQR6fHansd7T2YVN0mYaeK9/ReJ8uA902+6t//Ram/ZsG7YTuPUQ/lvQxr/8SRqu6mH7OICoUdlF/bspMjjmL5sfam6571vg2A944j1sCPWo45Yzw8p1hOOWE87Yj3uiHXCEetZRyzPNuRZjy85Yq06Yr3giOXZtj3ty7MNefrV14Pun3LE8vTR5gvVe1SO8UdNvefkiN955+DigC6QP+/FsXz137A4z3iNE5Zz2eqhsoXGbhiH895ehXVxn1jq3bgYdXpRoNzIP+67gNONuO8CTs/EfRdwasVs/hLQZ4V0dyBKXc6VPkvF+I+TrLHa1AGSh/XD46E3ClknRR7v3Xuj4PNGwWdS5HG/PQjWS45Yq45YTzpiPeGI9Ygj1glHrGcdsZ5zxPLU/bDa6guOWI86Ynnal6fPecYR6/Wg+6ccsTzL+PyQYq06Yj3uiOWl+/Sa9+UOi62uOmJ5xgCeWJv99ma/fbr0HZv99ma/vdlvvzZ1P6y2+qIjlqe+PH2Op+6/6Ii16ojl2W8Pq49edcQaVvvyjH0963HVEev14CdedsKqJGv35wyCdZEjltc8eXp9sRNWmnjv8SBy7XSUq932w/qCI9bnnbDS6/2JH9ZrXffpNb87MQjW2Y5Y5zhhpclTX29wksvTVtPk2YaG1e6HtYyvdV/oKVeaNvuO07/vSNPnnLDSa889D176Sq/PdZTrIUe5vPraNHn2j576Gsa+I02vOGJ5jvkec8TyXNPxnAfwnJ/w3J/D77cdgLxK9l+dF5/yOZj9rg2WlivEz8qB95D/OMnqLE89pNcDQq/qvHtHeZYqhI/yXCr0Y3X5JpFnWHZOJr7fhvSXQhmRHq/tebz35yPf+z9JmGni99vUWel4z/Sbvt/2pyO9ZcO6YTuNUw+N0u+3Gf/xJGq7qYfsQrV/ZRf2rKov7vfL1pfCesIR63lHrIcdsZ5xxHrJEetRR6znhlSuRxyxTjhiveyIdb8j1iuOWJ76etoRy7M9vuCI5Wn3nr7Qsx4fc8Ty9DmeNvGUI5an7lcdsTzletYRy9MmPGMTz3571RFrWP2Xp315tsdh9dGeWKuOWI87YpnubbyC45tK9j/yN+CmKsTPyoH3kP84yeorT3esp/R6qdBrP98XM1ntGvOQz0Z/xytNzzhiPeyI9agj1vNDivWEI9bTjliPO2KdcMTy+jZSmlYdsTzb4wuOWJ72teqI9aQjlqd9ebYhT7/qaROefnVY27Zne/RsQy85Yq06Yr0e7OspRyzPGMD62l1ZHsbbeB4J5iGfUMyPzxvdhHiukv2P+w3f+dLndRj/caGTGDH/5SX1arp7s5B1UuTx3pU3Cz5vFnwmRR73TYNgveSIteqI9aQj1hOOWI84Yp1wxHrWEes5RyxP3Q+rrb7giPWoI5anfXn6nGccsV4Pun/KEcuzjM8PKdaqI9bjjlheuk+v+byOYbHVVUcszxjAE2tY++1VRyzPGMDTR3vGE6uOWMNqX5v99mujbW/G5Jv2xXmbceGps69hjAvT5KmvYbXVFx2xPPXl6XM8df9FR6xVRyzPvmNYffSqI9aw2pdn7OtZj6uOWK8HP/GyE1YlWbvHaRC5HnSU6yInudLrnY5YnutDnvo611GuL7T9sD7vhJVe70/8sLxsIk38bvMw6N6zbXu3R682lF5f7ISVJs/2+HqwLz5vaBCssx2xznHCSpOnvt7gJJenL0yTp48eVrsf1jK+1vtaT7nStBmbnP59R5o+54SVXnvG5F76Sq89Y/KHHOXy6mvT5Nk/euprGPuONL3iiOU5p/CYI5bnupXnPNOTjliPOGLxeUM7Ia+S/R9L1vq6lM/B7HdtoFQvfd6Q8R9P1vZVfvJ09/nuS9bqdafQq+nuTCHrpMjjsfGZgs+Zgs+kyOM130GwnnHEetgR61FHrOeHFOsJR6ynHbEed8Q64Yj1rCOWZxvyrMeXHLFWHbFecMTybNue9uUpl2c9esrl6Sc8bcKzHp9yxPL09/zNc44JDma/awOl6WmLTTCWsZhqLNGxiQ/v+lyF+CWJjuuM/zjJ6itPN65T9Yb64bjuLCHrpMjjOjxL8DlL8JkUedw2B8H6kiOWp1zPOGGl19sSHyzvMp5wxHrKEet5R6zHHbE89fWCI9ZXHLGedcR61BHLU/dPOGI94ojlWcaXHbHud8SyeT6OLdJ0MPv/anfYnJtpNuZmGo3lVm1heWZ2Zb45W2suTjfnlxbrteZ0Y255dqFZq7WaraWp2vLM/PRya2F+urmyuDA/Gzd2mJ4fS3T/6oNfbxj+2XHwm4Z/Thz8KcM/Nw7+tOFfFAd/xvAvjoPfsc/9cfDnDD/O2Qf1jv2/OQ7+guG/JQ7+suFfEQe/ZfhvjYO/YvhXRsFv1Az/qjj4Hf/2tjj4Hf9Wi4Pf8W/1OPgd/9aIg9/xb804+B3/NhUHv+PfpuPgd/zbTBz8jn+bjYO/aPhzcfA7/nM+Dn7Hf749Dn7Hf74jCn6z4z+/Lw5+3fC/Pw5+xz//QBz8jn/+a3HwO/7tYBz8jn97Zxz8jv/563HwO/7nXXHwO/7n6jj4S4Z/TRz8jn+7Ng5+x79dFwe/49/eHQV/quN/3hMHv+N/3hsHv+N/3hcHvxMfvj8Ofic+vD4Ofsd/fiAOfsd/3hAHvxMffjAOfsc/fygOfsc/fzgOfsc/fyQOfsc/fzQOfsc//2Ac/I5/vjEOfsc/fywK/nQn/vx4HPyO//9EHPyO//+hOPgd///JOPgd//+pOPgd///DcfA7/v/TcfA7/v8zcfA7/v9Hkm7qYjdbi68uJUwvzMwt1lcWZlZqi1Ozc82FldnZ5YXl+anW7HRtub40U19q1Ffm5hampxeWpufr9ZXW/PTKXEf2BYk9SKp32tViDL3UVzp+YQnwK27yz3Xwl6PUaxe/FUU/yx2/vCLqtjG1PLO4UJtdmV1YmFt5tRNtLL/6b+ZVq1mZbizMN5cWXrWi5cXWwmJzab6xtNxYbrbmXvU1reb8TKvV7bNu8rabeq2WfvPyrmyTgZ29fDPoaJTq+1D2277nmabD7S7NzZCP9E+Pf+9/yu/ejN8E1EMCfNJkZR6JUV+vrkNUiF+S6D08xn+cZPWVp7uHZ4TkYf3wHp5RIesk5aWJ13RHBZ9RwUdhveKIdcIR61lHrEcdsZ52xHrEEesJRyzPMj7uiDWs9rXqiPWcI9YLjlie9rXqiPWkI5anfXm2oWccsTxtwtOv2l6/sWRtX+jXN8/Ura9dSNYmy8O4u0J5S0B/TbtLx6lKv7FM29Pfe7q4TMfyYNy0CPh5MUOaTI9bId8zxjH8sTj4TdP99qRXp1ymsRxdWb76b1icZ7zGk7V6jxEfqrKh/NxetoM8qIM8rO19Yo2JvBh1ujVQbuQ/EZBVlYPHN8ofqfjb6McCciH9LsHbnjUdjkOeow4bIR1iWzT+O0HO5dbi3Te9/zYcenaeRz2Y3s4huuvaXT2wDW7PwUro9zl0rwp4mOKOGU9tP2Bl6rcfQN0uUt56/V6a2DewztOU1vU/o7mFqigT21De3EIV8pH+X27r8vuT7HoH8NwZ4DlBciN9mq5r99KfAWWrCpqdJKPR/9tMrrT+dmf1p3Rn8ozR868lW7Yy9WvLWI8sm2Ga7XDd5tXL/wP1sm9PV2bmNxEoh/3+EcHPZJ8k2jRZHe+G+45zXKW/M2b8x0lW536oE8PsJnlYP+ZbUh3uyK4P37aw/K6F2++6+3BrC6lyF1wj/CTBGQ3SYpoEkZIcOq72NH2gvfY5TqbKUZJ5R9YHpu7kL2lalM0rTWPJ2jI7VtFSWZMx/uNJTDfVNZldJA/rZwvpJ5IJL1aSteZaFTxNXqvL3SLPsDKv0+O6kB7tGOnx2p7He9XMtiaTtc3u/e1eGVSTxHum39RO/yowfX9LuzdvVPC0vK2BvO2BPAxZzQYsbxyeO0zP7RCYqQwf2t7Fy7M1rG/r7ncla20/zxflYV1LWPj8bsLaU4B1PWHh83sIa28B1g2Ehc/vJax9BVi3ExY+z8eMnVmAdQdh4fP8WaizCrDuJCx8no/hPLsA6yhh4fN8NNg5BVh3ExY+z8dwnluAdQ9h4fN8NNh5BVj3EhY+fx5hnV+AdYyw8PnzCeuCAqwbCQufv4CwLizAupmw8Hl7dkJgcf8c5/Wy8v2z8R8nWWP1zxcla/WK+uFly4uFrJMij/3WxYLPxYKPwtrriLXPEetMR6yzHLHOdsQ6xxHrXEes8xyxznfEYr9V1F9/pP29/6H+2p5D20W6KtCoPhox8uKBalI+LvgAyax4qhjz1nZvHk7hcjyI040ck+NU7G7KwxiT/T5O0+6hvB2QZ+XBGHOUyvPR7H7c6Z5aDesrT1c87lX/k6TcdKCa0g2Na9fLB7Guaffy2fgpl1qrTDmQf+wpF9PF3oAu4hxLNFV6+omPv9wbSRdmi0XjAl7iUbH/XkGP01U3tY6+umjy149/dOGmbUCKbojFmSC63fR7T45YB4mOT8Sy8ILlQCxMLEdoOkzxV27ErkfF/TSpYdMk8ez35BB8/qwAn70D8tkr+MQ9haO7kh7nlIzuqqsaqmKZjD+fKGb56r9hcZ7xGk/W1lEMN6DKFqpnDGHLDOnP6RMr7skq3To9O1Bu5D8RkFWVA1fv0M/9BUxx37e9F1v5iri7eZozZe3R+G/Uzt+yOw9UaGvPTlJemvirAGoXwFbBR2E944j1oiPW045YjzhinXDE8iyjZz16lvFhRyzPMj7liPWsI9aTjliPOmK94Ij1hCOWp014tkfPNuRpE576etwR63lHLE/dP+aI5an75xyxPPXl6QtXHbE89TWsvnDVEcvT57weYiZPm/Dst710n17zydXDYveeuv+iI5an3XuWcdURyzMG8NTXy45YZd6OVeN6o1dvFKh5qdfLGwXTRHddu6sH9jll3yiYpnvVRL9RkGL/M9ruxm8jpCnufGyzUSF+XMaE+I+TrM7135mzUtuP1Lyn6e48IeukyHsDXGMe8jlP8JkUedxvD4L1lCPWs45YTzpiPeqI9YIj1hOOWJ428bQj1glHLE+b8NTX445Ynvp6zBHLU18vOmJ52uojjlivh3p8zhHLU1+e/dCqI5anvoa1H1p1xPL095725elzPNujp014xkxeuk+veQ5mWOzeU/dfdMTytHvPMq46Yg1r/PWyI5bNwahXVXiLvBrDnhvgg8+fWwJLjYeNXr3aEprrUa+22NxDpFc8GqH6UK/HrGeux/RWJzqe60Hfdn4OVkK/63Qvb66H9y0tZxNZcb/Ypbdm835F3DM6SeVTryviPbZffN7o4pax/9MGJilvCfJ4q/4yYOFpEZyq9BvLm9rr2X2cRID1sZiDOSpoK5RntHeNdeU4kMmx0XUfZ65w4+r+2naXjpOqeytvqvPLBqx79UVdk1u9jotz5JhnsvI9rkd8fneAz4EB+RwQfCbEc5Wc/8aH7zEfJXNovn29fBDLfEXcufv+7Z/1jPbPe3PxtGQ+1awFebgOxEm1DdNF2jZuKdE24p7stnE65FfEUIfYtjkpHZouyupwV1LctsdFOVQ/we809NtP4PO7AnzGBuQzJvgMWyyyl/LQlvg1RbSlMykPbYnXxVYgr0J5N0HeVsrDk7r5BLxDkMe+4RbI69c3YMz0Y079Jvr/JcrbLnDjvrrWbJbpX5D/OMnqK093vVW9UqtObDTdnSlknaS8ND3U7tJxXlXc2xLAesIR63lHrIcdsZ5xxHrJEetRR6znhlSuRxyxTjhiveyIdb8j1iuOWJ76etoRy7M9vuCI5Wn3nr7Qsx4fc8TyrEdP/+Wpr2cdsVYdsTz15dmGPOOJVUesJx2xNv3qqfOrXrpPr3m9dVjs3lP3X3TE8rR7zzKuOmI97og1rPHqA45YFq/aczjGxznnyOtyjVN5xoZaY+YxveWr/4bFeXzGxplxyhY8YyNkB7gGxev0g5yxweeyxD5j46xAuZH/REBWVY59jjop8+ULNbfUb92qM3fs2chtrLN3YV9AT8h/kPdUGkRn65FbkrV1d1YOVkK/G3Qvb++C2RGe7WLrW+mc8dy4lhmPnMYzbXZDPtLfDl9xfEd2vStZa09WLvXVBzuyLe6XY/qf5x+lvCVRnorAUnPkVqZ+v3CA7zKhbIiZ94WDrZCP9O8e78ry++dpzApg4jtdtv/G6G0dYWvSLTfSsAxG/36Qwb5+wZgjOeXanoO5CLZ4w7jGTASmKtc4lYtlGCMZjP4jUK4/gA1SSGO/0U6OtHtl2yF4JTn3EBuf5bwQ36Jn02v8+gXnsa2wvvD5PJ2yrRj9pwK2slXIgOXlemUZmGY8R4YfETLg8X5Lt91+PPsaRUKJP6ozSr+5KrkKtgqcvGRqSJ9ZHNc4SGeJzQ+XYbcLHttzZMRnU/VY9S63DreOtnIUtIXARnOYbUl0Up8PMF8a+Wtkpd/D5K/CbY0jT/CrcOp9ZXWErT07KfJ4fb8sn51Jty3ddfS2O/NsAY1S2UI1h39FPJ/QsxVxL0l63+lVsQuXud8vVI6J8ig+kwPymSzJZ++AfPYKPoyl4sg0rbS7+Uh/P/jXPzxPY27JwbTPXBi9iu3VnhOjV3MT+0QZ1fv1ZybFvFGX3B+d1aesRXMD+0hWNcYsK+u1GyzraJ+yjgne2Ce/2ukcuqd15wduO9o5hTkRYiR0zf0x03A3sz1H1J1Ex2EYT9uwq9tDv3cI+VRSro5lqSbFibckfwma6B/lNNEk0U3UzJ6HpfgsDkvNJO4UdMbzLioP0iNPoz8KfFTodyeV2+hfEKHfpJDJ5Bmj5327+Nlp0+HdydpkefckvWXHvHuB/up2l46TGsZamVJd/MXuLi7TsTxYjyybYWKXgXWbVy8/DvXCH+pDfncl+eWw31XBj3Vp+WmyOr6XMA5mv2sDpemFCvFLEh1WGv/xZK1uY4SV95I8rB/lhgMf6rsbrhH+EwRnNEiL6RMgUpJDp6r9TPEcJ1PlKMn8N2G24VvktrDp8/dFUYaquMfR1oiQX/HZOiCfrYIP7ypNE3/Q7ZAoK+8qTRN/fO2zkMcfdDucrC2X5d0awDwSwLwtkHd7IO8OkZfK9NadXRnZHaumYV2Nqru8dpCHdS1h4fP3EtaxAiz+SBw+f4ywjhdg8Ufi8PnjhHWiAIs/EofPnyCs+wqw7iAsfP4+wrq/AIs/EofP309YDxRgHSUsfP4BwnqwAIs/EofPP0hYDxVg8Ufi8PmHCKtdgMUficPn24T1uQIs/kgcPv85wvp8ARZ/JA6f/zxhfaEAiz8Sh89/gbBWC7D4w034/CphPVyAxR9UwucfJqxHCrA+Rlj4/COE9WgAK73mt1nxeXt2QmBVsv8Wfj0G9/3CnXrp3f7Gf5xk9ZWnG349lqzVK+qHZ/UeF7JOijzsizAP+Twu+Cisux2x7nXEOuaIddwR64Qj1n2OWPc7Yj3giPWgI9ZDjlhtR6zPOWJ93hHrC45Yq45YDzticV8WiuvTa5vKCsX19hz6M54eqtIzSI8YeeOGKsh8b4HM/KboescP6fW5hLXe8UN6fRFhrXf8kF5fTFjrHT+k1/sJa73jh/T6csJa7/ghvX4zYQ0yfjje7sUaZPzwKcJa7/ghvX5L0ou13vFDen0FYeHz7HM/X4D1VsLC5/sZP6TXVxLWIOOH+9q9WOsdP6TXV5Fc6x0/pNdvI6zQ+OGxAqwaYeHzjxHW4wVYdcLC5x8nrC8WYDUIC5//ImE9UYDVJCx8/gnC+lIB1hRh4fNfIqwnC7CmCQuff5KwnirAmiEsfP4pwnq6AGuWsPD5pwnrmQBWmt7V7sXC558hrGcL5JojufD5ZwnruQKsecLC558jrOcLsN5OWPj884T1QgHWOwgLn3+BsF4swPo+wsLnXySslwqwvp+w8PmXCOvLBVg/QFj4/JcJ6ysBrDT9YLsXC5//CmG9XID1bsLC518mrFeScBn/WtKLhc+/QlhfLcA6SFj4/FcJ60cDWGm6qd2Lhc//KGF9rUCud5Jc+PzXCOvHCrD+OmHh8z9GWF8vwHoXYeHzXyesHy/Aupqw8PkfJ6yfKMC6hrDw+Z8grJ8swLqWsPD5nySsbxRgXUdY+Pw3COunAlhpsl1Ju8TzP0VYP10g17tJLnz+pwnrZwqw3kNY+PzPENbfKMB6L2Hh83+DsL5ZgPU+wsLnv0lYP1uA9X7Cwud/lrC+VYB1PWHh898irJ8rwPoAYeHzP0dYP1+AdQNh4fM/T1i/UID1QcLC53+BsL5dgPUhwsLnv01Yv1iA9WHCwud/kbB+qQDrI4SFz/8SYf1yAdZHCQuf/2XC+pUCrB8kLHz+VwjrVwuwbiQsfP5XCes7BVgfIyx8/juE9WsFWB8nLHz+1wjr1wuwPkFY+PyvE9ZvFGD9EGHh879BWL9ZgPVJwsLn7dkJgVXJ/o9l178F9/3We6bqFeJn5cB7yH+cZPWVp7v+9FvJWr2ifnj96beFrJMij+ccf1vw+W3BR2Edc8Q67oh1whHrPkes+x2xHnDEetAR6yFHrLYj1uccsT7viPUFR6xVR6yHHbEeccR6zBHrcUesLzpiPeGI9SVHrCcdsZ5yxHraEesZR6xnHbGec8R63hHrBUesFx2xXnLE+rIj1lccsV52xHrFEeurjlg/6oj1NUesH3PE+roj1o87Yv2EI9ZPOmJ9wxHrpxyxftoR62ccsf6GI9Y3HbF+1hHrW45YP+eI9fOOWL/giPVtR6xfdMT6JUesX3bE+hVHrF91xPqOI9avOWL9uiMWzzkW7ZP7VHYd2idnz+G8E79iWKVnkB4x8vbhVUHmov14P0wyD7If79OENch+vM8QFj7f7368MwlL7cdT78Hd2u7NOwTP8TsM+HUFfrfus5B3N+Xhe3A8L30r5N1LeUcg7xjl3QZ5xynvdsg7QXl3QJ7pCN+Ds/cjTUdvy+6PUdnMBg9mv2sDJvW1NNYj1lsl53+SrJ1jTxP7APzCRoX43O3IB7Gubn/vv9ko2i8fP3AP8eF7zAefvycHy17NThN+Ue0WyEf6d2R1n2L/8Xm9mGpv8iG4d107yS2rPWs2xX7tYPa7NliqG/6JOPjNkP/FMnEbRN31Y1/IazxJZL9y0El3obKh/GyH2B+U2Td+vE+sMZEXo06PBcqtfK6SVZUjr20in9DpnCcCciF9qH82HWIf6ajDRkiHqo9fz+mcprfzic78zpYkyY11GCuh3+fTvWqiT+dUvm0sR07jW+TH8XmjCx1hUcZvKD5KZuOD5wvgaaOfoHflze7wyA981t41HSX639ndxfxUhqneu8lrKxXgh2cTWN2zfHlHxXC/Z/QL0O/xSYW3UJmxnEpmw8TzH1BmO4eBZVihuCtSHynjLuO1i+Tl+uGyqDphuzsq9BDSLcYpGMcg/eE+4xS0UY5TUCZ7Vo31WA+KT6ifPFqSz/iAfMYFn0HjEMVHycxjqjShPzlO/sTsDv0JPmvvwY8S/a+CP7k/4E94fwrHTuxj2Z8Yvzx/wvZp9J8L+BMVm3+gnS+zYaI/QZnZnxj9I+RPIsVP0p8YL9Vf7ki0PpKkXH+5Q+ghdn+5g/gcc+SDWNZWVCzH/qff2Bqf51g2r72+sFPzVO2V4wOkvw/a65epvaK9m86V3XAfdUzw5TaTJGvHZ2kK+bJjOVhl+yij/3qgjwqNNdIUGkuH5hyRDmlC83/VAA+0W7xvsTH2nbcQ7XGiPRagzRs3ptcL2XXcsf3sorUFnMO0ZHn3C5ktD9/5/Wi7S8epSr+xTKmt/Ml5XVymY3lQT/fnYCp/waeHW5m3CNwThIs+gPVl52xx+/9u1hbS9v+dnRqP7SRNn8jw4o5fZ5e4fjFx/bJ+OKn6NbnT+t1+fheX6Zgn1uEDlIc+m892Q19vGKnuf49igmFrS+tpL/3oU7UXpU9eI1B9J+pzlDD+I9j7PyB7NxruL9Jk7cfarOlvRDyfJo79jP4fQ9/z0fM1/1B7SxLtF1APfCbj/YmWRZXZaP8D2SO2MT97nOp8QeRBkhl5PxSJd4X4JYme5zX+E0Iek3tc5I0MIOt0fXa2MTO1PL2yODM3Pd2qEL7Jyvd4jrIt6HcJetP15+B5P103l80HVNtd/DboNU0jkPcQ5Y1CnsmYtqGPnd8rfzuS/GX0j/wnBf21UIZ+6nJS8OExxyBYx9aJtSfpbQOqL8TYhvtCjF/wHNDt0GEovxjydebb2O9jOdkPjmb8zIaw/3O0oSkVj7KvezAS77K+zvhPJPl1Oy7yBvF1y9NT9amV+enF5ZVma3l2pZKs7ROq4h77OmW3Zwj6yL6ipnwd+7MRyHuQ8tDXmYzK18XpF5u1MvpH/pOCnn1d2bqcFHzY1w2CdWydWObrMA7iOBV9HcepJ0R50NfxuGwH+aQ4R9/rOUL2qShvmnAMfQL0xPplHLyHcTM+w3M2Rr93oivD5ISWz8rwfiGf2lOE5TpzIp/uhKBLw2OLo25qHf3IzQt3tpY/0lq6s3W0mmjxuIhcfB5OJUSXJv7y1W30m6dvDhGOdcFlv3xl/xFLVR1ic9d7bqay1IUtkgvDaSrHYe6cmg62pIacbEKY1DDX5E7L1OpjmItmxVO9t4hny3TbaWKXh3o9RLih5pzX/Kah+V020aVney6z/ajMsjLeQ/olysNloEoAn4f0bwWb/AOa1sNu28phy/IjkOdnr416KsftYEfsNzAkYLtWS6kcGoW2RaXJps1D22SUbaEtmY2oerZn1NIuf9Sw32XsCcEndpuaoPKgHXO40u8ymrLfouWgd+a0ybzloCshH+kPw3LQ1SXqU7UZo4vcZhqqzaBey7QZVQ9l2gzqcFLQf7zdm4e2w0tpKm+9bQGfN7q421Zm51X4a0mFv2zTOBVtR22qaX9c2uOk+mgrb2onj/TRR2N9cPiIbcDkVj6At9P06wNCNnEP4Cjfb58MYbsfzeGdt5VjAfpI/oCgahvKLo1ebZVUfYxaQuatkpG2EE+ZrPeBnKxf5o82ugXo7wvQ83YPxr8/R3dGnyasY142xlcJ1PYDe5anwQ5Dfe+mr3/dHyiPKjNPoYW2nFboj5c20nRXey1/tTSR/h3MftcGTFy/I8DjAaEPXkK5l/pkmy6pirIqvT4o+OIUl+lklOjvhXocvaAX02Tbkeg+jeuEp0y5Ld/W7s03+gdgvHBfztA6TRjDfGFC8x5PtB2yrCeErNi3nGj35hv950Bf2y/QsqI8SlbVRu0zUOtpo9eTrEb/aKCNhmxJ+VxesldtlOVmH1bWLoz+abCLJ8ku1Hgkpfsa6Zq3JaQp5B/Ynx7MftcGTFyX2E6Vv+S6/DKVy9pvVZRV1ekDgi9OXbJ/eID4Kv9gPLDNLQPfPDseFTKniduc0X810OZU36/sQL3SqNor18nWHHoui9H/RMm5Aoy30zQCeX5xSl3OFaBPHW33lvtYQE9p2pKjJ6RXU7STSbFP5m3k6T2MVW9qd/OR/rfAT/wcjUPV3BbzQ9lD4yV8vszcQeTp+PkK8bNy4D3kPy504ihP59Uz9enLkA3dI+RvtfPplY2qekunJ3g+YhKwjC++gnmM7qn5X6577MuwL/o75IOUvalXGlgvWxMd++e9/vm3c3wQ+1vTsRp335KsLYea22Ef3+9nT9W8uuJzaEA+ainH2ie/nnQw+10bKPW/fe4Q5alxg9oCZfMgFcFHzXWg3e+A/pTpWFY17lR9SiXnP8qD9/jVR6wPbK/KV/A9rnfV3mO/ZjBJ5Qlt2+53i7t6XTX0OkPkeZDSfRDGiqyTGH2QmkMKrXmo+PB4gD4U9yA99kEmE9okbilOCHs70LMP47pXn3pOffefUR+kvvaOzx5td/OR/iDM9f/fgRiL5+bQZ+xOtCxJUs6H4/N8jAevm6v/xofvhdZUdlN57gmUp1/fhM9vlG/aTXzy5lf+a878Sr+v+F0CdvM/AnYT6vtDrxPFmDsPHX2xXj5lX496LdvU+BndZwaxqV1gUxMZpuprX+t6Pu7IB7H49UWMHXieRPWzJwJ8Qser5NnNBWdonmXtxuj/62QX8+ISdqPqIO+IEOS7Uev8p2otEbFUzGP0at0vFIMpW1LjejWuMtuOuy27Xvo1EOM/TrL6ytONd9WnSu8TutuZdMd6C6276o25q1tLdx6//ShXhgFOJr1Kvp8AjT6h3/xcKtQI0dwjeKQJ36NHQ+LBIAfUjF9GpiLaonzVCO/LKWeSlGuE+Hy/Z4Lx+1tGP5s5vLLvMaPx8Ka80HvMx3Jkr4oyjCfakeACDeZhma8LlNnofyBQ5uMFZb6Wypx3HhH+ZrqqKMP2ZK0NIIbSMe67Xo894fMbFazsIT55nft7qXMvOpugBflI/6fQuV9PnbsKvmOXP+/MEixXC2jy3p0fEZhp4g3URn9jVvbIEz/yXYDQ/nlcEP/4GcW6CdW50f8x1PknS9R5qP2os3hCvuK0DmTqrVoZG0f+p30g828rvUouG8jwc6FAhmnzGvWggYySKY+230AGRwB5K7RJUm7FFJ/nHaZxVkUbNa4T3K2CjSnvIDDcmRcawfEqKuNzB4AvMyndWafIM6+3QRDz3Wy1RtXV3hz5kqRcXeHzG7Uzfi/xiTGLmyae0djoYD3PBq/MrouCpAf77DBxkID0j0CH+TnqMNUswnpnatnmk6TcDH+ovZVtP6yjEYGZprwDHL9GAVSclarpWmgWL27wNl268+eATu32Gxd5Ax1mMbtSr83MzDZXGgtzrekZ7iNNVr5XZkXvfEEfd8ZoSh5mcR/oNU0jkHeC8kYhD1cG+QXvOIHZ1HIZ/SP/SUHPO1v6nTX2wLKXstVg/VT5srIHuxv9NwITGuqAUey3eBJHHbDJgyEuI/vENB3M/hdZ0kpBMn5WP9uELLzD3Gi/BXr5exf0lkW9ZG4+qhrgkYh7lSRfd8xDveS+kvTKdryEbGriCTGO5siZYqgDKNmu+z2AMjRphXzOG5DPeYJPzJUv5FkUj/2tPlekbmx385H+KMRj36V4TL39bfzUxGroQG087ExNoLK/Mfr/HdpVmQO1bwTMPDsre6C20f/eEExocZlHku5OevSP72n3lsHov5yd/pDq/x+e0R/me3Mw//sZXcx/3Cfm+3Iw/xww/2nAHvclvfzQ1pX9c5vD5/GteZTFuX47HxU5HAe/8wGKzwpdYJmM/6A7J5HXeLK2jmJMzqmyheoZP67EK9MK67N9Yo2JvBh1ekug3Mh/IiCrKgfHFYrPPqETo781IBfSWxtG27dnTYf40SpHHTZC9X0r8DT+6/moiOntbKKzPm5Lslb3h3OwEvp9Nt2rJvqjIqnP3Jf152reZGeOzCYD32P7x+fZ/oflZByUkVOVfqPcaX3/691dXKZDDLbjvA/0KZ+bh6HmcovafZpwMcLa6V1Hb7uz9cE7D92zcLR1zT2tI0eF/W6n8rHd3Ua/DxMtn6hhebyY+Vn6fTv9vkPIw4l1gmlC0OWlovZxKVyvp33g86H5ywsH5HOh4BPCulRghfz3hYL+9eK/DxCdjbkG8d8H6F6e/96oNwYZC8dPtukE2zLH6BdlY4m4sc980/w7+k7TmfG+NRLvCvEzfeM95D8h5DG5x0XeIPPTjblmvT736hJ6qzZVW1iuhdoy3uO2f0TQv0nQm65vT6LoWh5AegT0mqYRyLuV8kYhz2RU89Nx/NN8Kf0j/0lBz/MlZetSYV27Tiybn0Yfb217o3xTXJ/SfzzJb0SWPRmq39OfrLyp3Z69p4vLdCwr1gfPhX5WlCPUl4bGvmqsGXc+Y+PqCtseJ1VXVt5+6wrrw+SO65s2TofoczgpHVp5Ux1e1ocO0dZ4Th59LZ+qMiz6rVAerhNe0+7ScSrSYaUPHap5/WqyVk+HBBaP335EyGPlvCPplR/rL028HojP30FYRwuweLM0Pl/mzRfEup6wQmuyxwqwbiAstXHdsI4XYN1OWKG3uk8UYN1BWKGTe+4rwLqTsEKnpt1fgHWUsPJOaUv/HijAupuw8Hk+he3BAqx7CAuff5CwHirAupew1CH1ao4IY7YJcc/aetwD9+t9f4hGjX9irA0ovas413TXFrJOijzstzEP+bQFH4V1iyPWvY5YRxyx7nDEOuqIdY8j1jFHrOOOWCccse5zxLrfEesBR6wHHbEOO2LdRlhqbK18286kuwZych3gXQu333X34VZCCeNJ44G/b8/hPymeTwJY+EyoLOoEfqM3/5t3Eh7vHTH6L2XzlHgKVej5NIX2m0de622U7Vd5zT32aWqh/QRp4n5VzR9NijyekzhUko+HjafpmrbmXxHPJwVY9lutMWFbuoAwbid5+R77CHze6BSfCwfkc6HgE8K6QGAZvRojhdaY1H5Ca3uRPj7eWWNSY1Y1zlrPGpPp7Xyi4zUmNXZlrIR+n0/3itaYsE4P58hpfItsBZ8P2eShAfkcEnwYK+8FbV7LMvrv0loW6t7PvuaaofeL4r7nMVd6LSvvNDeUW52eNsha1spco7bUXGnVppuLi0u15ZDP6Pekj0sEfdw9nHNyLQvnKdM0AnnHKG8U8vDjxLyWFccPztXK6B/5Twp6jt/6PWHQA8vWsrAvsba9Ub4prk8Z3rUs3NPTz/oI1gevZd0hyhHqs/FeqK7uCPA5MCCfA4LPhHiukvPf+PA95qNkLjqV8Y93dZ/BdpJ3KuOxdjcf6Rfh/YE/yTDVWjHPCXGbQBtME7d7/HJXmf7d6P8NjAH5/QH1DtSxdr7MxmME7ofe5zT6/4tijEgnj8r3B0Lvl/FcZL/vl6l3coft60281x3ntHjvDs5RHaE8nHPi8S7PIWEezsHfTnltyLuX8j4Hefwu/OchD22Uk/LNeAjQj/Xhm9UXhfgAG9Sv2i/4RrjGPJOV77G94fOHc55jPxJ5b2I9cpvu7P9X71ZimTh2V+tCZfoX5LVR6zaqbKG9TrjuwesWCuvePrHGRF6MOj0SKLfyCUpWVQ4ez6t29kahE6M/FpAL6dVBRxs9X6N06DVfY3q7gugs7tiSrLXBe3OwEvp9Bd3Lm69R72hhHDc5qWUuey6H0b8H4ri9cM1zmYh1c9KbdzPk3Z1dR97PN6XmVVh3dwNvHgPdI8pTti/FPXt/UeLdEbVnD2VDTKy/u4Amb63jksmuLL9/nsasJDq251jbbKLsu7pGfynIwLG20YzklOuzOZjvAFu8PMfWE4GpynUrlYtlOEwyGP1boVy2jpQkiexnb4bfR9q9sh0RvJKce9wXHMnJC/Eteja9vhOuVV/P9noX0ds6ZZ5O2VaMfjpgK+pdqNBeaZaBaW7NkWFeyJD2Ezuy/KXbbj+es7Q0AtfsnlVVchXcInDykqkhLZ41B8ax3yHzU8tySc49rgZ7Fs+8W24dbh3NW3vbQmCHcphtSXTaXIftpHWvw94qZJ0UeRwvluWz3nVYtoWbc/hXxPMJPVsR99KUNpa7tn3vWo1Fee6j37GoahyMlXcWx0q7m4/0N4A/4i8YHwY5FKbtWTV6FReHDgwtGl8af9OlGqeEeKt9v0Z/rE9Zi750foRkRfmO9ynrtRss6+E+Zc1rl9aHveqkD93TuvMDtx1tYVNhMRK6HqN7THM7/b41R9SdRMfT3nx0Efeb3CfdJuRTSbkGlqWaFCc+z/sz0ET/KKeJJkl4W5Paho8h9yQNudQSVsgcyxzDg64JMfiYIKO/KeCaThSUm5uE2k6uPvChtqbzsXW4zIpT0GkagTzH7nhZfdAUdTDaLl9epR+1RV4dYztJ9KgrtTTE07bYheHZ2H9MyzihDyyHPmqbJrY/PCe/KjBubnfzkf54wP7UawDquFSjV1v9cXqfp7BRv/assj985ShNI5DnaH8tZX+oA7a/UHmVftQ2elzisPqdJHrUlTrazHgq/4cfGLejzdTydiXnv8nK90JbC97f7uUT62NGtizI/lKFcun1lUkvPX5oW/lLpscPbYfqjz+0/Sy0sVH6yDX20zj9+Pyk5o3t+14hK/P+RZjmeYn6PxW+8ZG5L4Psv3NB/vPct2AMxEd25B2NiPrHcmKdsx8z+q+DnL9LHz5FX4LT6GkagTxHX7LSb1+mfG2oLyvytdxfoZ3mfb8CsVDnecOKrYIe8TjG+5aY7lPDvhMk+9E+ZS8bG94L5XiQjsRT/VaorpTfnxTPP1AC60SgvA+CzIoe/QTS/7rQPWOOJtqW7s/B/C3A/OM+MVs5mH8rEI+o/lN9P8Lo24Ie+1STR70u2KY8lJ37zYeAP9PeRPzV642J4JsE5OU+t0he9u2W90fQN/z97HqM8Jz9YjNUl5eJ8pSty3sD5Wcse24kWWuvqg09JPT1jyY15mifmP9E9K8q1rm13eX9RzmxQZo4NkgT+8B7hVwYc4SOFub44E9Eew1t1Y3a79ZbNdXvoi6431Vj7ND3gorG2BzDI/1n2715Zb4phXzW0699nPq10HHRRfMNH2v30lvZ0MejLhYhH+n/Q8DHqzF6qD6U7eO40uRRr73juOnk8+1u3qm011CcqPRzYgD9sL2quEfZK78Oq6Zjy9orHmH9XrJXtZVa1SXPnxTN9fBWZ/SDip5jIKP/qxJxFcoQetWi7PyA6uMeSjRvbJuoE/6QbmcsvLtbnpA/35g5mXpdtQ/UK7ePkA7T1G+MyPMubcjjeAzbx4OUp+Zay/rdUNuxZ/FjyqEPH/fbXllGNS5Xvt7o9wl7CvWlIV9f1Kb51Qb0HfbsqZsT0LaMOijj60PjnUF8PY+51dbjIt89HrC/vHkelPWWQNnKxl39rm2cyrrfyLUNrnu1tlEhnSCW8g1qfobjrUHiTeujWCd58SbPgRp9M+CDlN5Cdnhax5vrsMNhizeVD8L5yP+aKVf5II75lP2F4rMiHxSa574vhw/SpUm9Rpumg9n/2oAptCYT93NjtekK8TN94D3kPy70GGP7l6pX9fki00+cz8nVplI3pdbTDrXX6ibP77APt7WwNN0AOPzqk/qkZtqePri7F1fFgfis8eA48MbdXcyPEKZ6PU7ttVDr6/j64p9R21djx1Cdh+KV+4GPose+Cek/CX3PH5RYX1d2Z/RFaz78+U61vs681X4B1Zca/cJQjQ8b9VO9Zs99VmjsiDbI60CqL8J2wW1AxVzYXkOffjWeHt8+V6/Bq76XP32JtmIyRraVhrIV1AHbSqi8Sj/rnRtmXaFOECsUg6vjqlWsZLiprbyT/CXKc7RE2dRYVI0J2DeafG3wJbx+qPbTqbEBY36hz/mGkL2XHVOpeO/+wHMq3kNeB7P/xR/WLPfZTfM125L8GIL9/BOgR/vspop/euUdLKk5kQrpCf2mo28o/dlk4z8udBkjNlUxgmp3pp8Ho8hTX8HYFO0XY9O8o3tx7o39KsaaL1JcqHwA+tO3Qj7SfxViza/kYCbJYOsUL+zsxfWeqwvNo/C+BXyO10jUvgWOhfL2aPCcrtF/A3xDaK+VyRV3DW3llK8R8DpAG/J4bk3ZH9oCz7urcUdob4fRf1uMO8qsUxzrU3b1+W5u59x2XqQYFXneW4Lnetcp0mRr2Dw+/c0NjBs21ynW0q93nQLtpew6xfHMd6t9rGU+Q6DGZaE+C+37LMhH+t8P2N+wvAdieopsf41TvVZi9VvmPZDQHLU6bjW1v09k9hdTj7NztU5Ma3WIx3FhGoF8pP9XmU2OQzns/0BHU84u1FeaCysL0wvLy1NLC3y8VpqsztLX7VJ7+Oe7uzozPXnrLE2GPxoHv7P/Ed9Pr4oyGX+zJX7tW/1PEj1mMV7jhOVctnqobCg/zxWMkDx2nYc10ifWWE7eQZ9yd+q0Gig388+jV23A7m8N4CO9+XW04a2ki21xdNEI1dtW4Gn813N8kP2+gOj4uGfU92gOVkK/L6B71UQfH8R+aSJZW257JrJPKX2sgvEfT6K2h44fGCV58touvlZ9+LaF5ey0A3Z5XHWoToTjYnPVdbpFusfmwCdoWKinulCWsyIwlAoMc1fSKwM+q1xJNYdvknTNld1HEZZdVwOy5GFUCGMigLHZdDabjkibTadc0/GOxhtzczPzjcXa1Ozy0sryVLMoGvfmv7Q4szjVWlyaqU/NNKdqy/2MBjjawFF3VehvlOjPz5ipFagtAcw08YkORn8RYPJIXkVFqpxl3ADKsytZa1c8gtgoe5pdmFucX5qfWpiaqS3VZmf6qU8VuVZK6GRUYE+K50dLYGEd2wcFjd4i2K1JeNQ2SvRXgU3wLpCt8Ixh3dgulhntAEcGfFi20TdAhn9Ab6GjHrjrxajdsatbqhC/JNFdr/EfT6KGAnWuD5Mnz74ij6QWK4SP8mwT+rG63C7yDMtmnNCnIf02KCPS47U9j/cOZrY1SZhpstMgKiKvKu6ZflPZ376nt2xYN5Wc/4bL99gvoG7YV6KfxhXKa+hARWzvKkYx/8Ft8aN7upjvzq5VHMP1x76ffX5enJfnr7hfNPrrwVfwIZLcL2I5WUbkNyL4pon9ldF/OOMbeQggD/fPm33D8qV9V2imJdR+QzNe1ha25tAb3ijRfyLQx2yHZ6pCLo5ljP5TgVhmTJRLtTe7Py7ox0S5diVr/ZI9q1YlTPeRT/RYUqsSqMPRdrF+tg2gH7OBSaJHXSnfto34FA0teRVXzaKhL1TxG8cMyF/1r3iP/TQ+b3SKD+tzW4CP8lOq3Sk9chu5q8/YDj+Esi1HhrKxndHfCzL8o0Bsh33Z8T1hWdmv4RgL6dvQl91PfRnXfZpUXF6lPKxL0xH6260CV/kNtgnVJpGeY21rY1tz6DGeQvpHhE3sSta222oOP5QP74XaxngOlqrPNHFsYvRfCvj8HUK+qpDP6HcK+h1AY/Io3exMNG8sD9Ynf0jJ6J8T5VH9CK6QpGkE8hz7EXnKIeqV+5GQDtPEOp8Q9KhLK98k0aP+VRvdQXnIdzvJUDSG4j5GxU/oo9R0MerA5BwT5fWru6V6hfhZ+fAe8h9P1tp8jDFrWRsx/UzE0U8tZIMTQj8mzxlR5Kl1Pg46KXibrJlZ9fgVpJ8AHSI9XtvzeO9Xaey6C54z/EnKSxOPlzGvKu5tOUVYkwIL9WZ1mrbjb5Iu+MRg9d9w+R7LiPVpNh/yEevlg1gWR6n2lP4dzH7XBkrNhpXjDFEO44125dd2pmfL+jrjP55Ebcv1kA2jfqzeVNu3ZyeTtTb8YLtLV2TfyEdhvTCkWI86Yj3liPWsI5anvp5wxHraEetxR6wTjlieZXzGEctTrocdsTzbo2c9PuKI5dmGnnfE8qxHT1t9yRHL076ec8T6iiOWp90Pq8/xLOPLjlj3O2K94ojlqS/P2MTTvjzjHE8/4Wn3nmX07IdWHbGedMR6PcRyw2r3nrHJZp/WH9bDjljDqi9Pu/eM5VYdsTzr0VNfwxp/PeCINazx12OOWJ5t27MNeerLsx/ybEPDqvtVRyzPeblhnRvytC/P2HdYY8xh7DvSa16z8ug7duVg43VobVjxqQiZ1ZryFsAYS9aW13Nd2fD3RMK3cu8WusIyGX9eY7Z89d+wOM94jROWc9nqobKF1qJx3R11kIe1u0+sMZEXo04nA+VG/hMBWVU5Jhx1MuqIxXv1VPtX67dGv0fQKzvZJXjbs1a3eyHPsW4bobpFH2H81/PWu+ntRqKzD5RvSda2jd05WAn9vpHuVQEP00b5d/5te2twT6/tR1F7iNK/g9nv2kBpphHyrXH7mZlmhfiZThPSm/HfKN8d8mFp4j0YZXxYmtrtLt0gfidNX3bEetYR61FHrIcdsV5wxPIs4yOOWCccsTxtYtURy9MmvuSI9XqwiacdsZ5xxBrWtu2pe099PeaI5VnGJx2xPOvR0+4fd8TytPsvOmJ52sTLjlieNrEZf702fLRnX/sFR6zXgy98xRHLy+ek1zzWHkSuF9t+WJ5tyNNHe/ZpwxoXDmuftuqINaz+3rMNrTpiefrozb7j9O870uQ5tvL0hc85Ym3OKZy6NuSpe88yfsURa1jHQ566f8IRa1jnCz3jnE0/ceriiU0/cep0P6x+okz8heceXpfR2xo7rinvTnqx9hRgXUtY+PwewtpbgHU9Yan9DGp/Rfp3MPtdGyjNLhj+vij4jWVbpz4Tyl2hsp0F9/3W1KdKn4Nq/MdJVl95umv8Z5E8rB9e4z9byDpJeWn6fLtLx3lVcW9LAOsZR6wXHLEedcQ64Yj1RUesVUes5x2xPPW16ojlJZfys8Niq885Ynm2bU+beNoRa9N/bfqvmGX01P3Djliedv+iI5Zn2x7W9ujpo4e1r/Wsx0ccsV4P/dDroYyecnn61WHst9NrHrcPi3156uvLjlhPOGJ5xibD2qdttsdTV8ZVRyzPenw9jNM8fTTv6Xot2v2zjljDOtfxkiNWDB/N7+ul6WD2vzZQak7ZXDSuaVSSXr4YizjOm7cqxM90hPeQ/zjJ6ixPZx5/H8nD+tlC+omzzlFbrhA+ynOW0I9aV+A48pzsN57djvRnQRmRHq/teby3LVvo8PST6XvQlQy3jzbQWFqpN6dbs9O1mYWp6eWZZmO5MVtbnppeqdfn6o35qblmc2Vpam55rtFcacw2liaStfXObSBSHU+VbQO8lhWpTQbXsvaJOup3LetIu0s3TP2vfScooq+dnkjW6pbtDMvnWK+lP9ts/MeTqHZfD9UZ6oft7Bwh66TIO4OeC30PII7Om4vr1Xns7wEonYe+B1BG52n6XLtLx3lVcW9LAGvVEesJR6wnHbEedcR6xBHrhCPWC45YzzhieZbxYUcszzI+5Yj1rCPWi45Ynvbl2R497WvVEctTrqcdsTzt/vVgE190xFp1xHreEcuzjJ66f8wRy9Pun3PE2vQTrw0/4VnGrzhiecYTw6r7lx2xNttQf1hfcMTabEOnTveeY3fPMbK9q8JzSGk6mP2vDZYaY4KvE3bnPN5zB8du8g3DPs9f7inDPn9w7OVajtwX+Mu9YtgXCux6s1l/VZzZ+srySnN6dr6xWJ9pzsysTK3MzsxNLa9MTy0sz7bqUwvNxnxrtrZSn2u9urrRXJqdWZlfXppZsXk6/O45frf+a9kaitk9fpe+Ss+m11sgH+mrZ3UxfzzDnADcBDDSNEZ4lcRzPrNRqxC/JNHzq8Z/nGT1lac7v7qF5GH98PxqVcg6SXlpeqjdpeO8qrgXwnrCEet5R6yHHbGeccR6yRHrUUes54ZUrkccsU44Yq06YnnK9YIjlqfde8q16oj1pCOWZz166v4xRyzPMr7siHW/I9Yrjlie+nraEWtY27Zn32HxhL0/j/HjzqQ3rwp5OyhvBPIQA/NQvpGAfPj8SM5zXA6Lf7dS/sHsd22wVDf87XHwO9/f2CZ0hWUy/hbPjgJ9Jee/YXGe8RonLG/dhcqG8rMdbAN5+DsdCmtbn1hjIi9GnW4NlBv5TwRkVeUYIZ2odlYROrH72wNyIf0uwdueNR2OQZ6jDhshHWJbNP7r+XaJ6e1ioruu3dUD2+C2HKyEfl9M96qAh2kXYSg/yu05r34nc55P00SAz4R4zsq3A2S8CPK3E4+LhIwXBWTE541O8akMyKci+DCWmqNJ00q7m4/0O7M5mrQMf3heL+bFQr5QW9wv6C8GGpNH6caenUi0zan/xidJwjaEMrCf2u/IZz/QjBKfSxz5XAI0O4nPGxz5vAFodsBz6e8DkId2ZnK8UchhfvZSuO/dVyE/k5d1YPzHSVZneToxw6UkD+uHfddlQtZJkcd++zLB5zLBR2EdIBkOwHMbVH+N9dbfgTjyBOvvgNBrv/V3Nun1sijlaMyaXG9K1ibLuxx4sy28GfKwrXCq0m8sU9q//JMLurhMx/KgjZlsY0JWRz3Nc3kTIddbgPe5Qv6QLi4HXfxZH7pA+34L5WF9XEF5aE9vpbw3Qd6VlHe5kGe9fUjIrg448kEdvZH4vNGRD+r7MuJzmSMfrDurq13J2rrDdsJtvCruMZ9LBR8rD47FcH3whrM0T4w98Vk733CU6H/jvC7mhzNMa+PYzhzb+KKV7YpkbbK8twLvyynvSshje74K8tgG3wZ5WLeclN8wXaR+o3phF5fpuBzot7n9h/r3SPFQ6f7d+G9U//5Gkqef/t2eVe3W9jPsEnrFMuXJoGLE9fq7uDFG+bo1/hsVe19WUq8qDrqMdI55tsdmV5JvEyEZQnG56mPMd1q7vwf2Vtx5Vm8Z0Pfae4ocV6Xp/ZT3JpGX4r/t3N6yom/muZO3JGvL+pZAWfH5t+RgjQDWGGBxv2L0z1NfcgXg+tnYzCz3F8YDeV8ZiXfZ9saxHcpjco+LvJEBZF1Zmqs1azMzy62ZqcXpqZUK4ZusfI/nk64S9OobuKbrt8XRdcPaXLXdxb8K9JqmEci7kvJGIc9kTO3+Y+f3yn9VJPnL6B/5Twr666EM/dRlTCz0Bx5Y29aJtSfpbU/oc+L6oO5ZBOiDLKk2P0l5aHO7KQ/b0x7Kq0EerilwUvGs6SJtAxf0Ec9i/3BlDqb1BTiGt75slGi/gfsTqQ/F/vmD7d48jAOMT4rx2zQuMj6qP07TrTly/Qb1X2hXfrYztcz2YTyQ91WReJftv9DPsjwm97jIG6T/WqyvNFu1xcWpxuLy9MzMTKg/wnvcf71N0Kvz3U3XtTi6XlT919tAr2kagTzu27D/MhlV/xWn/51aLKN/5D8p6A9DGfqpS/PtKm5SvuKz7d48nEvDmPq3qY3HiRMbLW43mJSf5/4BbZL7hzrkcf/QgLx++wfTRb/9A/pJLBNijsA95eNHif73oI/4+9RHYJ9uvFO6d57dS3eVkDtumym/Fmb8lQ+NMR5XPlG1O2V/3L4xD/eiYB7yqQk+CsvqMm4dNWsTQq6Eyo9tjOcbsY1hvXFSbQzHIf2sy2AbM9nGhDyOemoa72ayNlneFPDud12mAbroZ10GdT5FeWgz05SHtjZDeVjfs5TXEPKUaedpYntXthPyV+vlo/pn1pEHH9R3jfjUHPlg3Vld7UrW1h22E8wzPnyP+ah2puJ1XJf5y7M0T1yXUePwUaL/KViX+W8Up2AZT2Ubb1DeNOSxPc9AHtvgLORh3XJSfsN00e+6DMZ6WCaUvWycYvRbs5gjclxR20PlUjrdjHfixzs4B8E+rt94x+xx2OIdXtc6FfEOttXNeKebtxnvaD6v13gH2wnmGZ+ieEe1MzW3jfFO42zNE+MdfDYv3nkW4p1p6kfjzMucnvEOzstU1zkvw36jaA6lQrzz4qIPt7/3n+dvrj27i3n12flyXQG8/7fN+RtOp9X8Da+9bc7f6Pa2Gc908zbjGc3n9RrPYDvBPONTFM+odlY0f3NniXimzPzNgxDP3E3xzOb8TZfmVMzfcJxi9F8YovkbtY897n6A8vGO8R8nWWPFO2qdWO3dVP0G76fCPJ6/UXHV2wQfhcXzN8OylszzN9g++90Dj2OPfuId1LPJFne/RbPOsUAi5ML+u994B/dg9BPvoM7Z/6LNNClv0DgJ5SnTztMU6rc36r2bK4nPlY58UN8bHb/tSvz9kWpnPOZIE8Y7v3i25onxDj7L8Y7RfxbinV+hfjTOvsv+2zjHtE3IY3vGmIJtUMVJZf0G7rvsJ97BumW/od6VUnMo6p3CuHVU/ntxxn9clDdGTHEFycP6sbaVvttvZyTc1Dr6wbsXDx9ael/r+F3vPLL8wYU7jx5aOPzO5eU7W3fdhaVBDhOitGwtTGPXu8V9xLiyoBTXtb/3f1eytpZ5tviqAqxrCUt5z5DnQqzrCUt5SJ5xUq2NvSLSozy1AnluaOfLUyOsegHW7YSlRruG1SjAuoOw8PkGPdfM4YM06A2bgrfCZ7udKpD5znavzCgXj9SmC7COEhY+P01YMwVYdxMWPj9Dz83m8EEaHBHPAp+KuKfkuaedL88sYc0VYN1LWPj8HGHNF2AdIyx8fp6ee3sOH6SZh/tvBz4VcU/Jc2M7Xx57tkwPh7I69iild9Eb/43q4Yr0yqPmdwhZJ0Uez8q9Q/B5h+CjsK50xHqbI9ZVjlg1R6yGI1bTEWvKEWvGEWvaEWvWEct8ovk0rNe9xEfFCI0AH3yeRwqxVj/2Eh+cDcDR5s5zus+gDeJoE5+1vmiU6D8Bo81dGabpUo2UrA9A23IciXZOrcG+NSGdYP9zPlxzUqNGk7vf2SasI+4rsf2/g/KwPX8f5WGb+n7KmxHyrNe+sK42yo551q3pyEfFwaxvDz4qRlYxJs82qVh8OsDncsGnqP1fcY7mmdf+LfYbJfr3QPu/KsMcE2U8lW2cV6VVP2553wd5bIPfD3lYt5yU3zBdDDLbxH5Dtb2xZK2Nn4qVKeM/nqxt2zFibDWGVn2z8qv2rGq33DbVmHtK8FFYcyRDaIwUqf4a662/2GMkVX+hMVLZ+ruA9DoVpRzdr9Ojn05IZuxH+SQtjGl5vich3WDCMvW7Gog2ZrJFjs9mubyJkAvnFfpdDVxvfIb2ze0U62Oe8tCe2D9j/8dxXaz47PKccnnwCa18xIoDhyE+4/F5v/FZU/Apis8+22d8xquBRj8D8dkRis+wnQ1rfMb2jPEZ2+Ag8Znpot/4DP322wGf7RjpsA5Vm0rEvYrA4bZtZd4inrUv56l5jn3Eo995jn1C3jIxapw+pnyMavw3KkadKalXZVszpHNlB2wjyGdW8FFY7G9DMWqcWKo2Vbb+jP9Gxagq9t8n9LoR9p1Xz42APHH8ffeLHkXrWSZPupa+NVlrQ2odj+XGdS+7l1c3ofV3FWOE2mlo/T2vDHl1FFp/VzoYpbzvZP14qsNXzumlsXXjnweaH82uVb/MbTrS2lzpNs1rc/Nx5AmuzaF+0Ga3JWHbwbrL27dQF2VlW64VyMS23O8eCcRiW+53jwRisS2rPQxqvMU7/tQudjU2NPzUxn/pnHz8RgB/KoA/E8DHnZEco2K8z2+94LhiDvB/M4B/VQC/FsCvC3zGNL+B+5v4lF2j/ZsZRhojP3Whltcw0hR5l3xpnzLsu+TVvqrQm3whP9HvKQceWBu0k3xGzZ1YUm17o3aSY71we0c987wStgueV8I9FDyvFGsn+RU55fLgo/Y7so48+AzbTnL0NZhnfPheaAc+7yTHOBLnjv7dOZqnmndIU95O8gMwd/SnNHcU6S1i153kbM+xdpLj28eD7iRPdznbl5Buah19X+v4jQuHDy0vHD1025EPt+64u3XX0RGC5WbKzemqHHERJwmIm6YtlHc55dthnlsSncpMJ8TpNspPBxn/jZpOKNoKzWFCXcg6KfIGPWwNsdi1IfZZxOetgs9bA3zOEjIP2yEFZ1Eeuh60D05FbmLzkMmuLta7THc6H1KwUct0m4dMdvkU+b3QIZN5y3QXndvLEw/eL7NMZ/STEGpdkmFGfmnP9ZACtudYhxSs96U9DKPZb2AcZB8hsDz8IBx/bBA/PGf46gNB2B7t47u76Hd6vT+7HiW5riV72A/PONpD5wMI+IEi02VkWyz96kbeEBXlHhd5g3wAodFaXJpZWFhpLq3UlhZWWtzWTVa+twX4o39B+jMEfeTD1hasveAHEPAQ/zSNQB6/PjkKeSaj+gBCnA91NBfK6B/5Twr666AM/dSlms7g5deyWHuSXrvFtq18E7fF/XD/VIyXjP84yeosT2e8tD9Zq9cRoVcVK9qzKkZCH4x5yEeNyxSW9RfKvx8gPuqD8hcH+BwQMse1hcaC6hMsKR98gPLQB6B9cFJ9/f7sut/xEuqcD78blg+p9jtewo+e9jNeQp3zh1r2Qx5Ph6Gt8TRqaHyhYocy/iRNbO9YVyM55fLggzraT3z2O/LZDzTcTg448sG6s7oKxaLr9XsXCz5F46W7z9U8y46XjP6vzu1iHqP4OM68Xf9tnMcLGM+xPeOU837Kw3E21i0n5TdMF4OMl9hvbMYk649JDghZVbt9M1yzf6iKeyEfYHW5K1lbR/xx3v2Cz/4AnzeK8owJGU5lTMIHrw0Sk1iZ+o1J9kMexySR/FXfeuo3JkHfst6YhMfzaDPsd9DWOF4JbZeJNbe6UTHJRsUKZT6cvl4+6iPe6mPh++Ea84wP3wvFWHyQGI6tMCb55XM1T4xJ8FmOSYz+zyEm+c6GzNn138Y5TlO+UMUrbIMYr2Ddcioa1/UTk6hxHcs+Kmgvojyj/btQX/+e5myx/V2S9OZdBHlvoLyLhUyq30UM5IE2Z/RpWmn3lsHofzeTO9Xl716gMbfkYJodq/lAnF9I0wjk+dnvUj2V+/bzu3KgTk+Wt91bJhUHIT3Pub5R0KPPMx0pP8UxmJqvuQTu2Zyi0qfJeCr0iTKW0SfS96tP05HS56WE9QaBhToO6dNkPBX6RBnL6FPN6ZXVp+lI6fNNhHWJwNoP93jO27C3Cnr2SUj/p+Bz/uC8XvnQb7ItXCSw0fdWCAPLMS7KMUF5+GyK+7Uze+W3fvo/gt//H8T7LYL3frjH9afm+nHeitf7MNYZ1rlJjhHKzltwjBDr8GucC322RPyg6lnFlXm+B/PwWYwdeX7qf4GNTZzXy/uKAt5l1g2vEPKoOT7eVxVn/baxNCFktaTsiOfG+GP1mId2tJ/y0I7Y/nBvSL97tXCfQVkb43pW86lod2xj6pUSnDPlPSN7YM/IfuJ9peCt9uIZvXplAeuLbQztyJ49nT4SNuh+FcvD14VQJ5yUjeHaeVkb21/Cl5S1MfzI10VkY6aDS8HGmsS7XsCbbUy9PqbaqNpGz8fHRfpwS0Pt+7PE9qfsAe2P57bQ/nj+Sr06qOwPdcJJ2Rh+1KWsjXE9Fx0hzTam1gfxtQQ+omIObOxa4q1en8X2zzamjudF/bEfU6/jjYnnHG1sbkLIasny8LVX3q+Kr+iyHyt7tBnvgcOjM/iYZUzKxkxP/dgY17M6UqWsH5sGXD42pej1a7Yf9Qp7WfuxZyPbz1Adf2d5PwB5se3H22auoGNL0b/z8StTJXkafdFRAmx/yl6xbwjZHx+La8/hnCLKz0c6Gv1C1jbT+vjD7FrNwZie4s7B1FpqDgb1OtruLXdIh2nqt82bziaTtb55mvLQXrjdqT3IeBQvx163Qr94X4nYK2RXRbGXxSqvldiL135Ol9jrvhKxl9rHqtZ6MPayjwvxMSFtsLGniHezgDfbmPKNWF+md/Xuhj0b9/jL5tSEkNWSshXuH/u1FTVOZLtFf8KfC8GkbMz01I+NPVXCl+D8AdvYlUJe/GAn29jzYGM/UcLGkHe/NmZzHJs21pu30Tb2EyVsDOej2MbUu1j4kXu2sZ8BG/tOCRsLzYVt+rFu3jDb2Hci+bG/zF76NRuzdbbfAhv7+8T7zYL3pXCPbUytM+F6M+8dwLU+e3ZMPDese0sOUB7qnteGcC2A4ziMwVAnnJSNmZ76sTGu5zcRD6yrNLGNjQh5U9wbMhsbJ772zMHsd63P1FhebtWn6rPzc62pqeX56T2EnyazxR0R+E9NL8wuLczW6/NT9dZUfcP5L03PLC69KkStVT+pjo3mP728OFebbSzMLy/NLDenlzaaf2txan52cX5purZcm6/PN4v4p23hn2dnf7HNslyM088+xjQdaX/vv/mtrfC843xBw/C3kXxO+J0jakaTtXoy3tujlG1lpUw9IP9xktVZ15198NtJHtYPv9s6Fkc/rdSUzfawz90qdMNybCMZxyPJqObSTCbLG4E8kyOl+QcX9sq4JZKMcdvoSuddc+yncU/uf6J+1+oG5zLR7rdAPtL/F4jZ/iK73gW49rz5qR2Qv03k22+rry2CFq/5t8nOekV6s8mtOWXdSmU1+v8O87a792hM1B/KtSUH83+KuWDDxD1ZoTZv9DsEPbYxk2dXsrZt7qDnUPaxpDfhPVU/FaLlPtj6KXwu7/eYwMmTYbvAUfvmxkhW5Mn2kCaOOauCD7Yp7PPHBH/H/mFa9ZWWLG8rlRfzsOw/1O7ScVLxvpUpLe+f0DoG0rE8qq15xkZ2fxTuM98q0W4lWuzPWWejDjJOCj5bCXdbQP4K4YyI5yYS3R7V/7LyVoS8qq8ZlA9ifbLdywfrGfu0N5zfxWU/XhXPHm9385H+Ted3MS/Nrov6NPYlWIZPtbv32GdzHMttktc7ue9iGuzHkf6tWTmw72L/gFgnPzdH+lQxgor7OEb4AOizTvpUMcCuZK1u2IbHiBfGx9a/sA7mQY6Z8/N5mV4nAmVM773jfE2HMiAdY6i+0zBUu7bndgm5uO2x79ga4KH6M8VjlPIGrR/Vb2OsoWIYlY/9OfLhe1sEfVH8MZ6DrXC3Chzl57dTXkXksQ/D8qIP49hEjcnQN6p2l1d3odhbyV4mrtoakF3pD/2Q91xOba5Wry3NTq+s1JdnFhaniuZy7P62dm+5Tv6He6NQrjRtR3rKG4O8kXYv//Hs9wjwQSyTY5ToF6Cu07QVnrHnJwX/rcS/R25xD22NsarintGndfpDmYwx5uga0/NzC/OLtXpjpdFozs30M0dn8TrHKOuVhZOKYTr6g7InIIcP70a9IvRQzdF9knTntuLMgXTnttT7SFtEXZl+4sy1NWo4t4U6OtReqxslR5o45say2NxHmrBN4jxVmqxdY7tHepxLQPqjEN/cA7HJSVrBL6V7OEBXyfl/EkPcG2n33lP+AP2k0Rvv8fZaGS1vB+SNEp+d2W/UF2KZHKNE/3nyk+jb7PlJwX878e+RW9xjP7lD0O8Q9Cf3K1Hfh2X3bosneRI+3mPZHgYfrtY5QvP3ceY966V9nPHfqPl7FceF5u+3xdFPLRSbqXGI1eV2kWdYau5TzcWp+BvjeR6vvZjZ1yRhpsnG/RWRVxX30G6fDozb+vV5PG+hxksV+q3mI7C9jRL9z4Nf/2rOmDxJ9NzlSruXHsevau6b5w+M/uswf/AH52nMvHLlYf4UlOsnqU5GRRlSum/llL+ShHVatvxbcmT9ZmD+ZFSUFWVVexVGge7bOXRpwvmtb1PZTdZqovdK3NDWchqG+m94fC80b8m+K87a7Pc+R4X+QZWb+ad/41CG0JxByKYQf5zo7fmRRM/hWR2yTX0X7P+3SrRrNe4P2XWZNvi3RbtWdYx2/d3AXII9UzRX+/eovEW+keU3+t8FHf5OYK52a45cWLc7krX9XZIM3lZC/RbOtah6voHocZ2ObVnRm62ibe4AmdnfGf0fgl2Mwtlj7EewTv/p+Zo31umokJV5/xnU6T+jOlXrJWo9k9t0qI9K0wfavbIY/b8EPYTe1TG54r6rU5fnpaB9jbZ7y63WkFVcxPaF9Ojv2LbRlnj+b1RgKR+mYifcr8HtFftO9iNK/jHxrNHvBCxFb3ijRP8fAvHQTnhGtbmRHMz/BHb/H6mOsR4/2+7S/Y/zNW8sf1WUx+gnRPmRfifJavT/b6D8O0T5Ua772r2YRv+Xoq2xnFgu5XPt/hmCfkKUa1eyVi/2LOse6VD3CoP9j/EbT9baRJruavfKili8TyrUtncKWUN1vVPw4bquZP5fxQjbc+TMkw99As//jwos7Fe854lnpmbqc3MLc0szSyvzU0uLG76Xdn5mZb7ZXKw355db8/WZYdlLim1ro8cOceY9umOH7SBnKM40ehWfbQ/Q87wW4+etkWF8hvMRPHYw+vdkbTKlPZfOJQyVMU0cI/JeUabh+R5sm0rmvLjuIvAjvH9O7dXAOIXjM6O/BDDL7J8L9RlFsU9o/Z33z4XiIoWN9NWkuB+oiHLa/FqarD9BDGtjE4RzMPtdGzBxXzeSrO17UB6Of95GdryLdBrSGfbbIwIDdTJK9G8DGxolGUy2HclaW1d1wntH2a5ua/fmG/00tOcmjbfUXMLJfSUXaN4YY+wMyLpDyIpt5kS7N9/o50Ff23NkRXlQVjV2Mps9FWMn9FujJJPyH0i/Xv+hxk6h/arsfyuCT6iPwXpQ9IbHNnldIO5T+yPT56xf2iX45M2HF/VTak0Vx4DXUzvAOQ3l929u95bX6H8J2uAHczAtDkjT0XaXprPfIVlbZ45xTI11p+IGlIfnyz7eR6yAOEav4hXsp00nHK98XPjY0Pw76hLtJnHUZZm9GJHqcb5C/EwfeI99uqqbgz7yBNcpQ3sxIsXrc7gXA9ezcC+G2i+G9qL2P2P/uURtAduM8hvXtrv5SH8z+I0V8n9Yl2q/sGFsyeFpPlDNf/J4jevupGztXhq8Dr3zk6a8tnwkEHOrdVhlP0av9nOqvbhqrYH7OcUby8NrJkXvAfF+ZqO/W/SLjJk3jmGdGv2xPscxIZ32O45R851ldWptgmUtq1OjfyigU7WOENKp0X8+oFOlo5BO1byqmu/blazV907CKtKpfTeAZS2rU6N/PKBT5etCOjX6L51Cnap56aI5GfSpdn880WXmOdi891gRU/mvbaIMobpUPo3r8qVAXapyjZUs17hTucb7LJfR/2ikclVzylXts1xjBeXiONvof7JEudR7NGniuS6j/2nR9oZtLRLnKkbbveVWfg/p+40N+D0WNY8Zej8uZBMVuMfrFBXBB+NJNfblWE3td0CebANG/52SNoBxeppG2r0yH8zu1wZK2gZwrYBtoOw+SG4rSM/zIWmaFPS812KLwFL1rGwmb0yBuDgX4X7uyFRzcaW+Mj+72FypNefqG37uykKt0ZqqLy5O11sL8/MrG37uSr1eX5mZWpybWWrUVpY3/NyXqZXZhZmV2dp0Y3mq1Vhe2Gj+C7Ot+amZZmOpuTK/MFeb22j+i8szS7X5Zn15YWG2Njsz189aZSXpbU9pCrU/Fe+x/yx6Z4SxKgGson0q1xJWyC+E5pIi7TGfqhA/K0dC5e68J5as7Z9izCUV6XUL6U7tnVZ7g3hOUvUpap5eYVUcsfi7KqqPyFvHD9kNx7IHs9+1wVJpu7F7G2U3Kh4L2c2IkFWdj/X+dpcuz4eobwtvFFboHIXY54iUtQV+NzCSbQbfDawKvao9RPYsr1mlietP+SoVl54uWOh/1F6hW9q9ecpXqb2XVcrDurB4m31cP3PXqm9FeXmNcozO64q0HlHjeAd5Re7fZ9RatSW17s71jmNmrls1Zlb7Hvv9jrfpIuX9b0qcBapspEJ5W0U51LoA9wEqBgqdYRc6F0P571vbvTKrcaY690DFpkVxgnpXLbLtl+4bcL6O6ytG31B0vgTbupojVvtYK3St5q3UHnqFtcURq+qIlRerJslau4oU782UtSvjP56srZ8YdlU0T8R2VRWyqrVrPPeO80KxzesdKzRGKmNDig+3S+ST937TD1zY+4w9V/b9JqO//8Iu5juzazXnwXstsPwHs/+1/tI034j8zuY8xxmYVJyB9cJJxRkmd/r/z2iPYSKw1JhxnPIwBtlBedin7aQ87H8nKC+W7Y7klMuDT2ieK9b7APye5lZHPmq/UCh+DMUZ2wJ8VNxYtBfp0xdqnnnrQ7e3u/lIfxh8ywKNjSKN1WfV2l9C5S47BmF7Rt/ANoh7BbBuOSm/YfdSuaolxidqnGxlwv1cRXs7+l3jNH6h/U/D6sNVPXH94t4Yrl98Z4D9whmQhzrhVNRn9PM9ROUHkC60Tozvz3+a+nykY/tQ8ZN6hy4kY2jPemhNHnmptY+8cxPy9hPm+azVTB9Fa9qmp8jfQ5w51fsaeP5C+UcVC3BfMyowMY71XiOcbSxNLzSn52tLrelXV0tn+1kjDJ1pGjorlutA7fNIE88fGv1XqI+M890EPX/Y77uA11MZjP5XoM//KvkWtdal9MnzaaE9uMoeDb9oryaXweh/sqQP6Mz7Zv9H2r1yHszu1wZLU8oH4D5c9gGhPbdpWu/ex8kkv5+sJGv7A6Vz7iPU+0DbBT7Ptf8C1BG/D4R2PU6yKx+lYmWem1Vn9qey/D612UjzjH3HtRXKw3bCMRHvu8Q8FS9VhAwqtjFd9Dvv7uEnMLY7KV97rVynot32nDHX7i2n2luP9P3srU+TjenUO35s36ov6KfNpOk64qfiM2wzO4DX1naX1rEOGlYu03UVZB5pd2U3/mYveP6m0XXGOHFkrZmsdl6n9VvIE8uyhej5epTu/WsY12MZsR5DZyqrs0LxDFWTUZ0ru6PdH9Z2wto2AJbJpc5P3bZOuRTWVsJSZ87mnUH9j6FNqLW2vHngf0dzNersAnyWYx6j/28Qt/0pxW2e66AhX61iOu4LQmfuJ0l4ns3olC/u1Fmi+8SD2e/aYKn0+qXxHxc6ibHOVPb9ctPPjjjyTIViUlXPaTM5I1lbZygfngFhydZD+l2X576xzLo82jt+cyy0j1DNX6i5aW73SRKem+Hx2l9Bu9930feuQ99lUO2X273ax6HeRePxmqpztYZs9OocLjU2UWdiTZTACs2bFJ3pxbxRLnyWeefZropjTTeR49hpFcdi7MlxbGg8maYyulT1OEn0qDvVjrk9It8dlIftj9u4Wp/D9qLmuHBca3109hngnnOcksTfp2P788afq01N89y7s/xN62MqcfBrkfeS1Mzurm538bEsxjdtVzvhGtdp856PKfurdTsVeX2uvjdH/jRZ7Guxdaoba+s3tY5+eOHI8m23XnuodXjZtKG0G0o44hxp+5dwdq47ijNPjaM4TCOQj/RnZr+9Z8RXZhfqK82FlYXpheXlqaXCt4Ya2fVp7q0WN8pbxZr5i72bWHkrtTvBbPi97a4u39vulUntLDBctfvkmiwvptd51QZmIuuwWWZHbKQV8dJvzhj/jdoRq1Yi83bEnqRp98qDeSPtteWwPIw+rX5TmguAjm2LV/BxZPiedm8ejqLM3lP8NwGvy7PrmJGL+bKYkcveJD9asXs4E6dmyEZBfyf1g/SUh7NhI+1ePuv94txl2e9h/uLcxdn1jqQb9bwV8LithHbvpFFSNlmYHLnt6KGV4++6s7VwtLX8gduOthJKvFWOA6ktOUJUiY639o0K/CTAizGRLr1/OgRq9ez3qQ7UslHo6R6ozW5UoBZTP7GCmDSpQE0No0JBWOpobEiVXu+CZ9J0DWBXKO9awTdy4DYd+VXTxl4hPx6Nl+ronOx3VdBiW8CpWlUvibhXSfI7XA4mEih3vdms12rLs/WV5ZXm9Ox8Y7E+05yZWZlamZ2Zm1pemZ5aWJ5t1acWmo351mxtpT7Xas1ON5dmZ1bml5dmVrisWwJlmwjIOCHKi/obdh+ezcydch9+SXa96cODqRnZxzYi+xvpw5XvWe9Ausi/ow/nAWqkKcWZYZhShK/e9+iZX4dCnFGiten7NCbem4O3NSn2ldWc587NrtUgMnHUl5KjIuRQfh/1Ouy+fX/2+1T7dqxXzNv07T1p07cnm76dUinfzr7Y8sv44tPVt9mY5FT7Nss4vX3b7IYtEsXxPY1m5GNfOr7NthFxWfDzGUjHz2A7ezfQvDuH5j1A854cmrwFKaR5H9C8L4fm/UDz/hya64Hm+hyaDwDNB3JobgCaG3JoPgg0H8yh+RDQfCiH5sNA8+Ecmo8AzUdyaD4KNB/NoflBoPnBHJobgebGHJqPAc3Hcmg+DjQfz6H5BNB8Iofmh4Dmh3JoPgk0n8yh+RTQfCqH5oeB5odzaD4NNJ/OofkM0Hwmh+ZHgOZHcmgWgGYhh2YRaBZzaJaAZimHZhlolnNoWkDTyqFZAZqVHJqbgOamHJqbgQY/TVEFmkNAc4hoIi/2zcb16Y166JiGuJsaGo0K8UuS3hgyIf7jScz+M/zJGXV0YuiVYLVovZXyRiEPjye7GujYtnj8gGMEs18e26fJ7DbFvwF4fTTplR2fqRL/JFk7Lx2jLuZqMwtx7b5e63fDAb9KVqbu0nQC6DZmvaSruzjtpF4PrZeYrWxrJ51UJV2j/k7VBoEPZL+HeYPAddk1jkXf1e7ixRhbXR0Fv14z/GviyD9l+NdGwZ+q2TzDv7A6S2L6p+6n4Db+eMV6vWy/PKzHK8bdbFfvfPIwdNwhyqtev+bXatQxBUi/HcqI9Hhtz+O95ey/OrqDX+kr+1rdySNjqGxYN5Wc/4bL97aQjOqTrRybFa2z86uN94HstxBm0RFJPKeKr/4zPeLxJ3iOZP9PvgqfaMy8cuVh3gWy3JFdK99hZUjvHU90+StJWKdly78lR9Z7k275/12OrCgPysrjFHwm/f9AgG5U0FVI1mqiY33rr2If/8a+K9KrnlPsb1S5mX/6twPKUE3W+iCmVzaF+PxZv85ce6J9KR8BYvRPZf9TXT6WI0OSrLXrNGEslWfXZdrgl7L/2K5VHaNdm9zqVUo8moIx0nQw+18bLNXj2lqjrl6jrvjJX1OvITviz6l9TehLXiS+9hpXWR9u9F8FzK9k1+ooNo4n8vZb8XF1STK4r1KvtZp8Z8Azqp2ZDzX6SeBbJQxFb2M09A2TIAP3N0b/jex/qvc/za5Dx/yl+v/pRPPGOt0pZGXevwmY38yu1WvAfOyneq21Qr+VfaXp6navLEb/C9n/VA//PrtW8x8mV8x1T/tE25+DHGyro+3ecu+CvKqgx3aAtoH0u4CGbRtt6QzCUq8xqz5Exa74Kie3V8NVfkTJf4Z41uh3A5aiN7xRov9b2X8Vj+6GZ1SbG8nB/Lsgy3eT3vJjHeAr1H+QwxvLXxXlMfo9ovxIv5tkNfrfSfLLPynKvxtoxgjT6H8XMP99jpxYLuVz7f5eQb9HlGtXslYv9qzSvdGh7hUG+x/jh58/RfodJCvmIX8su2rbu4WsobreLfhwXf8f2X8Vo03kyJknH/oEa/+qX+nMLSbdfmXY95T86+z3qd5T4v65xOmF2aWF2Xp9fqremqpPbzT/xtzczHxj8dUVveWlleWp5kbzn5maqc/NLcwtzSytzE8tLW40/6XpmcWlVyuh1qqfVEcRfzUvj7FKmmxuH+f+kR7jQqT/T0b76t9/zq55XQf5pXT/K0BXyfl/EkPcG2n33lNrArhWYvTGe1zIaHl4FBnGUWnamf1GfSGWyTFK9P8z+211gusb9rw6Cg2PlmNeij+vlahj2HYI+rR+/tLwsv9Ydu+56JM8CR/vsWxmO6ldvyUDOL33ys0snd575eqNjdorh3vRQnvlQgcqGE3e/jWkydu/hjR5+9eQJm//GtLk7V9Dmrz9a0iTt38NafL2ryFN3v41pMnbv4Y0efvXkCZv/xrS5O1fQ5q8/WtIk7d/DWny9q8hTd7+tTQ/8j6mDdnPgW0sgbLE3cdUfr309baPqQF0bFuhfUxmv2ofk9ltiv/9wOuapFd2xAuNtePuxZleityPyX1MXK8j7V7emId1NwL6bJB+4rw70tVPDP2n+gm9O8LjiCTR8bfp6FTtVfq+7Pcw71Wazq43YK9SI+5epW7sfE0c/GbcvUrdvVbXxZG/s9fq3XHwW4b/nhj4r04/2F4uHNPnxQ5l+vY08ZoCH2uLfEYd+WA8xX1apIPOOnsItoOcar2T9zjhmFet8TM9x2uMP7Yx5V2z30t9Dgf5q3X1JPH1TylmpHX1Of4kke2rSMt6I/HEOX+uozShD0r/dlIdMQ3v95oA3qxzfJbXPD+Z/U/LMFrpxVR7yPBo4msJ0+g/DZjbK1rOJAnHm3a/6Ohok0cdE34GPRdaG1TYSF/NweG1Hy7nFrg3LrDNRnn95mD2uzZgMjzcG1ARPE0eXp8/THLtIZ2GdJb+7RZ8cU57nPjuJr6pDe0gGzLZdiTav3RizES3lYPZ79pgaYr1iOdjoB62Ur7Rh/YkKn+f0p2gsuBYWa3hsy7OiKKLxho7Q10o+2A7O5b9P/nefiVfF1uFLkLj8o3Yo7Gb5EW/O0oyKf+n9mb36//Uce/8KTK1JxR9FvNR+zDY7vL2ABoe9w2PZP9PHgpa6ZVvVDyP+xV3CT55n1Qr6mfVXAvub/oS4eIameq3LMYfJfr/DJhPZ9cx5wpeTXOsC7XfzHiiPJEO3a2xzeTtXa0mvTo0+q8kvXVhtoh1PCpwjH6H4Iv2zPvidhBf7IOqggeOUyLvRa2FxkaR63G+QvxMH3gP+Y8num4O+sgTPDwZ9cPjvUif45lLYxf1qTccn2PdqM9gK7+E/f834D63GeWXbG5plOi/CZg/k12rvbS4X5Z5bsnhaT5WxeQ83ud3ldLE51vg9XZRXrRBbstG/+3svxqTqE8DKvth/4P0bFNJovescz+qeKPtXN3WvPP28Bke753+tew/9ruMOZpTni05mL8JmGXGeSGd9jvOU58IKqtTfp9BjZ1DOjX670L535RT/rI6Nfq/B5isU6WjkE7VnrwzRLl2JWv1zfv7inR6TVvLWlanRv97Sbf8rFPl60I6Nfp/CJgbrVMs8y56Tn02uJL0+lTsS9Vz4wHMnTmYoU+HMUZeXSqfxnX5x9l/VZeqXDtLlmvCqVwTfZbL6P9VpHJVc8pV7bNcOwvKxXG20f+fJcqFbQ/7bp4LNPo/A0xre2q8ju9ypWmk3Svvwex+baCkx+sYP462e8ut/F7oM3tFsQF/Zk3N84Y+iRiyiQrcu7qd9JSxIvhgPKnG1hyr4buFiifbgNH/f9n/IhvAOD1NI+1emQ9m92sDJW0D6PPZBtT+kFAfocYjPN+Spslkbd3y2k7R/oyr271Yau+csgFck7a5jmHfcz+SAbzW9tyf6j3v/e45f83tuZ+fWZlvNhfrzfnl1nx95lTuuT8zA0jb5dnkK0cFv5TusgBdJef/SQxxb6Tde2/Y99wfyACGec/9BeS3sOze82EneRI+3mPZzHaG4V2in8quT+89/9PLG7XnvxIHf8M++XpNu4uvYpM0LtoD12cmvfRFsRHP+1aj1Hfs7+7U52LtXb2N9BNn72pXPzH0n+ontHf1tD4PDvbgnQjUVcWvPDW1l7xCvCPZeen1JeM/nsS0q+760gjJw/phPxPp3Y0167ooz6jQD+9H4LrD8SaO6ZEe15CRHq/tebx3afY/dIZThfISIUOS9MYrF1PZYu1FrRKfqgMfto80Hcz+1wZKjRqvOyIftS+F23ScPaGNzTMSw/o5rc5IfHv2X52RyG26nzMSp6hsGNcN2qZRrtB5YTHi50jnjs6xTSaJbzzDdetp72pPtqf8aq4T96pdDfcxT81pc/+I9O8BTDt/uGj/hNoPwf3Kjhx+6M95n9L1IMvHs+t0XcHW4W5qHf3wwpHl22699lDr8HKFOPJOpbxkNccrFgez37XB0rI64cqS5Z1RUm6eVUa501bTBlymY564emP8lXfhnZjonfBEQ6uh0O6YXYL3FspTK0dq50TeKjDuxFXP8clNRv+Z7H9apieAvpLo1XFcQeNeougEsgkqszqt6xSuJs6nOngK5ODyjrZ7yzvRp35CJ7oZTZJ0bQ51x7tiVJSN9s4ntKlTSPN+o43xrmO166MfL50mmx1PEj0LbXo+VW+e2um7w/zm6Z3Z9enwxbaHst+neqVPzbxw1HlwnbJwCkW/cWdeyo/SeOYl1gx9hfiZPKyfjZl5adRwZy/q6Or2Wt0oOdIUWoV/rZ8k9pzRvvr3QtLVx0na9lp+uDPl9biq+ePZ72Fe1XzZ8LL/WPZTvapptvPaWVWcmdpcVQynzVXFflJ9ZXNVMayfzVXF18KqYqO23tj2dbKquFIhfJRnc1Wx/1hzc1Vxc1XR5Mmzuc1Vxc1VxX5T5FXFlc1VxXz5N1cVv5c2VxUTKufmquLmqqK3N9tcVVxrY5uripuriibf5qpi+bS5qthJm6uKyeC2vrmq2E0j7d57m6uK30uvh1XFKzOA03tVcWrD3lWMNJveiNuH6e8TYVl4Vhz9gz2j+mD7LtHJ806T7vVZgJcm/DYR99uRVtYif2uiVh+mlbXED7t2en8Pofu9gusAP4Z+In0Poaa+h+Aof91i98UMLx2f2srRq7Nh7zmy3DrWWv7owk03HTpy00daS3e2jr7zro+0Xr19J4ffvMCEC2KcTE2MUaHfWwIYSaInInHRSB2Fwy4n0uT2VNmhAh53HS80D38aSh39Y7rbJmRVn7wuOgaT720JYG1xxOL6xvo4mP2v9ZeafCP2MbW8mIXJ8sZFmSuCXk35mtzp/5sBl+mYJ9bTOOWpaTG10L6T8kKfUWf/oP4nSbkFLzW8jL2wxqFVrEV5Pnp3qyMf9dmTXcnauuNjzPttw6OCj9pkYF1vKtfBHJ7qaN00WVjDmzJuSLqY78qu406d1GbZ/jHxsX5ov2qhm+0ZfQPboDqyuazfMF2kcj0CuEzH5VBLPmrapzO0TtbW0Yey/6nMn4FnENPkRlnTVGYRXh0vqeycP0U0bH2Aqme2D1yWYPvAZRT2K7h0gjrhVNTnfB1wmc6SqmflU5CXDbmU3eER5Aez62Gf7r8p+z0M0/02ZCgzHR9p2F06xu5M6SVr++QYMXaV5GH9cPtTG+q4X0/T1e0uHedVxb0tG4x16jbF1qbL2sKwborlsSo+yzFRmq5ud+k4L9TnnS5Y9nyaQktCaizCS0kqXlQxuE0TsY/bleTXjcmFn4JJkrXlNGzesIRH1XI/6jmVxD4deUWObWfUOMSSGvdxvWNMxfXOG/AwT8W9FSFDUWz7J4DLdJaUjVQoT23uVjEl9wEVIVdo46baUsLHdKPd4/QiYiZJIjf9WlylNvLlxQmhTX1KB9y+8BOcXKY0cfsy+p/J/sfdsKnb1xiVYRuUQen1mnZvGYz+72T/U9qfTXp1po7hVvpkewuNb1Burge1aXp7oAxG/0vZfz6qPE0bvyWtNpXKsQ/kQFlPyt/uLbc6Nh/peUxZdGw+b//CMRj7ENWHos7fRbLiFjE1nuUNskb/N7P/Ke1bKr3yoV2Pk+xYdvYzVcFXzVmNgcz/IruOPEe/YXMu3C+hHfTbL5ku+u2XPPzECPEblnaLcyLcbrGNVgU9t9uidm7x42Syti7ZvlVf0E+bSVNouylul7Y2kzc+HxVlSJ/7V4CH9Yj+HZ9l/270/wVk+bfZdYyYKGSXqv9iuy/7wo2a7zY6ZXdWLvXixqkY5xr/caGTGONc1c5CL4pF+mThVKj/VfWcblk8I1lbZ+qzUxgz25aFfmN09gNlYnS096IXZCqEpdqxahdF68L82UXD/2/Z//T5XZkSVPvldq/GdKr9crvPG9Pl1Xno00bqNQMVh6nXTCZKYG0L8C76PCDzVp8HZFmSJN92VZ9tuoncZ0+rPjv0+kcodk5TGV2qelSflJ6gPGzH3B6Rb+g1Jm7jaKdmv9he1NwfxvDWR7+Wtz6fU+mW9zzQy0lawS+le3OArpLz/ySGuDfS7r037FufLwNfm6Zh3Pp8cfbQMG59NtsZhs/EnJ1dn+Zbr2c2t16Hk/UnV7d78RPiq/Y72TNqvfWaLG97Aq/2Jd1+jve+xah37h899bZXyM/zzLuz32m/f1l2fejI0p2tW1tHjr7z9tt7NrGe3NhqO1kTSrySXaHfRbtST4cXB21T/qneSYC7Z9KER5fF8Hz74uDX1AzimXC9j8qJtnPQSQbDMzsYTdYmjr6MlkcCFX/56gklFYVZ2pv93wf3TJ+7SdZIq5Y1nJGOgN+xyUgrvk1lk3wUVZLoeuCegtups6wLndEDyFAlniwj0owkaxP75xG6Xy1Bq2wTd2WwfPwczzbyPdxRx4nrhT9YzVg444P024g2Vh3uFTKx7JYXaXa0YfiRZheln8eZzx2UZ3al7LOS81vFF3m0lQCusinDtLpCea0c/z/IRitJRXEVAA==",
      "debug_symbols": "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Tnl43tuPFV3wudk99O+mbyt6wWXTcDdiGOZcWNEwLd1969x9fyzV8gKHOr/JcMab2BlvMp7xJtMZbzKf8Sb5jDdZTniTFxjD+U3OOOLTGUd8OuOIT2cc8emMIz6dccSnM474dMYRn8444oczjvjhjCN+OOOIH8444oczjvjhjCN+OOOIH8444oczjvjhjCPezjji7Ywj3s444u2MI97OOOLtjCPezjji7Ywj3s444u2MI34844gfzzjixzOO+PGMI34844gfzzjixzOO+PGMI34844gfzzjipzOO+OmMI34644ifzjjiJ48jPs/r1kvXb7zJeMabTGe8yXzGm+Qz3mQ54U3m7ow36c94k+T8Jn3aeBOPIz6vl3+GGzn98ibft87rJZY8PK6wpL/e5du2S74vY1m+bvuxeKt58WPNi59qXvxc8+JzzYtfKl587mpefF/z4lPNi6/5DJtrPsPmms+wueYzbNY+w073bW/vnDZWr32KLa1e+xxbWP2ifZItrV77LFtavfZptrR6j/PskuZ19eNcWH3pO4aLya1olFvRJLeiWW5FWW5Fi9aKUtd1civq5VaU5FYk9pl9W5HYJ+RtRed/Qv74TfXU9Z3cis4/1ub0WFGav68oya1okFuRya1olFvRBUe/TeuKRnte0feNk60LSWb2fflz3cvPdS9/qXr5qat7+X3dy091L3+oe/kmvvyUH8v/PpClse7lq591C8sXP+uO433mSeM0/LzxdKv2nxtPt4nx+76Kn6J/s6/j7QL5j/sqfj4fV/abxrn/eePc3V8429MPrYfxY1cH8XO/566Kzwmeuyo+U3juqvj84bmr1s6uqp9Zf7Or45075nn6sqsbL9wP9zWnfny8sG0tOeX7KW/ovmz6IaH6CbsCCSPNAddIaJHmi4skjDS3XCRhpHnoIgkjzVkXSWhI+KcSivOuGiQUZ241SEg7+WMJaSd/LCHt5E8lHGknfyxhqynslrRK+PRVqU0Jc74v4suPgzdfuL+99/2Vb/+en76CvQwfmk+txvZKzVtt4Vdq3mptv1LzVnv+lZobmp+ueask4UrNW0UPV2reKqu4UvNW4caVmtNDT9d8poeerzk99HzN6aHna04PPV9zQ/PTNaeHnq85PfR8zemh52tODz1fc3ro6Zpneuj5mtNDz9ecHnq+5vTQ8zU3ND9dc3ro+ZrT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y395nh/bp2X41Fyc7oTUXBxJRdR8bHXav1LzVuvBlZq32ieu1LzVAnKl5obmp2veasW5UvNI7LkWzemh52tODz1fc3ro6ZpP9NDzNaeHnq85PfR8zemh52tuaH665vTQ8zWnh56vOT30fM3poedrTg89XfOZHnq+5vTQ8zWnh56vOT30fM0NzU/XnB56vub00PM1p4eerzk99HzN6aGna57poedrTg89X3N66Pma00PP19zQ/HTN6aHna04PPV9zeuj5mtNDz9ecHnq65gs99HzN6aHna04PPV9zeuj5mhuan645PfR8zemh52tODz1fc3ro+ZrTQ8/WPHf00PM1p4eerzk99HzN6aHna25ofrrm9NDzNaeHnq85PfR8zemh52tODz1dc/WnPYbUnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfR0zeWffxxRc3ro+ZrTQ8/XnB56vuaG5qdrTg89X3N66Pma00PP15weer7m9NDTNR/ooedrTg89X3N66Pma00PP19zQ/HTN6aHna04PPV9zeuj5mtNDz9ecHnq65kYPPV9zeuj5mtNDz9ecHnq+5obmp2tODz1fc3ro+ZrTQ8/XnB56vub00NM1H+mh52tODz1fc3ro+ZrTQ8/X3ND8dM3poedrTg89X3N66Pma00PP15weerrmEz30fM3poedrTg89X3N66PmaG5qfrjk99HzN6aHna04PPV9zeuj5mtNDT9d8poeerzk99HzN6aHna04PPV9zQ/PTNaeHnq85PfR8zemh52tODz1fc3ro6Zpneuj5mtNDz9ecHnq+5vTQ8zU3ND9dc3ro+ZrTQ8/XnB56vub00PM1p4eervlCDz1fc3ro+ZrTQ8/XnB56vuaG5qdrTg89X3N66Pma00PP15weer7m9NCzNV86euj5mtNDz9ecHnq+5vTQ8zU3ND9dc3ro+ZrTQ8/XnB56vub00PM1p4eernlPDz1fc3ro+ZrTQ8/XnB56vuaG5qdrTg89X3N66Pma00PP15weer7m9NDTNU/00PM1p4eerzk99HzN6aHna25ofrrm9NDzNaeHnq85PfR8zemh52tODz1d84Eeer7m9NDzNaeHnq85PfR8zQ3NT9ecHnq+5vTQ8zWnh56vOT30fM3poadrbvTQ8zWnh56vOT30fM3poedrbmh+uub00PM1p4eerzk99HzN6aHna04PPV3zkR56vub00PM1p4eerzk99HzNDc1P15weer7m9NDzNaeHnq85PfR8zemhp2s+0UPP15weer7m9NDzNaeHnq+5ofnpmtNDz9ecHnq+5vTQ8zWnh56vOT30dM1neuj5mtNDz9ecHnq+5vTQ8zU3ND9dc3ro+ZrTQ8/XnB56vub00PM1p4eernmmh56vOT30fM3poedrTg89X3ND89M1p4eerzk99HzN6aHna04PPV9zeujpmi/00PM1p4eerzk99HzN6aHna25ofrrm9NDzNaeHnq85PfR8zemh52tODz1Z86Hr6KHna04PPV9zeuj5mtNDz9fc0Px0zemh52tODz1fc3ro+ZrTQ8/XnB56uuY9PfR8zemh52tODz1fc3ro+Zobmp+uOT30fM3poedrTg89X3N66Pma00NP1zzRQ8/XnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfR0zQd66Pma00PP15weer7m9NDzNTc0P11zeuj5mtNDz9ecHnq+5vTQ8zWnh56uudFDz9ecHnq+5vTQ8zWnh56vuaH56ZrTQ8/XnB56vub00PM1p4eerzk99HTNR3ro+ZrTQ8/XnB56vub00PM1NzQ/XXN66Pma00PP15weer7m9NDzNaeHnq75RA89X3N66Pma00PP15weer7mhuana04PPV9zeuj5mtNDz9ecHnq+5vTQ0zWf6aHna04PPV9zeuj5mtNDz9fc0Px0zemh52tODz1fc3ro+ZrTQ8/XnB56uuaZHnq+5vTQ8zWnh56vOT30fM0NzU/XnB56vub00PM1p4eerzk99HzN6aGna77QQ8/XnB56vub00PM1p4eer7mh+ema00PP15weer7m9NDzNaeHnq85PfRszW8iovnpmtNDz9ecHnq+5vTQ8zU3ND9b876mTpR/3nie7tvO8xcVP/a0pibyZ3ta0/z/Z3t6xdTdP/a0sPifXvrv9aeu8vX3la8/Vb7+ofL1W+XrH8XXP94/lvslDYWX7m1Z7luPT7PC7aU/dnZqaWfnlnY2B9rZlOd1vMjLUth6SEu+7+TQPyaX6VMZ9QHjMmUG9dHlOmXUh6IDlRmmZVUmz0/KfN/W+lVFS/38TUX10awOFdUHxN+p2M13FZe+K2yd133Mw2MX01+F89u2S74v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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "notify_created_note_oracle_wrapper",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_balance",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_balance"
      ]
    },
    {
      "name": "transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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/5v7/Kf/m/v8p/+b+/yn/5vaf6D/m/r6H+j/5j7/6f/mPv/p/+Y+/w3/U/un/5v7+k//N/f5T/839/lP/zf3+U//N7X/SP839fU/0v/Nff7T/83tn/5vbv+G/6n90//N7Z/+b27/9H9z+6f/mzv/0/9Nff4n+r+pz/9E/zf3+U//N7d/+r+5/Rv+p/ZP/ze3f/q/uf3T/83tn/5v7vxP/zf1+W/0f3P7p/+b+vpv9H9zn//0f3P7N/xPff2n/5v7/Kf/m/v8p/+b+/yn/5vbP/3f1P4z/d/c/un/5vZP/zf1/p/p/+Y+/w3/U/un/5v7+k//N/f5T/839/lP/zf3+U//N/X5v9L/TX3+r/R/c/un/5v7+k//N/f5b/if2j/939z+6f/m/vyn/5v7/Kf/m9s//d/U1/+N/m/q83+j/5vbP/3f3P7p/+b2b/if2j/939z+6f/mzn/0f3Of//R/c5//9H9Tn/87/d/c/un/5vZP/zf15/9O/zf3+W/4n/r8p/+b+/yn/5v7/Kf/m/v8p/+b+/yn/5v6/C/0f1Of/4X+b+7zn/5vbv/0f3Nf/w3/U5//9H9z+6f/m9s//d/c/un/5vZP/zfz/p8W+r+Zz/+00P/N7Z/+b27/9H9zf/4b/qc+/+n/5vZP/ze3f/q/uf3T/83tn/5v6v0/0P9Nff4H+r+5z3/6v7nPf/q/uc9/w//U5z/939znP/3f3Oc//d/c/un/5vZP/zf153+k/5v6/I/0f3Of//R/c5//9H9z+zf8T339p/+b+/yn/5v7/Kf/m/v8p/+b+/yn/5v6/E/0f3P7p/+b2z/939Sf/4n+b+7z3/A/tX/6v7mv//R/c5//9H9zn//0f3Of//R/U5//Rv839flv9H9z+6f/m9s//d/c/g3/U/un/5t7/6f/m/v8p/+b2z/939z+6f+m/vzP9H9Tn/+Z/m9u//R/c/un/5vbv+F/6v2P/m/u85/+b27/9H9zX//p/+Y+/+n/pva/0v/N7Z/+b27/9H9z+6f/m3r/Xw3/U5//9H9zn//0f3Of//R/c5//9H9zn//0f1Of/xv939Tn/0b/N/f5T/839/lP/ze3f8P/1P7p/+b2T/83t3/6v7n3f/q/uc9/+r+pz/+d/m/q83+n/5v7/Kf/m/v8p/+b+/w3/E99/tP/zX3+0//Nff7T/83tn/5v7us//d/U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3/C/a//hf33Pf/C/vvc//K/v/Q//63v/w/+69n+G/3X9+3+G//W9/+F/ffsP/+vbf8P/rv2H//XtP/yvb//hf337D//r23/4X9f8Z4H/db3/F/hf3/7D//r+/Q//63v/G/537T/8r2//4X99P//hf33vf/hf3/sf/tf1/l/hf337D//r+vf/Cv/re//D//re/4b/Xe9/+F/f+x/+1/f+h//17T/8r2//4X9d+7/B//r2H/7X9fy/wf/63v/wv779N/zv+vc//K/v/Q//69t/+F/f/sP/+vYf/te1/zv8r2//4X9d978d/tf3/of/9e2/4X/X/sP/+vYf/tf3/Af/63v/w//69h/+1/Pv/3GA//W8/8cB/tf3/of/9b3/4X99+2/43/Xvf/hf3/sf/tf3/of/9b3/4X99+w//6/r3/wj/63r/j/C/vvc//K/v/Q//69t/w/+uf//D//re//C/vv2H//XtP/yvb//hf137n+B/ffsP/+vbf/hf1/0/wf/63v+G/13vf/hf3/sf/te3//C/vv2H//XtP/yva/8n+F/f/sP/+vYf/td1/5/gf33vf8P/rv2H//X9+x/+1/f+h//17T/8r+/f//C/rve/wf+63v8G/+t7/8P/+vYf/te3/4b/XfsP/+vbf/hf3/M//K/v/Q//69t/+F/Xv/9n+F/X+3+G//W9/+F/fe9/+F/f+9/wv+v9D//r23/4X9+//+F/fe9/+F/f/sP/uvZ/gf91/fxf4H9973/4X9/+w//6/v1v+N/1/of/9e0//K9v/+F/ffsP/+vbf/hf1/6v8L+u+98K/+t7/8P/+t7/8L++97/hf9f+w//69h/+1/fzH/7X9/6H//W9/+F/Xe//Df7X9f7f4H9973/4X9/7H/7X9/43/O96/8P/+t7/8L++/Yf/9f37H/7X9/6H/3Xt/w7/69t/+F/f/sP/+vYf/tf1/L8b/ne9/+F/ffsP/+vbf/hf389/+F/f+x/+17P/aYD/9e0//K9v/+F/ffsP/+t5/k+D4X/X+x/+1/f+h//1vf/hf33vf/hf3/sf/tf1/h/hf13v/xH+17f/8L++/Yf/9f38N/zvev/D//re//C/vvc//K9v/+F/ff/+h/91vf8T/K/r/Z/gf33vf/hf3/sf/tf3/jf879p/+F/f/sP/+n7+w//63v/wv779h/91/ft/gv91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ZuMkJM3GSUiajZOQhpAFQo5jOpYyjlN69qGVjW7jJiXtxk1K+o2blDQcNynpOF5S7rQcNynpOW5S0nTcpKTruElpSOklJW3HTUrajpuUtB03KWk7blLSdpykXAfajpuUtB03KWk7blLSdtykNKT0kpK24yYlbcdNStqOm5S0HTcpaTteUo60HTcpaTtuUtJ23KSk7bhJaUjpJSVtx01K2o6blLQdNylpO25S0na8pEy0HTcpaTtuUtJ23KSk7bhJaUjpJSVtx01K2o6blLQdNylpO25S0na8pJxoO25S0nbcpKTtuElJ23GT0pDSS0rajpuUtB03KWk7blLSdtykpO14SWm0HTcpaTtuUtJ23KSk7bhJaUjpJSVtx01K2o6blLQdNylpO25S0na8pJxpO25S0nbcpKTtuElJ23GT0pDSS0rajpuUtB03KWk7blLSdtykpO14SbnQdtykpO24SUnbcZOStuMmpSGll5S0HTcpaTtuUtJ23KSk7bhJSdvxknKl7bhJSdtxk5K24yYlbcdNSkNKLylpO25S0nbcpKTtuElJ23GTkrbjJeVG23GTkrbjJiVtx01K2o6blIaUXlLSdtykpO24SUnbcZOStuMmJW3HS8qdtuMmJW3HTUrajpuUtB03KQ0pvaSk7bhJSdtxk5K24yYlbcdNStqOk5TbQNtxk5K24yYlbcdNStqOm5SGlF5S0nbcpKTtuElJ23GTkrbjJiVtx0vKkbbjJiVtx01K2o6blLQdNykNKb2kpO24SUnbcZOStuMmJW3HTUrajpeUibbjJiVtx01K2o6blLQdNykNKb2kpO24SUnbcZOStuMmJW3HTUrajpeUE23HTUrajpuUtB03KWk7blIaUnpJSdtxk5K24yYlbcdNStqOm5S0HS8pjbbjJiVtx01K2o6blLQdNykNKb2kpO24SUnbcZOStuMmJW3HTUrajpeUM23HTUrajpuUtB03KWk7blIaUnpJSdtxk5K24yYlbcdNStqOm5S0HS8pF9qOm5S0HTcpaTtuUtJ23KQ0pPSSkrbjJiVtx01K2o6blLQdNylpO15SrrQdNylpO25S0nbcpKTtuElpSOklJW3HTUrajpuUtB03KWk7blLSdryk3Gg7blLSdtykpO24SUnbcZPSkNJLStqOm5S0HTcpaTtuUtJ23KSk7XhJudN23KSk7bhJ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X3N6aH3N6aH1NaeH1tZ8G+ih9TWnh9bXnB5aX3N6aH3NDc2ra04Pra85PbS+5vTQ+prTQ+trTg+trrn6FyeG1JweWl9zemh9zemh9TU3NK+uOT20vub00Pqa00Pra04Pra85PbS65upfJRxSc3pofc3pofU1p4fW19zQvLrm9ND6mtND62tOD62vOT20vub00OqaT/TQ+prTQ+trTg+trzk9tL7mhubVNaeH1tecHlpfc3pofc3pofU1p4dW19zoofU1p4fW15weWl9zemh9zQ3Nq2tOD62vOT20vub00Pqa00Pra04Pra75TA+trzk9tL7m9ND6mtND62tuaF5dc3pofc3pofU1p4fW15weWl9zemh1zRd6aH3N6aH1NaeH1tecHlpfc0Pz6prTQ+trTg+trzk9tL7m9ND6mtNDq2u+0kPra04Pra85PbS+5vTQ+pobmlfXnB5aX3N6aH3N6aH1NaeH1tecHlpd840eWl9zemh9zemh9TWnh9bX3NC8uub00Pqa00Pra04Pra85PbS+5vTQ6prv9ND6mtND62tOD62vOT20vuaG5tU1p4fW15weWl9zemh9zemh9TWnh9bWfB/oofU1p4fW15weWl9zemh9zQ3Nq2tOD62vOT20vub00Pqa00Pra04Pra75SA+trzk9tL7m9ND6mtND62tuaF5dc3pofc3pofU1p4fW15weWl9zemh1zRM9tL7m9ND6mtND62tOD62vuaF5dc3pofU1p4fW15weWl9zemh9zemh1TWf6KH1NaeH1tecHlpfc3pofc0NzatrTg+trzk9tL7m9ND6mtND62tOD62uudFD62tOD62vOT20vub00PqaG5pX15weWl9zemh9zemh9TWnh9bXnB5aXfOZHlpfc3pofc3pofU1p4fW19zQvLrm9ND6mtND62tOD62vOT20vub00OqaL/TQ+prTQ+trTg+trzk9tL7mhubVNaeH1tecHlpfc3pofc3pofU1p4dW13ylh9bXnB5aX3N6aH3N6aH1NTc0r645PbS+5vTQ+prTQ+trTg+trzk9tLrmGz20vub00Pqa00Pra04Pra+5oXl1zemh9TWnh9bXnB5aX3N6aH3N6aHVNd/pofU1p4fW15weWl9zemh9zQ3Nq2tOD62vOT20vub00Pqa00Pra04Praz5NAz00Pqa00Pra04Pra85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mnjea+J5r4nnvSae95p43mviea+J570mnveaeN5rOvFe0/aGoV4m3AzsJEu2Lf10SuYXLLeVb6mDQtKZp9uqOVFWc5Ko5px5262ao2U1x8hqjpXVHJLVHCerObJG5ShrVI6yRuUoa1ROskblJGtUTrJG5SRrVE61R+XXZ1yl5IS1xwtrTxDWniisPUlSe5zKP8E1Oq77jBij3UV7tA9qa74P/9y9YAmiawQxNYLYIkGs34N4ewiS+SIv2nVjIKuO+z6p/HaqattzTdn92/sYftpPwtvvNv69s/a5/a7z9vvO2x86b3/svP2p7/Zr1Xn7deftN523X/r8e9X+zudf3fn8qzuff3Xn86/ufP7Vnc+/pvP513Q+/5rO51/T+fxrOp9/Tefzr+l8/jWdz7+m8/nXdD7/2s7nX9v5/Gs7n39t5/Ov7Xz+tZ3Pv7bz+dd2Pv/azudf2/n8S53Pv9T5/Eudz7/U+fxLnc+/1Pn8S53Pv9T5/Eudz7/U+fzrOp9/Xefzr+t8/nWdz7+u8/nXdT7/us7nX9f5/Os6n39d5/Ov73z+9Z3Pv77z+dd3Pv/6zudf3/n86zuff33n86/vfP71nc+/ofP5N3Q+/4bO59/Q+fwbOp9/Q+fzb+h8/g2dz7+h8/k3dD7/xs7n39j5/Bs7n39j5/Nv7Hz+jZ3Pv7Hz+Td2Pv/Gzuff2Pn8mzqff1Pn82/qfP5Nnc+/qfP5N3U+/6bO59/U+fybOp9/U9/zr1Z9z79a9T3/atX3/KvF73911f6+51/d+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3vf6U73/9Kd77/le58/yvd+f5XuvP9r3Tn+1/pzve/0p3v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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_collapse_hints",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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y+kO1ofVpjtYv1Sb7mB9zfPp+h7eeN1yuoP1CbXpDnY/r013sPSwNl2Za7pTdVW+hzfXtpzuVF2V7+GNqi2nO1dX1cObPltOd66uqoc3ULac7lxdVQ9vRmw53bm6qh7e2NdyunN1VT28Sa7ldOfqqnp4w1nL6c7VVfXw5q2W052rq+rhjVAtpztXV9XDm4paTneurqqHN+i0nO5cXVUPb3ZpOd25uqoe3jjScrpzdVU9vAmj5XTn6qp6eENDy+nO1VX18OaAltOdq6vqYUf7ltOdq6vqYaf1ltOdq6vqYQfwltOdq6uSuboqmaurkrm6Kpmrq1rn6qrWubqqda6uqoe3WLScrsw13bm6qrHeI1Gf7lxd1VjvkahPd66uaqz3SNSnO1dXNdh7JKrTnaurGuxdD9XpztVVDfY+hup05+qqBntnQnW6c3VVg73XoDrdubqqwd49UJ3uXF3VYG8TqE53rq5qsLcJVKc7V1c12NsEqtOdq6sabdf/2nTn6qpG20W/Nt25uqrRdqWvTXeurmq0Xd5r052rqxpt1/TadOfqqkbbhbw23bm6qtF29a5Nd66uqshc052rq5prb3U/197qfq691f1ce6uHufZWD3PtrR7m2ls9zLW3elhkrulO1VWF0fZWf9l7juJ27GVS/tPBV468krANR95J2IYjLyVswnG0/evVOPJawjYcp3kt+HW6Mtd0p3nN9nW60zSf1+lO0yNepztNK3ed7jQd1+/pjrYFfW260/Qv1+lO8/rj63Tn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
      "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "EasyPrivateToken"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateToken::transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateToken::transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "initial_supply",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateToken::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateToken::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateToken::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateToken::mint_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "131": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "144": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "178": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "183": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "184": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "186": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "189": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "199": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "216": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "261": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "264": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "266": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "271": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "278": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "279": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "293": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "296": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "305": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "316": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "351": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "352": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext, messages::logs::note::encode_and_encrypt_note,\n    note::note_getter_options::NoteGetterOptions, protocol_types::address::AztecAddress,\n    state_vars::PrivateSet,\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\npub struct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, sender: AztecAddress) {\n        // Creates new note for the owner.\n        let addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(addend_note).emit(encode_and_encrypt_note(self.context, owner, sender));\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, sender: AztecAddress) {\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value() as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(result_note).emit(encode_and_encrypt_note(self.context, owner, sender));\n    }\n}\n"
    },
    "367": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/value-note/src/balance_utils.nr",
      "source": "use crate::value_note::ValueNote;\nuse dep::aztec::{\n    context::UtilityContext, note::note_viewer_options::NoteViewerOptions, state_vars::PrivateSet,\n};\n\npub unconstrained fn get_balance(set: PrivateSet<ValueNote, UtilityContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\npub unconstrained fn get_balance_with_offset(\n    set: PrivateSet<ValueNote, UtilityContext>,\n    offset: u32,\n) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value();\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"
    },
    "368": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/value-note/src/filter.nr",
      "source": "use crate::value_note::ValueNote;\nuse aztec::{\n    note::retrieved_note::RetrievedNote,\n    protocol_types::{\n        constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, utils::field::full_field_less_than,\n    },\n};\n\npub fn filter_notes_min_sum(\n    notes: [Option<RetrievedNote<ValueNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    min_sum: Field,\n) -> [Option<RetrievedNote<ValueNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    let mut selected = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n\n    let mut sum = 0;\n    for i in 0..notes.len() {\n        if notes[i].is_some() & full_field_less_than(sum, min_sum) {\n            let retrieved_note = notes[i].unwrap_unchecked();\n            selected[i] = Option::some(retrieved_note);\n            sum += retrieved_note.note.value();\n        }\n    }\n\n    selected\n}\n"
    },
    "371": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use aztec::{macros::notes::note, oracle::random::random, protocol_types::address::AztecAddress};\n\n// docs:start:value-note-def\n#[note]\n#[derive(Eq)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        ValueNote { value, owner, randomness }\n    }\n\n    pub fn value(self) -> Field {\n        self.value\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/easy_private_token_contract/src/main.nr",
      "source": "// docs:start:easy_private_token_contract\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract EasyPrivateToken {\n    use dep::aztec::macros::{functions::{initializer, private, utility}, storage::storage};\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::easy_private_state::EasyPrivateUint;\n    use dep::value_note::balance_utils;\n\n    #[storage]\n    struct Storage<Context> {\n        balances: Map<AztecAddress, EasyPrivateUint<Context>, Context>,\n    }\n\n    /**\n     * initialize the contract's initial state variables.\n     */\n    #[private]\n    #[initializer]\n    fn constructor(initial_supply: u64, owner: AztecAddress) {\n        let balances = storage.balances;\n\n        balances.at(owner).add(initial_supply, owner, context.msg_sender());\n    }\n\n    // Mints `amount` of tokens to `owner`.\n    #[private]\n    fn mint(amount: u64, owner: AztecAddress) {\n        let balances = storage.balances;\n\n        balances.at(owner).add(amount, owner, context.msg_sender());\n    }\n\n    // Transfers `amount` of tokens from `sender` to a `recipient`.\n    #[private]\n    fn transfer(amount: u64, sender: AztecAddress, recipient: AztecAddress) {\n        let balances = storage.balances;\n\n        balances.at(sender).sub(amount, sender, sender);\n        balances.at(recipient).add(amount, recipient, sender);\n    }\n\n    // Helper function to get the balance of a user.\n    #[utility]\n    unconstrained fn get_balance(owner: AztecAddress) -> Field {\n        let balances = storage.balances;\n\n        // Return the sum of all notes in the set.\n        balance_utils::get_balance(balances.at(owner).set)\n    }\n}\n// docs:end:easy_private_token_contract\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "95": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
