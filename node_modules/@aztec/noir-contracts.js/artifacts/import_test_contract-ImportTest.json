{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "ImportTest",
  "functions": [
    {
      "name": "main_contract",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "call_no_args",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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i5LSFyWlL0pKX5SUvigpfVFS+6Kk9kVJ7YuS2hcltS9Kal+U1L4oqX1RUvuipK/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bqXtRe6/GGoavkTpq9iJJjST9Xq//U7GwpX6aNQm7dKbK6U0V151UNelZ3nKzueFndCbK6Q7K6E2V1J8nqjqy7cpF1Vy6y7spV1l25yrorV1l35VfPvmZ1R9ZduY6+K3+7x9WtP0lYf7Kw/hRh/ami+uO3TVh/zhdQv2XSH828d7HRn5ux347up/zX1QtuJ/EjThJGnIRYThLS4yQpPJ3k5Iu8EvaFgcL2vO7Tdr6c6nasubaFx7f3JX/0Pwrvfzz4pxjC1/4n5f3PyvtflPe/6u7/+RsYivrvlPffK+9/UN5/6fNvq//K51+nfP51yudfp3z+dcrnX698/vXK51+vfP71yudfr3z+9crnX698/vXK51+vfP71yuffoHz+Dcrn36B8/g3K59+gfP4NyuffoHz+Dcrn36B8/g3K519SPv+S8vmXlM+/pHz+JeXzLymff0n5/EvK519SPv+S8vk3Kp9/o/L5Nyqff6Py+Tcqn3+j8vk3Kp9/o/L5Nyqff6Py+Tcpn3+T8vk3KZ9/k/L5Nymff5Py+Tcpn3+T8vk3KZ9/k/L5Nyuff7Py+Tcrn3+z8vk3K59/s/L5Nyuff7Py+Tcrn3+z8vm3KJ9/i/L5tyiff4vy+bcon3+L8vm3KJ9/i/L5tyiff4vy+bcqn3+r8vm3Kp9/q/L5tyqff6vy+bcqn3+r8vm3Kp9/q+75N2y659+w6Z5/w6Z7/g2b7vk3bLrn36B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP2roHz9q6B8/augfP0rUr7+FSlf/4qUr39Fyte/ok33/EvK178i6etfxRrL3v+SP/X/68E3Nxb2n65Ex8F1H6zwyZp3sMJndt7BCk8DWAcrfc0u3sEKTzB4Bys8G+EdrPDUJfuy/3TOW/1+sC5v+0+7nB4Hu3DKcdvJ3G5djWObGAkYOTAKT+S0YJRez9m2vSdpC+lLPix9PbenO3AurhEGMdGe/Mfn23U9O7i4vP/y7YcfZHyuH2j0JJTD0ehJP0ejkb7A3Uw0elLb4Wj0JMLD0QhPm2eiIaB5hUZUenvvkqhU8d4lUdnfvUuisq57l0RlO7+7JGsZv3uXRM3u9y6JmlXvXRI1m927JGoWuXdJ3t1b1sJ19y7Ju3vLWl7u3iV5d29Zi8DduyTv7i1rqbZ7l+TdvWUtqHbvkry7t6xlz+5dknf3lrU42b1L8u7espYQu3dJ3t1b1kJf9y7Ju3vLWo7r3iV5d29Zi2bduyTv7i1raat7l+TdvWUtQHXvkry7t6xlou5dknf3lrWY071L8u7espZcundJ3t1b1sJI9y7Ju3vLWr7o3iV5d29ZiwzduyTv7i1rKaB7l+TdvWUt2HPvkry7t6xlde5dknf3lrX4zb1L8u7espaouXdJ3t1b1kIy9y7Ju3vLWu7l3iV5d29Zi7LcuyTv7i1r6ZR7l+TdvWUtcHLvkry7t6xlSO5dknf3lrVYyL1L8u7espb0uHdJ3N07ylp4494lcXfvKGt5jHuXxN294ybu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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "call_public_fn",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bq+mqvrq/26vpqr66v9ur6aq+ur/bqXtRe6/GGoavkTpq9iJJjST9Xq//U7GwpX6aNQm7dKbK6U0V151UNelZ3nKzueFndCbK6Q7K6E2V1J8nqjqy7cpF1Vy6y7spV1l25yrorV1l35Srrrlxl3ZXr6Lvyt3tc3fqThPUnC+tPEdafKqo/ftuE9ed8AfVbJv3RzHsXG/25Gfvt6H7Kf1294HYSP+IkYcRJiOUkIT1OksLTSU6+yCthXxgobM/rPm3ny6lux5prW3h8e1/yR/+j8P7Hg3+KIXztf1Le/6y8/0V5/6vu/p+/gaGo/055/73y/gfl/Zc+/7b6r3z+dcrnX6d8/nXK51+nfP71yudfr3z+9crnX698/vXK51+vfP71yudfr3z+9crnX698/g3K59+gfP4NyuffoHz+Dcrn36B8/g3K59+gfP4NyuffoHz+JeXzLymff0n5/EvK519SPv+S8vmXlM+/pHz+JeXzLymff6Py+Tcqn3+j8vk3Kp9/o/L5Nyqff6Py+Tcqn3+j8vk3Kp9/k/L5Nymff5Py+Tcpn3+T8vk3KZ9/k/L5Nymff5Py+Tcpn3+z8vk3K59/s/L5Nyuff7Py+Tcrn3+z8vk3K59/s/L5Nyuff4vy+bcon3+L8vm3KJ9/i/L5tyiff4vy+bcon3+L8vm3KJ9/q/L5tyqff6vy+bcqn3+r8vm3Kp9/q/L5tyqff6vy+bfqnn/Dpnv+DZvu+TdsuuffsOmef8Ome/4Nyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvwrK178Kyte/CsrXvyLl61+R8vWvSPn6V6R8/SvadM+/pHz9K5K+/lWssez9L/lT/78efHNjYf/pSnQcXPfBCp+seQcrfGbnHazwNIB1sNLX7OIdrPAEg3ewwrMR3sEKT12yL/tP57zV7wfr8rb/tMvpcbALpxy3nczt1tU4tomRgJEDo/BETgtG6fWcbdt7kraQvuTD0tdze7oD5+IaYRAT7cl/fL5d17ODi8v7L99++EHG5/qBRk9CORyNnvRzNBrpC9zNRKMntR2ORk8iPByN8LR5JhoCmldoRKW39y6JShXvXRKV/d27JCrrundJVLbzu0uylvG7d0nU7H7vkqhZ9d4lUbPZvUuiZpF7l+TdvWUtXHfvkry7t6zl5e5dknf3lrUI3L1L8u7espZqu3dJ3t1b1oJq9y7Ju3vLWvbs3iV5d29Zi5PduyTv7i1rCbF7l+TdvWUt9HXvkry7t6zluO5dknf3lrVo1r1L8u7espa2undJ3t1b1gJU9y7Ju3vLWibq3iV5d29ZiznduyTv7i1ryaV7l+TdvWUtjHTvkry7t6zli+5dknf3lrXI0L1L8u7espYCundJ3t1b1oI99y7Ju3vLWlbn3iV5d29Zi9/cuyTv7i1riZp7l+TdvWUtJHPvkry7t6zlXu5dknf3lrUoy71L8u7espZOuXdJ3t1b1gIn9y7Ju3vLWobk3iV5d29Zi4XcuyTv7i1rSY97l8TdvaOshTfuXRJ3946ylse4d0nc3Ttu4u7eUda6FPcuibt7R1kLQty7JO7uHWUtrvC7S7KWQLh3Sd7dW9ZyAvcuybt7y/qA/t4leXdvWR9237sk7+4t6xvpe5fk3b1lfRN875K8u7esb2DvXZJ395b1zee9S/Lu3vK+tYzyvrWM8r61jPK+tYzyvrWM8r61jPK+tYzyvrWM8r61jPK+tYzyvrWM8r61jPK+tYzyvrWM8r61jPK+tYzyvrWM8r61jPK+tYzyvrWMsr61/Hq0jpUFo6zvQ/ViFL6KnxaM0ved+H6dyyjro92O/mPtvBdLfUVZXxrLQoO1816iIeE3hMdPp1zd92hSPm4e5TFWV7aPsUrftINxrEwf0x67iNz+dvlprPeTvB0892axr1nqa5b7mpW+ZrWr2fsf9N2bub5mvq9Z6GvWFyW5L0pyX5TkvijJfVGS+6Kk9EVJ6YuS0hclpS9KSl+UlL4oKX1RUvqipPRFSemLktoXJbUvSmpflNS+KKl9UVL7oqT2RUnti5LaFyW1K0rStvU1c33NfF+z0NeM+prFvmapr1nua1b6mvVFieuLEtcXJa4vSlxflLi+KHF9UeL6osT1RYnrixLXFyW+L0p8X5T4vijxfVHi+6LE90WJ74sS3xclvi9KfF+UhL4oCX1REvqiJPRFSeiLktAXJecvBlA6mlF2/qRZPm/mHs389h/f1wTKRns9KTwKVT6Xk2PrUdKv9fOx9+4UWd2porpz/sB+XnecrO54Wd0JsrpDsroTZXUnyeqOrLsyybork6y7cpR1V46j78ppP9Ztmz/pjxfWnyCsPySsP1FYf5Kw/rx9b743K33NalczphVhv33Ul5jWeG2cJI44SRpxkjziJGXESXjeeCL3OEmsTyd57xH77y4xrX7K2iUnr0t+dJfI1f1lE/JfI4lp7VPGDpG0Do1/QSVu2/7bkWrrt2s8froW9zRf1o8BJO0DyNoHULQPoCofwITVXZkH4LQPwGsfQNA+ANI+AOkz8eM7Bb+FzwN4/y3gVKTP28zDlT7LMw9Xek7APFzpGQTvcKv0fIN5uNKzE+bhSs9l3hzuUXAtfisnw5We+TAPl2wNd7GsqjXcxbKq1nAXy6paw10sq2oNd7Gs6vvh5m2trMq7x3Bj6+hcaf9qMdfqG0eH6PeStnv6ELGeHetdffB7+sr/19F37Gtld2qwr5VlqsG+VrarBjsB+wzsa2X/arCv5ULUYF/LDanBvpYrU4N9LXeoBbuDS52CHS51Cna41CnY4VKnYCdgn4EdLnUKdrjUKdjhUqdgh0udgh0udQZ2D5c6BTtc6hTscKlXYPfhwY/8CXa41CnYCdhnYEfePgN7QCZzBfab+997fUN8gh2ZzBTsyGSmYEcmMwU7AfsM7Ki3T8GOevsU7Mjbp2BHvX0KdtTbZ2Afv9dzcGHHHlxtrdDog9/ReKIm9sYn0nn8PtJzh+ttDTfYGi7ZGm60Ndxka7jDs91wK+Huw/XFt4br0jFcH/KPh1tsDbeaGu74rbPnDtfZGq63Ndxga7g03Ii+tfNz9sc+Dzk/vVRyuvOzS/5YtT7nJ7cYzn46bJs7OlJaRzMnANJ33F6WewL3KdyzXe4PNrdbfW5xZ76/F3Cfwr2C+wzuyeP+PuP+ngK4T+FO4D6Fu+H8fer93XD+PpU78vcp3LPweI81HgPYanjmfu+/8Lhp9l+4f2r2X7gPSfHYZC/F8LX/E/YM4u2/U95/4X6q2X/hvqTZf1Lef+F5crP/wuffZv+Fz7/N/guff5v9Vz7/VuXzb1U+/1bl829VPv9O2IeGt//K59+qfP6tyuffqnz+rbrn37Lpnn/Lpnv+LZvu+bdsuuffsumef8smfP59qh+mkk/6r6f+fN5/PfXn8/7rqT+f91/4/NvqvxM+/zb7L3z+bfZf+Pzb7L/092Ii7d/X5rSl5/6fPAkN+7GBnjrtP4YqfKrmHKr0tz8Yhyr9hQvGoUp/x4FxqNJfC2YcqvQ3cfmG6oUnK5xDFZ7XvPc+Ut72n3Y5Pa3NcfqGUdz2z8UibZ+OvZNZ6g1oVjJLvaPMSoZA5gWZpd7zZSWz1Ju4rGSWeleWlcxSX6Oxklnqe7H3yKT9ZexYS+NY8nHHSL7QU1pY7hyD9BR4ze9hSlgqH1fEHd87zuFu+HvHid/DlAlrUYP7L+743nEKd1oqn3krLyzHwc8P1l7d3R/UQ84nHO3WC3k52q0u8nK0W4vk5UjgyMLRbp2Tl6PdqigvR7s1VF6OdiuuvBzt1mff48haZYlwPzOowyvNoA5ndQX19NiZZisn1OHDZlAnUJ9AHR5vBnU4whnU4R9nUIfbnEEd3nQC9QRvegF1KTtJuvqQ8QnevpNkSfDIltWHV7esPmoGltUnqG9YfdRQLKuPWo5l9VFTsqw+aluW1UeNzbD6GbU+y+qj1mdZfdT6LKuPWp9l9QnqG1YftT7L6qPWZ1l91Posq49an2X1UeszrL70HWeh/qXqo9ZnWX3U+hZW34eHjORP1Eetz7L6BPUNqw+/b1h96btcQ/2fqJ/dDs/nsJ2oj5zfsvrI+S2rj5zfsvoE9Q2rj+f7ltXH833L6sPvW1Yfz/ctq4/n+3bVr5vdWl/1+xhrjI1j45aPbdnc9tTpj53W6ma3asbL0W79iZej3UoOL0eyOzuWfXNJt22tbaGicw+QMZ2ANFxe4AVp2KnzgjRsenlBGvaPvCANWzFWkM7wGwy8IA2/DMAL0vBzdV6Qhh9RvwOSd+fV6gjYZ2CHa5qCHR7rEuzfLyJfHRzZFOzwb1Oww+3NwO7hDadgh5Ocgh2+cwp2uNQp2AnYL8Cu5IP16uGWTcsP125aflQPTMuPKoZp+VFNsSx/QFXHtPyoLpmWH1Uu0/Kj2mZafoL8luVH1c+0/Kj6mZYfVT/T8qPqZ1p+VP0sy0+o+pmWH1U/0/Kj6mdaflT9TMtPkN+y/Kj6mZYfVb+V5W9sUVEJVT/T8qPqZ1n+CN9vWn6C/AvL31qyNiLzNy0/Mn/T8iPzNy0/Mn/T8uN5v2X5E573m5Yfvt+0/Hjeb1p+PO83Lf9Svj95OuTPTUXrth/ta2ztVEXbtkcLbfQUWvsSynmpafQtkmHb3NGR0uQeHldSyJ+vpDvJpWakqSSXurlPJUkgyURyqQcNU0nanbu5SS5V/p5KcqlK8lSSSxVlZ5IsS9U3LyX51m68rXVjCxzRHO7wT3O4w23N4U7gPoU7nNwc7vB9c7jDJc7hDk95CXctX6UVOGHT+lf4d9v6o45gW3/UM2zrj7qKbf0J+pvWH3Um2/qj3mVbf9TdbOuP+p9t/VH/M6x/2jbU/2zrj/qfbf1R/7OtP+p/tvUn6G9af9T/bOuP+p9t/VH/s60/6n+29Uf9z7T+DvW/pfX/fmXqm/6o/9nWH/U/2/rD/9vWH/n/0vp/v0bdTX/k/6b198j/beuP/N+2/sj/beuP5/+29Sfob1p/+H/b+uP5v2398fzftv6G639uK3tHXMyNoynXvSNU6InkfY+CG0nDlTReksFwTYqZpOHqDjNJw3USlw+S3rdIRnfMfNHFdELScMWBmSSBJBNJwy6YmaRhP8lM0rAzYyZp2ePwkrTscVhJkmWPw0vSssd5h+Sbu2x+v3L0jTsc0Rzu8E9zuBO4T+EObzaHO5zcHO7wfXO4wyXO4Q5PeQl3LV+gRjhh2/rDv9vWH3UE2/qjnmFbf4L+pvVHfce2/qgz2dYf9S7b+qPuZlt/1P9M659Q/7OtP+p/tvVH/c+2/qj/2dafoL9p/VH/s60/6n+29Uf9z7b+qP/Z1h/1P9P6Z9T/bOuP+t/S+rdWoM+o/9nWH/U/2/rD/9vWH/n/0vq3VqAsyP9t64/837b+yP9t64/837b+BP1N64/n/7b1h/+3rT+e/9vWH8//Let/gw79V9Y/bGHvdXDuRH/4f9v6w//b1p+g/9LP/0o99N/8if7w/7b1h/+3rT/8v2394f9t64/3f0zr7/D+j239Uf+zrT/qf7b1R/3Ptv6o/5jW3xvO/7bNHR0praN98If+RE6L/q36vzec/0H/m/6G8z/of9PfcP5nQf/m/E/Q37T+hvN/6H/T3/DzX+h/09/w81/of9Pf8PNf6H/T3/DzX+ifXED9z7b+qP/Z1h/1P9v6E/Q3rf9S+V/e4qF/qg1FS9lL427bmvKv+fkPLZX+Qf535V8q+4P878q/VPIH+d+c+2mpZ7+Q/135CfJbln+pJ7+Q/135l3rwC/nflX+p576Q/135l3rsC/nflR9VP8vyR1T9TMuPqp9p+VH2MS2/4dTvOLjk0FJ/ze99ouHMD+onw4kf1E+G87711W/N+8nww16onwwn/VA/EdQ3rL7hJ71QPxl+0Av1k+HnvFA/odZnWX3U+gyrn1Hrs6w+qj2W1Rfu+GKN+9KrZavhWf17/4V7lmb/hWfdzf4LzxtT3PLH0SmGk/4Lz3xa/S/C5+5m/4U/aWr2X/js2ey/8Gp/s/+kvP/C599m/4XPv83+C59/m/1XPv8W5fNvVT7/VuXzb1U+/1bl829VPv9W5fNvVT7/VuXzb1U+/1bd86/fdM+/ftM9//pN9/zrN93zr990z79e+q7yzf7rnn+99F29n3465eq+9l/6/Nvqv/T5t9F/6bsCN/svff5t9V/6/Nvqv/T5t9V/6fNvq/96nv/e+u+f+3/SkdvD8/1x9+3v8Oi4vz26vI9Xz/NinvHqeb7MM17h+QD7eIXnD9zjlb4LLft4hecnz+N9fonqdLyh1P2701CJjoPrKZwQ/P7TLjzPXQ84wpOfuXCEZ1Zz4RDgvIajKCccD0dRAjkejqJsczwcRanpeDiK8tjhcKRvvTYXDjLkb+AYyZDvgzWS8d4HS5YGu1ZGSv4YbHJfB7tWhtkY7FoZY2Owa2WAjcGuldF9P1jpu6PxDnatjKsx2LUyqMZgl8qgat6L6+S2/H0uXVx6fLC7lUcmffoJLuVjAUXK7lHlD9F9gCSA5AG5VOY3E+RSWeVMkEtlrDNBLpUNzwS5VKY9EaT03U70gFzKIcwEuZT7mAkSzoYJJAEkD0g4GyaQcDZMIOFsmEDC2TCBhLPhASl9Ox89IJFH/iHIGg+QNZ2AxKz9ZyDL8QEv3Q4/AWl31payyKqrD9ZPK9Tui6x66YurQyIvfQV0SOSlL1MOiXy2W/dVI5HdirIaiex6DDUSESSSLpHd+roaiezWANRIhOqCeIlQXRAvEaoL0iWSvpEKJPLS94qBRF76djiQyEvf8QcSeembGkEiL33fJkjkpW9NBYm89N23IJGXvsEYJPLS91AzIJEPD9b0dZtlL32bOEjkpe+EB4m89M3mIJGXvp+bAYmy2+H5HLYTiZDRiZcIGZ1wiYL0jQchUZC+tyIkCtK3j4REQfoOmZAobASJpEuE50XiJcLzIvESCa8u5Hisr5rTlhoShWMtVnrqtP8YqnCXzjlU4W6XcajSt8vlHKpw98U5VOEuhnOowt0A51DJzlCFZ6fZl/2nc356BH6+q2be9p92OT09Lw+nWdWx4EukrXEs8+48QfpmxKtil55FLopdekYrHvsdo/RsWQdG6RtJa8EoPcuXgvHbjVeC9J2stWCU7k6UYCRg5MAIV8WCES6JBSNcDwtGuBgWjHAxf4Rx3lLHQfqu45AoSN/7HBIF6TuwQ6Igfd94SBSk73YPiUKA2xUvEZy0eIng0sVLhAqAeIlQXZAuEaG6IF4iVBfES4TqgniJUF0QLxFBIukSobogXiJUF8RLBF80XaLv90UNERndbIkaO66GiIyOXyIli22GSBDfrvjIQg2Lj/zWsPh4LmdYfDzxMyw+PLNd8ROeUhoWH88/DYuPOpxh8VHhMyw+QXy74qPCZ1h8VPgMi48Kn2HxUeEzLD4qfHbFz6jwGRYfFT7D4qPCZ1h8VPgMi08Q3674qPCtK35je+KQUeEzLD4qfHbFL/D5hsVHtr+u+K1NAwtBfLviI9s3LD6yfcPiI9s3LD6e5xsWH8/z7Ypf4fMNi4/n+YbFx/N8w+IbrvAdixvFWhrHko/HCmG+PLbzdL58cLSbOJfj4JJD41gf0n6wvz1X+hTpd452c1BOjrTZTed4OdrNjHg52k0yeDnana95ORI4snC0+5yIl6PdRy68HO0+vXiPoz84ErX86XfrwN6pw/3MoA6vNIG6g7OaQR0+bAZ1uLYZ1OHxZlAnUJ9AHf7xAupKvim7/QLUN6w+vLpl9VEzsKw+aheG1feooVhWH7Ucy+qjpmRZfdS2LKtPUN+w+qj1WVYftT7L6qPWZ1l91Posq49an2H1A2p9ltVHrc+y+qj1WVYftT7L6hPUN6w+an2W1Uetz7L6qPUtrH5jzWgKqPVZVh+1PsPqE/y+ZfWR8y+sfmMlOSLk/JbVR85vWX3k/JbVR85vWP2I5/uW1cfzfcvqw+9bVh/P9y2rT1DfsPp2a33V72OsMTaOjVs+Nhlw21OnP/YNoGi3asbL0W79iZej3UoOL0fDNZGyb5Xiti21QDr3ABnTV5DJcHmBF6Rhp84L0rDp5QVp2D/ygiSA5AFp+A0GXpCGXwbgBWn4uTovSMOPqN8B6d1jhxUfPu+wcvLTrfWdE3zQDOwZrmkKdnisKdjhyKZgh3+bgp2AfQZ2eMMp2OEkr8Cu5VvSDP9rWn64dtPyo3pgWf6CKoZp+VFNMS0/qjqm5Ud1ybT8BPkty49qm2n5UfUzLT+qfqblR9XPtPyo+lmWv6LqZ1p+VP1My4+qn2n5UfUzLT9Bfsvyo+pnWn5U/UzLj6qfaflR9VtZ/tbq8RVVP8Pyxw1VP9Pyw/eblh+Z/8ryN1aTjBsyf9PyI/M3LT8yf8vyO2T+puXH837T8uN5v2n54ftNy0+Q37L8eN5vWv6lfH/ydMifm4rWbT/a19jaRIa2bY8W2ugptD5WN41+qWn0LZJh29zRkdLkHh5XUsifr6Q7yaVmpKkkl7q5TyW51NORqSSXetAwlaTduZub5FLl75kkw1KV5KkklyrKTiW5VH3zUpJvbZTZWDc2BjiiOdwJ3Kdwh9uawx3ebA53OLk53OH75nCHS5zCneApL+Gu5Ku0SHDCtvWHf7etP+oItvUn6G9af9RVbOuP+o5t/VFnsq0/6l229UfdzbT+EfU/2/qj/mdbf9T/bOuP+p9t/Qn6m9Yf9T/b+qP+Z1t/1P9s64/6n239Uf8zrX9C/c+2/qj/2dYf9b+l9W+tTJ1Q/7OtP0F/0/rD/5vWPyP/X1r/1hp1Gfm/bf2R/9vWH/m/bf0J+pvWH8//beuP5/+29Yf/t60/nv/b1h/P/03rXwzX/9xW9o64mBtHU657R6jQE8l9j4JiuJLGTNJwTYqZpOHqDjNJMkwyHyS9b5GM7pj5oovphKThigMzScPenZmkYRfMTNKwn2QmadiZ8ZKslj0OL0nLHoeXpGWPw0vSssd5h+Sbu2y2Vo6uBO5TuMM/zeEOtzWHO7zZHO5wcnO4w/fN4J42uMQ53OEpL+Gu5AvUtMEJ29Yf/t22/gT9TeuPeoZt/VFXsa0/6ju29Uedybb+qHeZ1t+h7mZbf9T/bOuP+p9t/VH/s60/QX/T+qP+Z1t/1P9s64/6n239Uf+zrT/qf6b196j/2dYf9T/b+qP+Z1t/1P+W1r+xAv0NGPQ3rT/qf7b1h/83rX9A/r+0/o0VKFNA/m9bf+T/tvUn6G9af+T/tvXH83/b+uP5v2394f9t64/n/6b1Jzz/t62/cP8fa9xFysU19I9+yx8HR/+0WmnNH4MlS4MV7ux4ByvcxvAOVnjOzjtY4Qkq72CFZ2Osg43CUw/ewQp/zsY7WOEPlXgHaymDimRpsJYyqGgpg4qWMqhoKYOKljKoZCmDSktlUFTDPthI+XmwJ71227Z32j2NMWzxA81S+RYvmqWyM140BDSv0CyV+fGiWSpP5EWzVFbJi2apHJQXzVIZKyuavFR+G4/HjTH5+j2acPwwPfWihD8+1BF9MFwqbX7N8D7YpRLh1mCXSm1bgyVLg10q/WwNdqmEsjXYpVLE1mCXSvpag10qjWsMtiyVmCU6Co8lh+8Ts/J4aez2w48q5bGhWlkq3+JFs1R2xotmqVzuPTSNHQoLAc0rNEvlibxolsoqedEslYPyolkqY+VFs1R+y4qmGs6GW2jsZsNaVoCrdrNyNRLZdQdqJCJIJF0iu25JjUR2XZsaiey6RzUS2XWxaiSy66aVSJQ3u65ejUSoLoiXCNUF8RKhuiBeIoJE0iVCdUG8RKguiJcI1QXxEqG6IF4iVBekS+RQXRAvEaoL4iVCdUG8RKguzJaosQdUdgSJpEuE6oJ4ieCLpEskfbNrAxI11iPP0vejhkRZ+pbRkChL39UZEmXpGy9DouzxvEi8RHheJF4i+CLxEuF5kXSJAp4XSZeIUF2YLVHY9tUnb6UgdyIRqgviJUJ1QbxEBIlmV7pLPSTaTirda23+t6ZEqC6IlwjVBfESobogXiJUF6RLtNZWnGtKhOqCeIlQXRAvEaoL4iWCdZUukfR9J2/PHPefznlrSOSS36m7nJ/YhLOfDo+VvIP3uXG0dykeSEJuaKSmACh9K07of7H+whMd6H+x/sKzKOh/8fxP0N+0/sJTdOh/sf7CH11B/4v1F/5cDPpfrL/wh27Q/2L9hT/Rg/7X6i99X27of7H+qP/Z1h/1P9v6E/Q3rb/h/G/b3NGR0jraB3/oT+S06N+q/0vf/hv6X6y/4fwP+t/0N5z/WdC/Nf9L360e+l+sP0F/0/obfv4L/W/6G37+C/1v+ht+/gv9b/obfv4L/W/6o/5nWv+K+p9t/VH/s60/6j+29V8q/8tbPPRPtaFoKXtp3G1bU/41P/+Rvnk95L9S/rItlf1B/nflXyr5g/zvzf1lW+rZL+R/V/6lUn/I/678BPkty7/Ug1/I/678Sz33hfzvyr/UY1/I/678qPqZlh9VP8vyO1T9TMuPso9p+Q2nfsfBzwu4Wvrep0jf2h7qX6q+4cQP6nvDed/66rfmfW/4YS/U94aTfqjvDT/qhfqeoL5h9Q0/6IX63vBzXqjvUeuzrD5qfZbVR63PsPoB1R7L6pNZ9eNRBI+0NY4NNdcD+vZ4wit7S8dWmT/YNXwQP9j1exA/2LV764vfnPPtuj2IH+yaPYhPdt/rgPhk1+hDfLL7VgfEJ7svdUB8IohvV3xU+AyLjwqfYfFR4bMrfoTP5xffpYf4W2nISbnunb79+RA03MLmLhHc+GyJynE13/6sJxLBM0+XyIdDouBPJIKzFS8RQSLpEsElipcIXk68RHBc4iXCmw/TJdryIZHfTiTC+wnSJUqoLoiXCNUF8RKhuiBeIlQXxEtEkEi6RKguiJdIuC+KNZaPo9Pzp3qnEq35xUYS7osgUcnCfREkKlm4LzIgUevdhSzcF0Gi26ghkXSJCBJJl0i4L4JEJQt/6gqJShb+1BUSlYzqgniJUF2QLlFBdUG8RKguiJeIzErE+/1CseteeL8yKHY9Bu/LfcWuE2AGaTdfZwZpN6vmBVnt5r7MIO1mqMwg7T6l4n31pNp9lsQMkgCSByScDRNIOBsmkHA2TCDhbJhAwtmwgKybnjyybPUTyHv/9aRv5/0n5f0XnqykeFwAKYaT/gvPEZr9Fz41N/svfEZs9l/4RNTqvxNe2Wr2X3hBqdl/4fNvs//C599m/4XPv83+K59/nfL51ymff53y+dcpn3+98vnXK59/vfL51yuff73y+Vf6nvXN/iuff6XvG97sv/L5V/reza3+B+Xzr/Tdk5v9Vz7/BuXzr/T9l59+OuXqvvZf+vzb6r/0+bfVf+nzb6v/0uffVv+lz7+N/kvfEbLZf+nzb6v/it4jzE+f6pwvjlVv+ejekXqbG47D/e3R5X28il73Yxmv8PmdfbyKXp5jGa+id9xYxqvoVTSW8S71xlip+1vt4XZnOg4+fdHJheD3n3bhee56wFnqLTBmONL34JoLZ6nvULjhLPVtCTecpb4X4YZDgPMazlLfdXDDWepbDW44S31/wQ0HGfI3cIxkyL8HK31fGN7BGslg74NdKyMlfww2ua+DXSvDbAyWLA12rQywMdi1MrrGYNfK0BqDXSvjagx2rQzq+8Ea3kHizdXpjn0eKLuvy7NUw/s8MIPEOjdMILHODRNIAkgekFjnhgkk1rlhAol1bphAYp0bJpBY54YHpOHV65lBwtkwgYSzYQIJZ8MEkgCSByScDRNIOBsmkHA2PCCxEvyfgvx+/5aKdbf/EGRrBU/D625L2fTJ1QfrrX46+i4RdloVLxF2WhUvEXZaFS8RdloVLxF2WpUtUd427LQqXiLstCpeIrv1dTUS2a0BqJGIIJF0iVBdEC8RqgviJUJ1QbxEqC6IlwjVBekSSd/xBxJt0jc1gkSb9H2bINEmfWsqSLRJ330LEm3SNxiDRJv0PdQMSOTDgzX5E4lQXRAvEaoL0iWSvtkcJNqk7+dmQKLsdng+h+1EImR04iVCRideImR04iVCRideIjwvki6R9B0yIdEmfRNQSLRJ3+cUEm3St3KFRJv03WpzPNZXzWlLDYnCsRYrPXXafwxVuEvnHKpwt8s5VOGukXOowt0X51CFuxjGoUrfr5dzqMKzas6hCs9Osy/7T+f89Aj8fFfNvO0/7XJ6el4eTrOqY8GXSFvjWN7deW7YhWecq2InYJ+BXXpGKx77HaP0bFkJRumZuBKM0rN8KRi/23jlhlG6g9CBUfqe11owSnc+SjDCVbFghEtiwUjAyIERLoYFI1zMH2GcttTxbUhwSOIlgvsSLxGcnXSJpO8bD4k26bvdQ6Itwe2KlwhOWrxEBImkS4QKgHiJUF0QLxGqC+IlQnVBvESoLkiXKKO6IF4iVBfES4TqgniJUF0QLxF80XSJvt0X9SYRMrrZEn2/42reCjI6fom0LLZZkCsaFh9ZqGHxkd8aFp8gvl3x8cTPsPjwzIbFx1NKw+Lj+adh8VGHsyt+RYXPsPio8BkWHxU+w+KjwmdYfIL4dsVHhc+w+KjwGRYfFT7D4qPCZ1h8VPjMiu82VPgMi48Kn2HxUeFbV/zG9sRuQ4XPsPgE8e2KD59vV3yHbH9d8RubBjqHbN+w+Mj2DYuPbN+w+ATx7YqP5/mGxcfzfMPiw+cbFh/P8w2Lj+f5dsX3hit8x+JGsZbGseTjsUKYL4/tPJ0vHxztJs7lOLjk0DjWh7Qf7EPOnyL9ztFuDsrL0W46x8vRbmbEy9FuksHKMdidr3k52n24xcvR7nMiXo52H7nwciRw/COO/uBI1PKn360De6cO9zODOrzSDOpwVjOow4fNoA7XNoE6wePNoA5HOIM6/OMF1LV8U0ZwvZbVJ6hvWH3UDCyrj9qFZfVRQ7GsPmo5ltVHTcmw+hG1Lcvqo8ZmWX3U+iyrj1qfZfUJ6htWH7U+y+qj1mdZfdT6LKuPWp9l9VHrM6x+Qq3Psvqo9VlWH7U+y+qj1mdZfYL666rfWjM6odZnWX3U+iyrD79vWP2MnH9h9VsryWXk/JbVJ6hvWH3k/JbVR85vWX0837esPp7vW1Yfft+w+gXP9y2rj+f7ltW3W+urfh9jjbFxbNzyscmA2546ve8bUOxWzXg5EjiycLRbyeHlaLgmUvatUty2pRZI5x4gYzoBabi8wAvSsFPnBWnY9LKCrIb9Iy9Iw1aMF6ThNxh4QRp+GYAXJAEkD0jDj6jfAendY4cVHz7vsHLy0631nSt80BTscE1TsMNjTcEORzYBu9/g36Zgh9ubgh3ecAp2OMkrsCv5ltRvBPktyw/Xblp+VA9My48qhmn5UU0xLT+qOpbld6gumZYfVS7T8qPaZlp+VP1My0+Q37L8qPqZlh9VP9Pyo+pnWn5U/UzLj6qfZfk9qn6m5UfVz7T8qPqZlh9VP9PyE+S3LD+qfivL31g93ntU/UzLj6qfZfkDfL9p+ZH5ryx/YzVJHwjyW5Yfmb9p+ZH5m5Yfmb9p+fG837T8eN5vWX6C7zctP573m5Yfz/tNy7+U70+eDvlzU9G67Uf7GlubyNC27dFCGz2F1sfqpj4uNY2+RTJsmzs6Uprcw+NKCvnzlXQnudSMNJXkUjf3qSSXejoylSSBJBNJu3M3N8mlyt9TSS5VSZ5Kcqmi7FSSS9U3LyX51kaZrXVjExzRHO7wT3O4w23N4Q5vNoc7gfsU7vB9c7jDJc7hDk95CXctX6UlOGHb+sO/m9Y/o45gW3/UM2zrj7qKbf1R37GtP0F/0/qj3mVbf9TdbOuP+p9t/VH/s60/6n+m9S+o/9nWH/U/2/qj/mdbf9T/bOtP0N+0/qj/2dYf9T/b+qP+Z1t/1P9s64/639L6t1amrqj/2dYf9T/b+hP0N60/8v+l9W+tUVeR/9vWH/m/Zf1vDKC/af2R/9vWH8//beuP5/+29Sfob1p/PP+3rT+e/9vW33D9z21l74iLuXE05bp3hAo9kfzYo+AWQiDJRNJwTYqXpDNc3WEmabhO4vJB0vsWyeiOmS+6mE5IGq44MJM07N2ZSRJIMpE07CeZSRp2ZswkLXscXpKWPQ4vScseh5Wkt+xx3iH55i6bjZWjg4cjmsMd/mkOd7itOdwJ3Kdwh5Obwx2+bw53uMQ53OEpL+Gu5AvU4OGETesf4N9t6486gm39Uc+wrT/qKrb1J+hvWn/UmWzrj3qXbf1Rd7OtP+p/tvVH/c+0/oT6n239Uf+zrT/qf7b1R/3Ptv4E/U3rj/qfbf1R/7OtP+p/tvVH/c+2/qj/mdY/ov63tP6NFehDRP3Ptv6o/9nWH/7ftv7I/5fWv7UCZUT+b1r/hPzftv7I/23rj/zftv54/m9bf4L+pvWH/7etP57/29Yfz/9N65+F+/9Y4y5SLq6hf/Rb/jg4+qfVSmv+GKxws8s7WOHOjnewwm0M72DJ0mCFJ6i8gxWejfEOVnjqwTtY4c/ZeAcr/KES62CLpQyqWMqgiqUMqljKoApZGqylDKpYyqCKpQyqLJVBUQ37YCPl58Ge9Npt295p9zTGsMUPNEvlW6xo6lLZGS+apXI5XjRLZX68aJbKE3nRENC8QrNUDsqLZqmMlRfNUvltPB43xuTr92jC8cP01IsS/vhQR/TBcKm0+TXD+2CXSoS/HyxtS6W2rcEulay2BrtU+tka7FIJZWuwZGmwSyV9rcEulca1BrtUYpboKDyWHL5PzMrjpbHbDz+qlPuGarQtlW/xolkqO2NF45bK5d5D8/0OheSWyvx40SyVJ/KiWSqr5EVDQPMKzVIZKy+apfJbXjSGs+EWGrvZsJIV4MjZzcq1SOTtugM1Etl1KWoksuuW1Ehk17WpkYggkXSJ7LpYNRLZddNqJLLr6tVIhOqCeIlQXZAuUUB1QbxEqC6IlwjVBfESobogXiKCRNIlQnVBvESoLoiXCNUF8RKhuiBeIlQXpEtEqC7MlqixBxQRqgviJUJ1QbxE8EXiJUJGN1uixnrkJH0/akhE0reMhkQkfVdnSETSN16GRBTxvEi8RASJpEsEXyReIjwvEi8RnhdJl2jyVrqhJZEr4dgdrdDjY91bpeTe/6C8/6S8/1F5/5Py/mfl/S/K+19193/yVoo/779T3n/l829WPv9O3pbw5/1XPv9m5fNvVj7/ZuXzb1Y+/xbl829RPv8W5fPv+B3wggv7BgjB1a3x2z48diAPOX8qbdwHQNoHELUPIGkfQNY+gKJ9AFX5AMbvuMY9AKd9AF76APwxAKJWRb+5xmQVP2/zDlf8LM87XPE5Ae9wxWcQvMMVn2/wDld8dsI7XPG5DOdw4yY+83lruEq+MIub+HxtTexrZZlqsK+V7arBTsA+A/ta2b8a7Gu5EDXY13JDarCv5crUYF/LHWrB7uBSp2CHS52CHS51Cna41CnYCdhnYIdLnYIdLnUKdrjUKdjhUqdgh0udgd3DpU7BDpc6BTtc6hXYG+sBRg+XOgU7AfsM7MjbZ2APyGSuwN5YjSUGZDJTsCOTmYIdmcwU7ATsM7Cj3j4FO+rtU7Ajb5+CHfX2KdhRb5+Bffw2TeHmnHfsvvjGb0d3gLw9bn8ari8fA3DaB+C1DyBoHwBpH0DUPoCkfQBZ+wCK9gFU2QPw7rF6hw+5lT+0vjmOwudt7uEKn+W5hys8J+AervAMgnu4ZGu4wrMT7uEKz2W4hys883lzuFreHIrC87VVsa+VZWrBntbKdtVgXyvrVoN9rexfDfa1XIga7ATsM7Cv5crUYF/LHarBDpc6BTtc6hTscKkzsGe41CnY4VKnYIdLnYIdLnUKdgL2GdjhUqdgh0udgh0udQp2uNQp2OFSr8De+i69wKVOwQ6XOgU7AfsM7MhkrsDe+pqrIJOZgh2ZzAzsFZnMFOzIZKZgR719CnbU26dgJ2CfgR319inYUW+fgn2CS637wSE8rSLy67d/dSmN30uYtsPL0xZbkfDd0fcBOO0D8LIHkErcr65Usnv65Xv3g+7uk+7uR+Hdr9t+s03V5y/dT7q7n3V3v+juflXdfSd85m11X/i82+q+9Fm30X3ps26j+9Jn3Ub3dc+6Tves63TPuk73rOt0z7pe96zrdc+6Xves63XPuuP3w+Htvu5Z1+uedb3uWdfrnnW9+FmXjjJVjV+6H8TPut93X/ys+333xc+633df/Kz7fffFz7rfd//iaev3SaQvqq70eWTY9jH64Nyno+/Y8YrPFOx4xWcKdgL2C7D7Ug/smz/Bjld8pmDHKz5TsONDlCnY8SHKFOz4EGUG9sU241CDHS51Cna41CnY4VKnYIddmoF9wor/FrYDbdVkJqz4D+w37B7YZ2APwD7j3k7APgN7BPYZ2BOwz8CegX0G9gLsM7BXYJ+APcOlTsEOlzoFO1zqFOwE7DOwD59SfQn7YMPmQuO3Y41lR1NcPY4u+ezgRPnj4Fjy46dr1ly/Gb+UMSR6VyIHiaRL5CGR8LmoBEgkXSKCRNIlipBIukQJEkmXKEMi6RIVSCRdIlQXpEtUUV0QLxGqC+IlgnUVL5HwdCH7sv90zltDIpf8Tt3l/MQmuNMnHXlXP/inZV7Oj170Q+wqPBeB/pfqnzfhiQ70v1h/4VkU9L90/s+b8AdA0P9i/YWn6ND/Yv0J+pvWX/hzMeh/sf7CH7pB/4v1F/5ED/pfrD/qf7b1R/3PtP4O9T/b+qP+Y1t/w/nftrmjI6V19JrLoGRnOP+D/jf9Ded/0D9nbzj/s6B/a/73hp//Qv+b/obzf+h/09/w81/of9OfoL9p/Q0//4X+N/0NP/+F/jf9Uf+zrT/qf7b1R/3PtP4B9R/b+i+V/+Vj43aXU20oWspeGnfb1pR/zc9/wlLpH+R/V/6lsj/I/678SyV/kP/NuZ+WevYL+d+Vf6nUH/K/K/9ST34h/7vyL/XgF/K/Kz9BfsvyL/XYF/K/Kz+qfqblR9XPtPyo+lmWP6LsY1p+w6nfcfDzAq6mvveJhjM/qB8NJ35QPxrO+9ZXvznvG37YC/WT4aQf6ifDj3qhfjL8pBfqJ8MPeqF+IqhvWH3U+iyrj1qfZfVR67OsPqo9htXPdh1fPIrgkbbGsaHmekDfHk94ZW/p2CrzZ7uGD+Jngvh2xbdr99YXvznn23V7ED/bNXsQP9t9rwPiZ7tGH+IXu291QPxi96UOiF9Q4TMsPip8hsUniG9XfFT4DIsPn88vvksP8bfSkJNy3Tt9+/MhaLiFzV0iuPHZEpXjar79Wb9KVOGZp0vkwyFR8CcSwdmKlwj+U7xEcIniJSJIJF0iOC7xEuHNh+kSbfmQyG8nEuH9BPESobogXiJUF4RLVDZUF8RLhOqCeIlQXRAvEaoL4iUS7otijeXj6PT8qd6pREt+sXFTEBJJl0i4L4JEZRPuiwxI1Hh3oTjhvggSFSfcF0Gi4oT7IkhUnHBfBImKI0gkXSLhT10h0a1WAYmkS4TqgniJUF0QLxGqC9Il8nZ9Eev3C8XbdS+sXxkUTwDJ8XLf7b4DkDwg7ebrzCDtZtXMIO3mvswg7WaovCCD3adUvK+eBLvPkphBwtkwgYSzYQJJAMkDEs6GCSScDRNIOBsekDR+1o7btv92pNr67VKPN+q20CrsqnkPkAKwz8BOwD4DewT2/z7+WRMlYJ+BPQP7DOwF2Gdgr8A+AXvcgH0GdgfsM7DDpU7BDpc6BTsB+wzssEszsJ9vBUg5HXXLp1Pc/r43Sj2Nck+jU1sR3R4U0YdPjc4qx2ln60t5Ko+UjzPUq89wvvkO6xnc5Wfwl58hXH4GuvwM8fIzpMvPkC8/w+XXdLn8mq6XX9Pn64lG2qeVSPnr7fJ8bb6Y90bpeR2aj0b1fCmy789UzxfHisdzt5jopNH5XaTs81ms4aRR6GlEPY1iT6PU0yj3NCo9jc4vhbIdjU50Ol+EodXI9TTy3zdK28mYzj+djsdj3PT0YPbR6DQiktvppVBPGsXGmc6up/MPHhsX4fkneK1GPZf7+Tcwzsd9UM6nExTnX3y0m1Ffs9jXLPU1y33NSl+z2tXs/J3TdjPX1+xFlJR8NHsyKo9mod0snTSjvmaxr1nqa3YeJTdbtTcLZzeeUPqa1a5mtPU1c33NfF+z0NeM+pq90C0dcod8Msuc1/jdI8dzkU6ugPgCST2uN9riSbPQbnZymUbqaxb7mqW+ZrWrWTonSf5YgpGCO2kW+pqdk6S0Hc3SyU0h5RfNHmPLJ5NwfjG2o7TjqJzEZA59zaiv2XmUUKXjCtjOxpb6muW+ZqWvWX1xdR+6RX9ymZatr5nr6mTxfc1CXzPqaxa77pPnlYx2s9zXrHQ1q67rzlX77ly1785VqaNZ2ZI7r8ceb5NRdl8+fbo1833NTsfW+NDq1oz6msW+Zqmv2Xll+/uXf2/NSl+z2tUsb33NXF8z39cs9DWjvmaxr1nqa9YXJS9q+36/A8XwdE++P9W5NfI9jUJPI+ppFHsapZ5GuadR6WlUOxq9KCM3GvVExPmUFOsefOn54erRKPQ0op5GsadR6mmUexqVnkb1/UbuRTG+0cj1NPI9jUJPo46IcC9Wmc1uf17s80mcu/OCsksPG5dyOWkW+ppRX7PY1+w8Zc55T09crv6kWe5rVvqa1a5mfutr5vqa+b5moa8Z9TWLfc36osT3RYnvixLfFyWhL0pCX5S8qIHfnqntzW4PU06ahb5mp7rl4x2lnB53yVvtUvJLR64+Xtp69sfHULOdoRY7Q61mhnr+lGXNoTo7Q/V2hhrsDJXsDDXaGaqdbInsZEtkJ1siO9lStJMtRTvZUrSTLUU72VK0ky1FO9lStJMtRTvZUlwnW/r+M8XbUNfJllpDTetkS82hrpMtNYe6TrbUHOo62VJzqGRnqOtkS82hrpMtNYe6TrbUHKqdbCnZyZaynWwp28mWsp1sKdvJlrKdbCnbyZaynWwp28mWsp1sKdvJloqdbKnYyZaKnWyp2MmWip1sqdjJloqdbKnYyZbKOtlS6wOrsk621BpqXSdbag51nWypOdR1sqXmUNfJlppDJTtDXSdbag51nWypOdR1sqXGUP2Lb9xT3JvF/LxEmi9nJ7n1+ePosD2v+ubLx0nSiJPkEScpI05SB5zEjRD+xTq0zCfxI04SRpyERpwkjjjJiCvejbji3Ygr3o244v2IK96PuOL9iCvej7ji/Ygr3o+44v2IK96PuOL9iCvej7jiw4grPoy44sOIKz6MuOLDiCs+jLjiw4grPoy44sOIKz6MuOJpxBVPI654GnHF04grnkZc8TTiiqcRVzyNuOJpxBVPI674OOKKjyOu+Djiio8jrvg44oqPI674OOKKjyOu+Djiio8jrvg04opPI674NOKKTyOu+DTiik8jrvg04opPI674NOKKTyOu+Dziis8jrvg84orPI674POKKzyOu+Dziis8jrvg84orPI674MuKKLyOu+DLiii8jrvgy4oovI674MuKKLyOu+DLiii8jrvg64oqvI674OuKKryOu+Driiq8jrvg64oqvI674OuKKrwOu+DDi1auwuREn8SNOEkachEacJI44SRpxkjziJGXESUZc8SPeuQsj3rkLI965CyPeuQsj3rkLI965CyPeuQsj3rkLI965CyPeuQsj3rkLI965CyPeuQsj3rkLI965CyPeuQsj3rkLI965CyPeuQsj3rkLI965CyPe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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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uezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt2L7LXuTxi6Gt33015lr/uWfq5W/9tpR1v5dnpRyG04TtdwvK7hBF3DibqGk3QNZ9U1nKxrOEXXcKqq4VRdV+Wq66pcdV2Vq66rctV1Va66rspV11W56roq16uvym/fcXUbT1U1Hr8sysbjlI3HKxtPUDaew2uzv9mer9O8d6kxnlv68HiR8pr/cfeC24ekKz5kveJDcpcPCevjQ9bw9CEHv8grYdsYKCzP+z4tx9upLvuea0t4/Pa+5K/xF+XjTzv/NYXwffx17PEfL/MPNH43+Pj94OMPg48/Dj7+NPj418HHr/3+2xr/4PdfN/j91w9+//WD33/94PdfP/j91w9+//WD33/94PdfP/j91w9+//WD33/D4PffMPj9Nwx+/w2D33/D4PffMPj9Nwx+/w2D33/D4PffMPj9Nw5+/42D33/j4PffOPj9Nw5+/42D33/j4PffOPj9Nw5+/42D33/T4PffNPj9Nw1+/02D33/T4PffNPj9Nw1+/02D33/T4PffNPj9dx38/rsOfv9dB7//roPff9fB77/r4PffdfD77zr4/Xcd/P67Dn7/zYPff/Pg9988+P03D37/zYPff/Pg9988+P03D37/zYPff/Pg998y+P23DH7/LYPff8vg998y+P23DH7/LYPff8vg998y+P23DH7/rYPff+vg9986+P23Dn7/rYPff+vg9986+P23Dn7/rYPff+vY99+wjH3/DcvY99+wjH3/DcvY99+wjH3/DcvY99+wjH3/Der3v2qNf+z7bxh8/6sw+P5XYfD9r8Lg+1+Fwfe/CoPvfxUG3/8qDL7/VRh8/6sw+P5XYfD9r8Lg+1+Fwfe/CoPvfxUG3/8qDL7/VRh8/6sw+P5XYfD9r8Lg+1+Fwfe/CoPvfxUG3/8qDL7/VRh8/6sw+P5XYfD9r8Lg+1+Fwfe/CoPvfxUG3/8qDL7/VRh8/6sw+P5XYfD9r8Lg+1+Fwfe/CoPvfxUG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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "pub_call_public_fn",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABrKAIAAQSARScCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABmScCAgABKQIAAwCKSHDsJwIFBAInAgcEAwA4BQcGLQgBBAAQAQYBJwMEBAEAKAQCBi0OBQYAKAYCBi0OBQYnAgYEAwA4BAYFLQwFBi0OAwYAKAYCBi0OAgYnAgIEAgAoBAIGLQ0GBScCBwQCADgGBwM5A4iAQ4BDAAEAAwAFIAIAASECAAInAgMEAC0IAQUAKAUCCC0NCAcnAgkEAgA4CAkGIjwAAwACAAYtDAIHJwIJBAMAOAcJCAAQAQgBJwMFBAEAKAUCCS0OBwkAKAkCCS0OBwktDAcEBigEAgQkAgABAAABgiMAAAFZLQ0FAQAoAQIBLQ4BBQAoBQIGLQ0GAicCBwQCADgGBwE8DQECIwAAAYIKOAQDASQCAAEAAAGYJwICBAA8CQECJigAgAQEeAANAAAAgASAAyQAgAMAAAHBKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1drNjoIwEAfwd+mZQ9uZfvkqm41BRUNC0CBusjG8+xYjyIoJF5SZiwFTp7/8Y1om9Cp22eZyWOfl/ngWq6+rKI7btM6PZby7NonYVHlR5If18Gsh2w+l9O0H51NatvfnOq1qsdIIJhFZuWsvvYol9nmRiZWRTTIaHGsodx8dr9E8husXw0Giuo8GaWw/2MrmO4kgRwykLTEQKGogagkhtYTQEAMZSQ1ELSFLLSGL1ECBGMgBNZAnBvLUEvLUdvtAbesIxDZXLRdYGEM3GrT7B3pRWyonu9pSA478hrdfMc9fIXN/4O3XzPOHz28ZYH3nB6+n/A6g9zsz8i/QnCB0iQKim/J7aXu/Bznyf379RKUefj/lD8r0/mD8s3+B1mdePzL3B95+C8z9nrffMc/fM18/A/P1M/DOHyTv/EEyz18xz3+B/mteP+/nB9C896/YwfH2k+pfbiBKf+gWRKrDuIE+/8hqNHYgM9kyKwi+r40anv0LtAzz+h1vv9PM/czz93O8wwCPjzmkHvrbOWZ5cTM1R3j7HCjxzXM08e4nrfJ0U2T380H7S7kdHBeqf0/Z08mhU3XcZrtLlbVniAbHh9pnYYeJC7FsLP0H",
      "brillig_names": [
        "pub_call_public_fn"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABrKAIAAQSARScCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAAECikCAAIAEI76Hgo4AQIDJwICBAEkAgADAAAAkCMAAAI4LQgBAycCBAQCABABBAEnAwMEAQAoAwIEHzwAAgACAAQAOAMCBS0NBQQpAgADAIpIcOwnAgUAAScCBwQCJwIJBAMAOAcJCC0IAQYAEAEIAScDBgQBACgGAggtDgcIACgIAggtDgcIJwIIBAMAOAYIBy0MBwgtDgMIACgIAggtDgUIJwIDBAIAKAYCCC0NCAcnAgkEAgA4CAkFOQOIgEOAQwAEAAUAByACAAMhAgAEJwIFBAAtCAEHACgHAgotDQoJJwILBAIAOAoLCCI8AAUABAAILQwECScCCwQDADgJCwoAEAEKAScDBwQBACgHAgstDgkLACgLAgstDgkLLQwJBgYoBgIGJAIAAwAAAcsjAAABoi0NBwMAKAMCAy0OAwcAKAcCCC0NCAQnAgkEAgA4CAkDPA0DBCMAAAHLCjgGBQMkAgADAAAB4ScCBAQAPAkBBCcCBAQAJwIHBAMAOAQHBi0IAQMAEAEGAScDAwQBACgDAgYtDgQGACgGAgYtDgQGJwIGBAMAOAMGBAAoAwIHLQ0HBicCCAQCADgHCAQ7DQAEAAYjAAACOCcCAwJVJwIEAm4nAgUCaycCBgJvJwIHAncnAggCICcCCQJzJwIKAmUnAgsCbCcCDAJjJwINAnQnAg4CcicCDwJ7JwIQAn0tCAERJwISBBwAEAESAScDEQQBACgRAhItDBITLQ4DEwAoEwITLQ4EEwAoEwITLQ4FEwAoEwITLQ4EEwAoEwITLQ4GEwAoEwITLQ4HEwAoEwITLQ4EEwAoEwITLQ4IEwAoEwITLQ4JEwAoEwITLQ4KEwAoEwITLQ4LEwAoEwITLQ4KEwAoEwITLQ4MEwAoEwITLQ4NEwAoEwITLQ4GEwAoEwITLQ4OEwAoEwITLQ4IEwAoEwITLQ4PEwAoEwITLQ4JEwAoEwITLQ4KEwAoEwITLQ4LEwAoEwITLQ4KEwAoEwITLQ4MEwAoEwITLQ4NEwAoEwITLQ4GEwAoEwITLQ4OEwAoEwITLQ4QEycCAwEAJwIEAQEKOAMEBSQCAAUAAAQJJwIGBB4tCAEHJwIIBB4AEAEIAS0MBwgqAwAIBSdGSLL1QRe9ACgIAggAKBECCScCCgQbLgQACYADLgQACIAELgQACoAFJQAABDMnAgkEGwA4CAkILQ4CCAAoCAIILQ4BCAAoCAIIPA0HBiYoAIAEBHgADQAAAIAEgAMkAIADAAAEMioBAAEF96Hzr6Wt1Mo8AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAEeC4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAAERyY=",
      "debug_symbols": "5VzRTuMwEPyXPPfBa6+9a37ldEIFCqpUFVTgpBPi3y8pTVpooLqRHdnKC2qRZ2cmu93YTuS35m518/pwvd7ePz43V7/ems3j7fJl/bhtv729L5qb3XqzWT9cn/67Md0fIrsHPD8tt93355fl7qW5cqRx0ay2d+1HR9KGuF9vVs2V6vvvRUOWABDzGIjY8AFELP4UtDgfbLz3/WjjYxiGB/PBofk5vJuAYwIfYQIfYQIfEkY5ou+LkaLIzxxK/Vh1PAx1nkfGBjKHscGFT2M7MUolifFjYmwgPYBsEP5ZjGXXX3zLSsNgb8ZS1TYG6X2S5WNmvR0Z7gxT3y+MP8tr5KrVx4rVW1Pztbem6mtPVV970prVW1e1+qqvvav62jupWT3bqtWHmtV7qlp91dc+mKrVc9Xqq56lSel3q9iPdlY+qR9bYpOYYYltT1advdnSJxYpzeqcMqulT1tSmo2lz3KSmp1RZh0Vfh93QYedcbWXzIpzg1nx52a5bLPs+lw5ZrlkVk0YzKozZ2YLv/Uw0dGsXjIb6biVHb1+NVv69kNas4U3qKRmXeG3nrRmC18TJjXLhS/f05qdU2b9nG49YU63njCnzJa+U5HW7JwyW/pORVqzc5oulr5TkdbsjCYVbArfqUhqtt7Fe6feVvsj3Kuvtl926l3hqypv+zcYnb+4x0Uu6hCbrTszW3gDTGqWC2+Aac0W/gZmUrN+Tpn1kz+9dspHQcaemu0ETf8ywAVBYksTJIUJGn9ZvH0m2z8RaT/qqaA9KACgiDBFgMl/M7+9APIAiBAmgpgiALKMgBQAffPi5AXQN0xWj6D484+B2kexNNS34a/vyHh2E3BIfg5vJ+CYwEf435x3IHEICGFShEkRpogwRYApGIeAECZCmAhhsgiTRZgcwuQQJrYISACQR5g8whQQphAAkBgE5BFQBEDKCAgpI6SxhAgkV4xFQEByhQgBAckVaxAQIyCgjATpRoJ0I0G6kSDdSDySXI+UUUCSG5AyCkhyBSkjZJojyDRHFEluRMooAslVQwgISK6SQUCMgIAyUmRupMjcSJ1FQEAZKSPJZaSMPJJcj5SRR5IbkDJCFl2KLLpUkOQqUkaKJDciZRSB5EZjENBoch3H4UwTf3LEwugCXOxh6MkRD+w+osec0Smrdsqqffw5Zaro410yWfSQM/p4300WPav28U6eKvr4y4rJomvO6JJVu2TVrln7TMxaMzFnvZMxlDd8XvWUV/34bkCy8NbkDc95w+e7vb633/4sd+vlzWZ1OAru/nV7e3Iy3Mvfp9WXQ+Kedo+3q7vX3ao7Lu54UlzXtqzRhSXdy95/tQtrpKVpqf4B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TestNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TestNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Test"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "example_constant",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "example_struct_in_shared_mutable",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "example_set",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "example_struct",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "example_struct_in_public_immutable",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "example_struct_in_map",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "another_example_struct",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ImportTest::main_contract_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ImportTest::main_contract_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ImportTest::call_no_args_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ImportTest::call_no_args_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ImportTest::pub_call_public_fn_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ImportTest::pub_call_public_fn_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ImportTest::call_public_fn_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ImportTest::call_public_fn_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "128": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "131": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "134": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "144": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "151": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "183": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "184": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "186": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "199": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "216": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "261": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "278": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "279": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "293": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "296": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "305": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "351": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "354": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "367": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/test/test_contract/src/test_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    macros::notes::custom_note,\n    note::note_interface::NoteHash,\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_HASH, hash::poseidon2_hash_with_separator,\n        traits::Packable, utils::arrays::array_concat,\n    },\n};\n\n/// A note used only for testing purposes.\n#[custom_note]\n#[derive(Eq)]\npub struct TestNote {\n    value: Field,\n}\n\nimpl NoteHash for TestNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // The note is inserted into the state in the Test contract so we provide a real compute_note_hash\n        // implementation.\n        let inputs = array_concat(self.pack(), [storage_slot]);\n        poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__NOTE_HASH)\n    }\n\n    fn compute_nullifier(\n        _self: Self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        // This note's nullifier is never used for any meaningful purpose so we don't care about having a real\n        // implementation here.\n        0\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        _self: Self,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        // This note's nullifier is never used for any meaningful purpose so we don't care about having a real\n        // implementation here.\n        0\n    }\n}\n\nimpl TestNote {\n    pub fn new(value: Field) -> Self {\n        TestNote { value }\n    }\n\n    pub fn get_value(self) -> Field {\n        self.value\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/test/import_test_contract/src/main.nr",
      "source": "// Contract that uses the autogenerated interface of the Test contract for calling its functions.\n// Used for testing calling into other contracts via autogenerated interfaces.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract ImportTest {\n    use dep::aztec::prelude::AztecAddress;\n\n    use dep::test::Test::{self, DeepStruct, DummyNote};\n\n    use dep::aztec::macros::functions::{private, public};\n\n    // Calls the test_code_gen on the Test contract at the target address\n    // Used for testing calling a function with arguments of multiple types\n    // See yarn-project/simulator/src/client/private_execution.ts\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn main_contract(target: AztecAddress) -> Field {\n        Test::at(target)\n            .test_code_gen(\n                1,\n                true,\n                1 as u32,\n                [1, 2],\n                DummyNote { amount: 1, secret_hash: 2 },\n                DeepStruct {\n                    a_field: 1,\n                    a_bool: true,\n                    a_note: DummyNote { amount: 1, secret_hash: 2 },\n                    many_notes: [\n                        DummyNote { amount: 1, secret_hash: 2 },\n                        DummyNote { amount: 1, secret_hash: 2 },\n                        DummyNote { amount: 1, secret_hash: 2 },\n                    ],\n                },\n            )\n            .call(&mut context)\n    }\n\n    // Calls the get_this_address on the Test contract at the target address\n    // Used for testing calling a function with no arguments\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn call_no_args(target: AztecAddress) -> AztecAddress {\n        Test::at(target).get_this_address().call(&mut context)\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).enqueue(&mut context);\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function from another public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[public]\n    fn pub_call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).call(&mut context);\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "83": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "88": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    }
  }
}
