{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "FPC",
  "functions": [
    {
      "name": "_complete_refund",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6131214474596857170": {
            "error_kind": "string",
            "string": "Function _complete_refund can only be called internally"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12569728078551279707": {
            "error_kind": "string",
            "string": "max fee not enough to cover tx fee"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgQEAycCBQQAHxgABQAEgEUdAIBHgEcGLgiARQABLgiARgACLgiARwADJQAAAFglAAAAhSgCAAEEgEgnAgIEADsNAAEAAiwAgEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAoAIBEBAADJiUAAAJgHgIABAAeAgAFADM4AAQABQAGJwIEAQEkAgAGAAAAriUAAAKJHgIABAEeAgAFAAo4BAUGJAIABgAAAMolAAACmx4CAAQCHAwEBQArAgAGAP////////////////////8OOAUGByQCAAcAAAD7JQAAAq0cDAQFBgw4AwUEJwIGAQAKOAQGByQCAAcAAAEcJQAAAr8COAMFBA44BQMGJAIABgAAATMlAAAC0RwMBAMAKQIABACa9PfkJwIGBAMnAggEAwA4BggHLQgBBQAQAQcBJwMFBAEAKAUCBy0OBgcAKAcCBy0OBgcnAgcEAwA4BQcGLQwGBy0OBAcAKAcCBy0OAwcAKAcCBy0OAgcAKAUCBC0NBAMnAgYEAgA4BAYCOQOIgEOAQwABAAIAAyACAAEhAgACJwIDBAAtCAEFACgFAggtDQgHJwIJBAIAOAgJBiI8AAMAAgAGLQwCBycCCQQDADgHCQgAEAEIAScDBQQBACgFAgktDgcJACgJAgktDgcJLQwHBAYoBAIEJAIAAQAAAkkjAAACIC0NBQEAKAECAS0OAQUAKAUCBi0NBgInAgcEAgA4BgcBPA0BAiMAAAJJCjgEAwEkAgABAAACXycCAgQAPAkBAiYoAIAEBHgADQAAAIAEgAMkAIADAAACiCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFVRZzFIAUNVI8AQECJioBAAEFWgLkG7UeqZ88AQECJioBAAEFrnClFxVNaFs8AQECJioBAAEFKIaSsEfc/UM8AQECJg==",
      "debug_symbols": "1ZrdbuIwEIXfJddczHg89kxfZbWqaJtWSAgqCiutEO++ThaHFLzrFZuCfYMSNJPz5cQZ/8T75qV92r09Llav64/m4du+Wa6f59vFehXO9odZ87RZLJeLt8fx3w10P0jSJ3y8z1fd+cd2vtk2D0jG8qxpVy/dMQmEi7wulm04A3eYXcaDMTEcrBlFUyLaKvhjtFV0Q7THRLBYK8dgsc6Og7/PGrQ0Db9qDEfUW/JP5D/L4L/k/Ef2kR8d0d/5lckegzXknfOzm5ofzWf+TsXhTVT0FireJlVQlWKaAcSMCoPAMTwcSqYNMsY7ECY4f4Y+fd+Bwp+IyGeIpnwr5F88Iv1E1OfpdXnqr8ozYFJ5zOjis+FRFqecYDFDsFjKPUiJQOLg/GU0kLwNtioDzqg4J3EcDA3lFGhS3D6SsI6MkR4ETSEgRKWASCEg1hUCwvjfIAgwVFoao/TXT9+odwOTH9Vy/v0GpTuaXNI1Sv4apXSlziSli6kDiEM2BygXSXpFkl6hROkamkvy6SSjQ5JQpvEIxIENykghjGV7CTQ5CUSfkUBz6kIxDCOGcJcalxFYPEYTsDur7mSwNCBXGBCV5hCV5pCF0oC4MCAuzSEuziEtDMjZ0oCkMCBPpQGV5pCU1ttLaV2Hlta5amGF0UJhXYeFOxRGjdFkfGYRCMMC0zCBA0P2gl/r5keqnF/q5jeV+3+H6UMYu0R+Gn1I+AO/p2F9FDxf8N9htmEpOkrW+hy/gBv45WJh3Nrb10+LeOKXHL8O6/rhmOWCX+vmZ6qcX+rmd6Zyfl83v6/cf6m8fkrl9VMr91/r9p+hbv8ZKvcf6x4/MNY9fmBTd//Fd/jANSl/UfOXHqikBt0BFTXD6IFuP2RlE7+DE2enzEh62t0WFljO+e8wZZiW39XN77Fy/sr9lyk+SpDYkwaYMX+noXADDflyDQf0xRqHcPZjvlnMn5btcSv86271PNoZv/353p5tkn/frJ/bl92m7bbLj3bKd6ZjWC9ExACP3XsWGtoMDQWdoPUL",
      "brillig_names": [
        "_complete_refund"
      ]
    },
    {
      "name": "_pay_refund",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "refund_recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "656596039621769501": {
            "error_kind": "string",
            "string": "Function _pay_refund can only be called internally"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15548924666521662104": {
            "error_kind": "string",
            "string": "Max fee paid to the paymaster does not cover actual fee"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1VzbTuNIEP2XPOehrt3V8yur1YiBMEJCgListEL8+zohtkNwcLbJydgvKEZ1fM6pble37Xa/Lq5Wv15+/7y5u75/Wvz463Vxe3958Xxzf9ccvb4tF78eb25vb37/3P33gtZ/2GUDeHq4uFsfPz1fPD4vfrCK+XKxurta/9ag5iTXN7er5ojS2/JzPIm04WSyE60D0VYob6OtcOqiMw8Eh1lsg8OS7Qb/vWz059PoL6UNZy5n1J9OlH+PLv8xlv8maa1+Tqpf6y+utg0uDW5ff6ZT62f5qH/DEudgCR1k4VK0hQkxj7A4BW3Dm58x0jucWwfhSvvZjWHfjYrcK9I8ouiU/bUckyMtHxRtcFGFE0p1OOYhXJh06W58digfyoSHpLYhw3SsIaMVFIn2LxPhNCyna5gw56/lJOo6Sh8oQ7pzq8TLTmJiI0R4IkJMpiIkT0SI+0SEJPq2ECbqKq3uStmc/4DRVLrzF9o9/xqUqQZUwxQ1TMOVegQ0XEwjSQdKVj6B4v+DlCqY9EANHQENV7rM3aiSdaTwnnC80gP1LvVXSub8tZwPwRH7hiWhGRTuQeEejOAMjmZwuAfHeyhohmRwhkAzZIUzwD2EwBkymqF8v/JJ4na4krRz/8pM7xQJTWHEeAq8CyY8hcMpBO9CzuCiwCnU8BQBpzDFU+BduOApvl9AkrYT8eT9PV/zaHhDkBhN4GCCjHaQ0Q4C7SDQDgqhCeAOCpbASdEEGUzAjCYAFzvHzzIcP8to3kfgKc7gAj5XcjM8Bd6F4104fK7kSfEUGU6RBU+BdxGMpwCP146ecXgxNEFgCRIJmgDtgNEOGDxnSoJ2IOA5U1JCExiaAN1NTdEE3++mHNSuF+Lg+ETh6I7q6EstoVsho68E9IOGhH7QkALdyAXtAP2gIROhCQxNAH5UkhntQNBtIODrIKugCcCDZjZ0Ix/xAiBGVrxwsnapITe4Ltg2ixnzEWPmdxkymuGI5/+jDCz9ulcW69e4paFlzkrG22gl/7CMaC3oiFH2zIJ8YoJiak0WMTFBRacmqExLUNDEOnXQH8hQaaNV8shyRibO3dJZEt1f0BhHzFmmrT/mrV905vpnnn87/6CkqZ3+qe58XHVAf9buyxTK/ln/+QuiaXtuNctj+oO6aRzFp0+Sws5fP4251x9j+kv3RVXz22Nfv+vM9ce89SeZuf48b/155vkPm7n+mdfPMvP8l3nnv9C8819o5vnnec8fCs97/lBk3uNXOeI9+qT125Tqz0bQlDr0WtCk7jA2gs4/ZXVpFwGoj95yspZ+Xw4T3df/B24ZTqs/zVt/5pnrn3n+4xSPjDSs5yDZ1b/mOMmbjK85mIjPQZLwJDy8UIrNOph53+yS5R3mXAdLVbDhfTzGYVYHK1Ww4U+tuV/2y0n6h6jvL5MbVK5BDX8SPYYqNVwy/C3r1y/JG1SpQWmNLxnekmEU5TUor+LyKq5UxXWg14+hogaVq9preBgbQw2/xB9FVfXeQlWoVIE6sKPNKCpqUGw1KKEqVB1Xla9DdeMw6q05+ufi8ebi1+1qu7nk9cvd5c5ek8//Pqz2tp18eLy/XF29PK7WG1D2e0+ujYrLUik3atYdrmmepSbZDOPNIUcsueimCK9jiZZC0mhodPwH",
      "brillig_names": [
        "_pay_refund"
      ]
    },
    {
      "name": "pull_funds",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "192384619482506110": {
            "error_kind": "string",
            "string": "Only admin can pull funds"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "pull_funds"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ef9buPe/hX//W7S4n5z+MK4s8v63WN//FvHdN96ypPe/RX7/W5S3v4Vb3v8W7v1v4d//FuH9byHvf4vDol3XLTVd81Onl/PXSeXCSceLibWTjktlSfus/vi7/F1HUl4scy2p7C3sclvs/nZauHaaXDttvXba8cVyySE8Tnt6CMd2Wrp2Wr52Wrl0WnihW3k8jmQp0X077QXJkrfHkji3LN9IvniKQvW0dO20cmluL7bSrp724oNTSnga5PrtNH/ttHDtNLl22nrttHjttHTttOMPzu3Q8jjNP1fJP/5+Tb3Yf67tmxyv4bV+E/fX3+R8LbK82ASu6VuE97+F/O5b3E9br50Wr5127RL5Yn2uelq5dFpcrp3mrp3mr50Wrp0m1067diON126kL5Y60rpfWFN6/pnqUXvr07J/wyh5/+0t3Pvfwr//LcL730Le/xbr+98ivv8t0vvfIr//Lcrb3yK//9Od3//pzu//dOf3f7rz+z/d+f2f7vz+T3d+/6c7v//Tnd//6S6//em+n+auneavnRaunSbXTluvnRavnZaunZavnVYunLYuy3LtNHftNH/ttHDtNLl22nrttHjttHTttHzttGtV4q5VibtWJe5albhrVeKuVYm7ViXuWpW4a1XirlWJu1Yl/lqV+GtV4q9Vib9WJf5alfhrVeKvVYm/ViX+WpX4a1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViVyrUrkWpXItSqRa1Ui16pErlWJXKsSuVYlcq1K5FqVrNeqZL1WJeu1KlmvVcl6rUrWa1WyXquS9VqVrNeqZL1WJfFalcRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVxGtVkq5VSbpWJelalaRrVZKuVUm6ViXpWpWka1WSrlVJulYl+VqV5GtVkq9VSb5WJflaleRrVZKvVUm+ViX5WpXka1VSrlVJuVYl5VqVlGtVUq5VSblWJeValZRrVVKuVcm17NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17dtezVXcte3bXs1V3LXt217NVdy17d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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "192384619482506110": {
            "error_kind": "string",
            "string": "Only admin can pull funds"
          },
          "656596039621769501": {
            "error_kind": "string",
            "string": "Function _pay_refund can only be called internally"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6131214474596857170": {
            "error_kind": "string",
            "string": "Function _complete_refund can only be called internally"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12569728078551279707": {
            "error_kind": "string",
            "string": "max fee not enough to cover tx fee"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15548924666521662104": {
            "error_kind": "string",
            "string": "Max fee paid to the paymaster does not cover actual fee"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BSMAABuOLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAHHUjAAAc5SQAgA0AAByCIwAAHJsuAIADgAUBAIAFAAKADi4CgAuADiMAABzgKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAABzgIwAAHTkoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAHTkoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAAHZkuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAAHWguAIAMgAYmKgEAAQUJHLKehpV5HTwBAQImKgEAAQXXyOCaO1UymDwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAHhMjAAAegyQAgA0AAB4gIwAAHjkuAIADgAUBAIAFAAKADi4CgAuADiMAAB5+KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAB5+IwAAHtcoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAHtcoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAB87AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAB87LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAB8KAQCADIAIgAYmKgEAAQUCq3zKyIDjfjwBAQImAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAB+bLgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAB9qJioBAAEFxWvEWg4QAAI8AQECJioBAAEFRafKcRlB5BU8AQECJi4BgAOABgsAgAYAAoAHJACABwAAH9sjAAAf5i4AgAOABSMAACBNLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAIDkuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAIAgoAYAFBAABAwCABgACgAYjAAAgTSYlAAAXBC4IgEYABSMAACBeDSgABYBEAAYkAgAGAAAgziMAACBzLQ0BBS0NAgYtDQMHLQ0ECC0NBgkAKAkCCS0OCQYnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWASAAGJAIABwAAIOwjAAAhWC0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAAH8AuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAhWC0MBgUjAAAgXioBAAEFvh4//z6k9vo8AQECJioBAAEFWgLkG7UeqZ88AQECJg==",
      "debug_symbols": "7V3bruQ2rv2Xfs6D7qTmVwYHQZLJDBpoJIMkc4CDQf79qGpvy95tuZRi0zLL5kuwK22ai4u6UJQs/vfTP37+8T//+v7zL//89fdPf/v7fz99+fWnH/74/Osv5dd///zu04+/ff7y5fO/vl/+70/m9h+b8C7w+79/+OX2+/c/fvjtj09/8xbzd59+/uUf5U9vobzin5+//Pzpbzn/+T/ffbIABCF0LSGHkN6Fyp+4EgKCUKZoygRNzliKUCIIWYomS9HkDEUoUoQyQcgHglBqtggbTHgXsgHiUui79cMmxjg9bWJO9XGwbzrS/jrADtAxwA4cYAcOsCM3G6ON1kxSEc3XjTHj80LeeIoQEITaI01PKBGEXLtX5jhNI2VQhpUQEIS8pQhFilAmCAWKpmgoQiRNFJuSpwghQQgozWhjlHsshBTKkaIpUxpsJmgKxlCE2pNwsjhNwglCZ2wtk1kdHMpgPQ/F1qTW82X4nR5PNi2e9o2nQzbw/nTI9sO4vX4YQ5hwY0jhq0E+mDze2OQr/Qldx1jnYHq5K4Pq/HQ0zXenOgOCDR+evplr8VLmOn8tc4/2bu6YC8m/Pwww99vg7uh9emX0wb40+jgePThfG/NiFmqj98ZMM4Q3KXc6Slm7TzOEM4sV49RRYriWuflS5qaDvYvhW7piO+J9GfTwyujxgEEcQ30cYy/0jR4n+DEY9zj07WU4AsZLmZvNtcy9lHejuZR3o7mWd62Xbm4Is7kRv8bvxM8sHfzim1uwYcafv8bvxY8OHfzhxfHja+MP8sefx/hfnP/oXhz/AcktTDN+tD38MdfxP9n8eLqGsm0wJdVNsD0gvck9GSVnm5yo5GySA9pyHpCjLWebHNSW84AcPBM5aKKdyLGmR86jp2/cZKfcbHIDys0GN8nY63LjMNZt7rw4PXzbGFq/2tZdbnRmzkS43NoMCliz/wH9nGbyyb3RnpX2A2g/JF+ntDsdZA6h/VSR9p60OzvTHm2HdshhClMhZ9d52kc3+WhxKNDZ5hECmycTnTO583R00zmbkkf+8Ozd+TrDXNf5h+Tl1flCnK89/7rOD9rzL+x87fnXdX7Ute2FnX/hFOflnZ8unPtX55/qCIc6/ynngyZWL+x8Te+e2vl5OjuRbFw5P+uwf1nngznVKSF1/nPO12H/us632vMv7Hzt+dd1vtOef2HnB3X+dZ1/4WPvl3e+1129Cztfd/Wu6/ygu3oXdr6md6/r/Ki7ehd2viZ5zuP8u0P1UOa5HHrERZ7q0D0dqgmWczkUdOl0ModqIuRcDkVd4pzMobpsOZdDs+43n8yhmlI8lUNRT4GezaE6h57LoVaj3BdzqKv1pJ1fVAeoDtU59FwO1ZvJzuZQnUNP5lDdPjuXQ/VE49kcqsn5czk0aFB0ModqUHQuh0ZN/Z3ModpDT+ZQXbacy6F66u9sDtVTf+dyqJ76O5tDdbflXA49V3U7dShiUIeey6EaFJ3LoVl3W07mUO2hp3JoNrpsOZlDdT/0XA7VY5xnc6jutpzMobrbci6HOl22nMyhGhSdy6Feg6KTOVR3W87lUD3GeTaH6rLlxRwKNk2gYV3BK+sxzrM5NKhDz+VQ3W05l0O1Vu7ZHKrLlnM5FDQoOplDddlyLofqMc6zOTSoQ8/l0COWLdbNDg0dh3oTJyjeoOk8DdX7RclsrMt3Yw854vicsRWKt6H39AlL1ecM6iLZLrLmkHOI6qPnfKT9SLyPrPYj+T7SfiTeR4dczag+es5HUX0k3UfeqI/E+yioj8T7KKuPpPsoaCpIgI8e1TctPtLYW7yPoq5h5ftI+5F4HyXtR/J9pP1IvI9Ac0HyfaS5IPE+Qs0FyfdRUB+J95HmgsT7SI8FvYCP5J9Tu7qPrJ4LGu6jN96T8n4E71bXmsfwruvHY3jXWPYQ3l1Q3g/hXWPOQ3j3Gkcew7vubxzCu55FOYh3be+H8K5nRg7iXeOZXXh/fBmbtUnH92N41/Z+CO+g4/sxvGse+BDe9azEQbwH5f0Q3nVePYT3rPPqMbxrnuAI3p2eJziId40jD+FdzxMcxLueJziGdz1PcAjvTvORx/CuceQhvHudV4/hXefVQ3gPmo88hndt78fwrnHkIbwfUsNIeXd6juMY3vWOjoN413zkIbyDxpHH8K7z6jG867x6CO+o+chjeNf2fgjveo5jH94flzoqvGv+/Qjei1XK+yG8az7yGN41H3kI71bjyGN413n1EN6dxpHH8K7t/RDe9RzHQbwfEUfWq+Zs9v4Dk3dMh5xx6GFCeZjiATFRzlNLdcZ2CzYX2t6fjj7NFjhw7xaMZ9UZXys9m4A9CwxOT5c/56fbJaejncjBZWGa8vDd2gO+FXfzqOVMNB1rc5wGi5zt2ltHfHOdc5jx23UfAC8PE1qBmBj2WW2Ymoe1MOuIrb7gyog1vTnHRTeDVsMDrJ0ScAG/2c0g1fJPkFKnTxbQtWz47XaStOqVOSozTWYCR27vOWby9LD/MLmAfweUhAGyQRqgPBZQyQ9M4453xnQaMzqcQtfSrENnNjVYZ9My9/QaczI1mLcp+FVjdkmZaTPDcSXfU8y4Ct+XPHaHmTKDTTxaExfrnWYEs+NKirFCYfBJKR9MebBK+WjKtZWPpjxqKx9Oubby0ZQno5SPpjwo5aMpz0r5YMo5solK+XOUo1I+mHLUBf/g8lnR6MAynHJQygdTbnVgGU65tvLRlDtt5cMp11Y+mnKvmcThlEelfDDlQTOJwykPSvloyjWTOJryqAv+4ZRrJnE05UmXQt9I+RuNuoXMQSPokoWFRl2GsNCoQRcHjRyFoJTGiBoccdCYNeBhoVHzuQw0Jt1V5qFRWyMHjbr7y0OjztQMF/Elp2MjC406NnLQqLupPDRqaoKFRk1NcNAYdIphoVGnGA4ao4bfLDRqa+SgMWnAw0Kj7gxy0Ah6zIuFxqA0ctCoGR4OGvUzNh4adYrhoDHrFMNCo2Z4GGgEo62RhcagNH77JdNgNN/IQaPVfCMLjZrh4aDRaYaHhUYNeFho1CmGg0YflEYOGrU1ctCoG6w8NA4PePy0rPIu9WhEb6en0bv5QFzzNmvvo6keivkD53dbx1+AeqCt6Tq2pgv5NV3Ir3Ahv47/sO5AW/N1bB3/idqBtuJ1bM3+Mraike3XZ8qjlPDatiLt93onyJEqcHmuneTtonZSuzxXhOndydjFsy1bQzbTnQshL4L/dimYUCvsYUhhZSvHev5JW1MtXJa869kKrq5zyjLlsa05+Vqe7qvqVm+2tptwaTuTrQi514SNs7UNm5BWSjaWpMxKYICSjfOizEpGWNKuS+ht3dzz3sJSyV0KgCK1cegEIc0G4VoqUaSyJUjl9khug6nJigCxQ7mJMc6pjbyiPLe/9eNWAgOUuBGWuBGW+BGWtC/Ms3GuVhnRrNpk+863rlSmSLVv3upKAUWqff9RV6rdQ3OcRh6bYTXy5HZtgq4UUKTaFUy7UpEilUm6cnpeyhljSVKRJJWflGpEd4sIf47SfAmX7xra1SdZNeDeGjaGX04NaW8N3u6uYXcbNsZ1Tg0MrbWujNDDBw2NqayESbXuZQn25qXIbQF5RxSdOES7+znt3lZT3F3D7iPr03Pt8xp2H1lxdxsQ9taQ7Y499E1D2lmDNWZ3DWF3DXlvDXZ3GzhimccaGApDAMyJTmuX6bP0riPtr4Phsoq+DthfRxhgRxjgj2gG6AgDdOT9daQBdiSGvRLv6nEg6/0iSVC1cNQi/AtaYIQWtEO0xCFa8ggtOQzRMsIWx3JN4WITquQl7ActjQ03g1MKrvz5Ya+oMa1HO1mAy4KJbznPgp+hvxfMMONfRA9t/IybgM5Zdv59XnuZ5d66rhaXRmhhiIBirKcyY1zoaO6GR3T14bLF2GuuOMHHZGDlbv/tFMWQsYIPbgn+roIhsuqqiPuryLurYAiruir2tyL5/VV8exwSIU39IsJiHppUgNtdBZr9VeDuKhjOPSVjphg6lV2EtQrcW4U3u1vhrd1fRWJQUctBp5IVfDwTWZy3i3GBxxr3BsjZsYCSr0enom/ASaLgeFnseFnsMFTbY4UTRcGJstiJwtjJouAw5JlY4aAoOOBlwZHFDsPFVaxwZE0SWdYwmGUNg3nwMFjenOc3L9JWbx+XumCCNEDSGLLSGLIoDJDz0gBJY8hLY4hh/5YXUHDSACVhgKKVBkgaQ8lIAxQkBR8hiVqDBVmrjACy2EFZ7KAsdrIsdrKoFWo0otiJBkTBsaKSvNEOXqEC1u1ztL4ByAVpgLIwQKPD+T4gEAZodDjfBySNodHhfB8Q7zhkF19ft7cqTU71wgmTcX538u+IsjREzAE9ByIcjMi6+SScLYvAJaL1497E6Wm/bKIbN3/MLXRxw557+yIzMq8X+E0Ntpoav/70usCX7qnH8DG8NPxsXxt+emX4RfVrw3/prstR2Xtf+LnOEQ46h6WtsVBvZzDOh7W1cCVrnfRxjdda6cMgq7X+Ur4NwgMMnyYg3qPrWQu+fqNgIDasFT6lBF8vHAy9m92sQTOvUnD9CQ5Hcdt9rbV2thZ71mY7X7KUI66tFT5K8VqbhI9SzNbGK1kL5lLWXsq3KDxO5rU2X2oGylfyLUjPLjBbeynfSs9dMFt7pcgRpOcumK29UnQBLl/J2vCyY/IdfnzZjvgG/2VHzTv8JHyRFd30SbGP3VSQ9fWiAGuD82trhQ+DzNYKHwZ5rYVwKWsv5VscnrD2GGZEi/Lu70dfYPyeeAcRmiAOUZaGaOM2q4dVMYoUUKScI0ltVPtgLHricGNvj1lJHKBk41YIZiUjLGnHkY9LyjhsBzQ9qbx/tY+iJO2vJG8UZWBWMsISO8ISO8KS9hH+x4VNihRSpLwnSQFFqn1xXVcqUaSeLi/wJgUUqWRJUpEklSlSQNKFhiRF00WyK+99zX7OO5cK8Ma43TWkvTVYs7uGuLcGt7sNG+M6p4adr9n3xvvdNcDeGoLdXUPaW0Pc3YYYd9dAGPO9SYEkhRQpcCSpRJFCki4EilQm6aKUffMbJVieSmJ0igJ4y5C66evI++tg+Jq4r2OAHW6APxiuCerq8G6ADthfRxhgB8OVO91yBt5GO0RLHKIlj9CS/BAtMEILwy3if0XLEFs4yrIcV5ij4Gfo78cV5vA2s/O/LmZRtAwomeEdQ/zzV7R8+3iFwdVGtTxNsXdhDu8YLoIsmyV1PROiXYJ/U5F3V8FwWWNXBeyugiGs6qrY3wqGOixdFZFBRaopozJ+rlQwXHzeVYG7q0hpdxXA4O5UN+MxhbxWkXZXgftbwXDZXE8FQ4E2hPowgu/MRJyBh8sc/CRTwfdOdeQyc78/nD2uyOSo1cKLB2XhYfiI4Sk8nYtJbwcShAFy0hhy0hjyVhqgJAxQkMZQkMYQR6TGCyhKA5SFAWK4cY4ZkDSGwEsDNHjqeHi/rOcoV8MKJ4mCk2Wxk0WxE4wodoKRxY61suDIYscZWXCCLDgoCo6X1dG9qCk0SFtZBGkrC47iNMyApDGUhK29QhK29gogjSEQx5CwtVdguBSaGRAKA5SFrU45StWwAopGWOo3ylplRFmrDI5yNaxwsig4zsuCI4sdL4sdL2oNFoMsdoKoNViMsobBKGsYjLI6+uhdix6cwR3d4vw1N1pcAwJZXR1kDYQoq/VkWSOPrC2CJGuLIBlRTTlZWezI2iLgKF7CCkfUnJ68qA2U5GW1HVnRMkc9D044UdQUmpKspjw6PO3U3iyAsjBAowPUPiAQBmj0sZo+IGkMjY6b+4CY53fsnPm3KdSySEWuPhzSO54sCg+YIAwPDsZzVG1bD9YLN/VRhckCX7qnHsN34aXhc38aMBp+emn4wb02/NfuulE6+4w1Mou1cCVrk/Rxjdda6cMgq7VwKd9y72hwW8tZ29YDCp9SOGvbesjCZyDOSkcesvBRitVaNMJHKWZr45WsteZS1l7Kt054nMxrrb/SDIT+Ur6Vnl1gtvZSvpWeu2C29lKRo/TcBbO1l4ouUr6StfiyY/Idfn7ZjvgG/2VHzRv8bIQvsjhrZBZrhQ+DzNYKHwZ5reW4/feFrL2Ub93whPXjKqk+j98T7yEKQRyiLA1R3Khty1iltCjBAUqSG6EEBiiBEZZg0/GPa8D63N45eiwVtirlcRYQLUrCCCV5gBI3whI3whI/wpKwZy3J9bOp1mBNPn149o4mGlFovn0K7NRAKjpwfx0M9Xz6OvL+OmCAHTDAH+gG6Ej762BItfR17G8HR73BbvWmoiUO0ZJHaLF+iBYYocXZIVrSCC1+iC3+21tyLhHn+8PZLL7daS7Ebl/qThFyWqzaLLRyBdZBjRZcnkN9Z1pPA9bDYYA37Y8yCzAXGYGUepl2G+byWDa6VexlGa6ZVB5vPCblkYNHhv3pkhL3lUewj3lkLC5YwAMv+FVZl2CT210Fw52YXRUMo7er54dLLnVcJaRgkYEfF2pXL08/Bt/FE4ThybLwMFyH+RSezmWPBRDKAuSMMIackcYQw506zIBAGCAnjSEnjSGGhREzoCQMUDDSAEVhgKI0hhjy08yABk8dD6/9CS55WXBAFByQxQ7IYgdlsYOy2MlOFhxR7HhjZcGJsuAMXqKCjdObISzOV1RAFoUBcl4aIBAGaHQ43weUhAEK0hgaHc73ATGPQ4vDNe3jhMHUM2i3Qzzz42/HCYOPXhwilIYoudGIvK8HlYOHD4dAG1tDWI8qecT5dNbzd8QVU0G4qcFXU1ffEd3kXxs+vjR8jC8NP5vXhp9eGT5HGeBD4UtnP09zRDC9OcIaX0+vWROiX1lr7aWslT6usVrrpA+DvNZeyrdedoBR1kz12IbNtmft4zviQgiyp5SyIVd962L3/r/Hd8QFjnrN+1rrzGxt90a8xzcGhBBlj1Lc1soepbitzVeylqFQyCtZeynfouw4mdvaS81A+VK+FZ5d4LU2miv5NgrPXTBba68UOUbhuQtua68UXUTnr2RteNkx+Q3+y3bEO/zXXW+/wQ+y4fuayiob4L1UUOeuqRClL6B5rU3Ch0Fma4WncHmthUv5FocnrGP9mNfepqjH1pZHFvcAxcX+wvtJmTg+A8BswPhFPbcBUbYBkOqeDcAc5L2V4wzJ+JeGb4U3nx584d23A3/8zvVz8LFePVD+hDV8fGn4Xvjkhak+jdCAL7ztd+AH4SNPD/5rsx9fm/342uwn6eN+B34YDv9xEJnGb9L2EI1fB3YRgTREB6wee4jEcXTA+q6HiGHB5uvtefl+6ewjRJxXIwHDLZbZ18xtsSM8Bv/h4fU9U2CCMDxZFh6GOzSfwtO7vQE4voNlBeSkMeSkMcSxzuMFBMIABWkMBWkMcayXeAElYYCSkQYoCgME0hiCIA3Q4Knj8SUcgF4WHBAFJ8tiJ4tiB40odtDIYsc6WXBkseOsLDhRFpwsCo6X1dG9qCkUpa0sUNrKgqPeOTMgaQwlYWsvTMLWXgjSGAJpDKGwtReisNUpYhYGKAdpgIQxlI2w1G+WtcrIslYZ2SZRcJyRBSeIguNlseOFsSNqDcZRhpsVjqg1WI6yhsEoaxhMsjp6EpVsyWlwR7c4nz5Bi2tAIKurg6yBEGW1nixr5BG1RRCNqC2CAkdSU47GymJH1BZBNE5SzypwJM3p0XhJGygFjqy2IypaLnBkjTtR0hQaTZLVlEeHp4CL6999A9DoQzV9QEEaIBQGaPSxmj4gaQyNjpv7gJjn948nvRvLwBTq3bEpzVfHvn2BFC33Mf5vxhOF4cmD8Vhn6y0U1vU+MPMmTk/7MhzUh58vABKtDcJNDbaaGr8uJ1/gS/fUY/guvjR87k8DRsOHl4Yf/GvDf+2uG6Wzn+sc4aB72byFeteDcT6srcUrWZukj2u81kofBlmthUv5FoUHGD5NQLxH17P2cQGQYq3wKSX46d1lTdm9IPVxAZBos/AZKFg7W4s9ax9fB1usFT5KsVrrjPBRitnadCVrrb2UtZfyrRMeJ/Na6680Azl/Kd9Kzy4wW3sp30rPXTBbe6nIUXrugtnaS0UXYK5kLb7smHyHn1+2I77Bf9lR8wbfG+GLrBJyTPBjNxXUKSRQrBU+DPJaa4UPg8zWCk/h8lrrLuVbNzxh7THMiMyHcid3ROP3xHuIQpSGKBpxiEITEbqKCCE/RmTLBpKtSkxY7Xj7jSpTvEo2ijsxK8EBSmCEJfis49+kMkUqk3Rliq5gAkmKpMuSdFmSLkfS5Ui6PEmXJ+kKJF2BpCuSdEWkSD09HL1JkXQBSReQdG3cHd+TShSpjTvYe1KRIBU3Tjb3pAJJitJ6o/UkKYqXo3MkKaBIeUuSorSoMtCTpEgtijRGRdIYFUljVCSNUTGRvAykFgUkLyOpRSHJy5nUokgRUSRFRFuV8npSlBaVrCNJUVpUcpYkRWlRyRuSVCRJkbxMiqNSIHk5klpUJHk5kVpUInkZSC0KSF5GUosirdoSadWWMsnLmdKiwDiSFKVFgbUkKUqLgnZS0oecay7Qpz8fLuXBvT+6LAjm31+Pu76+HWOxvb5diZDv9XHX18d9XRt3Rp93fX072uN7Pez6etwXPe6Lvj1u871+15aDZtd2j9bs+/p90e87naDbdbxHb/d9/b7ch325Z9isKjs89bsPe9tXfH+4uTXkna/A3aIUoIXW7mUJcybs6M2H72caDxcg08NlY3T58N1Uhl0wMaaa6v62qWfyqkvVVB9XpqYTebVn6oW8mk/UVzHOpvY+kLTJuIo6hdUJDIQTNYJtZm6m5vb3C1gvJcfF96P3srKrZ2NFExfXjtyevStoVyvhVJC+VUGqxy7SoptUBe20PaOC5PZWAN+swM4K0loBuL0V7G1Be1/hKQVx6vAJXENB3llBDrsqSMa4vRXAzgqs3VtBc+LAWmwbPayF2qm4jlB7T6Aj1L61vCcEBKF2a0+5rpIW89b7tVPJtFtwT4igybZTBda4GheYxTTs3mpxpI17sfpizTnW2vrhf3kxrsXaS/auWPuET18sk8TaXwSWsGqOsLBBSWqD9PWei9sp2YYYksTa01NfLJHE2ts/fTGabZkE0rU/hbCxBhJ2eZJ5FgOS2EbH6Yplklj7ArWuWHsjuC9G1LZhW8pVbHEEuIoFIIm1R/6uWDI0sUgTo1HSPiLXF6MxiRv9zVQx7xr9rX3erS8WaWKZIubbx0n6YkASs5YmRnKAdzRtLtLEaA7wNAf4DQeE+oGAj+shyG/M3T2xaGhikSSWLE0skcQg0MRIc7dHRxMjTfk+k7SFjZMYYKeVUBmAzVpso3enVKfFBA1tG1N+T6x9PLUr1r6rtC/WdgBAvYkMsluLtQ9F9MUiTSyTxNoHwPpiQBJLNEoSzQFA0wY0BwDNAUhzANIckGmUZBolmURJbB8csHmeFrNriLVP1XfFns013oXQUYQSQah9KrknFChC+XmhkpmiCCFByBKyWal9zGJbqLGzgzAnNxCWacCSanpTggOUBEKuceN4b0eoPUj3hAhZzY0Tpg83gNLGAdOeUBPew32UBO00Rkeo/b1NT6g5Bj3cw0jQjmZ6QhRN7Ugm1g/bk4GGUCQItRcbPSGKpkTRlEiaMkGoneV4vB8B7V2tnlAiCG3k7jtC+XkhNAQicOMzFFvvi3HWzYsY/1bzI+FGKYauWO6L4Vps49vcrhhNW+xvZoSZSWtaRxFu5cnfn77V4q5Pt48ihDC1cAzp6wNVBVA7OJyPYRWL8khAG5sUJtb7Owz2GLIlnKxrSd8py5Kjn/IMOQKsAG3sYywAWfcR0F1sY0OiI5bbn7LWpfFiWye61rGNGtTHvHAbvr18YyrleXk7Jc/08vZhUa6X444v31jam3mHzy9fX2TAtMN5G+aEWFgmxGASQ5LYxoqtKwYksY2UcFcskcQ2tpdSXeSUPdN5DHobpYtUIEllilQk6doYlB5W0ypSiSKFJLsyEKSscSQpki5L0mVJujZafU8qkqQo/rIbuyA9KaRIBUrrtRu7sB2pjfG3I7WxB9uTihSpjQRpT4rEBpJ0IcmurXHjkRRubPVCqEeLFncvvWcPcWMzNIdYAztcC7U3S3pCkSKUCULOU4QoRLRTGD2h1F3JrI9lldWWpYlFklg0NDGatkTTlmjagKYNaNqQ5jckassksexpYvj8kBPakcq8Es6uJUTonqGd2O5o8hR47T7dEWovzXpCgUBEIAyjG3eU9YTalNfdgQzrZrRxQ1lPiKIJegN2U4jS9pAwCYX2ZllPiDCxRmMpQokgRAkWIiVYiJRgIVKChfh0sPBn+fm/P/z2+Ycfv/z8exG5/et/fvnpj8+//vL+84//+/f0Lz/+9vnLl8//+v7fv/3608//+M9vP3//5defbv/2ybz/5+82YviuxNqxwPH33wm+uyXvyu9w/22w/E6+/L5RWZb7t383tvy+nyYvuUn3XfnPTeDuofs9vzYYU7AWvP8P",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "fee_entrypoint_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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f+frb3H8na+/xfF3vv4Wx698/e18e7ry+JWvv51vT7cmt2wX55AKL+3zPtnnrzKldHCtjct2nLGN9tHZhg8una/rrbh0vp1eOy6d9yFCXO5z7bxnEZ1r5/2N6Fz9RHPtvG8SnWvnPZboXDvvx96a6y1y2y726WCuI/VupbmO1I8V5tr5lomycx2pbyrNdaS+qTTXkfqm0lz9RHMdqW8qzXWkvmld974pHfRNnW8zKTvXofqmwlyH6pu+n2vnW13KznWovqkw16H6psJch+qbCnP1E811qL6pMNeJ+qbOtwf9bq738evthe7j19vf/B5/59uDlsevtw+5j19vb3Eff9/9QliWbSDBBXMwfq98/H2v6+Xx971Wl8ff9/pbHn/f6295/H2vv6Xxr51vD1oef9/rb3n8fa+/5fHrXn/XRff6u3a+PWh5/LrX37Xz7UHL49e9/q6dbw9aHH/n24OWx698/e18e9Dy+JWvv51vD1oev/L1t/NtPMvjV77+dr4tZnn8ytffzjeZLI9f+frb+ZaN5fErX3873wCxPH7l62/nWxWWx698/e18/8Hy+JWvv53vP1gev/L1t/P9B8vjV77+dr7/YHn8ytffzvcfLI9f+frb+f6D5fErX38733+wPH7l62/n+w+Wx698/e18/8Hy+JWvv53vP1gev/L1t/P9B8vjV77+dr7/YHn8ytffzvcfLI9f+frb+f6D5fErX38733+wPH7l62/n+w+Wx698/e18P7/y+JWvv53vpVcev/L1t/M978rjV77+dr43XXn8ytffzveQK49f+frb+V5v5fErX38735OtPH7l62/ne6eVx698/e18j7Py+JWvv53vRVYev/L1t/M9w8rjV77+dr63V3n8ytffzvfgKo9f+frb+V5Z5fErX3873/+qPH7l62/n+1+Vx698/e18/6vy+JWvv8r3v1qV73+1Kt//alW+/9WqfP+rVfn+V0H5/ldB+f5XQfn+V0H5/ldh0b3+BuX7XwXl+18F5ftfBeX7XwXl+18F5ftfBeX7XwXl+18F5ftfhd73v/Jpuzisxh6Mv/P118Wd/+3GwkunxX9cnNzjrHD769zwL9fmtL1wzp+vvXPpfF1vxqXzfqEZl877kGZcOu9vWnHpfd+yZlw678eacem8z2vGpfP+sRkXD5dDLvS7x1zod4+50O8ec6HfPeZCv3vIpfd9AptxmbbfDdu1ZlnsAZhpG94SmGk73hIYD5hjMNP2vCUw0za9JTCddzFryhuY2xOYwkubNS9um+6af12zvfh9tr3v4ffNbO/j73xFKI6/7w/uGON2cYxPPdzxS9sY1o+rbYzu+aXvk+37w1h4sn1/wApPtu+oQHiyfft/4cn2vRzKTrbzHQ2FJ9u3/RaebN99zruTzXabbHrqKvbJ9t0UCU/WzzTZkTooZ5etOXbWxq+THamDKk52pA6qONmROqjiZEfqoG6TXb6bbOd7Ir45WW+2q523y9fJjrTOFic70jpbnOxQ62xpskOtsy6nbSDeLN+/9Jrj9tG95nzwaTbUovwOmbDsn/NhOWhEO9978pqaOSYz1HLv3d7b+NX82V9T5/tlXkPmsGY634nzXTL7ozvnc/o62bFaxMJkx2oRC5P1M012rBbxMdn16an4PtmhWsTSZIfq+kqTHaqRK012qN7MPQaymvj9S5uQtn7eRP/0Y1j/8UWQzjcjfRNN3H/662J2f9a2dr7N6YlkSiaw8w1Ur6mZYzJ+KDL7S7u/PJQ6+KBZ8v6FM+OWgw+aofqmZP2OJhde2i/boL39/Al8gPERSRhvHvbS7RiH6sjaYRyq12uHcagush3GofrTZhg735hYDcahLEE7jEP5h7cwus0++OcZ7mCGsg+SYDr/0ZLsT1B638ZZeLad/6heeLad/1ReeLYz/XQs9r79tPBsO/+xuvBs9f4ssGa2en9EWDNbP9ZsnX/Mdn165vPiavt0dfjCZrDOS5TNYH2aKJvBuro32Hiz+19vnx9DfpAZrAMUJDNYtyhHpveN1RuSGawLFSQzWMcqSGaw7laQjIfMCzLz9sElMvN2wSUy9MCvyNADvyIzWg/8yiUevHbav5EZ3dOPjl68dk7bJG8Ynw5juU3hN8neN9VXRHK0HluG5J3NaF22JJvR+uxvE68Xm6abfSdGZ20uzNakZdu0xyTzzGY9nO3ymO0Snmd7H1G8fkT2MaKvmyHEFxuFtxxR7m1ELzbHbjki092I7PUj8uHxyVL4yrf1+0ec9d5/Hb7TPXyve/ir7uEH3cOPuoefdA8/qx6+Xzofvk2P4X9tyLzRPfzeV93C8Dtfddd163nsGv7sh4jRd75EvzPXwk8Lo+98PV+N2+caC/uipP2E4eSfxvzxPejoO1/7JafaeZ8gOdXOewrJqXbefwhOde28V5Gcau8r6ztTXbdhpBg+TfXghY17JOdPW175w1E8fk2/fLr0jrD3BVsBwpH6gEYIR+ovGiEcqW9phHCkfqgNwjhS8/EOwuVxXIB5eiR2iDClbRDZFH/UfHvv/fFfivFxvVv8B/PO050hmXceSQ3JfNZuvyVzD/PLmc/qJ1oyn9WAtGQ+q2NpyXxWi9OS+UjZsxLmCR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmWd86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDr2aeFnzo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ27wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5xYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5g4fej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5n3fsDtkMzxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZz7U4eVamONDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOBDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOID72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMEz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM8/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs08L/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztzgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlziw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzB0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzP3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OfMWHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYBH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZR3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5xodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRi5m5Z8KHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cucGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYWH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZO3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZz5ig+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzAM+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzOP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOMD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86NXMzYIPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwNPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczt/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo5cydJk+Uvr84hu3aGD9R/D1Tr8mJ/NlMNfX/fzbTFl23ecy0MPjvXvo+fqd8/F75+Ffl4w/Kxx+Vjz91Pv51+1g22brCSxuf83b1+tQrhO3DNk802SbnTTebrBlosjbFvb1IOReudjanbZK3En8M5INM7w1GOzK9ty7tyPh5ybiQ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8vFH5eNPysefdY/fLMrHb5SP3yoff+/rb2n8ytdfo3z9NcrXX6N8/TXK11+jfP21ytdfq3z9tcrXX6t8/bXK11+rfP21ytdfq3z9tcrXX6t8/XXK11+nfP11ytdfp3z9dcrXX6d8/XXK11+nfP11ytdfp3z99crXX698/fXK11+vfP31ytdfr3z99crXX698/fXK11+vfP1dla+/q/L1d1W+/q7K199V+fq7Kl9/V+Xr76p8/V2Vr7+r8vU3KF9/g/L1Nyhff4Py9TcoX3+D8vU3KF9/g/L1Nyhff4Py9TcqX3+j8vU3Kl9/o/L1Nypff6Py9TcqX3+j8vU3Kl9/o/L1Nylff5Py9TcpX3+T8vU3KV9/k/L1Nylff5Py9TcpX3+T8vU3K19/s/L1Nytff7Py9TcrX3+z8vU3K19/s/L1Nytff7Pu9dctutdft+hef92ie/113e9/VRq/7vXXKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8or3//KK9//yivf/8or3//KL7rXX698/yvf/f5Xj5cOMZvn8R9dvI06pPB44dtt97n2vlZLzrX3dV1yrr33AIJz7X6/Lsm59t5bSM618z5kzWt6zNV+P1cf8zYOn1zaL3aLPxy2ifuonX9c7dcPNp33OE3ZeNi8ZNN5bxZXbz+ujmEJ37Nxbrv21/z2Fz5kHtZtyGtcni52+WjMOe+vvCzp09V3jJ23iFowdt59asHYeWOrBWPnPbMSjL1v36cFY+edvhaMnZsILRg79xtaMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYOx9E1QtGHExIhhxMSIYcTEiGD0YJTDiYkQw4mJEMOJiRDDiYkQw4mIkMPa+lbQWjLgYEYy4GBGMuBgRjB6MEhhxMSIYcTEiGHExIhhxMSIYcTESGHvfkF8LRlyMCEZcjAhGXIwIRg9GCYy4GBGMuBgRjLgYEYy4GBGMuBgJjL0fa6IFIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwExt4Ph9KCERcjghEXI4IRFyOC0YNRAiMuRgQjLkYEIy5GBCMuRgQjLkYCY+9H7GnBiIsRwYiLEcGIixHB6MEogREXI4IRFyOCERcjghEXI4IRFyOBsfeDSrVgxMWIYMTFiGDExYhg9GCUwIiLEcGIixHBiIsRwYiLEcGIixHAuPZ+3LMWjLgYEYy4GBGMuBgRjB6MEhhxMSIYcTEiGHExIhhxMSIYcTESGHs/hF4LRlyMCEZcjAhGXIwIRg9GCYy4GBGMuBgRjLgYEYy4GBGMuBgJjBYXI4IRFyOCERcjghEXI4LRg1ECIy5GBCMuRgQjLkYEIy5GBCMuRgKjw8WIYMTFiGDExYhgxMWIYPRglMCIixHBiIsRwYiLEcGIixHBiIuRwOhxMSIYcTEiGHExIhhxMSIYPRglMOJiRDDiYkQw4mJEMOJiRDDiYiQwrrgYEYy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgDLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwExoiLEcGIixHB2LmLWfOaNozJ5ALGmLaLXXoatsvr0bC93QZifHxSyB+9tEnL9tImPy628WjUbrE7duMf2J05IpJM8B9XJ/skks3LwdU+Lu7jah9/MdteO9gPSTt3VEj6vqQeSUeTtHOniaTvS9q560XS9yXt3IEj6fuSdp4GIOn7knaeTCDp25KmzlMSJH1f0s4TGyR9X1LSo+EkJT0aTlKPpKNJSno0nKSkR8NJSnr0M0m9ydtL+2QLkq6L2Z+ALj4+5hg+qBPwtKBOBtOAeiYmaUGdJKMFdcKGFtTJA1pQ91BvQB1X3YI6xrcFdbxpC+p40xbUu/Kmv4YUlq6M231IXbma+5C6avnvQ+qqH74Pyfc3pK46qfuQumoz7kPqag2+D6mrBeo+pP4+vU1/n96mv09v09+nt+nv09v09+nd1xn39yH19+nd19nr9yH19+nd15ngv4fU1/na9yH19+nd17nP9yH19+nd13nE9yH19+nd1zm59yH19+nd1/mt9yH19+nd17mi9yH19+nd13mX9yH19+nd1zmM9yH19+nd1/mA9yH19+nd17l19yH19+nd13lq9yH19+nd1zlf9yH19+nd1/lT9yH19+nd17lI9yH19+nd13k99yH19+nd1zky9yH19+nd1/km9yH19+nd17kb9yH19+nd13kQ9yH19+nd1zkF9yH19+nd1/759yH19+nd177u9yH19+nd137j9yH19+nd1z7Y9yH19+nd1/7M9yH19+nd177B9yH19+nd13629yH19+nd136i9yH19+nd136O9yH19+nd13569yH19+nd135m9yH19+nd135S9yH19+nd134+9yH19+nd134q9yH19+nd12YZ9yH19+nd1zYL9yH19+nd1w/070Pq79O7r59234fU36d3Xz8Kvg+pv0/vvn5Oeh9Sd5/esb/fWsb+fmsZ+/utZezvt5Zx6e7TO/b3W8vY328tY3+/tYz9/dYy9vdby9jfby1jf7+1jP391jL291vL2N9vLWN/v7WM/f3WMvb3W8vY328tY3+/tYxCPyBa4mNIJj4N6febvP9jl/ttru42X3fbWndbqLst1t2W6m7LVbe9/2OA+22m7ra6KvF1VeLrqsTXVYmvqxJfVyW+rkp8XZWsdVWy1lXJWlcla12VrHVVstZVyVpXJWtdlax1VbLWVUmoq5JQVyWhrkpCXZWEuioJdVUS6qok1FVJqKuSUFclsa5KYl2VxLoqiXVVEuuqJNZVSayrklhXJbGuSmJdlaS6Kkl1VZLqqiTVVUmqq5JUVyWprkpSXZWkuipJdVWS66ok11VJrquSXFclua5Kcl2V5LoqyXVVkuuqJFdVSVqWuttM3W227jZXd9thlfiw3/bpWJzHbevxbeZxm13+8/tM4PbeHxcn99im1qZ8cG1OW6CR8+dr78MJfQ0n9jWc1NdwclfDOX440W44pq/h2L6G4/oaju9rOH19Kpu+PpVNX5/Kpq9PZXP1p/J+TJ9ZFvt1PHbpbDyms/HYzsbjOhuP72w8b382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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_set_public_teardown_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AK2c3Nzgs9B3tEZEwg9EdV2KIX4JOZDdgQLXPkxVfOvoo1sGIsuepVVNUqswsPz5zOOIJCLQiX02YpJ2XLDKl8B2Xqg1q1eWmB43dDgxVKzqJ7vUcLcOFYfhRahm1uc8EB5/cDvp80eJITRk5eibZr7b5agPqjVmwYJJFvPCT/fUGeLBrIfu8WXWyqslhOQaco6FFIsLUVa37JdKOn7KuQgjBOs403QYKy709pdvpqo26iLm1/ae+VI1S3cCEKDJLL+hDOjjHA3XS+fFm3215CAP0n0kBzf6x7TEh0kC8SbMCj9D0YrDFalSKaXa9RmZTQp/g59wpl0WasgKFGRLUfw4OSiNDmP2qMaOrd+NT5g9uPzbqwW1rTKzNNEmqXGhPBf2gy7g2Q9yOvkm5HRSo6tCc0egkfuV+p/NHDd0NId8itTXQC8y/O0gex+KI9Pp/LwQqkeA8joImK2SB5hKMJQVn8ggOMvOLdqEKEfCnMU0I8pFti04APTHJpFePl/9kIuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLseIL9Of+VaYSY3yI9JhKt+I7FDwk+CTwlUd8m0nZZsyx4ncYY75Mxmtr/ByJJ5V6f2ypEO1G8zro/dqnGt0LKSJuhl3HAALJiz6tMVoT2vGzT2/4j0vcUAVstJMCsP+5sisU79oLN10N6h2+GrBaASfha3I8aOujwerMuP+fSeciHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0E4YWuRKVxKct3D6sKlhhGD+ZHzY2Ikm+9qaIlWv6t4/J2WdFWWm/ysBxblfIRWoB14/DcC4SwWWZcUCNS059Sa7j/QzqZaeFaRl09Vx5KytsQ/D5021buBl6OC4XOFQVAYYN+P5YJaCoL//EXDq2FEG9WO3m7op0QHi3VvRm+hA36qMcXbMZrXIgM8pru20KFPydA73y5hSUq43aOBVzYfVF2tPEIsIb1d0UFo6VfhKVUJvWnnRZXL5ayNBrKXbZ3E0NhsJW3al5f256d2XYCtR4N4cx+iCabSQcFccgjthcDGiio0CWfxi/J43+z1wZP6KY+S3rhQijY6oyhtm5x8zOYdOCujldB4CdG0bd3w6lkZhd/lwxnycAQvEIGNBeUMXL3a0l9sIoSRMzqCvzAsKFRIl4NmPRDHOPXIFTk1LxDKPfrbZWhpqDczrnPOERVbwaYBTLwEeJhGsyLheED9dH5jT/ehuorwqByHr4lxexb2JSEJXTHtL+VxQOBU3LfpqQHmZ77wvqmvyFO9UhGZZ36YZWhjnpKpM4r5khF2vRxJaClWS5+HkvNGsyILwOFJzEbtIbZK/eOFOnL+2q6CwV7NA7lPOlS5yk+Xm5NA+90qGoOsxgZLRvv+R2agjqVcBYfAesEQ5U+R0FGK2fLjQQiqzhPc+v3h+q8lPvJox94GnfMfEIRkIlIzwy79wR3FjkbUse3yR98FbxwbtUyOeLMjfcSTKXawsqbqYVtR1NQ8V2dI7FWIUhwwVHqpr9GfrPijicvb3xVYxt4E/IBDwPlgOLdygcv+W47UatkiEvg9IkWeXTgOjEQU0ZK4EjKhqBqSTlugD3Qpfwhxzm92uSWaXblh/NLbicSKH39ArcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBDeoYAGsY+Nd8A+o/32Ho4M5Cx4pLKnX6UyeGoWpDZsIfCkY/3M6FK+2ks/kWMNUsymRblRi1A+WbB5qKHPLgADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "get_accepted_asset",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuNXvv52v6tYafzK19/udxUrjV/5+tv9rmKl8Stff7vfVaw0fuXrb/e7ipXGr3z97X5XsdL4la+/3e8qVhq/8vW3+13FSuPXvf767ncVK41f9/rru99VrDR+3euvX3Svv17xrmL38etef73iPbru49e9/nrFO179Hr/ijanu41e+/irf/8or3//KK9//yve+/1VweRt/WlzhpX+0sVzaZpjz52vvXDpf15tx6bxfaMal8z7kPC7vN2j0vW8w1gxM7zuXtQPTeUvWDkznvV47MJ03ke3A+L7BpP2lffIlMDG4j4tjDPu13n5MtfNGVnKqnfemklPtvN18M9X7+DtvC4vj77x7K42/8+3pVuPX7WITDux559vTlcffd8tSHn/fnUV5/F75+Pte1cvj73upLo+/7/W3PP6+19/y+Ptef5/Hb439Ov7Ot6crj1/P+ns8fj3r7/H49ay/x+PXs/4ej7/z9TeauF+c8sH4O19/i+PvfP0tjr/z9bc4/s7X39L4O9+erjz+ztff4vg7X3+L4+98/S2Ov/P1tzh+5etv59vTlcevfP3tfHu6NblluziHVHhpn/fJPn+VKaWDa21ctuOMbbSPzjZ8cOl8XW/FpfPt9Npx6bwPEeJyn2vnPYvoXDvvb0Tn6ieaa+d9k+hcO++xROfaeT/2o7neIrftYp8O5jpS71aa60j9WGGunW+ZKDvXkfqm0lxH6ptKcx2pbyrN1U8015H6ptJcR+qb1nXvm9JB39T5NpOycx2qbyrMdai+6f1cO9/qUnauQ/VNhbkO1TcV5jpU31SYq59orkP1TYW5TtQ3db496Lu53sevtxe6j19vf/N7/J1vD1oev94+5D5+vb3Fffx99wthWbaBBBfMwfi98vH3va6Xx9/3Wl0ef9/r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40OvZ44PvZy5wYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hYfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5k7fOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9n3vsBt0Myx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZz5UIeXa2GOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOAD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMIz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMMz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aFXMzcLPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczN/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztziQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxoZczd5o8UXp/cQzbtTF+ovh7pl6TE/mzmWrq//9spi26bvOYaWHw7176Pn6nfPxe+fhX5eMPyscflY8/dT7+dftYNtm6wksbn/N29frUK4TtwzZPNNkm5003m6wZaLI2xb29SDkXrnY2p22StxJ/DOSDTO8NRjsyvbcu7cj4ecm4kHcyKT6R+XqtNztFb038QrH31kwHxd4bxJ9RXOJGMZulcHXa55jcY4o3/AfX5rQNI+fP194p9t6m6qA4UrPcjuJIXXgzimGk9r4dxbF8QyuKY3mMVhTH8iOtKHooClAcy7u0ooh3kaCId5GgiHeRoIh3EaAY8S7fohi2a82y2AOMmBcRjLgXEYzYFxGMHowSGDEwIhiHcjD58VRqKWI0Pu5sVvP02vloJGHZHmIF+/Rt2Ww+OA7lYRpyHMrFNOQ4lI9pxzEN5WQachzKyjTk6OH4PY5+uzis5oAj6/U3Oe4/zwkhHXCceL1ezT7s1flPHO9sJl6DS2zyxOtqkc3Ea2WRzVBZ3g8/t/eB3Nishc/t239N/jGU/OV7l3mo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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "fee_entrypoint_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dB3wcxdXf051kS7awXDDGNmB6h9vrAkJMM733EuCkuzPF2MYFbFw4N4wBG2wMJpBCEgJJSCWhhPSekN57QkJ6r1968s2YfXdPT2/39nRv5B2s+f2etLcz+5//vJl5U3c25rzoqu2O8/XEi9cxJXHvf5uSGeQe/MfX7Uy4Mcy9bubeOObeeObeZCUzyb29mHAzmHt7M/f2Ye4dyNw7SOvHGehi3v+Z3v90MpfJlPOpspt2i8lUb18hm8xk+3IFt+BmC9lSqpBOlwuZQr63rzef7HUz6bJbyfamK8kX3X/b6ljJllyq3yTP/w2dZ5re0NwmKEkgrloP/0V6h+uD0fX/vDDwnM6omJI2JfE4uu+5NqKDZGvOPVBQn4m4HC9cZjXuDMN6wNxb1UO7IT20e3pIEB1gFxPWS0wOK8nQlcLurQFq5YwdJuVMciKtHBcusC464i/+H0VbQO3xA3JvFFPz4gaVOMSal/JqntshWItHxc1kLrVcrfKUTPNoJs1DxcTlaLRXtnTl7HbqFRE76da9Qzgt4DrjBglrcL+mbaj4nYLNUZdgYTOlQ80xJqzDLmFjIJ3uUV66pbpFgCuZ32MEdThgaBZ/cUiUcOqNF3U7abfINakDyQYS91DGehnYHW+Qia0WyF0MtfDSPMcNnWeK3uDGqVrhMB7tRte7oOtx8YHj1B71e7ySCUomMuNUaR1MEssrN2+S565yZSrN5dUklCfb5xi8/7vG/ecUJiu/3ZRMUbK7l1da2pzhGSaNGqZ6lmzNuZMFeXYgnlM9QzbN+z/d+7+H93/PeH2OSLu99KhLN2pK9lGyr5L9lOyv5AAlByo5SMnBSg5RcqiSw5QcruQIJUcqSSpxlaSUpJVklGSV5JTklRSU9Co5SsnRSo5R8jIlxyp5udaDkuOUHK/kBCUnKjlJySw6bNwTTUqE7donW3PuNOGeBLiT4wYJnxyXxz3FcHc82Zrbnu5TUDMuhJsczsI23VBhOzVukPCpBgrbaREvbDrdp1le2PYwVNhOjxskfLqBwnZGxAubTvcZBgqbCa6neBVDuq97ZtzOSranoUp2Vtwg4bMMVLKzI17JdLrPtqSSaWNwpoFKdo4lkxTnDp1nht7gBr7T0AB3OrreE12fSyYpzlO/z1dygZILmUmKuHAZEGy93fME6+ZFwgaP5s1FKA/OR9cXoOsLSd5crH5fouRSJZfFB+JJlkttP84xUC8vF8xrnfZdnOGZuZ5qyJ44ojxTBXPYyVQM6RYmXa5QenmFkiuVXKXkaiVFJX1K+pWUlJSVVJTMVnKNkmuVXKfkeiVzlNygZK6SeUrmK7lRyQIlC5UsUrJYyU1KblayRMlSJbcoWaZkuZIVSlYquVVJVckqJauVrKGTLlfEB+9aewVz70rm3lXMvauZe0XmXh9zr5+5V2LulZl7FebebObeNcy9a5l71zH3rmfuzWHu3cDcm8vcm8fcm8/cu5G5t4C5t5C5t4i5t5i5dxNz72bm3hLm3lLm3i3MvWXMveXMvRXMvZXMvVuZe1Xm3irm3mrm3pp43UiCO9j7P9P7n2zNDTCarTYcVwhglSsvulfIYZWulMPqvUoOy71aDKvsFsWw+t0+MayC2y+GlXRLUljlpFuWwupPuhUprELSnS2Fper2NUJYZYV1rRBWv8K6TgiroLCuF8LStnCODFZZY90gg9WvsebKYBU01jwZrO1tx3wRrPJ2rBtFsPq3Yy0QwSpsx1oogvViW7tIAqv8ItZiCaz+F7FuksAqvIh1swSW1zdZIoBV8rCWCmD1eVi3CGDlPaxlrWPV9ggvbx3LBawVLWMVKoC1snWsPsC6tXUs6K+61Zax8jWsVS1jZWtYq1vGcmtYa+J27PWWGDsA1lq5NG/fZig9UaUnCC+Py0/crRPOa6ktt55z9e6fKwTzRufzOgN6vM0CPUqW8SsM6XG9oB41Nzo5r/MJJuHXx8Pt7rxd/d6g5A4ld8b9J+eTrTl3Rrw+bymp07HtZhcLW+Wn03y7gXR3t5tpxxLC+X67YDt2l2AdFyw3ri15MUMwLzbGzdThKNULzsbehWzpxpA2dpP6fbeSe5RsNmhj9S7iKw3Yml0ibmN1mjcZSPc4S+r1JsG6uEXQxgqWG9eWvNhbMC/ujZupw1GqF5yN3YJs6b0hbexW9fs+Jfcr2WbQxuq3NK4yYGt6Im5jdZq3Gkj3eEvq9VbBuviAoI0VLDeuLXmxj2BevDJupg5HqV5wNvYBZEtfGdLGPqh+P6TkVUpebdDG6rfgrjZgayZE3MbqND9oIN0TLanXDwrWxdcI2ljBcuPakhf7CubFa+Nm6nCU6gVnY1+DbOlrQ9rYh9Xv1yl5vZI3GLSx+i3jogFbMyniNlan+WED6d7Vknr9sGBdfETQxgqWG9eWvNhPMC/eGDdTh6NULzgb+wiypW8MaWMfVb8fU/ImJW82aGP1KQ59BmzN5IjbWJ3mRw2kezdL6vWjgnXxLYI2VrDcuLbkxf6CefF43EwdjlK94GzsW5AtfTykjX2r+v02JW9X8g6DNlafktNvwNZMibiN1Wl+q4F0725JvX6rYF18p6CNFSw3ri15cYBgXrwrbqYOR6lecDb2nciWviukjX1C/X63kvcoedKgjdWnkJUM2JqpEbexOs1PGEj3NEvq9ROCdfEpQRsrWG5cW/LiQMG8eDpupg5HqV5wNvYpZEufDmljn1G/36vkWSXvM2hj9SmPZQO2ZnrEbaxO8zMG0r2HJfX6GcG6+H5BGytYblxb8uIgwbz4QNxMHY5SveBs7PuRLf1ASBv7QfX7Q0o+rOQjBm2sPkW3YsDW7BlxG6vT/EED6d7Lknr9QcG6+FFBGytYblxb8uJgwbz4WNxMHY5SveBs7EeRLf1YSBv7cfX7E0o+qeRTBm2sPqV8tgFbMyPiNlan+eMG0r23JfX644J18dOCNlaw3Li25MUhgnnxmbiZOhylesHZ2E8jW/qZkDb2OfX7s0o+p+TzBm2s/grENQZszT4Rt7E6zc8ZSPe+ltTr5wTr4hcEbaxguXFtyYtDBfPii3EzdThK9YKzsV9AtvSLIW3sl9TvLyv5ipKvGrSx+is71xqwNftF3MbqNH/JQLr3t6Ref0mwLn5N0MYKlhvXlrw4TDAvvh43U4ejVC84G/s1ZEu/HtLGfkP9/qaSbyn5tkEbq79idp0BW3NAxG2sTvM3DKT7QEvq9TcE6+J3BG2sYLlxbcmLwwXz4rtxM3U4SvWCs7HfQbb0uyFt7PfU7+8r+YGSHxq0sforkdcbsDUHRdzG6jR/z0C6D7akXn9PsC4+L2hjBcuNa0teHCGYFz+Km6nDUaoXnI19HtnSH4W0sT9Wv19Q8hMlPzVoY/VXeOcYsDWHRNzG6jT/2EC6D7WkXv9YsC7+TNDGCpYb15a8OFIwL34eN1OHo1QvOBv7M2RLfx7Sxv5C/f6lkl8p+bVBG6u/cn6DAVtzWMRtrE7zLwyk+3BL6vUvBOvibwRtrGC5cW3Ji6RgXvw2bqYOR6lecDb2N8iW/jakjf2d+v17JX9Q8keDNtaN17+Dh3Fb1ekREbexOs2/M5DuIy2p178TrIt/ErSxguXGtSUvXMG8+HPcTB2OUr3gbOyfkC39c0gb+xf1+69K/k/J3wza2FS8/l1RjNuqTpMRt7E6zX8xkG7Xknr9F8G6+HdBGytYblxb8iIlmBf/iJupw1GqF5yN/Tuypf8IaWP/qX7/S8m/lfzHoI1Nx+vfaca4reo0FXEbq9P8TwPpTltSr/8pWBf/K2hjBcuNa0tepAXz4n9xM3U4SvWCs7H/Rbb0fyFtrL6IKWlTEk+Ys7GZeP279xi3VZ1mIm5jdZq361gYN2tJvdaAUmlOJATLo6CNtSUvMoJ2sT1hpg5HqV5wNlaXQbCl7YlwNrZDXYxSMlpJp0Ebm1XxLjBgY3MRt7E6zR0GbGzeknrdIVgXuwRtrGC5cW3Ji6ygjR2TMFOHo1QvOBvbhezqmJA2dqy66Fayi5JxBm1sTsW70ICNLUTcxuo0jzVgY3stqddjBetij6CNFSw3ri15kRO0seMTZupwlOoFZ2N7kF0dH9LGTlAXE5VMUrKrQRubV/EuMmBjj4q4jdVpnmDAxh5tSb2eIFgXJwvaWMFy49qSF3lBG7tbwkwdjlK94GzsZGRXdwtpY6eoi92VTFUyzaCNLah4FxuwscdE3MbqNE8xYGNfZkm9niJYF6cL2ljBcuPakhcFQRu7R8JMHY5SveBs7HRkV/cIaWP3VBd7KZmhZG+DNrZXxXuTARt7bMRtrE7zngZs7Mstqdd7CtbFfQRtrGC5cW3Ji15BG7tvwkwdjlK94GzsPsiu7hvSxu6nLvZXcoCSAw3a2KNUvDcbsLEzI25jdZr3M2Bjj7OkXu8nWBcPErSxguXGtSUvjhK0sQcnzNThKNULzsYehOzqwSFt7CHq4lAlhyk53KCNPVrFu8SAjT0+4jZWp/kQAzb2BFvOhRasi0cI2ljBcuPakhdHC9rYIxNm6nCU6gVnY49AdvXIkDY2qS5cJSklaYM29hgV71IDNvbEiNtYneakARt7ki3vyEvuoxS0sYLlxrUlL44RtLHZhJk6HKV6wdnYDLKr2ZA2Nqcu8koKSnoN2tiXqXhvMWBjZ0Xcxuo05wzY2JNt2S8kuf4saGMFy41rS168TNDGHp0wU4ejVC84G3sUsqtHh7Sxx6iLlyk5VsnLDdrYY1W8ywzY2FMibmN1mo8xYGNPtaXvJDlvJ2hjBcuNa0teHCtoY49LmKnDUaoXnI2diezqcSFt7PHq4gQlJyo5yaCNfbmKd7kBG3taxG2sTvPxBmzs6ZbU6+Ml+zuCNlaw3Li25MXLBW3syQkzdThK9YKzsbOQXT05pI09RV2cquQ0JacbtLEzVbwrDNjYMyJuY3WaTzFgY8+0pF6fIlgXzxC0sYLlxrUlL2YK2tgzE2bqcJTqBWdjz0B29cyQNvYsdXG2knOUnGvQxh6n4l1pwMaeFXEbq9N8lgEbe7Yl9foswbp4nqCNFSw3ri15cZygjT0/YaYOR6lecDb2PGRXzw9pYy9QFxcquUjJxQZt7PEq3lsN2NhzIm5jdZovMGBjz7WkXl8gWBcvEbSxguXGtSUvjhe0sZcmzNThKNULzsZeguzqpSFt7GXq4nIlVyh5hUEbe4KKt2rAxp4XcRur03yZARt7viX1+jLBuniloI0VLDeuLXlxgqCNvSphpg5HqV5wNvZKZFevCmljr1YXRSV9SvoN2tgTVbyrDNjYCyJuY3WarzZgYy+0pF5fLVgXS4I2VrDcuLbkxYmCNracMFOHo1QvOBtbQna1HNLGVtTFbCXXKLnWoI09ScW72oCNvSjiNlanuWLAxl5sSb2uCNbF6wRtrGC5cW3Ji5MEbez1CTN1OEr1grOx1yG7en1IGztHXdygZK6SeQZt7CwV7xoDNvaSiNtYneY5BmzspZbU6zmCdXG+oI0VLDeuLXkxS9DG3pgwU4ejVC84Gzsf2dUbQ9rYBepioZJFShYjGwuuTTifexw5fS5ImCnbceE0TxYs29MEsW4S1J8uN91OvS3BTrq9luSN+d6cMEj45oQ87hJBQ2cq3UuQRRHC3V7YdCVtc8wXtslxM0ZGmue0uJlKsRSVW/nTXAR7TTGvUMQQ6YQnw2GVJDMAF+xbvAq0TKfJRAYsNWCZlgo3zabS3WYw3S2/WmNYh8nWnKsL5nIDw8cVws07GAWNW/VwpXWxzJAuVhrSxcoAXbR8tIEhXVy+Y6dT+hvwM1YGrmiPth3QDd9yA7ZUML9dSR3q9ljBsb1Pp0kdNCpTGNOE/ZbSCe5g3RrUY0y25tzlhgwiJt0kZ7dRPJrzrQYMwysiMrfXTEem5f1tiWgamFe0mymXVdRQDzV/GulcMn9WISw3nVZ1o5R3K6VKOpvvTfW5uXQuV8lU8rlCplTJZoqlfNnNFNOp3nI+WXEL5XI+m+7P5yq9pf5cBRttt5ROZ0q9ff1uNpUr9iULpXQxWcnk06lksZTOl0rpQi5XTKdLuUKl0FtIpYqVdCGZzed7k7lUujdlKn9WefkznCPNyYZGmqu9grXGFgNuit9qA8Z6raGGa63BUY3WxRoDulhnSBfrDI5qTJWLqyI+qjFVBq6O+KhmsqFRjWB+u1ePjGqoc1cbGtXcZuOo5jbDo5rbDBiG4k44qlmfiKaBKRrqNa+3bFRzu+Co5mrBUY2p/LkdjWr8GoUoT0eZ5GmqgdlgYwOzwXADs8FAA9NnqIFpF+YpacDuEMSSnDaTbKz6DBnDO0I0Vq3q9M6EXKMwYNosQo2Vqfy58yU0BXeXV7A2cps9kq0512/Tg+Qunpa/PSLYEzaR8aDDuCU6bBVrU8TzQ1eYTQY6CXcb6jDdbXC6dqMhXdxjSBf3GJyuNVUuyhGfrjVVBioWTNduMjBdK5jfbmVkupa67fZbSie447fZ5Gh6kyGDuNngaFpz3mzAMMy2ZLp2k2CnaEsimgZmtqER1pZhmK6VzJ97BadrK4IjYFP5c+8OGAGbet1hq1ew7rPFgJvit9WAsb7fUMN1v8FRjdbFfQZ0sc2QLrYZHNWYKhfXRnxUY6oMXGfB1noToxrB/HavGxnVUOduNTSqecDGUc0Dhkc1DxgwDNfvhKOaVyaiaWCuN9RrfqVlo5oHBUc11wmOakzlz4M7YBOK5HSUSZ6mGpiHbGxgHjLcwDxkoIGZY8kmFEkD9ipBLMlpM8nGao4hY/iqYdiE8mrBTSiV9mg2Vqby59VM/kjvERDcdOLuIXiO1GsE7bou08N1jtRrDDWir00YJPzahDzuw4KG2VS6H07UFSyEO6znSO1hyTlSkjvbcKV4XcLgOVIPCw5dsVUH0i+FrYWv9yrQGxIGzpHSGfA6A5bpdYYXaqTS3WYw3a1yfCTii126YD5iYIj1RkPDzTcaXOx6gyFdPGpIF48aXOwyVS7mRXyxy1QZmG/BFr5HDNhSwfx2548sdlG33X5L6QR3sB4zORf5iCGD+JjBuUjN+TEDhuFGSxa7HhHsFL0pEU0Dc6Oh+ak3DcNil2T+vFlwsWu+4Pyhqfx58w7YwreHoZHmW7yC9bgtBtwUv7cYMNZvNdRwvdXgqEbr4nEDunibIV28zeCoxlS5WBjxUY2pMrAo4qOaPQyNagTz2100Mqqhzn2LoVHN220c1bzd8Kjm7QYMw+KdcFTzjkQ0DcxiQ73md1g2qnmn4KhmkeCoxlT+vHMHbOGTnI4yydNUA/MuGxuYdxluYN5loIG5yZItfJIG7AlBLMlpM8nG6iZDxvCJYdjC927BLXzz26PZWJnKn3e/hKbg3uMVrCe5zR7J1pzrt+lBchdPq1iCG0eMnFsEOpTeI2pKh61iPRXx/NAV5ikDnYSnDXWYnjY4XfukIV08Y0gXzxicrjVVLpZGfLrWVBm4xYLp2qcMTNcK5rd7y8h0LXXb7beUTnDH770mR9NPGTKI7zU4mtac32vAMCyzZLr2KcFO0bOJaBqYZYZGWM8Ow3StZP68T3C69hbBEbCp/HnfDhgBm3rd4f1ewfqALQbcFL/3GzDWHzTUcH3Q4KhG6+IDBnTxIUO6+JDBUY2pcrEi4qMaU2VgpQVb602MagTz2105Mqqhzn2/oVHNh20c1XzY8KjmwwYMw6074ajmI4loGphbDfWaP2LZqOajgqOalYKjGlP589EdsAlFcjrKJE9TDczHbGxgPma4gfmYgQamaskmFEkD9nFBLMlpM8nGqmrIGH58GDahfEJwE8ot7dFsrEzlzycMzoCcoSI5Oy5vgz5peBZMwvZ8ktlrkWzNSbZD7icFbdqnIp4f+kzBTxloCz8tvMdEen+TnoWR5DjNw3Nky7WRGajpHlfpPP+MYFnXqhyus+c+Y6jj/VzCIOHnEvK4nxU0fKbS/dmdvJJ9ztBoVtrASpalz0e8MelReS3JUefx5y0p52Pj9tTJboNcwUnX9y8MvVxl6Q3NbYJTH2Tq3/9VleG/iDdcx9C15vBf9NwX1cWXlHxZyVcS9fvgpDv3BwlifVHQLn3VkC2W1t/BglhfEtTf14Q7XrRsfzVRL8NfQ9dfRtdfIWX76+riG0q+qeRbifr+mw6UL5ybKZOOTMwZXJ+k7aAgVtIUx5gFHA+ygOPBzvC0c8nWnPt1E7ZUV6RRTn0G3WQCxho6VNoR4lnOZ7LZ3v5e6zLRAM92Sw4Aj8thDdiQ+W2vhfkO7CyFKW/tMcMZ6KQ3Kn1bsAfx3YRsiwN6+C6jB+nM/Y7h3o9fzx5f/69tYO/ne+ri+0p+oOSHqPcz2hmW3k8q5gzeE7Az9n5McDTB83sjrTaTAORaxc4kk4VytlCyLhMN8PyuJTxNtdrPe1b6R7TVfn4YWu3nBVvtHxtqtX/s6UHrp9MZnsWjHxlYPIohni9AZgc17y+gCY1d4vXrcfGBzftP1MVPlfxMyc+ZiTvpQvMjwULzk2Gq/a3y/IUYz1SfSZ6/lODZ25dM9+XTXPn8BSqTv0TXY+P+E8u/Uhe/VvIbJb8dhonlFwQN0a8Ey/rvLJlYlpyY/7Wg/n5veGj1O1Sef4+uf4Ouf0vK9h/UxR+V/EnJnyMysSwWh2cHHKQjQe5GeunSHF9IRJ+jiQlrEzz/YMj+1Zx0R+fHgsbrL4Z6x39BveMuhzcGNqzi2FTgpHn+2BKekkPgGkldYMc49cqrSU9xeCcTeTZtBjeXNYObz9iFm+s1hFs2hJs3g5tKGsq3PjO4aVN8S3bpN+ca0oMhu2NMDzlDuFm7cI3VY9vKrym7bqrdTOEpV3C2dIZrjo5qJPbwSyX+EEOJl06zYCa5h1qS5jbBNB9mSZoFRyju4cOU5mRrzj1CUH+OJVuojnTs4Jm0hKcrWYYM8kxZos+0JTwzlvDMWsIzZwnPvCU8C5bw7LWE51GW8DzaEp7HWMLzZZbwPNYSni+3hOdMS3geZwnP4y3heYIlPE+0hOdJlvCcZQnPky3heYolPE+1hOdplvA83RKeZ1jC80xLeJ5lCc+zLeF5jiU8z7WE53mW8DzfEM8orwteMExpTrbm3AsF9ZewZL3oIscOnhdbwvMSS3heagnPyyzhebklPK+whOcrLOF5pSU8r7KE59WW8Cw6dvDss4RnvyU8S5bwLFvCs2IJz9mW8LzGEp7XWsLzOkt4Xm8JzzmW8LzBEp5zLeE5zxKe8y3heaMlPBdYwnOhJTwXWcJzsSU8b7KE582W8FxiCc+llvC8xRKeyyzhudwSniss4bnSEp63WsKzagnPVZbwXG0JzzWW8FxrCc91lvC8zRKe6y3hebslPDdYwvMOS3jeaQnPuyzhudESnpss4Xm3JTzvsYTnZkt4brGE572W8NxqCc/7LOF5vyU8t1nC8wFLeL7SEp4PWsLzIUt4vsoSnq+2hOdrLOH5Wkt4PmwJz9dZwvP1lvB8gyU8H7GE5xst4fmoJTwfs4Tnmyzh+WZLeL7FEp6PW8LzrZbwfJslPN9uCc93WMLznZbwfJclPJ+whOe7LeH5Hkt4PmkJz6cs4fm0JTyfsYTney3h+awlPN9nCc/3W8LzA5bw/KAlPD9kCc8PW8LzI5bw/KglPD9mCc+PW8LzE5bw/KQlPD9lCc9PW8LzM5bwfM4Snp+1hOfnLOH5eUt4fsESnl+0hOeXLOH5ZUt4fsUSnl+1hOfXLOH5dUt4fsMSnt+0hOe3LOH5bUt4fscSnt+1hOf3LOH5fUt4/sASnj+0hOfzlvD8kSU8f2wJzxcs4fkTS3j+1BKeP7OE588t4fkLS3j+0hKev7KE568t4fkbS3j+1hKev7OE5+8t4fkHS3j+0RKef7KE558t4fkXS3j+1RKe/2cJz79ZwvPvlvD8hyU8/2kJz39ZwvPflvD8jyU8/2sJz/9ZwlMD2sAzZgnPNkt4xi3hmbCEZ7slPDss4TnKEp6jLeHZaQnPLkt4jrGE51hLeHZbwnMXS3iOs4RnjyU8x1vCc4IlPCca4tlGeEbpu/SThinNydacu2tMTn9jLfku/WSBNCcLfcViLl0wWR7jgmnezZLyOEWwPH49YUd53N2SvJkqmDftcTvSPE0wzd9O7Hzt4HRL2v5d5Xi6e1jSL9tToGwXK5W8W8xnTOaNZDu4lyW2doag3flewo407y2Y5h9ZkuZ9BNP8XUvSvK9gmp+3pI+3nyVtwv6W8DzAEp4HWsLzIEt4HmwJz0Ms4XmoJTwPs4Tn4ZbwPMISnkdawjNpCU/XEp4pS3imLeGZsYRn1hKeOUt45i3hWbCEZ68lPI+yhOfRlvA8xhKeL7OE57GW8Hy5JTxnWsLzOEt4Hm8JzxMs4XmiJTxPsoTnLEt4nmwJz1Ms4XmqJTxPs4Tn6ZbwPMMSnmdawvMsS3iebQnPcyzhea4lPM+zhOf5lvC8wBKeF1rC8yJLeF5sCc9LLOF5qSU8L7OE5+WW8LzCEp6vsITnlZbwvMoSnldbwrNoCc8+S3j2W8KzZAnPsiU8K5bwnG0Jz2ss4XmtJTyvs4Tn9ZbwnGMJzxss4TnXEp7zLOE53xKeN1rCc4ElPBdawnORJTwXW8LzJkt43mwJzyWW8FxqCc9bLOG5zBKeyy3hucISnist4XmrJTyrlvBcZQnP1ZbwXGMJz7WW8FxnCc/bLOG53hKet1vCc4MlPO+whOedhni2EZ5ROpPrrp0wzRstSbPkWVebhinNydace3dMTn9/sOQ8oHsssY+bLeG5xRKe91rCc6slPO+zhOf9lvDcZgnPByzh+UpLeD5oCc+HLOH5Kkt4vtoSnq+xhOdrLeH5sCU8X2cJz9dbwvMNlvB8xBKeb7SE56OW8HzMEp5vsoTnmy3h+RZLeD5uCc+3WsLzbZbwfLslPN9hCc93WsLzXZbwfMISnu+2hOd7LOH5pCU8n7KE59OW8HzGEp7vtYTns5bwfJ8lPN9vCc8PWMLzg5bw/JAlPD9sCc+PWMLzo5bw/JglPD9uCc9PWMLzk5bw/JQlPD9tCc/PWMLzOUt4ftYSnp+zhOfnLeH5BUt4ftESnl+yhOeXLeH5FUt4ftUSnl+zhOfXLeH5DUt4ftMSnt+yhOe3LeH5HUt4ftcSnt+zhOf3LeH5A0t4/tASns/H7OD5I0t4/tgSni9YwvMnlvD8qSU8f2YJz59bwvMXlvD8pSU8f2UJz19bwvM3lvD8rSU8f2cJz99bwvMPlvD8oyU8/2QJzz9bwvMvlvD8qyU8/88Snn+zhOffLeH5D0t4/tMSnv+yhOe/LeH5H0t4/tcSnv+zhKfTZgfPmCU82yzhGbeEZ8ISnu2W8OywhOcoS3iOtoRnpyU8uyzhOcYSnmMt4dltCc9dLOE5zhKePZbwHG8JzwmW8JxoCc9JlvDc1RKeky3huZslPKdYwnN3S3hOtYTnNEt4TreE5x6W8NzTEp57WcJzhiU897aE5z6W8NzXEp77WcJzf0t4HmAJzwMt4XmQJTwPtoTnIZbwPNQSnodZwvNwS3geYQnPIy3hmbSEp2sJz5QlPNOW8MxYwjNrCc+cJTzzlvAsWMKz1xKeR1nC82hLeB5jCc+XWcLzWEt4vtwSnjMt4XmcJTyPt4TnCZbwPNESnidZwnOWJTxPtoTnKZbwPNUSnqdZwvN0S3ieYQnPMy3heZYlPM+2hOc5lvA81xKe51nC83xLeF5gCc8LLeF5kSU8L7aE5yWW8LzUEp6XWcLzckt4XmEJz1dYwvNKS3heZQnPqy3hWbSEZ58lPPst4VmyhGfZEp4VS3jOtoTnNZbwvNYSntdZwvN6S3jOsYTnDZbwnGsJz3mW8JxvCc8bLeG5wBKeCy3hucgSnost4XmTJTxvtoTnEkt4LrWE5y2W8FxmCc/llvBcYQnPlZbwvNUSnlVLeK6yhOdqS3iusYTnWkt4rrOE522W8FxvCc/bLeG5wRKed1jC805LeN5lCc+NlvDcZAnPuy3heY8lPDdbwnOLJTzvtYTnVkt43mcJz/st4bnNEp4PWMLzlZbwfNASng9ZwvNVlvB8tSU8X2MJz9dawvNhS3i+zhKer7eE5xss4fmIJTzfaAnPRy3h+ZglPN9kCc83W8LzLZbwfNwSnm+1hOfbLOH5dkt4vsMSnu+0hOe7LOH5hCU8320Jz/dYwvNJS3g+ZQnPpy3h+YwlPN9rCc9nLeH5Pkt4vt8Snh+whOcHLeH5IUt4ftgSnh+xhOdHLeH5MUt4ftwSnp+whOcnLeH5KUt4ftoSnp+xhOdzlvD8rCU8P2cJz89bwvMLlvD8oiU8v2QJzy9bwvMrlvD8qiU8v2YJz69bwvMblvD8piU8v2WIZxvhmU7mMplyPlV2024xmertK2STmWxfruAW3GwhW0oV0ulyIVPI9/b15pO9biZddivZ3nTFwz5QMM3fHqY0J1tz7nfa5PT3l4Qd+ZwQ1N93LSnb7YJp/p4lae4QTPP3LUnzKME0/8CSNI8WTPMPLUlzp2Can7ckzV2Caf6RJWkeI5jmH1uS5rGCaX7BkjR3C6b5J5akeRfBNP/UkjSPE0zzzyxJc49gmn9uSZrHC6b5F5akeYJgmn9pSZonCqb5V5akeZJgmn9tSZp3FUzzbyxJ82TBNP/WkjTvJpjm31mS5imCaf69JWneXTDNf7AkzVMF0/xHS9I8TTDNf7IkzdMF0/xnS9K8h2Ca/2JJmvcUTPNfLUnzXoJp/j9L0jxDMM1/syTNewum+e+WpHkfwTT/w5I07yuY5n9akub9BNP8L0vSvL9gmv9tSZoPEEzzfwTTHHde3OPzNS/Bhyg5VMlhSg5XcoSSI3U8SlwlKa0LJRklWSU5JXklBSW9So5ScrSSY5S8TMmxSl7upf04JccrOUHJiUpOUjJLyclKTlFyqpLTlJyu5AwlZyo5S8nZSs5Rcq6S85Scr+QCJRcquUjJxUouUXKpksuUXK7kCiWvUHKlkquUXK2kqKRPSb+SkpKykoqS2UquUXKtkuuUXK9kjpIblMxVMk/JfCU3KlmgZKGSRUoWK7lJyc1KlihZquQWJcuULFeyQslKJbcqqSpZpWS1kjVK1ipZp+Q2JeuV3K5kg5I7lNyp5C4lG5VsUnK3knuUbFayRcm9SrYquU/J/Uq2KXlAySuVPKjkISWvUvJqJa9R8lolDyt5nZLXK3mDkkeUvFHJo0oeU/ImJW9W8hYljyt5q5K3KXm7kncoeaeSdyl5Qsm7lbxHyZNKnlLytJJnlLxXybNK3qfk/Uo+oOSDSj6k5MNKPqLko0o+puTjSj6h5JNKPqXk00o+o+Q5JZ9V8jkln1fyBSVfVPIlJV9W8hUlX1XyNSVfV/INJd9U8i0l31byHSXfVfI9Jd9X8gMlP1TyvJIfKfmxkheU/ETJT5X8TMnPlfxCyS+V/ErJr5X8RslvlfxOye+V/EHJH5X8ScmflfxFyV+V/J+Svyn5u5J/KPmnkn8p+beS/yj5r5L/KdGVLKakTUlcSUJJu5IOJaOUjFbSqaRLyRglY5V0K9lFyTglPUrGK5mgZKKSSUp2VTJZyW5KpijZXclUJdOUTFeyh5I9leylZIaSvZXso2RfJfsp2V/JAUoOVHKQkoOVHKLkUCWHKTlcyRFKjlSSVOIqSSlJK8koySrJKckrKSjpVXKUkqOVHKPkZUqOVfJyJTOVHKfkeCUnKDlRyUlKZik5WckpSk5VcpqS05WcoeRMJWcpOVvJOUrOVXKekvOVXKDkQiUXKblYySVKLlVymZLLlVyh5BVKrlRylZKrlRSV9CnpV1JSUlZSUTJbyTVKrlVynZLrlcxRcoOSuUrmKZmv5EYlC5QsVLJIyWIlNym5WckSJUuV3KJkmZLlSlYoWankViVVJauUrFayRslaJeuU3KZkvZLblWxQcoeSO5XcpWSjkk1K7lZyj5LNSrYouVfJViX3KblfyTYlDyh5pZIHlTyk5FVKXq3kNUpeq+RhJa9T8nolb1DyiJI3KnlUyWNK3qTkzUreouRxJW9V8jYlb1fyDiXvVPIuJU8oebeS9yh5UslTSp5W8oyS9yp5Vsn7lLxfyQeUfFDJh5R8WMlHlHxUyceUfFzJJ5R8UsmnlHxayWeUPKfks0o+p+TzSr6g5ItKvqTky0q+ouSrSr6m5OtKvqHkm0q+peTbSr6j5LtKvqfk+0p+oOSHSp5X8iMlP1bygpKfKPmpkp8p+bmSXyj5pZJfKfm1kt8o+a2S3yn5vZI/KPmjkj8p+bOSvyj5q5L/U/I3JX9X8g8l/1TyLyX/VvIfJf9V8j8lukMRU9KmJK4koaRdSYeSUUpGK+lU0qVkjJKxSrqV7KJknJIeJeOVTFAyUckkJbsqmaxkNyVTlOyuZKqSaUqmK9lDyZ5K9lIyQ8neSvZRsq+S/ZTsr+QAJQcqOUjJwUoOUXKoksOUHK7kCCVHKkkqcZWklKSVZJRkleSU5JUUlPQqOUrJ0UqOUfIyJccqebnuryg5TsnxSk5QcqKSk5TMUnKyklOUnKrkNCWnKzlDyZlKzlJytpJzlJyr5Dwl5yu5QMmFSi5ScrGSS5RcquQyJfpb8/o77vob6fr74/rb3lcr0d+k1t971t9S1t8p1t8A1t/X1d+u1d+F1d9c1d8z1d8K1d/h1N+41N+P1N9m1N891N8U1N/r09/C09+Z099w099H098e09/10t/M0t+j0t960t9R0t8o0t//0d/WqSrR34TR31vR3zLR3wnR3+DQ37fQ347Q32XQ3zzQ3xPQZ/Xrc/D1GfP6/HZ9Nro+d1yf6a3Py9ZnUetznvUZyvp8Yn32rz5XV59Zq8+D1Wet6nNM9Rmh+vxNfbblw0r0mYz6vEN9lqA+p0+fgafPl9Nnt+lz0fSZY/o8L31Wlj6HSp/xpM9P0mcT6XN/9Jk6+rwafRaMPmdFn2GizwfRZ2/ocy30mRH6PAZ91oE+R0C/o6/ff9fvln9YiX4nWr9vrN/l1e/J6ndQ9fud+t1J/V6ifudPv0+n31XT74Hpd6z0+0v63SD93o1+p0W/L6LfxdD9Vf0Ogd6fr/e+633lep+13sOs9+Hqfal6n6bet6j38T2vRO/z0vue9D4gvS9G7xPR+yb0PgK9rq7XmfW6q16H1Otyep1Kr9vodQw9r6/nufW8r54H1fOCep5MzxvpeRQ9r6DH2Xrcqcdhelyi++ltLzb9jt5nrN0hTt15ZsGJe/56X67ep6r3bep9jHpfn97npvd96X1Qel+Q3iej943ofRR6X4FeZ9frznodVq9L6nU6vW6l13H0uoae59fz3noeWM+L6nlCPW82Q8neSvZRosfdehyqx2V6nKL3vh+k5GBnsEuh6wne/11/ctzuNz732Ek43KQAP92f0G7ZiS9L3/utt9yK/Xo9v9e+ec8np/2k7TLsd3SA3wkBficF+J0S4HdagN95AX4XBPhdGuB3eYDfVQF+xQC/awP8rg/wmxvgNz/Ab0mA3y0BfrcG+K0K8LszwG9jgN99AX7bAvweDPB7VYDfIwF+jwb4PR7g97YAv3cF+L07wO99AX4fCPD7cIDfRwP8ngvw+1yA35cD/L4a4PdNz+/ZTyz71+u+/eHrsd8PPL/3FT5x2rceGzcZ+/3Q8/v8eQ997aIJN/dgv+cD/H7l+XF28I8Bfv/x8Rvn/Z+wx4v/O73fbd5//ZhuT2Z6v5OtObcT4UrjF5K9/Z3OQCfMP92JMA3gpwA/YQZ/+zsc2j1YHYjvkHi7vd8xpEt4BvzakN9Dnt9ozx+ul3rXnQTPRL5jTtJ6m8jwb0Np0+6Eqom4U7UyfaKH7wzAdtOFXDpVyKVSpXKyWMrlK73pfDLdl0339ve5yXQ2VSjli+lkspwu92eSpVxvtlQu9mbTlb5ibw6wT2Kx0+U+BZUt5gp9bqWYqyT7MvlCuljJ50vFUq+av84mS25/zu1PuZVCoZjNFvuzva5bKfdmK4Ua9iwjenmxrmh3shH8dBbwTzGCn+oD/FMRvuD7g0nAP80Mfs2Wn24Gv5a/ZxjRf53/mR6+48jr/iwj3N084J9tRjdpwD/HDP+afs41wz8D+Och/JgB/ZxvBr9WNi8wg1+rWxea0X8F8C/y8B2E7RbSqVQ+rdc1C6Wkmyn1pwqq9erLJPuTxf5UuTfj9lYyqUy6v9Tfp9ZAi24lWSn291YKL4ID9sVGuKdrZecSI7pP19rFSxndJFtztTbrMn/sIasfsC9nsFPFdH+yt5IsZgvFfFktZidVZyRf7iuUK7lUsU91PFIl13XLGfUnVS5levtKObcvp1bAs30qulqeXlE1kadurQ/1CmH8XDHZW87lavb4SmH8vr5cvqj0CfhXCeOn+3PlSjpfswdXC+MXs5lKJZsuAn5RGD/rJsvZVL5WNvuE8Xv7ktlcoVArP/3C+KrfnC71Fmt9wZK0fvrKyf6S2wtjsrKHD3FoB3FXhOP2XG+MxOc4A8ecDom/i3CV7vfFSHyYD9YPjO9Ad7Org7n2MH7YxlC/OHMP4uGwrhTEukoQ62pBrKIgVp8gVr8gVsm7NlvXMrV2dLYR/HQB8K8xgp8sA/61JvDdet/xOoTvyPGv4V+P8GMG8OeY0X8N/wYz+qmNa+Z6+Caw55nRTa0PNt8Mfm1ccKMZ/FofdYEZ/JptWGgGvxfwF5nBr/VRF5vBr/XxbjKDX+uj3mwGvwT4S4zguzX9LEX4crYzVbNttxjBT9fwl5nBr9m35UbwMzX8FWbwa/MqK83g1+zzrWbwa/a5aga/1vdZZQQ/WxsjrzaCn6uVnzVm8GtzrmvN4NfK5zoz+LXyeZsZ/Fr5XG8Gv9Z/uN0Mfq3/sMEMfq3/cIcZ/Fr7dacZ/Fr7fpcZ/Fr7vtEMfs2+bTKDX7NvdxvBz9fa93vM4NfmYDebwa/Zzy1m8Gv2814z+DX7udUMfs1+3mcGv2bf7jeDX7Nv28zg1+zbA2bwa/bnlR6+M3TsNL2h9zzr/UgPe5uMuX1cgn2tJOyRgv1U2uH5dn3dju4LjqNKYebbcfxdzkCuJubbcXzAh+oHz7drvw6Gaw/jR/Owg4mng4mnh/Gjfb9WsO4RxLpNEGuTIJZkGu8SxNogiLVREGu9INZSQSxJ3UvWoc0RxVotiCVZJiR1L1m+1gpiSdZtyTKxRhBL0kZvFcSKavsIfWqzfatkrpuJGxz4jUJx4z4VdXHyG/PWfdVHJ9RxaThwY536mvLCpXP7z5q3qLzQCXhAuxOr/P2oKS9G/EaHSIPjNFbssyEUSzvwmFs3wcTPxhisOHOPFmas84QPB4wBeUU7wjO938mWnJsOkw4c/3ANIjgjwQ0iQD+jzOgnFSP4mM8oRj+0DNO8izn1ityOsHD4USiNODy+hufxvW95/3ucwfUINr/HGL84cw/0q7l/haQN5w0tp2byIeOGLacQf5djst7UyylXLrjGrNMZnM+SG4LC5Ctn2zoZP8CCDXq4nOLwo1EacXh8Dc/jez/z/vc4g8s0LaedTHrwPVxOn/euO33SM9P7nWzJ5fNcO0XrAdaT5AbnsPUA4u9yTJa7ej3g8omzJ6C7LoZrD+NHJ326mHi6mHh6GD/aEW0Fa5Mg1hpBrHWCWJsjirVBEGujINZ6Qaylglh3CmJJlvso6iuoHWwWSzvJsrpFEOt2QSzJsiqZxtWCWFGt29sEsW4RxILFQ9rPBHzHqfeVaHs/0/udbMm9OHbD8UE68D0cfxfhKsun3lfi9Mr1aUE/Y8zop8ZnDMNnDKMfyMuxjB9gwVwLHjPg8GNQGnF4fA3P43tJL8N6CKZ2dMwwlkkPvofHDIfEBqYN5w0tpybzAccHvPE9HH+XY7LeJAPLBVf/O53B+Syon2SYfMV8IS+7GT/A2sX7jcspDj8WpRGHx9fwPL53LCmnuEzTctrNpAffw+W0QMopzhtaTo3kg1sJXU4h/i7HZL2pl1OuXIxh9NjpDM5nQf0kw+Qr5gt5uQvjB1hwcBMupzh8N0ojDo+v4Xl87wxSTnGZpi817cKkB9/D5XSWh9vpk56Z3u9kSy6b4fJSDj/vdjPppPUM61quXKdD1zOIv8sZXC5M1LNxhI9fOQDd9TBcexg/WkZ6mHh6mHh6GD86rmkFa50g1lJBrDWCWHcKYq0WxNogiHWXIJZkmVgriLVKEGuzEBZnn1vhdY8QL+22CGJJ1u1tgliStlCyPm4UxJLMxwcEsSTLhKTupeq2I5xGyTKxSRArqnZCktfO0GcaadN2nO4l6+NtgliSabwvorwk+xOSaaTrA3hsGfP+dzqD657gOLscI/FBOvA9HH8X4SrLpz7O5vQ6jtEr6G48w7WH8aPj7PFMPOOZeHoYP9pmtIK1ThBrqSCWZBo3CGJtFMTaIoglqfttglgj+dgc1gOCWJJlYq0g1iZBLEn7tVkQS1L3kmVVUvdRtV9rBbEky9ddgliS+ShZviTrkGT5ukcQa7UglmQaJcuqZH2UTKNkfyKq+RjVvtx9glhR7edI9jFH+hMvjTokaSckeUmVL31N51Vb4XWvEC/tJHUv2QeAtpbudwN87czOoaVC77Glc2hG9mA1mEPj9tZ1OoPLoaB+3DD5jPlCXk5g/ABrovcb7wnD4cejNOLw+Bqex/dmekrpIZja0T1hE5j04HugX70n7CjvR6dPemZ6v5OtuQKdD4U4cNxYT4LlLtTHD3D8XY7JclevB1w+cfYFdDeR4drjDC47tDxMZOKZyMQzghUtrPOFsIJsGPhr18k8J21vcXyQDnwPx9/lGLULbpBeOXsJ+plkRj+1PcqTGD6TGP1AXu7K+AEWfPEWt0c4/CSURhweX8Pz+F6JtEe7orC0DuzKpAffw+3RlW0D04bzhpZTM/kQ/p0PiL/LMVlv6uWUKxdc/e90BuezoH6SYfIV84W8nMz4AdZu3m9cTnH4XVEacXh8Dc/jewtIOcVlmpbTyUx68D1cTud4P8Y5/vUzTH3GuJzdpjrEz9H6YCS/3XIybH2A+Lsck/WzXh92DalX0M9kI/opVcKUH8wX8nI3xg+wpni/cX3A4SejNOLw+Bqex/fWkPqA6w6tD7sx6cH3cH1YQew2zhtaTo3kQzJZCVtOIf4ux6SdrJdTrlxw7V+nMzifBfmUw+Qr5gt5OYXxA6zdvd+4nOLwu6E04vD4Gp7H9zaTcorLNH1XbwqTHnwPl9M7yXiXpmem9zvZkiu7XF7K4ReTnYyu5fBTvZ1Mfsnh9xUAf6oZ/BzgTzOCX6jl73Qj+NmafvYwg18C/D3NlJ8a/72M4KfTgD/DCH65xn9vI/iZGv4+RvD7avV3XyP4vbXyv58Z/dTyd38j+JUs4B9gRj81/gea4V+z/wcjfMm5CMA/1Ah+Mg36OMSpuziTJogf+iIHofAxn/+ARf0gri6CZarfx6UN86fjvkMQH6wDP6xDmsTqZPxM5OnBAenG8XcHcKXp0I6egTNUnWi3VhCrKoh1jxAW17dthdcyQV67CfHi+r+tYO0uiBUXwtKOfqyvFV5ThXjp62kRxZouiLWHINaeglh7CWLNEMTaWwhLO/qRplZ47SPI625BXvsK8dLX+wliSbUd+np/QawDBLEOFMLSjs6dRgUL1pDNzndles3Od6WLZue7MiWz813ZtNn5rkze7HxXph/66tAeQhy4bOH2TW5ckQn9LijE30W4yvKpj+/2JHyofuj+nb0Yrj2MH62jezHx7MXE08P40b28rWBtFcRaLYh1pyDWBkGstYJYSwWx7hLEWieItTmiWJJldb0glpTuuXY7KmVVsj5uEcSKan28VxBLsg5FVfe3C2JJ2gnJtlbSRkvqXlJfUS1fkn0TyXyU1P3OYCe2CWHpazqGbYXXSkFeuwvxksTSbnlVjtdUQV5SutdulSCWZJmgc+mtYMWFsLSTKhPaVQWxVghiSZYvSV5SZTXKtnCsIC/JsiqZj5J2Nar6kiyrdG41KnVb0n49IIgl2f+6TRBLck5hnSCW5FhhrSAW9O9hHns68ot5/82uASSHvAYw3QyfwDWA6Yxeuf2wgnxKYfIZ84W8nMH4Adbe3m+8tx+H3wulEYfH1/A8vvd6L+N6CKZ2dG//DCY9+B7oV+/tf1V8YNpw3tByaiYfwn8DFuLvcozWGzeoXOzJ6JErF/BsD+NH+/QzmHhmMPFweU/3vrWCtUkQa40g1jpBrM0RxdogiLVREGu9INZSQay7BbEk65BkPm4VxFotiLVFEEuybkuWL8k6JGlXdwbd3yWIJWmjwRZy71EJ9j+S3HtOgvi1dw72DtAFjp/uxQF/7j9gUT+Iq4tgCafNDUpb0Nhtb8RnBrr2w9q7SSzu3TgTeTrD8U83jt/su4DZlNl3AbM5s+8CZipQ5vdF+owR3e1vJC8Loc9Sgfi7CFdTdWp/wofqh46HDmC49jB+dO/eAUw8BzDx9DB+tN1uBWurINZqQaw7BbE2CGKtFcRaKoh1tyDWPYJYkrqPalndIoi1ThBLsnxJ2pxNglg7g+7vEsSSTOPmiGJJ1u31glhSutfXdF9uVMpqVPsAklgj7fZIu23Sro602yPt9ki7/dJrt7WT1FdUy+q9gliS+pK0OZK6v10QS7IOSbbbUbXRUe1PSKZRsu8rmY+Sut8Z7MQ2IayYM3h/TitYMwSxpObJ9fXeQlja0b3HrfAaK8hrpRAv7VYJYlWFsPT1Po4c1ktd9/qavjvRCtbuglhThbC0k9TXfkK8JMuqdpJ1KKrlPqppfKnbQkle2o20Hfa3HdrdKoSlryX3PEjpS19PE+S1QpCXVFurnWT7KKmvKLYd2j0giCU55rtNEEtyTWedIJbk/MRaQSz6fhveGxbz/nPnxet4Znq/k625UozEB+nA93D8XYSrMB83SK/7M3rlzrsX5NMfI/iYz4GMfiAvD2b8AAvOycTvt+HwB6I04vD4Gp7H9/6XePF/D8HUjr7fxp2Vju+BfjuU/CMxMG04b2g5NZMPqdDvt0H8XY7ReuMGlQuu/nPlAp7l8ou2+2Hzi8PaIIi1WRBrjSDWJkGsrYJY6wSx7okor7WCWEsFsbYJYt0iiPWAIJakvjYKYknWxy2CWJLlXtIWSubjbYJYkjZHskzcJYglqfvVgliSvO4WxJIsE5J9E8l2WzIfo2q/JMuXZH2Mqo2WxJIsX+sFsUD3MF7B45uY97+TPBdzRMd6mRiJD9KB7+H4uwhXWT71sR6n1wMZvTbzfTHgCtfYD8cz3N/x0m6TINYaQax1glibI4q1QRBroyDWekGspYJYUt9G0m61IJZkfdwiiCVZviT1dacglmT5kqxDknZVskxI2tWo1m3J+ihZh7YKYknWx52hfN0liCXZB4C2dpznh/vb+DwS7IfjCerz4+chXDfzXMz730n4xRzJPnZv6PM6IP4uRicm+vyHhNQr6O5QhmsP40f3rhzKxHMoE08P40fbplawtgpirRbEulMQa4Mg1lpBrKWCWHcLYt0jiCWp+6iW1S2CWOsEsSTLl6TN2SSItTPo/i5BLMk0bo4olmTdXi+IJaV7fU3P64hKWY1qH0ASK6rttqTuJfsAkjZasj8R1bI60m7vuDZtpE/eHNZIn3zHla+RfuGOK19R7BdqJ6mvqJbVewWxJPUlaXMkdX+7IJZkHZJsO6Jqo6PapkmmUbLvK5mPkrrfGezENiGsmDN4j1MrvJYL8pohxEtfjxXEklwfktTXNEFeq4R4aVcVwtLX+zhyWFJlQjv6bnMUdC9Zt6Xro1Qd0td7C2FpJ1kfd4byRc8bagVrd0GsqUJY2knqaz8hXpK2UDtJGx3Vch/VNL7U21pJXtqN9E3sbzu0u1UIS7I/oZ2UvvS1ZJ98hSAvqbZWO8n2UVJfUWw7tHtAEEtyTuE2QSzJdat1gliS819rBbHoeUNjkV/M+w/7fLGt0/HM9H4nW3Ju6POGIP4uZ3BbJcenvs93sjNYr2MZvYLudmO49jB+dGy8GxPPbkw8PYwfXfNtBWuTINYaQax1glibI4q1QRBroyDWekGspYJYdwtiSdYhyXzcKoi1WhBriyCWZN2WLF+SvCTzUZKXpJ2QLBOS+XiXIJakvQe7Cn0r2ieY6f1OtuSyWeib4L5MzBkYN+2byMTtFmIkPsfh+3UQfxfhKsun3q/j8g3rh/brpjBcexg/modTmHimMPH0MH60braCdYcgliSvTUJY+nqUI4Mlncalglh3CWJtFsRaL4glqa8tglj3C2LdLYi1ThBLUvcbBLHWCmJJpnGbINYtglgwz0f7FtrN9P6r5jBdyKVThVwqVSoni6VcvtKbzifTfdl0b3+fm0xnU4VSvphOJsvpcn8mWcr1ZkvlYm82Xekr9ubN9h2yvZ0O377K4Lsu4O9uBj8F+FPN4KcBf5oZ/AzgzzCDnwX8vc3g5wB/HzP4BbNnH7i18n+oGfwi4B9mBr8E+IebwS8D/hFm8CuAf6QR/FQS8JNm8Gv2zTWDX7NvKTP4NfuWNoNfs28ZM/g1+5Y1g1+zbzkz+LX2PW8Gv2Y/C2bwa/az1wx+zX4eZQa/Zj+PNoNfs5/HmMGv2c+XGcFP1+znsWbwa/bz5Wbwa/Zzphn8mv08zgx+zf4cbwa/Zn9OMINfsw8nmsGv2YeTzOD3Af4sM/j9gH+yGfyafTvFDH7Nvp1qBr9m304zgp+p2Z/TzeDX7M8ZZvBr9udMM/i1/ttZZvBr/bezzeDX7Oc5ZvBr9vNcM/i1/tt5ZvBr9vl8M/g1+3yBGfyafb7QDH7NPl9kBr9mny82g1+zz5eYwa/Z50uN4Gdr/c/LzODX7P/lZvBr9v8KM/g1+/8KM/g1+3+lGfya/b/KDH7N/l9tBr9m/4tm8Gv2v8+puzp2utynlhKyxVyhz60Uc5VkXyZfSBcr+XypWOrNlPPZZMntz7n9KbdSKBSz2WJ/ttd1K+XebKVQ497PYrfi6vP+JRN6cSs1u1BG+DEx/oUafsUIfrJWr2Yb0U+pZpevYfI2lSnl+orJfCVfLBYqqhFNldS/nCo1lWyq2JvuL6pSVOorF/vS/b2p/lKqlC4XlK0pp3tz5XK9zbpWuty4yZrerzOi9/p6wvXiei9s/6u/2XmHt0kCzo6eg+JqJ+m6wfsN3yPVbk61HmYO8sfhH+168b+Ob5MXXzdKj4Pi0Q7SnRBP93a99sZIfI7D70GC+LsIV1k+9T1ICcKH6ofuQWpnuPYQP+3omnQ7E087Ew+H9YAg1lJBrLsFsdYJYm0UxForiLVBEEsyjesFsaJavlYLYt0jiLVFEEuyfEnq605BLMnyJVmHNgliSZYJSbsKexU7ncFtoVzbnEtDW4vHHeDAD48bYsSvjMKfVK2Hoy5OfuM0jVby3IQ6Lg1H+eB+Uwnh+/UZtAM9diB/yT4O4HeawU+D7kc7A3VK09Tpoyvw5/4DFvWDuLqcwXo30T/k0ob50/oyGvHBOvDDGt0kVifjZyJPOwLSjePvDuDKpYOObzh7xPW/IXxnAC8cfhwTNzwLOuxCfoI6TAXpENdFiH8s4lkq9y2efca82Q5xcaIH0NsUEu6Mal0PtAyO9sFyyO8p5F4c4WFndsy4Y9sBSFOz7QDWbYn4DdXuaUdtA9W5djqvf0PmFuJMmmgZ8ptbiCN/HP6Po+rx/cG7HoPiHBsQZzfhjcNrd0Z1YPhdUNriTJixhCOE/z+Pl86/73j5x+kO+HSS519KZRnS1GxZxvlIuQEmlB2at3750ja6zuX7E+qcaXzdAemA331MfMC9h4TVDvJ4PLovOMcV+jtpEH8X4SrcDtX6MOMJH6ofsC1ah2O86znziqUTivMXLp5TbiOqHIeuMXwPgYMwOCx2PYiS4xOOZrt251QHP0cdqLKdcN7HK37anIz1rrsdvnhp1+kMTrNgFvWHLTIQf5dj0kzVi8w4wofqp43ox1AR7os5g4trnIkT+EJejmf8AMuzOgNMFw6PyzEOj6/heXxvqleeepzB1e7M6kAOXJXE90C/upxOIuUUl/vrqgP92pk4wa8jwG90gB/uskIZAL8u9Nwc8twYBlNzuGZ0Hc+vrOH8huZ+nDO47PvZIj+sWQQLPz+eYE1ogHU2wcLPTyBYExtgnUuw8PMTCdakBljzCBZ+fhLB2rUB1nyChZ/flWBNboB1I8HCz9Pj23ZrgLWAYOHn6ee2pjTAWkiw8PP0eNPdG2AtIlj4eXrk2tQGWIsJFn6eHm86rQHWTQQLP0+PXJveAOtmgoWfn06w9miAdQ3Bws/Ds90MFm2f90T3d0T7DPF3Ea6m2uc9ncF6xfqhy5Z7MVx7GD9qt/Zi4tmLiYfDmiiINUkQa1dBrMmCWLsJYk0RxNpdEGuqINY0QSxqtxq11xdWX/wf1F7Dc7js4nBxFIZrozGGX38g7oTvF5xDOHNxcn3MG6oD/fAULu0P4ulG2ifHU7HjiR/uY1K7j6dpJxC/McgP0oP7mO0kPdd7981O9ySTOL/8dEXHvdx/xwk3HchN6QaNa4caD8Y6qTownuGfckmWw6QDx296ygV0MTFAF5OMxJ0JPf00iehioiFdQFlsNC6gSzxc338iEx5PV80uL1KLJscvvaA4exQKis0QpdNNwo0nvyf40JpJwk0iv6F7QXlgLOwoj6DpMC5+zozAdTtzXztu2NRD4uSyjTudq4d5fnJAPBNbjGciE4/ZU1CShk8pqa+6ckNVnCaIP+g0ubBmAOIartPeuLQF5TN32lsQVtgTygDL7Mk29TwNOuUOx9/sKXd49Q7budFeX0p3g7YETB3SZsnMbp50Lmx5hPiHa+dv2J0HXNcWnu0hftrRrxpwuwA6mHg4rE2CWPcKYm0UxForiLVUEEsyjZL5KJnGNYJYkmm8SxDrbkGsOwWx1glibRHE2iCIJVkmJOujZB2SLBOS+loviLVZEEtS97cJYknq/h5BLEl9SdrC1YJYkvqKqi2U1JekzdkZ+kySZUKy3ZbSvb6mJ29HpdxL6v52QSzJci+ZRkk7IdkHkNTXNkGsMG/HcuN6CM+9UcDNS+0sbxRkSTiJNwqy5F7c4d8o0Ni/IW+r07cRtDM7H5tOxUh8NI0Oib+LcBXO/9qcFbf9iJv3BN1NZbj2MH70q8Tc1qSpTDw9jB9tt1vBuksQ625BrDsFsdYJYm0RxNogiCVZJjYKYi0VxJIsE5L6Wi+IJamv2wSxJPV1ryCWZFldK4i1M+TjPYJYkvqSbIdWC2JJ6iuq7ZCkviTtvWT5krQ5kvVRskxI9pmkdK+v6RxMVMq9pO5vF8SSLPeSaZS0E1Htf20TxII5GO5VFbpFnhvD7h4QD35+9xBY3HgYwnOvtgTN9XCvtsDcg6FXPFJB+cG9HjOUuR7Qm0vC0bkebNum+WA55LdL7vnN9dB9S8u8iSzQr6H9aOzWbLpfEe8ZpfsiudcV8T1afvHzEM5sGps/baCH+JWRH92qX0FY+LQI6uLkN06vLq/PN3ESAc6Pkg9mOxM2Rvwg7B2ddR6/8XgMd96bmSscvryfVa2Ho47Le0iv1vnvW8x7uv8V8+Zex8Vz5NgPuNJ7NB/x8+MD4tm/xXj2Z+LpZp6L+fyHeOg9Gg/HOWi+fajxYCywFWbn7psv/1TPuPzTvbkV5EdPNcMnNeN1IOq4ugG60HUjPbGOS8OBM3uy2/DpkL4ihnWI6zZ1nA5BF2F1OM5pXLe7mHRw7QR9p6HZdgI/Py4gns4W4+lk4olaX2Qi8cNlib6miMvSrsQPlyW6LnYN8osRv2uRXwfxw6eO0xPw8Inh1DbgE76btQ24zzQ7RLkO025i+18mfqMZXLOvrqXTYdoXHH8X4SrLp77eyr1Sy53YCLrbleHaQ/y0W1Gth6N+ceZeWwDWBkGszYJYawSxNglibRXEWieIdU9Eea0VxFoqiLVNEOsWQawHBLEk9bVREEuyPm4RxJIs95K2UDIfbxPEksxHSfslqa+7BbFWC2JJ6kuyDkn2JyT1dacg1ohd3XF2VUr3+pqut0al3Evq/nZBLMlyL5lGSTuxXhArqv3VZYJY0F+F5/AYH885G16XS+3IMza4NWY6pgd/7j9gUT96xsauZtIWeMZGUDnAa1B0nb6VMzbouSymz9iYHJBuHH93AFcuHZMEdRLmyxfc3FKzecuduQPPGq5jtb0LkwL0hONv5T2VFAkH65FtzuC8m+yD5ZDfKXLPb+8ClCN8tgusb+k547O7eM74yGl8ps145I/Dr0dfcTzPux7nDC5PkC7uqw9wZJvZL8c0P8/fTvzKTHpiDBY3Rw5pavYLB/hdJvqFA8D0+8JBB/LH4a/qqnP5/lQeM4Yw8Ttd9OsXsI7Q4dTTjcNQDhC+H3GAr19QzIRPukb7YC5FZbHSxWM6DCaXri6SLsqhk3CA8NehdD2PNkjhMPAbl5O51YHcxjBxOT73MDZ+lvoFxdvoWX2Nv35B/WhZofrCz/vplJYVCL8woKx0MBxwemm+Ug40TJcPh5sZDvh4v/5585d6X6NwiKMf1Wknv2lW0izoYHD8HKhBP7O0i8fB4cDR4oeXYUczcYz24Yif1eqB7C2V55QXlX0U1EbA2n0ia3N4x30+AGyp4a+RhX4Pk34VrsMMn8CvwnHvK3NH2MKzPYwfXd8PG89YB9XnRfMW+JUFXCi5shD3iT/GPO+QZ2PMPccZ+E4v13ehaW72C5WdTHq4eHpajKcnZDwTW4xnIhMPxeL6kdpVqnV/HP5eZF9fmMpjtvlgwmcuIDzXt+f2nEB4bm5iEpNG7v36XZ3GcWNd0vZocpNcG80NTCJcuTFmWK6zhplre5NcO5m4cZusGp1rbyovOGveotopzA5DwyHXtD2mYWgzM9qH6lgSjnbD6LQNNXUTyO8xDD/OcaaOcok7jR3dkvwGVEV/5lNFHYevolDs6bAUP4uHpVAkbmLCQZw3k/Tg8DhOCL8ExcN1/W4i6YbwjzNdvx6GE/DpJM/LNvH5XtDhUmewA79bnIFpx37LUPgTq/Vw1HHDWEiT1sWzTQxjcT5SboCJmwyct3758jQexpIP9eH4bnb80wG/40x8VJfgrx3k8TKCMdP7nWzJZYsxEp/j8N1KiL/LGaxbE93KZYQP1Q9nhgM+1LcUXWP4SwkchMFhsbsUUXJ8wnHZvhvzHHWgynbC+StotuEjxGzhqk+/L4o5xJl7tLeVYPhz8XS0GE8HEw/dHaod/aDbDc7gtILfXPQc/fjaPORHP+g23xmcLvC7MQBzQQDmwgC/RQF+ixk/zemEsXWO1BxzVYN+JA7nnV898MOaRbDw88sI1vIGWPQjcfj55QRrRQOscwkWfn4FwVrZAIt+JA4/v5Jg3doAi34kDj9/K8GqNsC6kWDh56sEa1UDLPqROPz8KoK1ugEW/Ugcfn41wVrTAGsRwcLPryFYaxtg0Y/E4efXEqx1DbDoR+Lw8+sI1m0NsOhH4vDztxGs9Q2w6Efi8PPrCdbtDbDoh5vw87cTrA0NsOgHlfDzGwjWHQFY+pq+XYKfv4Ng3dkAa3eChZ+HZ7sZrJj3H7pfd6H7ct0dN/Ruf4i/i3CV5VPvft3lDNYr1g+d1dvIcO1h/HBbhP1wPBuZeDispYJYywSxlgtirRDEWimIdasgVlUQa5Ug1mpBrDWCWGsFsdYJYt0miLVeEOt2QawNgli0LQvq1+trWOQN6tfDc9ie0emhOHkGh8cYfuOGOOK8rAHnaYTzUMcP+noGwRrq+EFf702wWhk/nFUdiDXU8YO+3ofwGur4QV8fQrCGOn7Q14cSLPw8tbmNxg9LqgOx8PPNjh+uIFhDHT/o68OcgVhDHT/o68MJ1lDHD/r6CII11PGDvj6SYA11/KCvkwRrqOMHfe0SrFbGDymCFTR+uKsBVppg4efvIlgbG2BlCBZ+fiPB2tQAK0uw8PObCNbdDbByBAs/fzfBuqcBVp5g4efvIVibG2AVCBZ+fjPB2tIAq5dg4ee3EKx7A7C0O6U6EAs/fy/B2toA6wSChZ/fSrDuc4LTeJQzEAs/fx/Bur8B1tEECz9/P8Ha1gDrGIKFn99GsB5ogPUygoWff4BgvbIB1rEECz//SoL1YAOslxMs/PyDBOuhBlgzCRZ+/iGC9aoALO0urg7Ews+/imC9ugHWyQQLP/9qgvUaJziNxzkDsfDzryFYr22AdTzBws+/lmA9HICl3ezqQCz8/MME63UNeJ1AeOHnX0ewXt8A60SChZ9/PcF6QwOskwgWfv4NBOuRBlizCBZ+/hGC9cYGWCcTLPz8GwnWow2wTiFY+PlHCdZjDbBOJVj4+ccI1psCsLSDXUnjmOffRLDe3IDXaYQXfv7NBOstDbBOJ1j4+bcQrMcbYJ1BsPDzjxOstzbAOpNg4effSrDe1gDrLIKFn38bwXp7A6yzCRZ+/u0E6x0NsM4hWPj5dxCsdzbAOpdg4effSbDe1QDrPIKFn38XwXqiAdb5BAs//wTBencDrAsIFn7+3QTrPQ2wLiRY+Pn3EKwnG2BdRLDw808SrKcaYF1MsPDzTxGspxtgXUKw8PNPE6xnGmBdSrDw888QrPc2wLqMYOHn30uwnm2AdTnBws8/S7De1wDrCoKFn38fwXp/A6xXECz8PDzbzWDFvP+w/vQBdF9uvSfjxkh8kA58D8ffRbjK8qmvP33AGaxXrB+6/vRBhmsP40fnHD/IxPNBJh4Oa7kg1gpBrJWCWLcKYlUFsVYJYq0WxFojiLVWEGudINZtgljrBbFuF8TaIIh1hyDWXYJYGwWxNgli3S2IdY8g1mZBrC2CWPcKYm0VxLpPEOt+QaxtglgPCGK9UhDrQUGshwSxXiWI9WpBrNcIYr1WEOthQazXCWK9XhDrDYJYjwhivVEQ61FBrMcEsd4kiPVmQay3CGI9Loj1VkGstwlivV0Q6x2CWO8UxHqXINYTgljvFsR6jyDWk4JYTwliPS2I9Ywg1nsFsZ4VxKJzjo32yV3pXQftk4Pn8LwTfcUwTp7B4TGG3z68OOLcaD/eVYTzUPfj6eurCVYr+/GKBAs/3+x+vN0IFrcfj3sP7obqQL8b0HP0HYa5yI++WzcP+S0lfvORH52XvhH5LSN+C5DfcuK3EPmtIH6LkN9K4rcY+YGO8Htw8H4k6GiWd7+TpA3K4Ezvd7JFx30tjeoR51vM57/jDJ5j147aAPyljBiJZ6lgPBjrxOqL/6GM4vJLjx+4hcRD79F48PO3+GDBq9na4S+qzUX+OPx5Xt5r7F9OHYjJ7U2+Ad07IyCt8CyUKWrXZnq/k605F/BXmsFPB9lfnCZaB7HumilfOK4ux2HblZlCugtKG+ZPyyFuD8LsG1/RJFYn42ciT5cHpJuzuRxXLh1+dRPHE3Q658oAXjh8UPsMOsRtpKAOU0E65Nr4oZzOCXqbRsLRL4tyfR2K5ZDf08i9uMOfzsnZtk4fnhBvIzuOn4dwQUdYhLEbXDwcZ4gHny+ATxudT96Vh3KHj/zA77VMQf44/KYJdcyFHib33o1fXYmh+PDZBPSoGIjP76iYuT78lqB2j55UOJdJ85QAzoCJz3/AnOEcBsphBel3GWoj2X4XxDWO8KX5Q9PC5Qktd0sYPfjpVjvcT8H9GBx+TZP9FFy+aT8Fc4JnubEe1QMXT1A7uSRkPF0txtPFxNNqP4SLh+NMx1TaYXtyD7EnUO5w3cLPwnvw7ST8cmRP7g2wJ3R/Cu07URtL7QnE52dPaPmE8A8E2BOub35O1Z8zYGJ7gjlTewLhX03siaH+E2tPIC6uvRzj8PpwnHDt5RhGD6bbyzEknuWC8WAsqCtcX47an2b71vh52pf1q6+Pj+Xj5Oqrvsb9Axz+RFRf307qKy7voHOu3NA2ajkTb8wZrNM4cy/Ili33wQrbRkH4pwLaqKCxhnZBY+mgOUccDocJmv+LB8SByy2+D31j3HbOJWFXkLDLA8L6jRv1db93bXZsn69AXcBzmODAr8pwBr9VKPxF1Xo46uLkN07T9q/GT63j0nCUD9ZT1QeTsxf09HBIcxuDu5LgYhtA9QXnbNH6/w2vLuj6/9mxPB4tJ9pd6uGZHb8WkjR/saP5S/VDHZe/wFvn77RpdVwajsaJ83AV8cM2m57thm09YGjdP0/6BFGrS0OpL83ok6svnD7pGgHXdmJ9thOMeHc9zI9JeYcwtL3QDuoP1FnQX4J5Xjva94PwP0Ntz+xpfPxB9c1xeLuA9UDPZKw6PBcuzbVoPD1BecR1TK48ZlzIx9WEM457jaG4YyQ+x+HnedcglVA+wLuL8Uu0wDXr5vOpXKaUrfTlCtlsOUbwgSu9R+coubMgxjHhQdfrjOg6XQIbEK/W8dcivWqXQH5riF878gOOug5dN20g/7WG+IfRP46/hwk/q1oP10xe9jDx0DFHK1jLh4g1wRlYB7i2EPdtaFuI+y/4HNC9UIPB2cUgWwe2jdp9nE5qB6cTW1dFzwiWoQzXH6W2brWhuMPaOoi/2/HP2y7GrxVbV8pm3EylN9tXqqTLpXwl5gxuE+LMPWrruHK7CxPesK1IcraO2rME8ltN/LCtA46crTPTLqaTYfSP4+9hwlNbFzYve5h4qK1rBWv5ELHA1q1Cz1e9a87W0X7qSiY92NbRcdk+xCaZOfqenyOkNhXz1Q6PoVciPVH9Uhx8D/eb8TN0zgbCH4L67Qd28/wgDWcy/Lg9RThdh3X7h1vJhNPdeOhHzS4vOv+a4oJy6fxy/4LyorjD06NJpMmnwymHhNOOfvlqIflNp29uIDjQBIf98hX8x1hc1mFs2vSCPdQmbDExYXNJXDPhmRYdN3SkTa2ZZbxU6GEFxN/lDC5yJraPcFObWD+0eTSzLJFK6g9f0qlv7a6tDtYN5QHlhW4DBH/uP6SX3qPNBC6LtNwEmUA/k3UmMlnHdtfDUxsQZstWmKV4fA+HLxM/vHQWC8Cn0yAnonr8PJkKxV0dSEfto5PIT7KeaR5L0BQTLU+4G+VX/rnPN0D4oK1k2sFSQ9DWIq5s4bIEZYTLZ3iGWw7vJlybXfrvZuIxXae6SXpwOaZdvGaXHrny22gJ7VKfOum3hHYk8sfhs2gJ7QqSn/h5rOft6arW/YapzqSarTNcPgTVmUZb9kGH3BLrJdWBflyd4fRKy84NDAeunePKDoQL03/A/OTyyA3df4D4h6v/MDekXkE/t5jRTzKMjeDsGrfMSW09rvvcsIRbhsPtBB3G3eRV9qAtBUF1h1sa3779jwxXTPeDgurDUOPBWPDZFvj6G4wlqqgPtbLb/3n4VEsHeobbjkDTg8sQbhvWkLYBL5MELcvTsc+/x9cxbxtiW29ym18j+04/gYOf9+uHjmF46evrvGvIY5gi2Yzy+G6fYbh2OH+2kvzBtpDLH4ibG97DsxiXcnwAcbw/oO5hjg/6hNPX1zuDw1Fb5Dh8P4TmIZ6e4MLTbQEQ/jUh+/NQHsz2TVy2P4/zn/ZNwrZHVE84PMYAG9RDwlMdagfl4klULh4j9Zuzo0Otw379SD/bb3jasDdsHwXi73JM9pnqfRTuE31BZWIFw79c9Q/fqAxBeG32qZ3vQVgQL35VbCW5R9uooD6Ndtj2PNPNY+D0cf0iOJ4eY4Sx/c2WZy5NUag3Yco1F09Qn2mJYDy4PtPXsAy9WpcB3d+KeHJ9ZLqtrYrSECcYXHg630jxqyQ8PJ9w+G22UB9ou/cvZLM/S9reoDRqB59jjDGc4kwYuqVzlVOPm+N8LuEM4b+E2mq6bZ0bu+DtXXSrPoT/KsJ8YSrP03HC2VFuGW0VCgN8uO3Tq8lzeLmuSuLhsOmSOYeziuDQdLahez0MNrdkrGWm9zvZogO8NR5eAsWxluHTTsL/iJTj25yBOg3SmZZ1TLz4+MMeEu86Eq8uQ5umDcQEbng8gPOd5gntp1KeFeIP4X+O6vNPSbuH22vcPv7Wp8+Nxw9rAriuZriuQnEtrQ70h/C/RvraPI3nivlgrjtu3pDvmw+Y96gO1A9nP7hXIJq1H9yS/krih9tian+5ucGgNgbnAxcezwvg8P9gxlZB840a/18B8xZ0DmAJSkNQO8WNd/H6w/+6eVy/177gs6x0reu3aJ6jbRc+bu1wHUzs0lzcs3zifiOKe5SHGTTHItn/4/IKb6mg+RI0r9fDPE9fZTDxehOOk2ufaV+/2deb8PN+r+qDv3aG+7Ohx64QfxejExNjV25sGbTW0ugT3TR8lQnP5Rseu2Lb6pB48di1Su4F2eJGdmHPJu0CnjvG4Zciu7A3sQuYF319DduMiQ7PxXGC86iHeZ4eU2RqXDiRpOeWgPQ0u86Knx+uVzwnknj8yk2SlJuhvsJ8GSo36YByQ9ckuTVoLg/CzMEH5cHckPEsazGesK9/vpTL1AlCZeoUVKZmkTLFrTO+VPW8QjAebq6HO76Obvnl2tmVAfEEHR/lV24u3IWPM2y5gfBJVG4uCVFuuDzwOwIJxztce3KGyx4GYXF9bwjP9W2D+mBh1wOgvOA+G5Rts6+dhN9PAvF3Ea6yfOr93VXOYN3dyuhurFOf+yiWF7qpwonl/gVL5y+imQGAPc5AJVcJIIR3yG/6nCaVIGFuYeLQDp8TggtSD3medqgpfhhOjcI28ucq4a0+6XSccJUQP9/smYdV5I/Dz/cMXthzGnDhaeachuU+3ONMGrp8nqO6586mOCMgzRD+5oA0r2iQ5lkkzX7nreHfNFycScNoh99UEXSWzCRnIPdmyxN+frg6K5NIPH6N+xrSuDc6e2U28sfh98Cbg0jjznW+Taff70wmnK7ZKIzf2SAJBlM7+oIIhL/bS7vhiR/2Xaeg94PwRvnNuzTWTVCe184VQ3m+NUSeB9Uf7qyxIFthdUfGLSfDlHEcv/UdmR/GBiq5SgAhvEN+0+eCOjI0rF+lbrUjw3HyC9tsRwaPAGhHptkdI/h5CGd2N1Vq0I5mvKpTRXH6HXSId1gEjeDo7iuKTxsA/LImpzu6wwLCvwl1YrZ6q4ZcXu3qw89xwuUVfn64dvfsSuIxMYurHZ3RGO7Oul8ZhDc4GnWSnm6ywcSDBBz+Qz11zGdJgxl2F1mYmVpa5h0n3Ax/UH0LW3+ojhIMpnZ+B9R+g3SgzLzZmk3uuFW7bOjGn3bouF0VXYxfS4f15CtuMpfLpyupYqGczdE2ErjSe2FW9PZgwpudMcqwh/XcivSqXQL5rSR+7cgPOHIHWJjpmGVKYfSP4+9hwtMDZ5udNZbAgkMnuMH6jrJlYT9cAeG/FzChwR2gjNutoLegl5HnuAOhtaM2UbuZ3v9GJanSwEF8kD+jGC70zSAI+wLSy7ZpA9Pit/Mn4ZNenDaHwfDTHY2DO8TjGmcgtxUhuHETTxhjiQ9PjTFcO1C4eKa3GM90Jh6TK184zkb9sb82uSJ1c7Xuj8O/DfXH/k76Y9xbRxAfN7GK+0LURtKddzQMtTcQ/j+oXjX6YABOZ1A5C/vBgNqBqd7JMDtyQoumOeHUd/di+3hqdWAaIPyXvDRo/bePaw7zNB/MFMIc3STm6T6Y+yLMMd41Vx4nOwPj43aCcjvce5jn8a5bzEU4f2sfTZpvBr/2gZ15jC5wmiB+zsY0Y8twXMP11jqXtqB8xh+PoyvTHNa8JrE6GT8TeRr0diSOvzuAK5cO2q/g4pnM6ATC3xjAC4eHOozLPjwLOsQf5RPUYSoov/FHAiH+oXw0CfS2GwlHP5qEdT/fB8shv3cj9+IO/9Gk7SfQeO05N28y1oczcKD3aPnHz9Pyb8Zm5vu5ndLgaF+McqQuTn5j3jq/H51Qx6XhMAYtx34fIOVsrh8GN5fbqN5rhxcjYMFz4aJ5C8rnLLj2puKi8kk3lecuYsrvaGdg+mi5oyfRzSdh8fwsDkcXM+eR34vI78UMH+qoTrDrZsL5uUb140B0PZT6gZ8Pmr/cq8V49mLiCcI6kMEKst97MeF3Fvu9LwkHY65W7Pe+5J6f/R6uN6YpFh4/waYTXJdpH/1iMh4y0/fpTYN9x7YTdAZx32go7hiJD/SN7+H4uxk+wLuL8WtlfjpVSLtuQS2hl5OZZLGUDKrL+B6t+wuY8Acz4UHXi8zomj1geQHSq3YJ5Hcj8WtHfsCRm582Y596Q+kfx9/DhKfzJWHzksOaNUQsmJ/GNh7q9nDZJrM2pfn+JD39Ac/H0I1ceL0Hz6VTx/VDIb3b3zAN0Q+l6+KY9zhnsA5pXjU79uXGmmbnM4Yvr3Ddo47LK0hvs3mF8wN4m7VNw6dDbHOo43QI6dU6/H0TOsRljc7JY1tLP8gcFf3GiB9eJzypWg9HXSMdPteEDrl5/bgzWE83MFh0/NbH8IF0LnYG8sf5px1dD8TPLyZYSxpg0c3S+Pkwb75grLMJVtCa7PIGWOcSLG7jOmCtaIA1j2D5napNyxWHNZ9gcR+iA6xbG2DdSLC4NXnAqjbAWkCw8PNVgrWqARY97RA/v4pgrW6AtYhg4edXE6w1DbAWEyz8/Bqf57B9066buQd13ewHRdymP7TFjX9MrA1weuf6uaC7tQzXHsYPt9vYD8ezlomHw5oriLVMEGuBINZiQawlgli3CGItF8RaIYi1UhDrVkGsqiDWKkGs1YJY8wWxFhIsbmzN2baxTn0NZPs6wAnF+QsXzyk7xOH+JMSBfy/yib+Hed4JwMLPBKUF9zXpXAjYX78TceneEQj/CW+eEp/aFPS8dkH7zQ2v9abCtqt0zd3UfgWqf6y/oJeJuPmjHsaPzkncEDIeiTKu3UlVPv4Y87zTAAt+c2tMuC7tSTAWEb70HrUR+HkIx8WzV4vx7MXEE4S1J4MF4bkxUtAaU9CpqIZObaqtMXFjVm6cNZQ1JtDbNBKOrjFxY1eK5ZDf08i9RmtMOE/n+/CEeBuVFfx8UJm8ocV4bmDioVh+L2jTtSwI/3eyloV1L1e+Cumg94vMvudRCL2W5Xc6HebdxfglWuBaKaSS/elKOZlN9/X1J0tBNqPZkz72ZcKb3cNZYNey8Dyldgnkt5z4tSM/fII4XcsyYwcLyTD6x/H3MOFp/63ZExMlsGAtC7clULeHyzaZtSnRXcvCe3qaWR/B+UHXshYz6Qhqs/G9oLxaHBDP/i3Gsz8TTzfzXMznP8RD79F4OM7cOAa/PzCup/4Mrif4/QH87E3Vuj8O/xB6f2BCwN4qOidE6wQug9rReo9PuQ3TvkP43TxO3PsD3DtQN1X9OUMcCXQ/6H1OCD/d42C2neffHwh6v4zORTb7fhn3Tq7ZNOZL1K5hx9k1utcdz2nRvTtV5LeA+K1CfnS8S+eQsN8a5LeI+HFzueC3DvnRd+HxSe64jFLH2WZ8CNDsiXVcGs4hceJyQ9/J5d5l5/YLHoCusR9wpfdoecPPz/d5jtoRw3sTXcN1urb/n3u3EqeJ9t25daEw7QuOa7jWbbi0Be11wusedN2Cw1rWJFYn42ciTxcEpJuzCRxXLh10PM/VswMYnUD45QG8cHjuoKPhnq/hdCg1XwN6O5SEo+904DK4zAfLIb8PJff85mu4d7RwP+7UHp5z2HM5IPxq1I87A13TuUyMNccZ6DcH+S31rg3v5ytw8ypUd0tR3HQMdAuTnrBtKd6z9+wQ9+xhbhgT59/NKIzfWsdlqJ/7/ak8Zszh+/a0rw1lIuy7uhD+yoC+NoRJ+KRrng/mIlQWiz5l3WEwuXTdSNJFOcwnHCB8GaUL1pEcx2Hb2Tno99zqQG4LmLgcn3u0LVjg4xcUb6Nn9fVN6Jpr62l5vZmEh3VKP53SsgLh5waUFe5dqKC90pQDDXOjD4cFDAfdTozx/PvnzV/qs7SUQNfUPHNZSbNgLoPj50ANOnlQHSgO/A4qftyynONzj2YDPIvPvCuV55QX+a29tRGwG3wia3N4N7IOW3NDXoe9keHaw/jR/mLYeIa6DkvLwhyf+GPM8w55Nsbc005XljtGvXjNjUXp3EezY1GuclAsv7M4KtW6Pw5/O7JH9At+8xEPDhP2rEJ4rl8cdGBoo/ElxA+65MYpQXFz+34h/PImuXJrPbjPv4BwxfxWNMl11jBznd8kV796CW2YMtLX3lRecNa8RWVcVSgNh1x3kns0DN0GfqMP1bEkHJ32pkcX0XaTtkkLGX6c40wD5RJ3Gjt6nvcDqIr+zKeKOk7wtiZuGz7ucp9KhlzcElZQcQxzDA82TRiDHhME4R8OME0rG6SbVgluOzn3gQ9uazo9tm74P2yeLHEfT8Q6aK+GTy+nnyoTnjvGtoeEx7rilobotC1uwvDZ2ONI+eOOXAxKW9BWPu+n78dt6QcJIfwTAeVvFcOBOy4Vwq9mwq9CYegUdhX5wbNc+cOvHGmXQH6C5a/MlT+sA1r+gtLL6WcNEx4vcUD+9pDwWFfgx30glrN/oHN8tBm3vB3z+Q9c6b2grQVnVgfGY+pjRrAsSO0l15XT10c6A8OvRvFy9pKGBz3jqRYu/+hHqZ9DdWwTKV+4ncbTj5/r4ePG9XsZw5XG/Qs0zfNFYn+47hs9MvcriPuD0/yfp20L7gPRIzv8jkbE+sfpxHlO7RiE/xbi+WqkY+2wLcHT6NolkJ+gLak025atQn5h2rJGtpa2V7ic+n2/AmNhnfsNK7iPs2M82sd7gZnu44Z99EPFS5rkHrZvuAyl42lyRCPWJX1dg8srzu73MM+vCoG1MiC9qxFnLjy2Ezj87xndU8x2hy9LVR/MPyHMXzaJOdsH868B/RGu/eS+HwHhuddEcJsKfLjXBdcSP8ydtptrUPw07LUkfuyH6zCN1wngS9vcRnypbQe/seNf/K/LkuNddxI8YbuYDsrLg5j0hM3L2ndjmPRTLHgu4Qwur1wdWsPoa9R4HrO9ScwuDwe3r1xf54ZqPe6xJO5VKBztG2hHbeAyhhfucwQdLUz7BxMQf6ivQVt1jba7bjnJtbtYF+0oXmw7HSd4WwOEbzTGpn14HP766kC/MN+UwvEMpV3bTNq1oOOig+Yb9PUUEh7Shm081kUJ+ePw+zBlBjCrDIeg/ODKfhWFAT7ca+/wbNTKa1A/scqkd2UL+qHlFdtNeuw/Li/0dVhuOjZsecVHWK8h5ZXbSs3lJZ0/qTJ8bmXSTfXU4RMe8GgbmkNl2a9fhTkEvWoRdn6Aa+PWOHzcuG5WET79kC6EPyakPR+eORnX5eoH1iutH0E61K7ZPmLVuw56XZqrH6uJHzfXGsbuahdUd+BZ/DFlbgwe5tMAQfOLQeNyztZD+DMDbD3XlgbZ+ioTnrMBnO2AZ3fcnABflrEOwtj6oPHOKiZ8FYUJsvV0zM1tPW5ku08IKH9+8zyY69yAtIXtdzW7trEj83441zZo3leRH207ubUvzjZw8zO0vzXU/qZ29FvRjfqbdA4Uws9psr8ZVA5XMeGrKEyk+5tDKIdVJr07sr/J2SA8H5kM8em7oPIXtL4lYYPiDC/cFnOv0Wo30/ufbNEFrcmY/dxYMhsj8YE+8D0cfxejRxPbv7h85T5fZPZzcsmMNlO07Gt3bXWwbvzsTow8D2th2p2LcOh2be6Tmro+bSBzTVw/ED8LcdB+4N1o7uwugsm9Hhe2/4tfX9wzYOxIj5Xi8jzos25VFA8XHrdNOPzWgPHhKoYDV+4gfKM1H/r5ziryW+3wcXP7Bbi2FMI/GKnxYcrd0Wv2tM0KGjviMriKxMO1Rbhe0DrA9bm4+oo/WcfVLXqMJrduC1h0zKgdrMfSehnGVsCRlNRWPN7kmHE8utdsv5jWGW7MGBQ3l0dBNgPnm5/NeCLAZlTRM9yYkOoUwj8ZoNNVzuB0BelUYp9PWJ3SbaIQT1idQvj3h7DDYXUK4T8UoFNOR0E6DWtnwsz9NdIp3dLMrSkH6RTCfzJAp9yxB0E6hfCf2YE6xWleQ57DNoMecUPtXZfPcz0BmFUfTLiPnws6BrjR/gDAo3n51YC85NJVDZmuVULpWtVkuiD8tw2la4lPupY0ma5qg3QtIemC8D8MkS6/PVR07h/C/zhk325nmTOje6iqyG8J8eP2LwWViaGMbxJkfBN05Aj+nHLQ3Brdo/XHkGVgePaE82UAz0/SMhD0Woh2tAxw/W7uaKceJjyMk7ky4PdZaRzPUMrA/7oHhjO1txYfTYXTjccReI7iXBK+iuLl6iIND/UO762tIs50/0ktvPd6Kbe31u/V/o4JfNx+dYXOaUD43SfUMTu9a+51frr/NWjfP/ceCdYzrbcQfhekh6B6C7x2RL3F5SuM7Q6aC6ky4bHtBp1xtpva5xsYLO7ILK6e00+l4DkhwN2+r6G7MX9uLrnV/s8eqFyEGfdUEWbSB3MfVO5nTBiYfm6/kw53yASZuPdnyjlgcuODoFcI1zDh8fig6l0HjbloumleHULsQhWFo3UfngvbH8V+dM4+qF6tYtJIddjhBI/t6fjBZcpZmL0PYd9zavRuSwfRc9C6D9dHCConYfsI3BwaXrfa/ny17gccDc+Rppq1xUHp5fQz1D2RVFdYJxgraO05yBbjsgK4uqxc6mUGt0a7JETauD0Y3Fo4rSvA71RUV+i+ea79D+q3Q/gzAuxio/mgoe4l4NY5qwHPceucOK6Z3v9kstKSg/hWeXijGC4QL21fLkB63DaN5xobxLc1x7WdMaInbIMFbUMyRuJznMFjBdo2ce3NTBE+9TXZVYSPX70D/aw2wset4DVZXH7xmizOG67/wM1d4PHIlaRvxNkAbE+PQP44fAn1y4o+mI7TfDuL93g9PnYgbpXBbWWPWtD+oVXEDz9H9wbjPKFtTKN3k+heRgg/B9mGoHcMgZfZveOVHb43FnTG7Y31G9diLFwWwqydrWLw6bzozQH90KD9ucub5L6S4U7rOa07V5I+Ko5zWYg4W9mfOwX54/CrhrHfMLI/d3D4KgrTzP5cXF7C7s+9x7Pd3PvbYT6/GbTWHXT+ib7eHfnj8PcGlL+onH8CejJc/lI7er2DrmlUkR9dCwnam8l9ZkiXv/le+TOpx3whWevTQh7iY+ixSyB/HP6NXpnsQumA/y19kiVfdCvpYqWYLZZKmf4iPVZeO8gzfcyULg8PT6jrDPQkrTPtAL/dDH7tvd8ESmucSRPED2WpDYWP+fx3HH7MAnF1ESzhtLlBacP86VxBgvCBaz+sRJNYnT5+M2XSXcvTeEC6afx+4bk6APc7AvBxeLDruAx3EF2MMqOLVFC+daA4If6hHJsNv6eTcPQzZ1jf7T5YDvk9ndyLO/yx2dQudTuD0w3PGLYpoY8Thfi7HKP1oWYH2gkfv7qLjxOcM69Y8k75pCaPZh1WJ4ajyaZZV2sWyT1aHNrIc9DV45pQyjPGYHAqAMxxzkAO+FnOlMR94nWcenGl5qMRFlzHA7j4YcQIRncAxkjVGak6jBupOuGqjnRvPFUo5HpTfclMvtRfKWXSjXrj0vH39+X6MuW+/pybyaUzyVIzowHa28Cj7jijv3YS/icBK1BtAZja0ZNMIfzPA0byXK+IS2cYM4D5jHMGlys6ghiu8pQvFvp6+3szxUwu2Z/M55rJT67nGguhk3YGu4d5vj0EFs7jxdWB4aEH2+EEj9raSfi/Bew+6UDPANbN1caccTnAIwP6kTgI/y/E4WEyu4L1QJte3GsXbOr6YyQ+x+GbXoi/yzHaFXBpfgAfv/JleCTVFyP4mM8oRj+Ql6MZP8CCGSds03D4USiNODy+hufxvU7vQ289BFM7OAU1xvjFmXug3+11bOLAtOG8ifn8B1x6j9oFrBtqK7GdxiuUu0wcmBZc37k+CtgPWhf3mFjHHO9dc/0Ymn/U9lOb79fP87NXtF2E8JM9TtzHU2i7iNNJOeL4Eky82lF7BeGneRwMDwHYj1r6zb7h9Om2K2imJaj+Bs14QV3o8AkPeO0k/D4oz2gbMxo9E2d40b4MhN8fYdK+TCeTLq6+wf0uJnwnk65xzmC7BM9yqxKge8Mn2fZzqxJYh+3VxvoZ1YJ+oAz0kPBYV5xtG0XiaTS0pKu43CwatoVc/432GXD8XPuK71E7jZ+HcFw8VJ+jAuLh7BRX7zg90jpyTEC94/p2+APAo3w4hO3bQfiZiMMbAvp2uC07fmIwV2rX8BgLhz8VtWUnkbaM5r12XL88TvxwXoKOsL3tYHA5u0HLBFcncXja14Y61uETHvencPizmTIxzhlcb+M+8WF++F5Q3ejyweLyUzvaN4HwFwbY/DEMvzjDD8KPZcKPQWGAD6ebsQ4fN04Pzk/6AXEIfzmTHq4dwSsk2iWQn2A7wn7dA+uVtiNBOtSO6rybCY91CenrIeGx/rk6Oob44XhHEw6NxlC0jeH6T9hGcdPFWAfAs5NJr1ze9bsxEh+kD9/D8Xc5g8u8iTFr2DIC+uk2o59kUBnsZvQDfHYxwieZhrLSw8QNXOHNeWxXcPhupEMcHl/D8/jecjJ2HYeeA/we4qcdHS9jvzhzr20HYfUwWFhvkKe6Ht9IdEG/lMX9B1x6j3LE+QllPshGDDUejAX9KK4+aZnp/U625NIpSMcuTDogblyu5OpONh/W1kH8XY7RuuwGlWGsH8g3ru7Dsz3O4DK8vFoP16h843g4rC0RxVoniHWXINbdgliS+togiLVREGu9INZSQSzJNG4SxJLktUYQS7I+SubjWkEsyTq0WRBLMh8ly+pWQSzJ8nWPINb9gliS5T6qNkcyjdsEsW4RxHpAEEtSX5J9E8nyFdV+oWS5j2pfbrUg1p2CWDtDXy6q5V6ybzLSpjWHFdW+XFRtoWRfTtIWSuajpL6i2v9aJogV1f7XbYJYknVbsg5J6kuyHZKsQ1HVvaT9kpyXk+ybRLV8SfZ9o9rHjGLboa/pmpVE2zHOBxtfB60Nc/HEGM7cmnIbwuh0BqdXcl0Z8CcYwod0j2d0hdME8dM1ZvDn/gMW9YO4ugiWcNrcoLQFrUXjdXesAz+s8U1idTJ+JvK0JyDdOP7uAK5cOroFddIuiEX36nH1n1u/hfATmPBcORnHxA3PQt5ORH6CeZsKyltsIyD+obz1Dnq7iISDr1i0OYPrxngfLIf8vojciyM87IbLvtPfsLcG7+mF/SjcHiItM73fyZZcLhVkW822M7l0jMQHOnWI3iD+4bLdQTZMO7oHI4wN025ltR6uFbuj3X2CWHcLYq0TxFojiLVFEEsyjWsFsZYKYkmWidWCWJJl4g5BrJ2hTGwUxNokiBXVui2pe0l93SaIJZnGOwWxJPNRstyvF8SSLPe3C2JJloltgliSZWKk//XSsNFrBbFWCWLtDLbwAUEsKZujr+lYuxVe91blsCTrkKSNlmzTotovjGqbFtWxlaTuJeuQpL4kbfRI22F/26Gd5NhK0hbeI4g1Mqew4+qQpO4l03i/IFZUx0OSut8giLVWECuq/ZwRO7Hj+hMjdmLH6T6qdiJM/wufe0jPM+bW8QFrQgOsWQQLPz+BYE1sgHU2weL2M8Bzk3ziwWdr4D0Yk5i4OXzA4PZxaJnp/U625PLFTiYdcvipEqyH74rSHfP+Q9yT0X25tftM6PNWIf4uwlWWT30vwWTCh+qH7iXYjeHaQ/y0q1br4ahfnLnXFoC1SRBriyDWOkGspYJYtwtirRbE2iyIJakvyTRK8eLsbFTK6j2CWJJ1W7JMbBTEGrFfI/bLZBoldb9GEEuy3N8riCVZt6NaHyVtdFTbWsl8XCuItTO0QztDGiV5SdrVKLbb+pqO26NSviT1dZ8g1gZBLMm+SVTbtJH6uOPSGNV2e2cYp0naaLp37KVY7u8WxIrqXMdWQSwTNpq+F6jdTO9/siWXzsBcNF47iTkD48V9EcF583KMxAc6wvdw/F2EqzCf2jw+t5aD9dNG9GNmnSNZihF8zGcyox9uXYH2I6d4v/E6Fg4/GaURh8fX8Dy+91VvoUPSTur3rT/v4TZRB1L9FTedLeezyVwxky3l0qlSKp8sZbIV1y24qd5MIZ2u9GcKpUIqXUnlU/3dzuB8p3XAUB5nwtYBupZlqE4GrmVNYvKo2bWsudV6uCi1v/A9ojDn1JspC+m+oZYF0+fUc2Uh6Jz6sGXh1mo9XKv5J9mnlhxL3imIJdm3WCuIJdnflOzrR3WOLqrrAncJYkmOG+4VxNoZ1vyiuAav3cg68I7T/cg68I7T/W2CWJLlPqrrmiN2YsfpXjKN9wtiSfYnoqr7bYJYI3WoOaxVglgjdWjH6V5y7L5WEAveoaBzSNrN9P4nW3OpTiZeIewMYE+Rx66dQbt769glegOwp8rzrgD2NAbbTaddRSfvVkqVdDbfm+pzc+lcrpKp5HOFTKmSzRRL+bKbKaZTveV8suIWymrGOt2fz1V6S/25GvZ0cd7pLMzT4e9x4++pF73CCeUefy89Tp7V123IH4f/1OQ6Zsm77ka4DsLQrpPgxRzJ+cxUMkbicxx+fhXi7yJcZfnU51fbCB+qHzq/Gme49hA/7VZU6+GoX5y5F4S1QRBrsyDWGkGsTYJYWwWx1gli3RNRXmsFsZYKYq2OKK8tgliS5V6Sl6Tu7xTEksxHSd3fJoglmcZtgli3CGI9IIglqa+NglhRrduSbQf0J+C9btx/HOsM9MN9pzHEL4H8MAb2w/wSAfzw8wmf52g6oP/bQfxner+TrTkX8Eebwa99F2IUoyucJogf+rPtKHzM5z9gUT+Iq4tgSesuKG2YPy0HoxAf+v0IDmtUk1idjJ+JPO0ISDeOvzuAK5eOBNEJV89ijE7g/ugAXjj8OCZueBZ02In8BHWYCtIhrosQ/1C+qQF624uEg7M42pzBZXCUD5ZDfu9F7sURHnbjCAZnR2l99svfHp/ntesOiKebeQ7SNwZx3Av5jw5Ib5y5Rzni5yEcF0+sxXhiTDwUi5uj0a5Srfvj8F/y5mV0Gl6YOhBzBsMvqC7uzYSfgcIAH0438Gw3E3fM5z/E4zjBZWgGCkPt1N6C8eyNwrSTePYRjGcfFGYsiWdfwXj2RWHGoOf07/2QHy5nYEsPRv5ytjRVhHQe4gx24HcouvfKap0HdXHyG/PW9eHRaXVcGo7GuT/yO5T4HYD8DiN+ByK/w4nfQcjvCOJ3MMNnqPmM82p/n3RJxIN1dACJ5wDBeLC+DyTxHCgYD847yKtOZ3De7ajyj/MW/A5DfjSvD0d+NH+OQH5Up0ciP7w3mjquvoGedH37eIj6trPrlyuX4Eb0W/cbqn5xu0bdiH7rfmH0OxQd/reJNhfnFaQJ+rfw/H7eYrge98zYbeDzeKxJ3//YA/mdSfz2ZPw0/r+9BWzo32I90DEGbofizL2gMcaBPlgJhNWJsODcw3YS/jhPH2bLZC4f1GeBuA8xFHeYth3H383wAd5djF+iBa6V/kIynczlSuVcpi+bqcScwXU3ztyj465DmfDcNwxB14eZ0XWq9k3jah0f94W1SyC/Q4hfO/IDjrrcXzdtIP9DDfEPo38cfw8T/myUhmby0iQWtgcSWKOGiDXBGVifsM0x3C72cjYIHFfne4gfLnPjiR+uT/Q71rjNxHNv1DVqF3ebXsel4Wg6cPtwiA8mtAX7IX9oy9pJ2HNRG3oWaUPx+PC86kA/PA6DeDTGNbvV7+N4uPZYuxt8eJVJ+2VmziFT4vpUtP061FDcYdsvOueA+QDvLsavlfarz62ky8m+vkyqr5TN5XJB7RG+R9uvw5jw3Lm5oOvDzei6j2u/8HyNdgnkR9s23H4BR679MtP+ZvrC6B/H38OEn4PS0Exegm3n+k2crbi+OtAPz//gPvU1pI6b6Sem+ri5Q4fwx/lG2wdcJmn7gMdGtH3AY89m2wfQRbPtA7aTOE0YM4HucTa+nYS/GbURi0kbgdt0iFuH+wfJW6wnwbytUF07jE6S6F6zc8bAu9k5Y1yWk8QP11eX+OE8SxE/XA7TxO8Ihk+Y9kU72h/EeeU3dpKIh+t3c3W11Xg4+0j1LREPzjvIK7PtWnPlH+ct+LnIj+Z1CvnR/EkjP6rTDPLbDV1Tx9U33LY2M+e2s+oX79OgbkS/db+h6he3p9SN6LfuF0a/Q9FhM3PGOK9wmlrp+7yX9GPMjAWTyQkkXTiukT7USB/KL56RPtRLvw3C5/RRN9IG1f2Gql88l0ndiH7rfiN9qMFuZ+hDhZ3rCdvXuqD64n/a1/ovmmf6927+vA5CcVc94zjSRxrpI/nFM9JHGplnwm6kjRmZZ8IuCvrFbSt1I/qt+0Whj4Tzqtl5Jr++z0zSj9mR80yGykiZ60NQ3eLy02wfCufnUN/vOJL4mexfYT5D7QvgvBqu9zteqn01s3s4miv/OG85+0nzWsJ+NjvPhPdxNtMG7az6bXaeaaj6xfHsTPpttg8FeorI+x2R0m9YHQ71/Q5cRmmbi+d6IBye66EYOA6zeRT+u0YQf5djsk7Wz644iPCh+oH2b6xTf8dldnnROYv75lzbf3p56cLj5pbOKS5YdG1xznGl0oLywoU4NTiGbia1tLTQMHDdw9zHGIc0SAWceDDOGZzLhxCsQxtgzSJYXM8DsA5rgHU2weJ6F/Dc4T7x4DDcDA/mc3gDPudW/fkcTrCOaIA1j2Dh548gWEc2wJpPsPDzR5Lnkj7x4DDYGiaZuDl8Wm7dBpxvrA7kjHm5BCvVAGsBwcLPpwhWugHWQoKFn0+T5zI+8eAwuCXNoHhizD2Oz6KqP58Mwco2wFpMsPDzWYKVa4B1E8HCz+fIc3mfeHCYHLqfR/HEmHscn5ur/nzg2TAtHOYq2KKEfisB4h+uFq6RXukpMQWGaw/jh9sQ7IfjKTDxcFiHCGIdJoh1qCDW4YJYRwpiJQWxXEGstCBWShArI4gFNhFsGs7XiSQero9wZEA8+Hk6UsDPxXz+Qzz0Ho2H48zNpOHTtL8wpf4MLoP4pCb8LLRF7ST8Z6fWMb/sYYIuuZEStAG4bMnZ3HQO0o3bVofoBLc/u6Nr6rhRI/BudqYW5xFtK3H9LxA/XJ97iR+uU0cRvzTDZ6jlC+fVcJVjOmOdFIyH6wdTfUvEw/WRuT4mrifYD+Kh94JOFqIz9n71/7dT+Dj96j/0/dpJ+Peh+v8HshKE+5uCdTxP6zF2XB+K7gTpRX60PB+F/GgZPBr54byljrMboItmZ5twWwdpipJ+tWt2tQvrYqg2lNpJXKepncR55Wcncf5ybUirtgDn1YgNDR8PzjvIK8N9iKbtS474SdoX8DsG+U1F19Q16rM0s1qws+oX21zqRvRb9xuqfun8FHaS+sX5+FLVb1gdgi6a7X/gMlpA+LQNwOFwH9JvntthMCgObRchzW3Ms/C1K26uexKJg5tvx/doGzSJ4RvUppqt3y+efo7jg3Tgezj+LkYnJuY50yH1yvVt00Tn2I/OtXHz+RkmHg6L2iWu79XpDK5jgvrKhM0/iL+L0YOJ/OPWkyYxeh2O8u2Xz8kAPlkzfGonsHHrNdz8nz5ppcNxfPuvtEz6revAPb+8wXHT9eWgtb50Ayy6vuyXBr88wlh0fZnTQTvxW+RNymkdXrb7wDCwLjoHhbnCuw4atxleewpdp+nak5kxfPDaE9YPLrOjnOCyg/POb13+CCattCwf3oATLcvN7gHAWLQsB+0BSDbAomUZP0/7BdhW051fGSY94Jdl+OkyPn93f/xkAL4bgJ8OwA/aWYznGzPED89rZhH+kgD8oJPpDw/AP4LBp5hgN/D+nf2JH4Rd5mFsH2d4J1d1Oibb3nSam693SJqxjW12rg14t7KznOYxro9Z4ofrFx33cLbB9BzYcO0sH64d37Q+HC4YD2cbzb6d2lz552wRtmc0r3HbSvMH9wOoTv32WFDH1Tf8NuyO35kbff3ifSfUNdq1O6Lfxvpt9s2yoerXzAmY0dJvWB3iEzCH+nYepEnveoY3hGeXF51eXnpRcc61peKia+fNPa984+LywkUJAru/Dx34TZsmKCIYxwmgq10b8TuI+MNhqW0O76DYmJmSMt+tAt7Ndqu4LOa6TrRbhZtf2q0Ks7UE8xlq9wDn1UE+6ZKIB+touLs7VN8S8XBbuaM0rMB5y5lNmtfYbNL8wWaT6hQ3S9PRNXWNhjHNNEs7q36bPbhoqPo1c7h99PXbbLcKf8Bvx79wGi39htUhfql0qAdD0TYX93nggw7gtwd6jn6ca0/khw+Uoh9bwlMEM5yBfjOQ397edTvhNdHb69FJwgmXhxKdeoM4cNwHGoo7TLvK5QHmA7y7GL9WPiaRKvf154rFSrq/kuwvVra/RInxgSu9Rz8mwb3kuAsT3rBdLUJ9wR+ToK9HJpDfgcSvHflhm0Y/JmFouF0Mo38cfw8T/gyUhmbysoeJB9fvZrDgwxR4qhvqttn6lipwfXZw1GZq1+zYCHg3OzbCH12nH+nAdo++BN7qR24xnzC2SLugMpHwSZdEPFhHe5N49haMB+t7uD++a/gwiKbKP9fu0A/tYT88VU/zJ+xHLJs9EG6oh0HsrPqdga6pk9TvDOS3M+kX95up4/Q7w7seKb91P2wXqWtURpsZG81AfpCmkf7HSP/DL56R/sdL335PQdfUjfQ/6n5D1W+zH3Mf0W80+3cj/Y96GMn+B+XezoTdi/hB2C3odeRnvOtxzuC2ax9noN9eyG9f4jeD4QR+ezOcYiQO/DoMhNeuUh2YBgj/So+31uWrp/GYbT6YsEWVm+eb4d3r9P4nkJ9c+e13Ne8lqAxgnW5Pb3VgmnB7HmfC07nUA5jwuLyCjrjX4/cjWDMYrH3QPZgr5PQJHHeEPjFHqs/9GqSJ6pPTP9bTDO+a6zPtQbD2YLBmoHtB+gSOO0KfMxBHqs99G6SJ6pPT/74oDOioxxms6z0JFqfPvdE9OpcNz3cw4TFeOwn/JLI5z08dyA/bzRmE+14MNra9MYKB09HFpKOb+OFnNW5x8kDcRke70bzhXuHB65xQtrljOuBZw6+XNn2EDT3egjumCvzwq6d0TRe/ekpfG8CvntJj+LBr9OppmP5VjMQDuNRW0TKzP8MRH3XCvRpFXy10Q8YJ4RsddUjLH1de8Ws1QeWPHnsFz+H+BeZPj2yB8F9Fdf0F75qzx6Ans/Y4WebsMdYrtcdBOtSu2ToPOuOO6kgRP1xeaL3bn8HER21hmwb/W1qbLpXKbsbN9xbKmUypN0s/kIB1McZA/JlsMd9fzLtub8YtZ9xhj78/m+vrVySSZXe7OoY7/mypr5DMp4q9pf5cKZ3tH+74y32Z3nxfb382WUr2ur3pRvHrevawF8jk3KB2c6sv/oe2sgM9L/lqLuCPIvyE8F3QU7szWE8Q92gjaatUwuQDjr+LcBXWde2V0tGED9UP3cvSaUY/Zf3KKpQ9bPM7GN1QHqMIxy5DHLl2FThx+22Ahw7zKfIKYpshjmbraKW2twz3DfFRdDEyxwF5g/s1uNy3IX8cvmNaHTPhXY9DuPA82KkxyH8U4w+/Ib/amLD4mv4G7lSvODyUyQ6ftHaQtEL4sV76NLfvTOAxsf4wrzYfzHEI8wUyfsNjtaA6D+HHMOFxHQM+45zBdXMMeQ5z73QGOnyPy58YCUvbYGin8HN+vzsZHD8OoxkcbjzdSbjiOGl50I6OeeJMPLhO4Ta/k4lfsH3Icm0lOPDrIOnFfjjtl1Xr4ajjxpiQJp3e35AxDQ5H+XB1TbJvBPfb0X0ab5yE7SBhcXtOddYuwLGHiaeD4I4K4B8jOAnmuW6Hr4/c/7B8Ywxfrq1pNR6MdXl1YDw4n3GbliVtGrbjcebZJdW6Pw5/FGrTCiHbNGpLcBquqNbvUZtN+7G0TtK5D9p20TC4HcfhX860XdQ+YCx977gQfQSu30f7CEWkzxOJPrk+wDhnsG5oGe4kceH+MbQvVAdnIB6nTvOPC/TaHZBGfe+saXw4zAGHoxhc2wkYXL2G58YxvGjdo7ajIyAOrj3j4mgnfq3mD9du474G14fh/HF7juOh99qY8I36H10+2BxuB4PD2fnRxC/G+FEbhtOLbRjtm3BjMmwbuXrnl3dBfW+Oe5h+VUcAd05/2A5Jz+UkC0k32Z/PVipuKVfsyzSay4H7o6oD07X9P7rXjtKl3Wgcnvh1Ir9EdWD8Xd7vBIoHYwGPdhJ+Ecpr7TrQM/B8DxN/B4l/AG/mHi5rFCvO3IPwOk9v8DiamKNLZXsLxd6+pJuqpFLpQq5RvnJ6wnMH2oGucV50MGlrJ+GXozZnJVmHaWfi0+E2BoSL+fzfjsHcS1QH3uPyCJddCA9xd1UHcwS/McivncQz1vuN9YWxgEc7CX8HKbu4vMHzPUz8o0n8A3gz92jZHcOEH8OE1/mzhtgjnHbpub/tcRJ8fI9y22iwXuUyObdQKBb6c/2V3kx/37CvPfTmKr3pdJ+b7i2Ve93csM/9Z9J9Fbei5v/TlWS64A772kcxmVJrPn19Wbdc7O2tDHv6Xdet5DJ9hVx/Sk0xDvvaS6aSL+Yq+WQ2VcqUU6XicMdfzJd7M7l0qj9d6S0WkoXhjr+vlOtP9qbdUrGYT+ZzhaGsPdE5Eu1gjorOj8wcIk/iQh/TWbPTzuC+rIk1lTjhQ/UD13RuCj/LrcPBOTwxxi/O3GsbZqyg+RrT85VhywLE3+UYLZtukF7jjF7pHCB+lo71tKP5187Ew83p24IFz2vHzeFeVx3oh/OY6pTWd+zHrWNRGxc0LxI03wS8YOzNzaXitNA5jc+S9/DNrL0mk9Te07gwX+h3Y31odzZJA4T/KRqnfIHMFXDrB5w+24gfN6fGrT3RfKj1q1EaRgekAcJ/nVlL49aCIT2G91hluD1WeA0Ljxu0BK3faUfnjscy4cegMHSeaSzyo/WXq/9Y53QeGs8t0fAYj86tP4/yiO55xeW6i3DHaadzUHEm3qB1P83lP6TOGtork+fW2cB1M3qjthTXE2ov6f4J7IfLAdYBdXHyG+ti+1rB9DouDQdO0k7gd2e286sO5rUj6i2ed6b1llunx+GbWafXDtq3HmdwXtLyzbUFzdQZ7c4g8XFrDrjO+LW7XJ+I2osEkxbtaNtaC0/249D1tZne72SLjmtb6X4lQ3u8ctz6EbhuJt3URuD6Q20E7YtgP26/f1gbAbpo1kZw/UbOflAbwa2rcnWA1g9uPSRo3YsbN8EZZTGC6TjB6xrcmnGj8TndA6Cd4bIfenwO8Xc5RtvM2pis0foRLetB+3+4NjZG/HA8o5l4OKw2QSz63ijOD1oWDM2NhB6fQ/xdzmCdmigLXJ2LMXrl5mrC7JmOMX7Nzq9EHStoDjBMvnPx0PKP48Ht+4B9OtMHPgPP4fEefpaO9yD8E9PrmAXvmnvvmO6Nxumf6f1PNucy9IbhsX+RGz86RN9jmDTHmPBcew68mz2/BbfnY4gfbh/GEj/clnUTP2wTdyF+pspuu0+6JOLh9vgFtfdDjYfbP8GNP1uNB+cd3ZPEtWdDbRu5cQjXNmLbcuF0Pk5sW/Cz51br/jj865FtuYSMQQzNjRdo+ceu2fkAWp6xbaBlEM8L0Xd6sGu0B7iZMyhw2etE+LRe4jgN94Ob0r92zZ6RBbybtbG4TnYSP1wWu4hfq7YZ85GwFUFz+q3Gg8MM11lcw91mGJ6rbNr+0Dam2flIzv5QneL6gfvE1DWax2zmjKGdUb/UJlMnqd8YScdM73eyNRd5/TbbJ4dwzerX0NxApPQbVoegC4n+CX7Pg9uHzo3HIXzQGgGOj+tHw7NRHWM2Ww9o/3MX5EfLzDjkh3VCXaMxbTNnoHDjFByO7luPMRzxWCRoHhjuc/M77UycQRy5udGg8sqt13Lz7bSccmMqzN9vTPWsp49G6/OgJ8PrfFlunQ/rtZ1wCtKhds3WebpviHtXl5uroGNhbt0Nz7NJ70PMp/qzxXS2N9lfzuaLuXyjfYi1dfdqPZxgPqYgXsivuFO3B4lqnRPEz72XAeGAa6cZrkngCnvRoQ7hOHFa2kh4ek3f/fg2mv/AaYR04HsYH8Jz++Dx+wHAkXtnYky1OazRBGtUC1jAi3s3YNQQeXFYHQSrmXdePuvljd/an998+ffJnBb3XmvQfDmE/wua03qetE2S67JBc4Hc/i+6byToHT/HCZ73pPMj+DncrnD90Zne72RrLvQaGsTf5Rjt17lB7RHXZwD9jDHDJwN8uP1rXD7rM2d2cQbnGeYHWFw/pNl9AnQfTZh9Ari84zNOgs4h4d6n5uZ9aL13nOA+It3b+Q9U73u8AyOD3gPl6i+t99y+EvDz21fil+dBfahuJjw3zoC4cZnoDoE1KiDuXZjw3QFxY174WRq3X9nl+sKgmx3RF8b71GhfOGjvqXZhdMnlYw8Jj3XH1eOgfvIY4sfNo3P1GMovri9cXxvvgYU2+iDvHn6H2nHkbTquf9L4hWSmyJ35I8g/bXgtLW14z14Syt1J1To+tzYAZe7kal2XJ1cHcuLWNAGXW/eeRfzw3Adg6/o83qlfT3Lqz2h3CuIQI36nIj/aJ8B1SLC8FQyXh9REhn8CpU27E6pm4gb8E83guzCe2MfDi/vo0vHJS0cwrUFrYYbXV9IxEp/j8P1uiH+4zm5s1G+DOqbbQ2izFi6at6A4u3xeuTjgU60Yro1JGk46DkOXQGPkN91WQ8PHGZwgF2NwuaSfWH3xf5gp0ngDrBMIFreNAE9HJaoD/Wd695MtuHyhPsUD3bh2Z/D0NI6/nYQ/0PstPW1XyRfdSrpYKWaLpVKmv+Hr03A0ud1dmXx6uLoycTP4KcNNY60rc2J1IL5D4o2TcNwzXFcGwnBdGejm6ObLWxHYfg0nZkGXZBaKh3ZXcHeqjfidQvhhP9zNoa8dnYb86NRY2G3pJo8qVl2mPrPLgS9+Eml7Gqt1fLw8p10C+Y0mfnjIiJfiDib6MbGdS+knZ1L/+iD4iQx/PAWkr+mn7/FUB+0WGcrH3rDdIoi/y6je6t2isMtpulsEw5fZ5UXnLO6bc23/icVFxYuvXTS3vHAh3UIbJ79pX4Z2Tf2O3aQ8YWjPvabl54APtYkYj/a9/PpmbQwuOG4p2m+7HdYBN61Bl+Bxu++3tQ7rkdtiiOsFcMTLPdwyDNgPbrluOI5Rg09NRPkYNfh8nA39WvgMzo7u1+7uXVs+RZcf6dcGu7D92lb6rDBNra/HITztuD6ryS16uM9jKM/ciT78tYM+z0Sn7rB/h+M/xg9qv2ywbfD53h1t2+DTciO2LdClDW+VdQ3XQ9a2cXUyyLY1sl8nIWw65p7FxGt4iSC7I5cIwLZBPY8zYXFd4I6cp312xweDs49067yD0u2m024yWcq7lVIlnc33pvrcXDqXq2Qq+VwhU6pkM8VSvuxmiulUbzmfrLiFcjmfTffncxX9Fa0KTWtbQNq6ncY2vM1Hf1G34fApzR1tw/f2rkdseKAb6Z86I/1T4kL1T9HXGAbomR4vgHHaSVjvi7jb+7QTffDC9HfjPs/hMSrFcAT1xfGIMTxs75/P8H7vaNsOcyAj24MCnentQbnh2h50YrWOH7Q9CMLRZxqtqRm211nDesqYXANKeltCtARtwcDx03lt8Of+Axb1o9tLDJXhwO0lQUcDcZ/0CcLqaBJrR+ap32fQtoep1v3oOnEC+XUQv/bq4DTqfsQMFM5v3MNt0YN1Z41xKMKDuXyuzZe23aZshnYTHf9+D9yL+trPId7vKK/97Otdj3HqfVv8WXu/OoLHCnDNvQZEj50wVJ9TwJV7BZY70kivB+/qXettcuVT5560pNy/eNG18+aeUOy/puwQRxeEYyjxfg0zTiiHEUfPc86GTnHB+72jO8WXedeWd4r7h6tTbGj/bNZwRWf3zHMVHMowTFDga+AEYU5BYU7xCXMqCoM3fWlnYu8914k8hfhhO4M7BGDY8GQztyktRvxOR37DNCFfHNmzP2RX27N/DMpH2mDHnIH5aLJDjeNzHH5gE9Xzf3WHACbh+otz5pyz4NqbiovKsxbP7dd9ApwEDNvGJJE253j+z/EJR00ENQvUFODqj3H9nqf3gkxXzOe/wzzvOIPHc/g5up+rTSAe0+ui3GuAcRK3qU8bcabdITrkPpEAftwnEmIMFlc28DGMxyNcGo7ywfnQgfBxOrj84sbb3CdEONMN9w3PLRk5Vj9sfuB5gmbyw2/+gtZNur5v65rrcd7vHT0EwU3xOGdw2Y0RP+54aQiHbTs3HwddFq477zhyzWg74XOq91+n9QLCmZsniDO6CtM04/Ry8wqjQsSN9XVilY+7w+HtED4eBYc/x/uv03+xd821e3Hi18Zgc3US0mjk06fZXF9/JltMll39MzXsn97MFvP9xbzr9mbccsbN7iTrXAXL17kyI+tcjd0wrHOlRta5huxG1rkC0k3zdHuYat1vR65zwXTYDlrnKoysc9XDj6xzvehG1rmIAnBCOYyRdS5/1+wg8wjv2vJOcW7k5YxgJ/VyBsxp4/ObYs5g4xZncIZpDcj0Sxlus52aOPHDnRo8SboH0Y/pgYWhshZqw/NBSCe07NQaZLM8UzESn+Pwgwq412UwX5JoUBEnfPw6Droxhk3fc+YVS7MWzLthYGuMUxHzSR32x47TTsznvnZBr+HY9Ir9gd7vKHc/Z3jXNvR0Dvd+7+ieDrxiMTL9F+hMn1KZMbxjiO3pcEOrZnb0nIzCnIzCaDfUV6G46Qm6kwcPy/DUBT5FE8r9S3nqAnoNMPTULd++3vXceYuurSw9Hw7huaBcXFCad/Nc2GlxQnHOHIe4Zk8e9Ns5EXTyINfc2mCu4cSzHW2ur/Gu7TbX2ZLdb5y6vbac9IefOwmFOcknjJ/Zx2H8zD4O47fZE4fx2+yJw5yGwpzmE+Z0FOZ0nzBnoDBn+IQ5E4U50yfMWSjMWT5hzkZhzvYJcw4Kc45PmHNRmHN9wpyHwpznE+Z8FOZ8nzAXoDAX+IS5EIW50CfMRSjMRT5hLkZhLvYJcwkKc4lPmEtRmEt9wlyGwlzmE+ZyFOZyEsZw9yFj1o64Ba47VRtaOSa7tG7o0wxrQ03HpM2uTyQE7X7Tjk5acR884ya02olfO/LDE1pHo3Bc2dLO7GRXtn84JgN3TLkLP4FlU7kLmkgdarnjJiJ1uFno+hTv2qwdfLE/aKq8a/dSWAE+yfsd5Sm4Y71rPKYz9OJH7cWMPuDkGLUrgyaiYSqE1m26oDOyk2jouh7ZSTQ43TR+/BuH5xZHuLYl6KTwsDuPjiZ8wi56BvHn8pn7WBs8a/YU8fquEK4d504WH4uuS+W+xbPPmDfbIS5O9ADpnELCgQ1tcwaX7Q4fLIf8nkLuxR1+w4gN83GgyCi8jeA4A09kl9ZXEr3kaOhDj0lc/xySFhwv1QE31xvz+d1G/geFpffxvW7GDzBhIwbmiz/Kjv/vinBNzJ1OMoPP5tWu6HoSSSfW90whDoAHdZZ7k66N+OExBuYXk+fnOsTFmbjAQZmZhO6BPscTrqZ25wO+qRd1Ad9Uv4Urk/geLQO0fcKcaD0V5lqsjfcQhziJk3LEYTib10Z+J8j9eIiwXNnEH56n/Ohz9Csd9B7tyzlM+NoY0fvf7oOFP4iLw48iYU3l4USGE3D/f6baM69A6wgA",
      "debug_symbols": "7b3fjjM7cuX7Ln29L5Jk8N+8ysAwbI/PoIGGe2B7DnBg+N2Pvk+VKdUuplhiRZIMxrpp1P46UyJ/K5SMtVJi/tdf/te//vP//d//+Nd/+3/+/h9/+R//87/+8re//8s//edf//5vt//6r78Y+v1v//F//unffv3nf/znP/37f/7lf1hP8Y+//Ou//a/bn8HY//7jL//PX//2r3/5H2YL//3H16MtbfvRNjyOjrFwsNuy/zjYmZBeH2x89vbj6NvfIRyH27yVRmJs2EdiyB9Hu6346i64/cXJbJ+O/oc//mI80JyhCUBzhiYW0VAyDzSugoaMoY+jyfjHW8Tt9zuky98hl97BOEu7CMa5tFXe43a8OQ734eloVzg657wXj9k2Q89DKklG/kmz5P80A7uJn4EpzyBtx5u459L+NYNfp9nSabTZvMu90ePj402xNsL+wSRnHwebWJr17dN4fByiffqo3Rj9Go+bbDw02Xj8ZOMJk40nTjaeNNl48lzjcdtk4zGTjWey67PrfX22Lu6dx20xNl/G0/v6bK1Nx3jiZz4FmpujY433taNjPtqNmLOttKHuaFpvM3gca4rdQzRH8xDdVjnaxPiogedxlI/e7NE9b8F/OvqXQh4KTa5QgEKTK9S7q7GUD4W88xXm2TyMzJMzT7lwbLKHk0z2+Xpe1GdNNRPUXEjNDDXXUZO2qdU0Nh1rIVnzLOevwRvJg7dzDz6744OUg3v9Qbp9HvbP0VOubVMsNkPGHbm2jZ+O/oXFAUsJCwFLCYvXisXZAwt9xRKApYRlblsxDMvc/fmFWPwDSzRfsMzd6I7C4ifvGEdhmbwXvXCBfsJiv2BR2+XGw9LZHL5gUdvlvsZCwFLCorbLfbq25C99i1+oy03HOG7xv69wuTCJsmmHZ91WzZbcth9tnuk1JVF+oeYcavqFPMUsao5Lif1CVghqhoUcHJuav7jMbuGOu1UmZ19ps46vmsenr4O7rViKKexYbEoPZ2vSbyqzO7gxVGY3cGOoEKgUqMxu38ZQmd29jaEyuwsaQ2V2NzGGyuxd+RAqcfbudgwV9LYlKuhtS1TQ25aoEKgUqKC3LVFBb1uigt62RAW9bYkKetsClYTetkQFvW2JCnrbEhX0tiUqBCoFKuhtS1TQ25aooLctUUFvW6KC3rZAJaO3LVFBb1uigt62RAW9bYkKgUqBCnrbEhX0tiUq6G1LVNDblqigty1QMRua2yIWdLdFLGhvi1gW6m8fM01p+4Tl90xJzUwX6kNzeN7fulLr3h1TvA3jMWpFe0/d/g3i6xV/IVcB8d8VfyHzBPHfFX8hjwjx3xTfLOSEIf674i/k9yH+u+IvlGpA/HfFXyi7gfjvik8QX6/4SPgUi4+ET7H4SPgUi4+ET7H4SPj0im+R8CkWHwmfYvGR8CkWHwmfYvEJ4usVHwmfYvGR8CkWHwmfYvGR8CkWHwmfXvEdEj7F4iPhUyw+Ej7F4iPhUyw+QXy94iPhUyw+Ej7F4iPhUyw+Ej7F4iPh0ys+IeFTLD4SPsXiI+FTLD4SPsXiE8TXKz4SPsXiI+FTLD4SPsXiI+FTLD4SPr3ieyR8isVHwqdYfCR8isVHwqdYfIL4esVHwqdYfCR8isVHwqdYfCR8isVHwqdX/ICET7H4SPgUi4+ET7H4SPgUi08QX6/4SPgUi4+ET7H4SPgUi4+ET7H4SPj0ih+R8CkWHwmfYvGR8CkWHwmfYvEJ4usVHwmfYvGR8CkWHwmfYvGR8CkWHwmfXvETEj7F4iPhUyw+Ej7F4iPhUyw+QXy94iPhUyw+Ej7F4iPhUyw+Ej7F4iPh0yt+RsKnWHwkfIrFR8KnWHwkfIrFJ4ivV3wkfIrFR8KnWHwkfIrFR8KnWHwkfGrFtxsSPsXiI+FTLD4SPsXiI+FTLD5BfL3iI+FTLD4SPsXiI+FTLD4SPsXiI+HTK75BwqdYfCR8isVHwqdYfCR8isUniK9XfCR8isVHwqdYfCR8isVHwqdYfCR8esW3SPgUi4+ET7H4SPgUi4+ET7H4BPH1io+ET7H4SPgUi4+ET7H4SPgUi4+ET6/4DgmfYvGR8CkWHwmfYvGR8CkWnyC+XvGR8CkWHwmfYvGR8CkWHwmfYvGR8OkVn5DwKRYfCZ9i8ZHwKRYfCZ9i8Qni6xUfCZ9i8ZHwKRYfCZ9i8ZHwKRYfCZ9e8T0SPsXiI+FTLD4SPsXiI+FTLD5BfL3iI+FTLD4SPsXiI+FTLD4SPsXiI+HTK35AwqdYfCR8isVHwqdYfCR8isUniK9XfCR8isVHwqdYfCR8isVHwqdYfCR8esWPSPgUi4+ET7H4SPgUi4+ET7H4BPH1io+ET7H4SPgUi4+ET7H4SPgUi4+ET6/4CQmfYvGR8CkWHwmfYvGR8CkWnyC+XvGR8CkWHwmfYvGR8CkWHwmfYvGR8OkVPyPhUyw+Ej7F4iPhUyw+Ej7F4hPE1ys+Ej7F4iPhUyw+Ej7F4iPhUyw+Ej614t/AQHy94iPhUyw+Ej7F4k+e8KXjtf8s/u/R09Sjtz7vJWODp9ela6w96tw+VYELpZfOLu1HZ9riY9ipVIwu7UCcy08Hx9LBm90/Q7fqcM8H/0Y+dzC0JPK545glkc8dgiyJfO7oQSZy4/cpuluz8AX53IZ/ReRmbpstFPkxRWeNe32wDdYcM3SVg0125mg/KX0Rc27bDDE/H7xtO2q72crB/jBZPufn6f3WfW7HDN2v0n1uswzdr9KdoLsk3emI07aQf6I7sg6duiNwkaT7w3FZk+hLk44oZyExERItJCbiJ0li2mMY9jPqEg73uEnpsvmz8hYpmFblEZktq7w3+8HGk/1B/22Rr6FIqkWCMA5FUi0SQpEsWyThuDfnP5uLd4sEMR+KpFokyARHF4mPxwxr8W7lxr1FJihITL4beRbxoU7dkTSK0p3rRp5DzqhTd6SMknR/fZvIIQ1cSEykdguJSRBTkJiMt/EcIjOtyiMHW1Z5ttsuDvkaiqRaJAjjUCTVIkFyt26RcN2bI8R8KJJqkSATHFwk0R0zjOFnLoSQCS4kJjJBSWKy9XZE0F2l7ggPdeqO6FCU7mydN9JAnboj4OPX3UY6dE81p8241xUhiBMkJt9XJz2yNZ26Iy7TqTuSNVG6c31l1iOE06k7QXdBur/+QqZHsraQmIjLFhITGZgkMRm/MOuRgmlVHpHZssqz3RQLyNdQJNUiQRiHIqkWCZK7dYuE655sQMyHIqkWCaFIBhcJ315XAZmgIDH5buQFxIc6dUfSKEp3rht5ATmjTt2RMkrS/fVtoog0cCExkdotJCbSNUliMt7Gi4jMtCpPUH5V5dluu0TkayiSapEgjEORVIsEyd26RcJ1by4i5kORVIsEmeDgImHcHikhE1xITGSCksRk6+0S4kOduiM81Kk7QXdJunN13glpoE7dJw/4Qj6+dRy9F6L7Znen7bbPX5X+jXzyuGxF5JOHTysinzzKWRB5njxwEYn88e0aZ2L+gnzyWGRF5JMnEjKRv/XQDL7dOfPkMQPE/HQw2489MkF3lbpPHjNA94t0R8wgSneuH/lkZB06dUfgIkn31z8hyYhylhGTNoREC4mJ+EmSmHw/8blJDOWVKo/IbFnlub7GcysBFAmKpFYkCONQJNUiQXK3bpEwfYvsRgdFgiKpFQkywdFFwrY7J23IBAWJyXYjjwziQ526I2kUpTvTjTwyyBl16o6UUZLur28TGYKY64iJ1G4hMZGuSRKT8TaeQWSmVXnkYMsqz3bbxSBfQ5HUisQijEORVIsEyd26RcJ1b84i5kORVIsEmeDgIuHb0JEsQcx1xEQmKElMvt4O8aFO3REe6tQd0aEo3dk6b6SBKnV3CPhGPzSDba8rcgjiBInJ99VJh2xNp+6Iy3TqTtBdku5cX5l1COF06o4QTpLur7+Q6ZCsLSQm4rKFxEQGJklMxi/MElIwrcojMltWebabYoR8DUVSLRKEcSiSapEQimTZIuG6J0uI+VAk1SJBJji6SPj2uiJkgoLE5LuRR4gPdeqOpFGU7lw38jxyRp26I2WUpPvr20QeaeBCYiK1W0hMgpiCxGS8jecRmWlVHjnYssqz3XbxyNdQJNUiQRiHIqkWCZK7dYuE695cQMyHIqkWCTLBwUXCuD1SQCa4kJjIBCWJydbbBYLuKnVHeKhTd0SHonRn67yRBurUffKAL6V98DYb+6z779FPnjylYB+jd38efZw7EnGb3dm7LYYvo5/bq9dG392c+nR8vn2mT6P/PSA324BotgH52QbUvVcKR5tnA21fBxRnG1CabUDdF4zbdf9YAp4uQ/uA0jbbgMqXdUr7SkZ+C68H5I3dvyPq3XPSvNnShdrQPnxnnlq7UL6qZ38c/NQlxXKXlI0/2qT8hMbmrXR8OL5JZUJ8NHduKwdm4QjMyGyfjv4N0gIkD0i3EkhvHyBDqIC0j3FbQ/6nIAkgeUB6gOQBGaogfXwN0jl7oHkGWUYT07FSPt3ioLsnSJFhNPHIB8iF16MxwT7uuQR6Sgjidh9Qmm1AufOA4tNKcktF/J8HlLfZBmRYBxQ283pANofD5T591O19MOUWJIQ9lrpFELYymLAdg0nPP9ItXqfMdrSiZovrXKeyq4I0+TXI2xU8Hm/hw0+uU5kYRpMeDZ3NP7wsZD/bgELnAVUvC3G2AaWfDyjEY0Bx214PKPr94xjT1+tU7juYdGxlkSg8D6YU4frtEeHG1xep2+vuI07Wm8olKmbahxxztpWj3XH5u/n9x7GmePGL5rj4xacbIOWjTXx8mOLzOMpHb/a4Dm/Bfzr6pqXfts5amq2s5e/BlFfjFI7La86V1djYuB14bLS1K3dwOx4XjZnYV/vNAs45HAc453BodjjjekW/ecA5hxMA5xxO5IDjwgNOcj/wGX5LHOPJD7GeDWTZzW4pPLaXSE/Dj2X85J/4f+ly/Zalz8Bs/WeQ0+MH5c9VXZ7Bw/Jb656+EUP3ojbFFuxW68eXUrbaBFI6PvDpeaOw4njSdrTg7tFn/vr6zT/c/uuf//2vf/vbX//3P/7t7//yT//517//23/8OnP79T+m/DD22+feHAHL0/XAbL+/P2PKT+eunkVNZ/mms0LTWbHprNR0Vm45q/yUvupZpumsptpwTbXhmmrDNdWGa6oN11Qbrqk2XFNtUFNtUFNtUFNtUFNtUFNtUFNtUFNtUFNtUFNtUFNt+Kba8E214ZtqwzfVhm+qDd9UG76pNnxTbfim2vBNtRGaaiM01UZoqo3QVBuhqTZCU22EptoITbURmmojNNVGbKqN2FQbsak2YlNtxKbaiE21EZtqIzbVRmyqjdhUG6mpNlJTbaSm2khNtVH+xpDb/OOm8/OPIG7xyu+zfNNZoems2HRWajort5xV/oqCM9vjtyFPd/N+nVXKpY5Q4bbaPP2+y/jSF0KP30z4p+8z3BbS+3gMw3jSdqTPyaTKePzjfo4Pz5GUvQ/IzjYgN9uAaLYB+dkGFGYbUJxtQGm2AeW5BmS3bbYBTXaltlv/K3U8tpv20dPzgApRtH/8tMFH8/rg5PdhpKdfQZhf3yH4+sK3yOtIxJ++10Hlb4w8WqpPh/4m6EDwhwQJBH9I0IPgDwkGEPwhwQiCPySYQPCHBDMI/oyg2UDwhwQNCP6QIDzJTwnCk/yUIIHgDwnCk/yUIDzJTwnCk/yUIDzJTwnCk/yQoIUn+SlBeJKfEoQn+SlBeJKfEiQQ/CFBeJKfEoQn+SlBeJKfEoQn+SlBeJIfEnQjPIl5EEyvoZh0fIPVZOsqL20oP541EO3zS/+eq1E0V6tork7RXEnRXL2iuQZFc42K5poUzTXrmSsp6ptIUd9EivomUtQ3kaK+iRT1TaSobyJFfRMp6ptIUd/kFfVNXlHf5BX1TV5R3+QV9U1eUd/kFfVNXlHf5BX1TV5R3xQU9U1BUd8UFPVNQVHfFBT1TUFR3xQU9U1BUd8UFPVNQVHfFBX1TVFR3xQV9U1RUd8UFfVNUVHfFBX1TVFR3xQV9U1RUd+UFPVNSVHflBT1TUlR35QU9U1JUd+UFPVNSVHflBT1TUlR35RX6ptsDvtc3fb0VNAzMpEOMubptXNpJGHbn+QYnp6TarK5Y1ypJRuIcaVubyDGlRrJgRgJGDkwrtT+DsS4Umc9EONKTftAjCv5gYEYV7IawzC6DS6GBSNcDAtGuBgWjHAxLBhpIYy3oogHxlwbiDHRHi9u8vb86ulq7Cu5HkHYV3JJgrCv5KoEYV/JhQnCvpJrk4PdrOTyBGFfyRUKwr6SixSEfSXXKQg7AfsI7HCpQ7DDpQ7BDpc6BLtil2o3v4/E2NuMK9jtTaaPw61JT1AylY6O23F0tE/f7btjV+xSB2K3il3qSOyKXepI7Ipd6kjsil3qSOwE7COwK3apI7ErdqkjsSt2qSOxw6UOwQ6XOgL7Us/RE4QdLnUIds0u1aV0YCeqBb82HGOxIfgn7Lk0FmP3F7/dS3o+OpaOdvEYucvu09G/ZdLsagXJRJBJgkyaXbMgmTS7bEEyaXblgmTS7OIFyaTZ9cuRaamnxi4sk+ZUQZBMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMSz2DfWGZkEKIkAkphAiZkEKIkIkgkwSZkEKIkAkphAiZkEKIkAkphAiZkEJIkCkghRAhE1IIETIhhRAhE1IIETIRZJIgE1IIETIhhRAhE1IIETIhhRAhE1IICTJFpBAiZEIKIUImpBAiZEIKIUImgkwSZEIKIUImpBAiZEIKIUImpBAiZEIKIUGmhBRChExIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTIlJFCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCiJAJKYQImZBCiJAJKYQAmWhDCiFCJqQQImRCCiFCJqQQImQiyCRBJqQQImRCCiFCJqQQImRCCiFCJqQQEmQySCFEyIQUQoRMSCFEyIQUQoRMBJkkyIQUQoRMSCFEyIQUQoRMSCFEyIQUQoJMFimECJmQQoiQCSmECJmQQoiQiSCTBJmQQoiQCSmECJmQQoiQCSmECJmQQkiQySGFECETUggRMiGFECETUggRMhFkkiATUoiLZLLkD4SpJhPlQya/bfmrTEghRMiEFEKETEghRMiEFEKCTIQUQoRMSCFEyIQUQoRMSCFEyESQSYJMSCFEyIQUQoRMSCFEyIQUQoRMSCEkyOSRQoiQCSmECJmQQoiQCSmECJkIMkmQCSmECJmQQoiQCSmECJmQQoiQCSmEBJkCUggRMiGFECETUggRMiGFECETQSYJMiGFECETUggRMiGFECETUggRMiGFkCBTRAohQiakECJkQgohQiakECJkIsgkQSakECJkQgohQiakECJkQgohQiakEBJkSkghRMiEFEKETEghRMiEFEKETASZJMiEFEKETEghRMiEFEKETEghRMiEFEKCTBkphAiZkEKIkAkphAiZkEKIkIkgkwSZkEKIkAkphAiZkEKIkAkphAiZkEIIkOn2b5BJgkxIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTIZJBCiJAJKYQImZBCiJAJKYQImQgySZAJKYQImZBCiJAJKYQImZBCiJAJKYQEmSxSCBEyIYUQIRNSCBEyIYUQIRNBJgkyIYUQIRNSCBEyIYUQIRNSCBEyIYWQIJNDCiFCJqQQImRCCiFCJqQQImQiyCRBJqQQImRCCiFCJqQQImRCCiFCJqQQEmQipBAiZEIKIUImpBAiZEIKIUImgkwSZEIKIUImpBAiZEIKIUImpBAiZEIKIUEmjxRChExIIUTIhBRChExIIUTIRJBJgkxIIUTIhBRChExIIUTIhBRChExIISTIFJBCiJAJKYQImTSnEGEzh0zx08BT8dWzOaA8y3Qiatp2UaPJtaPtlvejrY2fjv4tk+YUQpBMBJkkyKQ5hRAkk+YUQpBMmlMIQTJpTiEEyaQ5hZAjU9ScQgiSSXMKIUgmpBAiZEIKIUImgkwSZEIKIUImpBBTyETO7UdTqt1SCWQ/Dg7hIamLpVnmx82a7WkY5YODOY4O1m+Vo000Yed9+zu72qvng3fI5qkWS3NMt1tLHwcn+6s2Hgf/rlvEMqhbiXWLnAp1K7FuEdyhbgXWbUKSibqVWLeIdlG3EusWWTfqVmLdIvxH3UqsW0Ldom4F1i1uD6FuJdYt7pehbiXWLe6XoW4l1i3ul6FuJdYt7pehbgXWbcb9MtStxLrF/TLUrcS6xf0y1K3EusX9MtStxLol1C3qVmDd4n4Z6lZi3eJ+GepWYt3ifhnqVmLd4n4Z6vbxwtbHo25T7aVNCseof/1Nn47/XV24q4Xquqq6woZ7T6iu66oLd4hQXddVF+7joLquqy7cbUF1XVddhOpCdV1WXbhzgeq6rrpwfwHVdV114S4Aquu66kJWj+q6rrqQ1aO6Lqsug6we1XVddSGrR3VdV13I6i+qrnh8N+X25+ejf4NHjD0IPAH8GPAIPweBRy44CDwis0HgkSYNAo+gZQx4iwxiEHjY80Hg4VwHgYdzHQSeAH4MeDjXQeAVO1fn4p4hG0feVlDe/tUfUa9J8fHDvFAEv9kDvLVPx/7Grti3jsSu2LWOxK7Ys9IWj3GToVjBHrbHT3/D49hsfoN0ij0oL0jFnpIXpGKPyAtSsefjBUkAyQNSsSfjBanYY/GCVOyaeEEq9kG8IOFseEASnA0TSDgbJpBwNkwgNTubQPkAGapfarYu7iSty09pffZvh25EwD4Cu2bXNBC7Zo81ELtmRzYQu2b/NhC7Zrc3DrvX7A0HYtfsJAdi1+w7B2KHSx2CnYB9BHa41CHY4VKHYIdL/TZ2MseWDUTbJ+y/UcJ5sqGEm+RCGeAQ2VDC9bGhhJNjQwl3xoaSgJILJVwUG0o4IzaUcDtsKOF22FDC7XChjHA7bCjhdthQwu2woYTbYUNJQMmFEm6HDSXcDhtKuB02lHA7bCjhdrhQJrgdNpRwO2wo4XbYUMLtsKEkoORCCbfDhhJuhw0l3A4bSrgdNpRwO1woM9wOG0q4HTaUcDtsKOF22FASUHKhhNthQwm3w4YSbocNJdwOG0q4HSaUcYPbYUMJt8OGEm6HDSXcDhtKAkoulHA7bCjhdthQwu2woYTbYUMJt8OF0sDtsKGE22FDCbfDhhJuhw0lASUXSrgdNpRwO2wo4XbYUMLtsKGE2+FCaeF22FDC7bChhNthQwm3w4aSgJILJdwOG0q4HTaUcDtsKOF22FDC7XChdHA7bCjhdthQwu2woYTbYUNJQMmFEm6HDSXcDhtKuB02lHA7bCjhdrhQEtwOG0q4HTaUcDtsKOF22FASUHKhhNthQwm3w4YSbocNJdwOG0q4HS6UHm6HDeVSbsfRgdLFUDs6pJ2ku+W2T0fHO5ql3AsvmqXcCC8aApozNEu5BV40S3X/vGiW6uZ50SzVnfOiWarbZkUTluqeedGgGz5Fg274FA264VM0BDRnaNANn6JBN3yKBt3wKRp0w6do0A2foVnr2e28aNANn6JBN3yKBt3wKRoCmjM06IZP0aAbPkWDbvgUDbrhUzTohs/QrPVsb1406IZP0aAbPkWDbvgUDQHNGRp0w6do0A2fokE3fIoG3fApGnTDZ2jWevYzLxp0w6do0A2fokE3fIqGgOYMDbrhUzTohk/RoBs+RYNu+BQNuuETNGmtZwPzokE3fIoG3fApGnTDp2gIaM7QoBs+RYNu+BQNuuFTNOiGT9GgGz5Ds9azY3nRoBs+RYNu+BQNuuFTNAQ0Z2jQDZ+iQTd8igbd8CkadMOnaNANn6FZ69mivGjQDZ+iQTd8igbd8CkaApozNOiGT9GgGz5Fg274FA264VM06IbP0Kz17EleNOiGT9GgGz5Fg274FA0BzRkadMOnaNANn6JBN3yKBt3wKRp0w2do1no2IS8adMOnaNANn6JBN3yKhoDmDA264VM06IZP0aAbPkWDbvgUDbrhMzRrPbuOFw264VM06IZP0aAbPkVDQHOGBt3wKRp0w6do0A2fokE3fIoG3fAZGjyL7hwNuuFTNOiGT9GgGz5FQ0Bzhgbd8CkadMOnaNANn6JBN3yKBt3wGRo8i+4cDbrhUzTohk/RoBs+RUNAc4YG3fApGnTDp2jQDZ+iQTd8igbd8BkaPIvuHA264VM06IZP0aAbPkVDQHOGBt3wKRp0w6do0A2fokE3fIoG3fAZGjyL7hwNuuFTNOiGT9GgGz5FQ0Bzhgbd8CkadMOnaNANn6JBN3yKBt3wCZqMZ9Gdo0E3fIoG3fApGnTDp2gIaM7QoBs+RYNu+BQNuuFTNOiGT9GgGz5Dg2fRnaNBN3yKBt3wKRp0w6doCGjO0KAbPkWjtxsmt9mPo8n58AlNYSQUdyTGm6eR5NK4w5Y+Dg726ZWzuUPX22cPhK63gx8IXa83GAdd8TP/BkLX62cGQtfrlAZC1+vBBkInQO8PXa9vHAgdjnQAdDjSAdDhSAdAhyPtD32x526m/WhH1n86+vdk13KClcmu5cAqk13L+VQmS5omu1anX5nsWh12ZbJrdbaVya7VUVYmu1Yn93qyiz2rsTJZTR3UYs9TrExWUwe12DMPK5PV1EEt9lzCymQ1dVCLPTuwMllNHdRiz/erTFZTB7XYM/gqk9XUQS32nLzKZDV1UIs9y64yWU0d1GLPm6tMVlMHtdgz4SqT1dRBLfbctspkNXVQiz1brTJZTR3UYs8/q0xWUwe12DPKKpPV1EEt9hyxymQ1dVCLPeurMllNHdRiz+OqTFZTB7XYM7Mqk9XUQS32XKvKZDV1UIs9e6oyWU0d1GLPh6pMVlMHtdgznCqT1dRBLfacpcpkNXVQiz0LqTLZpTooco/JVn8TaOL+uz27PV7Zplw4Nh08ksuVY/NBPOfPx/4CvtYzkyQAX6qTlAB8qW5WAvClOmoJwAnA+wJfyllIAL6Uu5EAfCmHJQH4Ui5PAnA4za7AzbbWA8lEEF/La6Zjh6VEpkbcpmPPJOfo6ehQem1vDjV92j4dfSe5lokcSXItdziSJIEkE8m1/NxIkmsZtZEk13JgI0muZa1GklzLMw0kudbj6IaShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIrnWw++GkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51uPUhpKEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudYDD4eShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIrnWI0mHkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51kODh5KEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudZjvYeShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIpngcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkczwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XF4SJoNHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kDj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiaSFx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLB43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIknwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSHp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJAM8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkhEeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQSPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJZIbH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8ND0m7wOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSBp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJC08DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkg4eh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSYLH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NE0sPjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiGeBxuEjC43CRhMfhIgmPw0WSQJKJJDzO90iSjfnjaHLeVo42FI/X9uZp3Lk0y7Clj4ODDU/Hmg+N4J7m1wi+bH6N4Pjm1whecnqNIlzq/BrB/86vEZz1/BrBs8+vEUGj6TVCzjC/RsgZ5tcIOcP8GiFnmF8jxTmDOwZiwuYq1K3dto+jLbnPGv0mmRSnAcwkFXt2ZpKKnTUzScX+l5kkgSQTScVekpmkYsfHTFKxL2Mmqdg9MZOEx2EimeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4/CQdBs8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkgYeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSQuPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIPH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEkuBxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCR9PA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIBngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk41IeJ/mDZN7o09H32S7lQ6qzXcorVGe7VD9fnS2pmu1SfXF1tkv1rtXZLtVfVme7VA9Yne1SfVpttms9T706W1W91FrPJa/OVlUvtdbzvauzVdVLrfWc7OpsVfVSaz1vujpbVb3UWs9trs5WVS+11vOPq7NV1Uut9Rzh6mxV9VJrPY+3OltVvdRaz7WtzlZTL0VrPR+2OltNvRSt9ZzV6mw19VK0karZauqlaK3nflZnq6mXorWen1mdrapeaq3nUFZnq6qXWut5jtXZquql1nouYnW2qnqptZ4vWJ2tql5qref0VWerqpda63l31dmq6qXWem5cdbaqeqm1nr9Wna2qXmqt55hVZ6uql1rreWDV2arqpdZ6rlZ1tqp6qbWeT1Wdrapeaq3nPFVnq6qXWut5SdXZquql1nruUHW2qnqptZ7fU52tql5qrefgVGerqpda63ky1dku1Utl44/ZhtrRJqaPg+3TDjg25cKx6eCRXK4cm9M+5Jw/H3snvlQ/J4L4Uj2lCOJL9bU57sMmQ1vlaBud3ZHH/Hy0KzG/sdqh2197bz0dfSe5VM88kuRaz5oZSnKpXn8oyaV8xFCSS3mUoSQJJJlIruWtRpJcyzONJLmWFxpJEh6HiyQ8DhPJtZ41M5QkPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TybWeNTOUJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8m1ngE1lCQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJtZ7NNpQkPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4PSb/WMxOHkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51rNMh5KEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudYzhoeShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIrnWs7+HkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJJ8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEh6eBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQDPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIRHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8kEj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSGx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DQzJs8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEgaeBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQtPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIOHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0mCx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLD43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIhngcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkYzwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSCZ4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJDM8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBweknGDx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLA43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhImnhcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkXTwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSBI8DhfJlTwOmeNoMjl8Ovo+25V8SH22K3mF+mxJ1WxX6rnrs12pL67PdqXetT7blfrL+mxX6gGrs13qWe312arqpZZ65nl9tqp6qaWeHV6frapeaqlncNdnq6qXWupZ1vXZquqllnomdH22qnqppZ6tXJ+tql5qqWcU12erqpda6lm/9dmq6qWWemZufbaqeqmlnj1bn62qXmqpZ7jWZ6uql1rqWaj12arqpZZ6pmh9tqp6qaWezVmfrapeaqlnXNZnq6qXWupZkfXZquqllnrmYn22qnqppZ5dWJ+tql5qqWcA1merqpda6ll69dmq6qWWeiZdfbaqeqmlnu1Wn62qXmqpZ6TVZ6uql1rqWWP12WrqpdJSz+yqz1ZTL5WWevYVkXH7bKPZCrNdqpeqzpZUzXapXqo626V6qepsl+qlqrNdqpeqznapXqo226WeDVSf7VK9VHW2qnqppZ6DU58tqZqtql5qqWe+1Gerqpda6tkp9dmq6qWWegZJfbaqeqmlnuVRn62qXmqpZ2LUZ6uql1rq2RL12arqpZZ6RkN9tqp6qaWedVCfrapeaqlnBtRnq6qXWmrv/fpsVfVSS+1hX5+tql5qqb3g67NV1Usttad6fbaqeqm19j2vzlZVL7XWvufV2arqpdba97w6W1W91Fr7nldnq6qXWmvf8+psVfVSa+17Xp2tpl4qD8iTQ9yP9iG559neRzTgs7U9+G/h64ioOCLrdiGci6kyIhfyth+dtq+PpconkRnzm4QebxJ7vEnq8Sa5w5ucpBDMb2J6vInt8Saux5v0+MRTj0889fjEU49PPPX4xFOPT7zv8Yn3PT7xvscn3vf4xPsen3jf4xPve3zifY9PvO/xifc9PvGhxyc+9PjEhx6f+NDjEx96fOJDj0986PGJDz0+8aHHJz70+MTHHp/42OMTH3t84mOPT3zs8YmPPT7xsccnPvb4xMcen/jY4xOfenziU49PfOrxiU89PvGpxyc+9fjEpx6f+MTxiU/xODpvpvAmqceb5A5vkrceb2J6vInt8Saux5tQjzfxzG9ibOFNOD7x6bj947LdPr3J16PTcYsluccdFpty4djbBenj2Jw/H3sffJQ8+CR58Fns4O22bZIHbyQP3koevJM8eJI8eC958HJX2Nvg5a6wt8HLXWFvg5e8wpq5V9iwH2tuK1Jh9HMvsbXRz73G1kY/9yJbG/3cq2xt9HMvs7XRc6yz2cZj9D5WRv/6O4a3EcXpRpSmG1GebUR2m25EZroR2elG5KYbEU03Ij/diKa7ZtvprpC2/xXy5TfV7ebcdCPq/1mL9jEiG7+OyE83ojDdiOJ0I0rTjWjAp5/CMSJPzyP6erClYyCWiL4MnzbZwzeyh29lD9/JHj7JHr6XPfwge/hx8uHb9Bj+14aMkuzhz77qvh6+n3zV9X7veawP7vXB4Xa7/uPgcMtXv8518iX6nbn6HPPLuU6+nvsj+7U+mtcHp21/4URPP7S+VfN9qpOv/ZxTJT1Tnbyn4Jzq5P0H51Qn71UYpxpmX1nfmarfc8cUw6epFl7YuH3M1vjHC1NxFGlf8tz26dA7wtkXbAEIV+oDBiFcqb8YhJCA8KcIV+qHBiFcqc8ahHCl/m0QwsnzLgkIJ8/cBCCMcCc/Rgh38mOEcCc/Rgh38lOESWsVbtkeCJ++KlVEmNI+iE8/Di6+sLm99/7Kt7/j43i30QdzrWU7kjmBeXfmWm37SOZaff5I5lqDgZHMtSYJI5lrjR4GMs9as4qRzLWGGyOZw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KG9mZsNPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7MDXxof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmVv40P7M4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDuzN38KH9mcOH9mcOH9qfOXxof+YE5t2Zw4f2Zw4f2p85fGh/5vCh/ZnDh3ZnPvsTTJdkDh/anzl8aH/m8KHdmYt6hmJ6fXAM+7ExfqJ4n6mk6vrZTEnNTEc4+scD6n1l8K9e+j7+IHz8Ufj4k/DxZ9njH/L8SM7xm6nHT5vbH6BMW86Vl3Z0NAuO0tOwb29zn61VNVunarakarZz9w3cs527y+Ce7dw9Cfds5+5guGc7d7/DPNs4d3fEPVtVvVSU20vdxy+3O7qPn4SPX24Hcx+/3J7kPn65XcZ9/JP3DeYIFMkZqrx02mgP291jrjblwrE57S+c8+dj71wm7zBGcUmT9yLDuEzetQzjMnl/M4zL5H3TMC4ELkUuk/d5w7hM3j8O4zJ5XzqMC/rdMhf0u0UuGf1umQv63TIXmpyL2fNIMraQB+TZ+4za+GfvB2rjn33dro1/9vW1Nv7Z18HX47fb7OtVbfyzryu18c+ed9TGP3suURu/7PXXbrLXX7vJXn/tJnv9tZvs9dduwtdfI3z9NcLXXyN8/TXC198h+/tzjl/4+muEr79G+PprhK+/Rvj6a4Wvv1b4+muFr79W+Po7ZF9jzvELX3+t8PXXCl9/rfD11wpff53w9dcJX3+d8PXXCV9/h+znyDl+4euvE77+OuHrrxO+/jrh6y8JX39J+PpLwtdfEr7+kvD1l4SvvyR8/SXh6y8JX39J+Prrha+/Xvj664Wvv174+jtkz0HO8QtffyffSbA+fuHr7+Q7CdbHL3z9nXwnwfr4ha+/s+8NWB2/8PV39v37quMXvv7OvsdedfzC19/Z98Grjl/4+jv7XnXV8Qtff2ffT646fuHr7+z7yVXHL3z9nX0/uer4ha+/0+8nVxu/8PV3+v3ZauMXvv5Ov99ZbfzC19/p9w+rjV/4+jv9fly18Qtff6ff36o2fuHr7/T7RdXGL3z9zcLX3yx8/RW+/5UVvv+VFb7/lRW+/5UVvv+VFb7/lRO+/5UTvv+VE77/lRO+/5XbZK+/bvr9ry7bVzTsx5pts58OvoNRu9F1DYzana5rYNRudV0Do3av6wqY6TcvGwZG7lNM7uOX+7SR+/hJ+PjldjX38cttPu7jl9sj3Mcvdym/j1/uivt7/NPvKlYbv9ynNdzHL3z9nX5Xsdr4ha+/0+8qVhu/8PV3+l3FauMXvv5Ov6tYZfzT7ypWG7/w9Xf6XcVq4xe+/k6/q1ht/MLX3+l3FauNX/j6O/2uYrXxC19/p99VrDZ+4evv9LuK1cYvfP2dflex2viFr7/T7ypWG7/w9Xf6XcVq4xe+/k6/q1ht/MLX3+l3FauNX/j6O/2uYrXxC19/p99VrDZ+4evv9LuK1cYvfP2dflex2viFr7/T7ypWG7/w9Xf6XcVq4xe+/k6/q1ht/MLX3+l3FauNX/j6O/2uYrXxC19/p99VrDZ+4evv9LuK1cYvfP2dflex2viFr7/T7ypWG7/w9Xf6XcVq4xe+/k6/q1ht/MLX3+l3FauNX/j6O/2uYrXxC19/p99VrDZ+4evv9LuK1cYvfP2dflex2viFr7/T7ypWG7/w9Xf6XcVq4xe+/k6/q1ht/LLXX5p+V7Ha+GWvvzT9rmK18ctef2mTvf6S4F3F7uOXvf6S4D267uOXvf6S4B2vfo9f8MZU9/ELX3+F739Fwve/IuH7X9Hs+18Fl/fxp81VXvqtjeXSPsOcPx975zL5uj6My+T9wjAuk/ch13F5vUEjzb7B2DAws+9cNg7M5C3ZODCT93rjwEzeRI4DQ3ODScdLU6IamBjcx8ExhuNYsh9TnbyR5Zzq5L0p51QnbzdfTPU+/snbwur4J+/eauOffHs6b8jvB5tQsOeTb09XH//cLUt9/HN3FvXxk/Dxz72q18c/91JdH//c6299/HOvv/Xxz73+Po/fGvt1/JNvT1cfv5z1tzx+Oetvefxy1t/y+OWsv+XxT77+RhOPg1MujH/y9bc6/snX3+r4J19/q+OffP2tjX/y7enq4598/a2Of/L1tzr+ydff6vgnX3+r4xe+/k6+PV19/MLX38m3p/PJbfvBOaTKS1M+Jvv8VaaUCsfauO2PM7bRPjrb8MFl8nV9FJfJt9Mbx2XyPoSJy32uk/csrHOdvL9hnSspmuvkfRPrXCfvsVjnOnk/9tZcb5HbfjClwlxX6t1qc12pH6vMdfItE3nnulLfVJvrSn1Tba4r9U21uZKiua7UN9XmulLf5P3RN6VC3zT5NpO8c12qb6rMdam+6fVcJ9/qkneuS/VNlbku1TdV5rpU31SZKyma61J9U2WuivqmybcHfTXX+/jl9kL38cvtb36Pf/LtQevjl9uH3Mcvt7e4j3/ufiFs2z6Q4IIpjJ+Ej3/udb0+/rnX6vr4515/6+Ofe/2tj3/u9bc2fj/59qD18c+9/tbHP/f6Wx+/7PXXb7LXXz/59qD18ctef/3k24PWxy97/fWTbw9aHf/k24PWxy98/Z18e9D6+IWvv5NvD1ofv/D1d/JtPOvjF77+Tr4tZn38wtffyTeZrI9f+Po7+ZaN9fELX38n3wCxPn7h6+/kWxXWxy98/Z18/8H6+IWvv5PvP1gfv/D1d/L9B+vjF77+Tr7/YH38wtffyfcfrI9f+Po7+f6D9fELX38n33+wPn7h6+/k+w/Wxy98/Z18/8H6+IWvv5PvP1gfv/D1d/L9B+vjF77+Tr7/YH38wtffyfcfrI9f+Po7+f6D9fELX38n33+wPn7h6+/k+w/Wxy98/Z18P7/6+IWvv5PvpVcfv/D1d/I97+rjF77+Tr43XX38wtffyfeQq49f+Po7+V5v9fELX38n35OtPn7h6+/ke6fVxy98/Z18j7P6+IWvv5PvRVYfv/D1d/I9w+rjF77+Tr63V338wtffyffgqo9f+Po7+V5Z9fELX38n3/+qPn7h6+/k+1/Vxy98/Z18/6v6+IWvv8L3v/LC97/ywve/8sL3v/LC97/ywve/CsL3vwrC978Kwve/CsL3vwqb7PU3CN//Kgjf/yoI3/8qCN//Kgjf/yoI3/8qCN//Kgjf/yoI3/8qzL7/FaX94OCNLYx/8vXXxYP/7cTKS6eNPg5O7vGscPvrueFfjs1pf+GcPx975zL5uj6My+T9wjAuk/chw7hM3t+M4jL7vmXDuEzejw3jMnmfN4zL5P3jMC4ELkUu6HfLXNDvlrmg3y1zQb9b5oJ+t8hl9n0Ch3FR2++G/VizbbYARm3DWwOjtuOtgSGAKYNR2/PWwKhtemtgJu9ifMo7mNsdmMpLG583t0/X51/H7C9+n+3se/i9mO19/JOvCNXxz33hjjHuB8f41MOVX9rG4D+OtjG655e+T3buizHzZOe+wDJPdu6ogHmyc/t/5snOvRzyTnbyHQ2ZJzu3/Wae7Nx9zruTzXafbHrqKo7Jzt0UMU+WNE12pQ7K2W1vjp218etkV+qgqpNdqYOqTnalDqo62ZU6qNtkt1eTnXxPxDcnS2Y/2pHdvk52pXW2OtmV1tnqZJdaZ2uTXWqddTkdkzXb65f2Oe6Xbp9z4Wq21KL8DpmwHdf5sBUa0cn3nuxTM2UySy335I7ehrz52adp8v0y+5Ap1szkO3G+S+a4decop6+TXatFrEx2rRaxMlnSNNm1WsTHZP3TXfFjsku1iLXJLtX11Sa7VCNXm+xSvZl7DMSb+PqlTUh7P28iPf0Ylj6+CDL5ZqRvoonHT39dzO5nbevk25xeSKZmAiffQLVPzZTJ0FJkjpd2f7opVbjQbPn4wplxW+FCs1TflCwdaHLlpWnbB0328xW4gPERSRgyD3vpDoxLdWTjMC7V643DuFQXOQ7jUv3pMIyTb0wsBuNSlmAcxqX8w1sY3W4f6HmGB5il7AMnmMl/tMT7E5TZt3Fmnu3kP6pnnu3kP5Vnnq2mn47F2befZp7t5D9WZ56t3J8FtsxW7o8IW2ZLa83W0WO2/umez8nR9uno8IXNYp0XK5vF+jRWNot1dW+wIXP4X7LPtyE/yCzWATKSWaxb5CMz+8bqA8ks1oUyklmsY2Uks1h3y0iGQOaEjN4+uEZGbxdcI4Me+IwMeuAzMqv1wGcusfDa6fhGZnRPPzo6ee2c9kneMD49jOU2hd8kZ99UXxDJ1XpsHpJ3Nqt12ZxsVuuzXyZeJ5umm2MnRmdtrszWpG3ftMck88zGF2e7PWa7hefZ3kcU+4/IPkb0dTOEeLJR+MgR5dlGdLI59sgRmelGZPuPiMLjylL5yrel4xJniejr8J3s4ZPs4XvZww+yhx9lDz/JHn4WPXzaJh++TY/hf23IyMge/uyrbmX4k6+63u89j/XhZz9EjDT5Ev3OXCs/LYw0+XrujTvmGiv7oqTjCcOJnsb88T3oSJOv/ZxTnbxP4Jzq5D0F51Qn7z8Yp+on71U4pzr7yvrOVP0+jBTDp6kWXti4R3L+tOUVFUfx+DX99unQO8LZF2wBCFfqAwYhXKm/GIRwpb5lEMKV+qExCONKzcc7CLfH4wLM0y2xIsKU9kFkU/1R8+29j9t/KcbH8W6jD+aTpztLMp88klqSudZufyRzAvPuzLX6iZHMtRqQkcy1OpaRzLVanJHMV8qehTBP8KH9mcOH9mcOH9qfOXxof+YE5t2Zw4f2Zw4f2p85fGh/5vCh/ZnDh3ZnnuFD+zOHD+3PHD60P3P40P7MCcy7M4cP7c8cPrQ/c/jQ/szhQ/szhw/tzTxt8KH9mcOH9mcOH9qfOXxof+YE5t2Zw4f2Zw4f2p85fGh/5vCh/ZnDh3ZnbuBD+zOHD+3PHD60P3P40P7MCcy7M4cP7c8cPrQ/c/jQ/szhQ/szhw/tztzCh/ZnDh/anzl8aH/m8KH9mROYd2cOH9qfOXxof+bwof2Zw4f2Zw4f2p25gw/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ789kfcLskc/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7Ml3p4uRTm8KH9mcOH9mcOH9qfOYF5d+bwof2Zw4f2Zw4f2p85fGh/5vCh3ZkH+ND+zOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ7szj/Ch/ZnDh/ZnDh/anzl8aH/mBObdmcOH9mcOH9qfOXxof+bwof2Zw4d2Z57gQ/szhw/tzxw+tD9z+ND+zAnMuzOHD+3PHD60P3P40P7M4UP7M4cP7c48w4f2Zw4f2p85fGh/5vCh/ZkTmHdnDh/anzl8aH/m8KH9mcOH9mcOH9qbed7gQ/szhw/tzxw+tD9z+ND+zAnMuzOHD+3PHD60P3P40P7M4UP7M4cP7c7cwIf2Zw4f2p85fGh/5vCh/ZkTmHdnDh/anzl8aH/m8KH9mcOH9mcOH9qduYUP7c8cPrQ/c/jQ/szhQ/szJzDvzhw+tD9z+ND+zOFD+zOHD+3PHD60O3MHH9qfOXxof+bwof2Zw4f2Z05g3p05fGh/5vCh/ZnDh/ZnDh/anzl8aHfmBB/anzl8aH/m8KH9mcOH9mdOYN6dOXxof+bwof2Zw4f2Zw4f2p85fGh35h4+tD9z+ND+zOFD+zOHD+3PnMC8O3P40P7M4UP7M4cP7c8cPrQ/c/jQ7swDfGh/5vCh/ZnDh/ZnDh/anzmBeXfm8KH9mcOH9mcOH9qfOXxof+bwod2ZR/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7M0/wof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmee4UP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3M3G0bfGh/5vCh/ZnDh/ZnDh/anzmBeXfm8KH9mcOH9mcOH9qfOXxof+bwod2ZG/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7M7fwof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmfu4EP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3OnOBD+zOHD+3PHD60P3P40P7MCcy7M4cP7c8cPrQ/c/jQ/szhQ/szhw/tztzDh/ZnDh/anzl8aH/m8KH9mROYd2cOH9qfOXxof+bwof2Zw4f2Zw4f2p15gA/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ78wgf2p85fGh/5vCh/ZnDh/ZnTmDenTl8aH/m8KH9mcOH9mcOH9qfOXxod+YJPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7MM3xof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KG9mZsNPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7MDXxof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmVv40P7M4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tDtzJ8kTpdcHx7AfG+Mnir9nSpKcyM9mKqn//9lMR3Td5jHTyuBfvfR9/E74+En4+L3w8Qfh44/Cx58mH7/fL8smW1d5aUM570f7p14h7BfbrGiyQ543PWyyZqHJ2hSP9iLlXDna2Zz2Sd5K/DGQDzKzNxjjyMzeuowjQ3rJuJAPMik+kfl6LJmDIlkTv1CcvTWTQXH2BvE9ilvcKWazVY5OxxyTe0zxhr9wbE77MHL+fOyd4uxtqgyKKzXL4yiu1IUPoxhWau/HUVzLN4yiuJbHGEVxLT8yiiKBIgPFtbzLKIrwLhwU4V04KMK7cFCEd2GgGOFdvkUx7MeabbMFjDAvLBjhXlgwwr6wYCRg5MAIA8OCcSkHkx93pbYqRkPxYOPN02vn0kjCtt/ECvbp27LZfHBcysMM5LiUixnIcSkfM45jWsrJDOS4lJUZyJHA8XscaT84eFPgiPX6mxyPn+eEkAocFa/X3hzD9o4+cbyzUbwG19hkxetqlY3itbLKZqks783r9jGQGxtfuW7f/jXRYyj5y/cu81Jx3lCSBJJMJJcK9YaS1Jzr8ZJcySm4zcWDZK4NpPLN/bxS789LZqXOn5OM3Vbq+98jY0zw++G3v5+25zC/JvH11V/+hstuK7mEsSRX8hRjSa7kKS4myfYLOrsRqA+gvpJXeZd6tMeL36I8V6FuYzy+3hCft9P5ILmSVxlLUq9X4Sap19u8S5Lz/qbd9DqnodyNZl82krtmFzeSu2bPN5K7Zoc4kjt67Iu4v/yekTXoZy7i/vJ7Sdain/k298p3LqxFj8LHEn0HH0v0EnwsCSy/vU5xfr/AWuTIo8ijJx5FHjn1KPLItUeRV+wEbzdLD5S3qJkq5G93Wx9Pm0lPUDIV7+Rsx9HR2j9zd4qd4FDuil3jUO6KHSYj9ztLxQ6TnSWBJRtLxZ6RnaViF8jOUrGvY2ep2Km9y9IeNz9vAftWYAnvxcaS4Kf4WKK/5GOJdfzbLD1tO0vvSyyxjvOxxDpeZnmng5X5BZ2lHvHIT0dzwmjN8bzM2y3krXKVqvxub6lnSI4lqbmj4yVJIPldkny/alzqmZZyqGv2Lp+oB1NY5zW7kTodzf6iTkezv3ApHXSIqr+IDfZIWIJ7/v79fa94u9QTKXuyjAWWmr3LD1iSLbDU7F7eZXmMxYbgP7EsjSVsx1jC8z2qWJxnPAx7Sq5ydLL7NBOZT8feNdXso1bVlKDpcppq9ouraqrZja6qqWYPvaqmmp3/qpoir1hO06WehqtGU79/PTP5WNAU+Y1ATen4nD4BfGiKHEm0psEVNIU/nUFT690O5XaL2RZ0guecQ6fHrqjB+IJO8JEydII3lKET/J4InZZ6DvDKOsGXydAJXkuGTujLp/DE+fFFt1zKGJd6nvXKOqEvl6ET+nIROi31HPGVdUJfLkMn9OUydEIfcZFOlvyBMPmKTi4ktx8dUi7ohD5Cgk5O83OJRemEPkKGTugjZtCJ3PGYHHLJFXTC72ym0CkfOSzllAo6EXSaSye/baXrHr5vJEMn3NeQoRPua8jQCXmEDJ2QR4jQSfPzuEXphDxChk7II2TohDxChk4EnUTohDxChk7II2TohDxChk7II2TohDxChE4WeYQMnZBHyNAJeYQMnZBHyNCJoJMInZBHyNAJeYQMnZBHiNDJoS+/SCdzPB3gFnbXdHLu0Mm50vcsHfry6XTKhe8tO/TlMnQi6CRCJ/TlMnRCXy5DJ/TlMnTCfUIZOuE+oQidCPcJZeiEPEKGTsgjZOiEPEKGTgSdROiEPEKGTsgjZOiEPEKGTsgjZOiEPEKETh55hAydkEfI0Al5hAydkEfI0ImgkwidkEfI0Al9eZNO0VZ0imHf8DXGcBxL9o49oM0egh1d8xDsaIK/jT3G/XCbNlfBnl3aEWbanh67noprQcqPteDp4OKDznIyxyw3+/pgY7Z4iGM+QUkfFYD2mqMC7iwJLL/LMtl8sPRbgSVi/u+zDHSwDOEry6j5Ku/dMW7ro6mwzHHfZd5s5uniGj4WzKj5chk2c6CMnwZeXNW2fCxU9tk9nXQ1aX+q0O21c+3o2z/vRxuKlaNT3qFkU7jURM2X7VU11ZxyrKqp5m9oSNU0Z3csqFv6JOrXg0M+ZhmyqbimdGuNPg5ONtgvziZq7iBRLm+Xi+bvq6Bc3i4XzfE8yuXdckmabyugXN4uF823Q1Aub5eL5oAP5fJ2uSDERLm8US6EclmpXO6iIiBdUFQkpAuKihxTnqhms9uhKm2V5drkcNzwz3mZ7xZlhB4CK/dmD/aBu2y/Xo8ysokVVUWEIF3VXFAVTn9FVQmqLqgqHPmKqsKSr9gtwZOvqCq+ArSiqvimznqq0oZsaUVVkS2tqCqypRVVRba0oqpIIVZUFSnEFKra7fjVu7WfVb3rhFxBhk5ICmToBO8vQicDNy9DJ/hzGTrBcc+h0/Ho7ZtMW0EneGgZOhF0EqET/JMInSz6vTl0Or7vbd2fRnLXCf3eFDo5f3yePm0WfeiEfk+GTuj3ZOhE0EmETrhbJUMn3H+SoRP8kwydcP9Jhk64/zSFTuT270dYSq5ydKB9D/AQHtm6i6VZJr8jSSl/Ova3/g45h279kZ/o1h+5zNr658eTOjaTKwd74/bbtt4kqhwdgtuOcThTKC6ESSiuy4qLUFworquKC7Ediuuy4kLWiOK6rLgQkKK4LisupLoorsuKC1E0iuuq4iLk3Ciuy4oLITqK67LiQkKP4rqsuJDQo7guKy5CcaG4riouJPQorsuKCwk9iuuy4kJCj+K6rLiQ0KO4LisuJPQorsbiiu6okngj8rW4PBJ6FNdlxYWEHsV1WXERigvF1VpcyR/F9YT7UVyIIlBcrcVF9rhy3cZfKC409Ciuq4or4MY1iqu1uJLfgcQUSsWFG9coroc2dGw368lshXIhlAvK5fvlgpvLKJc3ygUeDeXypM1h6X3aCrdRAm4Ao1zeKBfc0kW5PGkTtqNcbM1HGbfZQx23/clJlYA/pL/9HUzteO8PhsaHrbA4Rjg1lG+/8j1m+at8a6MxlPwxeEqxkL8npFgo3+byNfZ4cWd84eqYcHVEeV1YXoTyQnldV17IyVBeF5YXcjWU14k2sVAuyNVQLm+UC3I1lMsb5YLvSqFcvl8uGT9nQLm8US74gQLK5Y1yQSqNcnmjXJDToFwe2uTjmSA+J18oF+QuKJc3ygW5C8rljXJB7oJyebzwdnz9LRhT6l2Qu6Bcvl0ufkPugnJ5o1yQu6Bc3igX5C4olzfKBd/uQ7m8US6EckG5fL9ckOqiXL5fLga9C8rl8cKG4lEuhR02vEHvgnJ5o1wI5YJy+X65oHdBubxRLrgjjXJ5o1xwRxrl8ka54I40yuWpXI6jg/3Tz9K+Hp0s7VWS7C/59kGnj9rC7WvU1kW1ZXGvG7V1VW3hxjhq66raQhKN2rqqthBbo7auqi1CbaG22mrLBH9sgH/7+6m6jhjCIhNHeV1YXsjQUV4Xlhcyd5TXheWFjB7l1V5e0TzKKxXKyyHuQnk1l1dIdJRX3ArfvXRIvFBezeUV7WNxjBQK5YXQC+V1YXkRygvldV15IfdCeV1YXsi9UF4XlhdyL5TXheWF3AvldWF54eupKK/28krhUV5PwI/yInxDFeV1YXkhtUd5XVheSO1RXs3llbbjybghGVMoL6T2KK8Ly4tQXiiv68oLqT3Kq733evpCTjK2dnzDY+mP4MP7nAvli7sCKF/B5Yu7DihfweWLuxooX8Hli7smKF+55etxVwblK7h8cdcH5Su4fHFXCeUruHxx1wrlO3H5HrctfNi2QvkSyhfl2618j1n+Kt/aaAylh0D059e/ly+SB5TvvOXr06N8Y+EbVQHJA8pXcPkieUD5Ci5fJA8oX8Hli2+coXzby9c/fds/lMoL3whDeV1YXvjGFsrrwvLCN6pQXheWF3JHlNd15RWRC6K8Liwv5HYorwvLC7kayuvC8sI3blBezeWVDt63v31hb+pIKC+U13XlhdQe5XVheSG1R3ldWF5I7VFeF5YXYlWUV3N55ceX40MO9LW8EmJVlNeF5YVgAuXVXl7hsTjmWPilWcItbZRXa3lFa45nst3+9l/LK+OmEMqrvby8e5RXKvzQMOOmEMrr8cLWx6O8UvzB0ffiQueF4rqsuAjFheJqKy6TwuNnH7e/C64x44YQyuvC8sINIZTXheWFG0IorwvLC5kXyuvC8sL9RpTXZeUVNtxvRHldWF5I7FFeF5YXEnuU14Xlhcwe5dVcXtE8hI/eFMqLUF4or+vKC6k9yuvC8kJqj/K6sLyQ2qO8LiwvpPYorwvLC6k9yuu68jJI7VFeF5YXUnuU14XlRSgvlFdreaXteNxZSmYrlBecI8qrubzy09Uru9LVC87xovKKREd50eej7+RhqgaRt/Abo8ijFR9FHt8tGUUeX7sYRZ5A/iLy8dE6R1Mgj5v1o8jjPvYo8jDqo8jDw44iDw87iLxDP38V+fzoKnMokEdvcxH5RHsSapN3BfLobUaRR29TJn+ng/7jFR30CC/oELLoV3SQF7+igx7wFR3NuWu2x9cKbM6xsv6H7bH15FPHm80HSQJJJpKavQMvSc1egJek5t6el6RmH8BK0mvu+94kedwEDU/fTn2QxNr9bZLh8aW9VCCpeO12Lu5sjCNvKyRv//rYndyk+Phaaygmrps9Eldrn469c1e80g/lrrgvGMpdcRfByP3OUnH2yM0yKE4q2Vkq7m/ZWSpOQdlZKs5M2VkSWH6f5fFbLGPyZl72T9nEfeTZPP0GaucOnzaGO3zaGO7ocYdwj+g7LuJuD3+crU1fuKNHGcOdwH0Id/QzZe53Oug6XtFBhvuKDpLWV3TQV76gk5CGvqKjOd/05kHHP+VCDzqanUOdjub+vk6HQOcFHc29cp2O5l65Tkdzr1yno7lXrtPR3CtX6WTNvXKdDnrlV3TQK7+io7lXvl1XDjrRfKZTeHWb96+cO2cej0f7SFkzgSQTSc09OC9Jzf36myRvxx8kP92r/XosmYM6WfPlvm7W7APGUdfsLz5Rt6V1XrO/uLmrJzpfd+SJmp/67aIzDzre/GjFiZofcM1MUrNv4SWp2eO8SZJtPY4bgfoA6pq90yfqwRTWedV+6PGYkBsdW6Cj2LfQFo9xk6Gf7T4QNT9Nk5mkYt/CS1LzMxKZSSr2OMwkFXscZpKK+753Sb7c7yZqfp7ZuyRf7ncTNT+fjJw7Ellyf9oF/OvxNsb91W9/pj+7Os3PG2MmqXnt5iWpee1+j6SJwR3zjIG+slScULKzJLBkY6m5q+RmqTh7ZGeJzvL7LONjl5nb3/nPLDU/B+h9ljE9WKbwhaXmdZwebMhb+sTyTkfzylyno3mtrdPRvHrW6Wi+c1enoznRq9PR3EtV6Wh+utI36GhO0+p0NHfWgY7v3FJIrtZZvzz+TlNzb81Pk0CTkabm3v09mjcQ+8Ct257uMGb/wVJzp8/NUrMv4Gap2UVws9TsOX7A0tivLL1mh8LNUrOf4WYJ9/Ntlu6wktbd+D2zLBz98uk/t7s94D6EO4H7EO7wXhzc7yzhvfhYwnvxsYT34mMJ78XGUvMT7dhZwnt9m6WnfZrWP//O+WAJ78XHEn6KjyWBJRtL9JdsLCPW8e+yvOX59nj156MPlljH+VgutY47OljeLl+Vo3PY52i27RH62JQ/0Cy1LPOiWWqV5UWzVFj4FpqnXRB/fdn86ej4wWap8I+ZzVLNFjObpcI5ZjZLhW28bNZ6ABozm6WaaGY2epviOhu9XXGdDYHNKRv0xeds0Befs0FffM4GffE5G/TFp2zWetgZMxv0xeds0Befs0FffM6GwOaUDfriczboi8/ZoC8+Z6O3L6bN7HtxkSEqsNHbF9fYpLUe0sXMRm9fTCbmg03ePrEpvPbLR0WltR66NZCj3n6blyOB4/c4sj1CK631CC0hzPV6CbLuWNttTBXmlPL+2pStrRzt4/7SPj/hSx/Q9ZqUgdAVu59x0BXbqmHQ13rgmBToio3ge9Czf0AP+aulXuvZZENJKjaDb5LMx2d7s4WYxxBIfpekPUhSKpBUbPLeJXkMe/OhQBLWjYsk/BgXScUmyx27JZH7E5v3jr6TVOyceEmu9QzHoSQVe5y3SBqKx88hvXn+fXFp3K+fMJzWet6jGOqKvdNA6gTqA6gr9mQDqSv2bwOpo6++hDrtBwdvvlJf61mX81AP+0uHkArU0cN8k7o3xyS9o0/U7yQJJJlIotfgIon+gYuk4vz3zdXpGPaNpK+sTrd/TfQYeP7y5bO1ng8qiDt64CHc13qmqSDuyK3HcF/L9aX9aEfWfzr6PtulOtt0fLfI5Y0Ks11p7SZzHE0mh6+zXer5ZLcP+XHPP5qtMNuVPrf12a6UktRnSyvNNj6+vZK2rXJ0OuZ464CPY39tUfv12Hxc7HP+fOyd4krX+nEUV0owxlFcKb0YR3GpfmYYxZWShWEUl3q61TiKS/Xswygu5QWGUVzKYwyjSKDIQBHehYMivAsHRXgXDorwLt+i+PoZRSnAvHBgXOqZfgMxwr6wYIR/YcEIA8OCcaneu3bXdKkH29Vnu1QvW53tUj2n3Y6dVCylwmyXag1rs13qAXH12S7VaFVnu1Q/VJ3tUm1Ldba00myd34dNtNnK0SEcv/pLj4bO2o+dC5Z6zBovmaV6NFYyS/VzL74XVrAxx76IxuSnl/Y7mqWaP1Y0az1ErPYt4LUeC1ad7VLfZ6/OdqlfD+fjN4Auh9rRJu4rg91cJfJhvI+z1gPBRBBf6jcbIogv9avlOYhXQue1nokmA/lSv2yWgXypHzVLQJ7XejCcDORLGS4ZyJdyffnYX4oM1cIOG93+63EbPz2WyhWh+z1ISVukT0ffSa7lKEeSJJBkIrmWA7yQpDm2+EvWhALJtZzdSJJrGbaRJNfyYSNJrmWvBpJc6/FsQ0muZYZGkoTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVzrmWtDScLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwON8kGY5JpphsgSQ8DhdJeBwmkg4e55skc9hHknIyBZLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk13pi4VCS8DhcJOFxvkcyb3b7ODpvz09zPEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJD08DhdJeJzvkox5J2m2XCAJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51BOlx5LU63Hc45lAzqZQIWniYyQx0POw7yD1WhxmkHodDjNIAkgekHr9DTNIvfaGGaRed8MMUq+5YQap19u8CTLn/Wi7bZVhh23bb1GEzXylvtSzqaeh7vNhmsrU4Zm+S/14Jo/dnH09bHp6GuDTz9MoFK9G2TwuR9k+hu02+hAJfkyASPB6AkQiiDS/SPCoAkSC/xUgEry1AJHg2wWIhExgfpESIgQBIiFxECASEgcBIiFxECASQaT5RULiIEAkJA4CRELiIEAkJA4CRELiML9IGYmDAJGQOAgQCYmDAJGQOAgQiSDS/CIhcRAgEhIHASIhcRAgEhIHASIhcZhdJNo2JA4CRELiIEAkJA4CRELiIEAkgkjzi4TEQYBISBwEiITEQYBISBwEiITEYX6RDBIHASIhcRAgEhIHASIhcRAgEkGk+UVC4iBAJCQOAkRC4iBAJCQOAkRC4jC/SBaJgwCRkDgIEAmJgwCRkDgIEIkg0vwiIXEQIBISBwEiIXEQIBISBwEiIXGYXySHxEGASEgcrhDJ7Y9loZg+iXSHjgRhAHQkAt+Dbs0xSWueRnJ/vM0NJAEkD0g4ayaQcL9MIOFQvwvSuQNkzowtm8tpnyL94rs3bMcyBn86vURwp7NLRPCm00sEZzq9RPCx00sE1zu9RASJZpcITv0KiV4HdgRXPwD6UvbSpQMjWf/p6Ptsl3Jqtdn6pUxPdbZL+Qdyj9nGUDnaxH05u901OY61KReOTQeP5HLl2Hwgz/nzsXfiS9kBEcSX6u5FECcQ5yYe9mPNttkC8qWabxnIl2q9ZSBf6tabDORLeR0ZyJcyXCKQh6Vc3wvk99lqcX332WpxXPfZruV20h5Qu0SmdvGw6fiUO0dPR4fia1t/kKTw6eg7SQJJJpJrmZORJNfyHBeS9MeX+p1PW4HkWlZiJMm1HMJIkms1/gNJxrX6+ZEk1/IKI0mu5UNGkoTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIJngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXicb5LM7vjZ3JZTgSQ8DhPJDI/DRRIe53skyT5IWm8LJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8Dg8JM0Gj/NdkjHvJN2fSL539J07HNEY7vBPY7jDbV3B3dCxaZHx5mncuTTLsO0/cAz26fcd2XxoRNBoeo3gEOfXCN5zfo3gaufXCH55eo0MfMwEGtF+cPCmoBFBo/EaBbtrFFJBI/R1l2jkzYHEP792th/c0auN4Y7+awx39FRjuOOOxTVr8DHJG3dfWYNv//oYSrY5PqDcVbK4GyJBJXgOCSrhTosElXBfRoJKpFcl9yAZNlfj/uLoO0nFPpuZpGLnzExSsRd+i6S12/5oHEuu8C0Dq9jdMpNU7Fd5STrFnpKZpGLfx0xSsTdjJqnYPzGTJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJAkeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx/kmSW/3o60v/caR4HG+SZJcPkiGrXI037OhDcE7za4QPNnkCnl4vdkVgoecXSF409kVguedXSGCQpMrBI8+u0Lw/rMrhExhdoWQKcyuEDKFyRUKyBRmVwiZwnCFwvEbsW2zBYkQKkwvEVKF6SUiSDS7RMgVppcIwcL0EsEVfVMiH+IhUa7vBJQ3t7+4z0/7wn18SyTK7QHu45e7QN7HP/nqkd1RPpmo8tI2hn0gNkb3/NL3yU5+Head7ORZKe9kJ48deSc7+VrFOtk0eRjGO9nJcyXeyU6e0PBOdvI+583J5n37XpsMfZ0saZrsWh1UZbIrdVDObvkx7Ph1sit1UNXJrtRBVSe7UgdVm+zsD+5+d7Lby8mutM7egpn9pR3Z7etkV1pnq5NdaZ2tTnapdbY22aXWWZfTMVmzvX5pn49tVH3OhavZUovyO2TCdlznw1ZoRGd/5m2XmimRsbM/w/bNS8dxQ8jR09N8Wj5NdvanzHYhU66ZlaIYRzEcZHL6Otm1WsTKZEnTZNdqESuTXatFfEzWP92fPya7VItYm+xSXV9tsks1cpXJmqV6M2ePb5l4EysvHdLez5tIT18bofCBZqkWJKbD8cbsfta2mqX6lXfIVEygnf1Rnl1qpkxmqU7o8dLuTzelCi+95eOljdsKF5ql+qZkj2GnXHlp2vbrNdnPV+DCMB6RhCHzsJfuwLhURzYO41K93jiMS3WRwzDO/sRHKRiXChrHYVzKEozDuJR/eAuj2+0DxfS1E5z9OYLjwOD3Sr9eu/ePYSwefTeIOzYtGcMdP7q7iLujB/enzZnPjrZPR4c/q4RH9olQCVuSSFAJu5KMV+nX9+oOe2XiF42wLcn8GhE0ml4jbEwyv0Zw+vNrhFRgfo2QIMyvEdKG6TXCozMFaISkYX6NkDPMrxFyhvk1Imh0kUZnOWnhtZM7vlVvQqi9dj5meRP0aZY3mHdNkUuspylyjLk1vauEJEOCSsgyeqv0m7vmB1XadLRszlGFJNnjxy/kfJU7xUc7+PQdFJOLPzmi/eDw9KN6k82HRop91TwaxZ1fSL6gkWJfJUYjgkbTa6TYJ4nRSLHvmUgjc2gUChopdj1iNFLsecRopPj+7Twahd3DhpC+aqT50ZViNELOML9GyBnm1wg5w/waETSaXiPkDPNrhJxhfo2W8keODo1cDJWjyW32Qf356Phz6q/vCMWlHM881F/nnnEpDyOG+lKuRAz1pXyGGOoE6pdQf5nxzv444kWpL9Xdi6G+1H3Beai/dkmzPyl6UerwpgOoz/7s7EWpw5uOoA5vOoI6vOkI6gTqA6gv1a9v7qC+5dpADAXab2vc/k7Pr54Kx1uf9l/V3v58gpL9B8uluvDBLJfqrceynP1Z6aJYLtUHD2a5VHc7mOVSPeu1LOOxlcbthshWYElgycZyqXsfg1kudUdjMEv4Hi6WbkN/+W2WIe8Dv/3pCiyxjn+bZUr74TeL4wsssY5/l+UtgHq8us0FlljH+VhiHedjiXX8+yyjPV49fV573jv6Th5p5yjyyEavIR+SP74Wn5525LvvZXUDDO5DuCNzHcMd+exF3PMBJWQbv3CHBxzDncB9CHd4yzHc4UPHcIdnHcMdjnUMd/jVq7g/fsad/RfuFn51DHf41THc4VfHcIdfHcOdwH0Id/hVDu53lujJv8uy+t0Riz6bjaVD78zHEv3wt1l++q4dFViix+Vjib6VjyWBJRtL9JffZ2kfLF2tr791SPuvaG6LEv25r3e4HzKGO+6HjOEO73URdxfywT095wfvHHvXCJ5ueo0IXnF+jeBBx2v0+rn0juBt59cInnl+jQgaMWh0Zwkv/n2WjyeHx5gKLOGvv88yHZl6zIXfvRE8c1NdFlnCB/OxhF9lY+nRD3+bZfL7NG9/lliib+VjSWDJxhL9JR9L9JffZ0n2NUus499nWdmHZq3nRw9miRyXjyX6Sz6WBJZsLDVnG85tB0uXQ4WlidG7/fjb3w8sH1lw0JxtcLPU3BMxs1zrCbNXs4zpwfLpqWs7S809ETdLzT0RN0vNmRs3SwJLNpaaMzdulpozN26W8D18LOF72Fiu9ezHN1luxxPVDRmKFZbh8cNxb56SDfNBUnN3+SbJl0+yd2s9o3EoSQJJJpKa+0pekpq7yndJmoNkKJDU3FPyktTcUfKS1Jyjv0ny5dN7neone/KShMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxeEiS5id5OndsVWkceVshefvXdKTsJm/PT8/5enQ2cR95Nl92J6BNcfc5lLviXvVa7tbsULK1X7kr7myHcidwH8Jdcdc8lLviHvti7s4c3F3+wl1xRz6Uu+J7FEO5K76jMZK75ifyDuUOvzqGO/zqVdw3++gj0xfu8KtjuBO4D+EOvzqGO/zqGO7wq2O4w6+O4Q6/OoS75ifyDuUOvzqGO+nlbrM9dsWxOf/sl2Ok+Zmj75J8+dsSsop7bGaSirtmZpKK+2Bmkoo727dJvvqVDml+Ai4zScXdJzNJxfc/3iX5+pu+mp99y0ySQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCR1PzESRs2c5CMnwaeiq+ezQEl+MrRNubHc/X+tAPZnbzm/vNS8snu8b1NLhXIE8gPIq+5vx1LXnM/fC357XiGXTKxQF5z/zyWvOZ+eyx5zf35UPJe8z2LseQ13+MYSx4edhR5eNhR5AnkB5GHhx1FHh72KvLx8SzcWEgPPDzsKPLwsKPIw8MOIq/5adEXkz9GfiOfC+ThYUeRh4cdRR4e9irylA7y3hXIE8gPIg8PO4o8POwo8vCwo8jDw44iDw87iHyEhx1FHv38ReTDsS3C7bVz7Whybj+akqscHejxLeVH8u9iaZY5Hc/q3Z6GUT44WL8DDDbVXvrXzg/Hl6tTMtun4+/lRSgvlFdzedFD+Oer16O84MxQXheWF+wnyuvC8oLHRnnxlFewhfJCkIDy+kF50aO8oq+9ej54h/z8baTSHJM9XjvZp8o9PClyGBSuxMJNiLFQuCILF99kQeGKLFx8EQiFK7Jwcd8FhSuycAmFi8KVWLi4V4TCFVm4uAuFwm0u3GwPgLe/w6fj7+WFtBXl1X5dzI9vAOWt8A2gDIeO8mq/epmH8NmZQnmhq0N5XXj1Qu+F8uLpvVypvPANIJTXheWFbwChvC4sLzhHlNdl5eU3fJsG5dVeXu4R2GaiQnnhOy8orwvLC7kXyuvC8sL3R1BeF5YXobxQXteVF1J7lNeF5YXUHuXVXl6Ve45+Q2qP8rqwvJDao7wuLC+k9iiv68rLILVHeV1YXkjtUV4XlhdSe5TXheWF1B7ldWF5EcoL5XVdeSH3Qnk9XtgcR98qbauVV7TuePF4m0KhvJB7obwuLC/kXiiv9vIK7lFeMX8tL4vcC+V1YXkh90J5XVheyL1QXheWF3IvlFdzebntUCfeCqVQXoTyQnldV174tirK68LywrdVUV7t5UVP5eV9obyQ2qO8LiwvpPYorwvLC6k9yuu68nJI7VFeF5YXUnuU14XlhdQe5XVheSG1R3m1l5d7Lq9QKC9CeaG8risvpPYorwvLC6k9yqu9vI45/vq78I0Jh9Qe5XVheSG1R3ldWF5I7VFe15UXIbVHeV1YXkjtUV4XlhdSe5TXheWF1B7l1V5e8am8cuGpHEQoL5TXdeWF1B7ldWF5IbVHeTWXF5lj4/FItrDHBCG1R3ldWF5I7VFeF5YXUnuU13Xl5ZHao7wuLC+k9iivC8sLqT3K68LyQmqP8movr+25vApPRPOE8kJ5XVdeSO1RXheWF1J7lFdzedn02J2QnK8dT84cx1NxwyaPlB/l2K8cnX+UozfV45M/Bk8ppkL54i4Cyrdf+Xp6lG8oOV/cdUA5jrmalsox4C4FynGicsRdDZTjROWIuyAox4nKEXdNUI79yjGGRzlm+3MnHgjli/LtVr75cTW9Re6FcsRdHJTjkKtpuRxx1wflOFE54q4PynGicsRdHJTjROWIuzgox27lSCY+ytG5nzvxiLs+KN9+5euerqbkC+WIuz4oxzFX02I54q4PynGicsRdH5TjROVIKEeU4zzliLs4KMdLyvFeXrgrg/K6sLxwlwXldWF54a4Jyqu9vPyjvGwqbC8ZcRcE5XVdeSXcpUB5XVheuOuA8rqwvHAXAeV1YXnhrgDK68LyIpQXyuu68kJqj/K6sLyQ2qO8Liwv5F4or9byCjkct7RDjvlreWXkXiiv5qvX9hD+9ncolBdyL5TXheWF3AvldWF5IfdCebX3Xnl7Kq/CZreZUF4or+vKC7kXyuvC8kLuhfK6sLzwbVWU14XlhW+rorwuLC+k9iivy8orbEjtUV4XlhdSe5TXheVFKC+U16GNcXnXxiSqHB0p7K99+zMXigupF4rrsuJC5oXiuqy4kHihuFqLK5hd9xhsLBQX8i4U12XFhbQLxXVVcRlkXSiuy4oLSReK67LiIhQXiquxuHzaqyT6XAhRDdwiiqu1uGLeBx2TM4XigltEcV1WXHCLKK6risvCLaK4LisuuEUU12XFhd8yorhaiyt5cxRX4WnuweKXjCiuy4qLUFworquKC9/nQnFdVlz4PheK67LiQkKP4rqsuJDQo7guKy4k9Ciuq4rLIaFHcV1WXMi5UFytxfX8fa5SQu8IxYXiuqq4kHOhuC4rLuRcKK7Ligs5F4qrubjC8a2IENPX4iJ8KwLF1Vpc8eAXo6FCccEtorguKy5CcaG4riouuEUUV3PPleOjuHyhuOAWUVyXFRfcIorrquLyuLeI4mruuY5HMd7+LPRcHr/+QXE1F9fTr3+MqxxtKPljKJRKuZhHLoZibC3GZMJRjKVE3yMXQ3FxXOmKxUUoLhTXVcWFXAzFdVlxIRdDcV1WXMjFUFyXFRd+LYTiuqq4AnKxKYrL0o7Q2rh9OvquEyKjKXRydn9t68gVdEL6IkMngk4idEImMMf6lB46/Wkkd51gr2XoBKcqQyeYPhk6YbcFETpFfLlIhk7II2TohDxChk7II2TopNk/bf6h023GVZZbOrJS+5SVZvpgqdnjcLPU7EO4WWr2Cu+ypONmm/XuE8vCWGzeyTv39Iu7cOeeNPf+I7lr7uUv5e5CPrin+MT9nWPvGmnu46VopLmHl6IRQaPhGpE51iOy5qtGmu8lStEIPnh+jeCvv62Re3yvy8WtopGPu6A+PwH8iIgSrPgQ7HDtI7BnmPYh2OHZh2CHDf82dnrcSqHnVy9iv11H9qNvtR2fwX89OFnaeSf7C8SfVYIRl6ASQSUBKsGMS1AJdlyCSjDkElSCf5egEuz+/CrFDX7p2yp5e8TE3vpPKt1ZohP7Pks6vvTn/VZgiWv891keh1sfUoElrsRsLA3SVD6WiEg5rpcNV1eDVX8UeSSf15APye8Ib/fVHxu0hA/uBO5DuKMnHsMdeeNF3PMB5XazMX7hjgRxDHf4xTHc4S2HcLfwoWO4w7OO4Q7HOoY7/OpV3I8bMyH7r9wJ3Idwh18dwx1+dQx3+NUx3OFXx3CHX+Xg/pulU9yTm9uKtb+4yVttF3tDcYdivHn+iWFp5OFRwt48HWs+uCvuya/lHg8rlHyBO4H7EO6Ke/Kh3BX35EO5K+7JL+Z+fHE2hQJ3xT35UO6Ke/KR3EnxPaRruYfHM6tSgbvie0hDucOvjuEOvzqGO4H7EO7wq2O4w6+O4Q6/OoS7X6l/t/mxrd5mthp3zjzdr9SPX8rxdW7lV+qvR3JcqV8eyZHAkYXjSv3stRxf5m1+pf50JMeV+s2RHFe633Epx0ofvtL9i4EcA/wMD0f4GR6O8DM8HOFneDgSOLJwhJ9h4RiLHE08Ht73FIfalAtvkA7kyeXKsTntVHL+fOx9MGGmwcSZBpNmGkyeaDDl5xmOGoyZaTB2psG4mQZDMw1mpitwmukKnPpegcOxqm6bLYwmTTWaPNNo8jbVaMxUo7FTjaZ8taGcj5bS29e9bdr2T22ipxabPn6dV94ln/Ud4uXvkC5/h3zxO6Rtu/wdzM/fwe8OLMXw6R0KLmnLu5WxZnscTcUXTvs+z9nY2gu7vM/T0va4eeaOiVotE3VaJkpaJlq/3sdPE72fFZrOii1nGXP1dcrYy9/BXf4OdPk7+MvfIVz+DlHJx9okLRPNSiZqNy0TNS2rhLVNZ7mWs072ZrDHc6CdM4+NNz6mdbKxQOUk33JS+StIbzzS+vzY+xvEq98gXf0G+adv8Pqp3+nkZ5eMb2CufoOiBvZ222P/9N5uOnw5KTecVP6Ke+2kk6vEO7e+bkd8HOyf7wV+3PpK3l7/Fu76t6Dr38KzvgVthbcI179FvP4t0vVvkX/+FmHbLwzBfv1KYQrb9W9hrn8Le/1buOvfgq5/C3/9W4Tr3yJe/xbp+re4/tMdr/90x+s/3fH6T3e8/tMdr/90x+s/3ZHjc/Hy130pcVTUyy9CpZNvS3hzfEXMO/r0FvfTXNtp1Haabzvt5Pp7fKHtdpqv4Lv9azpoZ5u/GIqTu/XMb5J6vEnu8CYnt8yZ38Rd/tHMHNewl79dS9lf/xbh+reI179Fuv4t8tVvkbft+rfgWE9e/jArb/b6t3DXvwVdvfDmzV//FuH6t4jXv0W6/i3y5W9htuvfwlz/Fvb6tygWrfd7aurTU6eX0sdJseWk1HJSuVS2eMzq19/5Tx1JPrnNtcV8tLDb7Ubxl9NM22m27TTXdlr5Yrndbig9TnvahH0/zbedFtpOi02nuRPd8mM7+i0H8+W0E5I57dvSG7NtX0g6ajvNt50W2+aW2k47+eDk7J4G6f98Gm1tp5m202zbaa7tNGo7zbedVv7g3A7Nj9Psc5X88X5NlffT4n6T1ONN8s/f5PW9yFy+Q8j7Fub6t7DvvsX9NNd2GrWd1naJPLk/Vz0ttp2W2k7LTaeFre0003aabTutbSENbQvpya2O6I8La4zPP1Mttbc2bsc3jKK1X94iX/4WJ7c6WN/CXP8W9vq3cNe/BV3/Fv76twjXv0W8/i2u/3TH6z/d6fpPd7r+052u/3Sn6z/d6fpPd7r+052u/3Sn6z/d6e1P9/203HRa3tpOM22n2bbTXNtp1HaabzsttJ0W205rq5LcUiV+27a200zbabbtNNd2GrWd5ttOC22nxbbTUttpbVVi2qrEtFWJaasS01Ylpq1KTFuVmLYqMW1VYtqqxLRViW2rEttWJbatSmxbldi2KrFtVWLbqsS2VYltqxLbViWurUpcW5W4tipxbVXi2qrEtVWJa6sS11Ylrq1KXFuVUFuVUFuVUFuVUFuVUFuVUFuVUFuVUFuVUFuVUFuV+LYq8W1V4tuqxLdViW+rEt9WJb6tSnxblfi2KvFtVRLaqiS0VUloq5LQViWhrUpCW5WEtioJbVUS2qoktFVJbKuS2FYlsa1KYluVxLYqiW1VEtuqJLZVSWyrkthWJamtSlJblaS2KkltVZLaqiS1VUlqq5LUViWprUpSW5XktirJbVWS26okt1VJbquS3FYlua1KcluV5LYqacteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZq27NW0Za+mLXs1bdmracteTVv2atqyV9OWvZqT7DUf3zA0mUzhtJMqObb0MznbT6eVtvJlelDIbThxruGkuYaTpxrOWbY9ajhmruHYuYbj5hoOzTUcP9dw5roqp7muymmuq3Ka66qc57oq57muynmuq3Ke66qce1+VXz7j6jYeP9l4wmTjiZONJ002njzVeGz5Dq69ta4fp1lrfGU8N4e+HcMP8c+7F9zexPR4E9vjTRzLm7jweJPgnt6k8Iu85PaNgdz2vO+TKW+nuh17rm3u8dv7nD7GT5OP3x/8g3fu6/i98PEH4eOPwsefhI8/yx6/2YSP3wgfvxU+/tnX39r4ha+/Rvj6a4Svv0b4+muEr79G+Pprha+/Vvj6a4Wvv1b4+muFr79W+Pprha+/Vvj6a4Wvv1b4+uuEr79O+PrrhK+/Tvj664Svv074+uuEr79O+PrrhK+/Tvj6S8LXXxK+/pLw9ZeEr78kfP0l4esvCV9/Sfj6S8LXXxK+/nrh668Xvv564euvF77+euHrrxe+/nrh668Xvv564euvF77+BuHrbxC+/gbh628Qvv4G4etvEL7+BuHrbxC+/gbh628Qvv5G4etvFL7+RuHrbxS+/kbh628Uvv5G4etvFL7+RuHrbxS+/ibh628Svv4m4etvEr7+JuHrbxK+/ibh628Svv4m4etvEr7+ZuHrbxa+/mbh628Wvv5m4etvFr7+ZuHrbxa+/mbh62+Wvf66Tfb66zbZ66/bZK+/bvr9r2rjl73+OuH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+1854ftfOeH7Xznh+185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maHxdC7iy1PKorw+xbx/in3/FPfmKbf/cr+OLP9i0pgt7hLd/s5PH5b0+1w6Pzdth/l/avh+xQBfDg10jM+750NvMyo3u1wvnn764mnflzik9OcXzz9+8f3SE7c/j7zcZLO8+O0//AtZ856/p5y/NePswtE/xNeDqtZb+HUwFVc8fzxD3senuVP+NbLy3eHXp8T3T0nvn5LfPOX2X/H3ha4IIbj9Gpk2/3SiP1/KX58S3z8lvX9KfvuU8hX49SnFK3A6VpX09LOF/RT7/inu/VPo/VP8+6eE90+J759SvqImKl00qJQDu7BfAVykxyIf7i+fL3358hfW+F7eXPvy9tqXd9e+PF378v7alw+ML5/cl5eP1758uvbly32BPfqCZ2d1v46Uv8ry+hTz/in2/VPc+6fQ+6f4908Jb59Sfmb361PS+6e8r358X/34vvrxffXLz421R0JmQ/xz8Zefpvr6FP/+KeUvXcQ9dLf5y6ey/DzK16ek90/Jb59SfqLf61PMm6fc/ivBS/zxl3we34bj67khb39+r3Ik+/oU9/4p9P4p/v1Twpun3P7r153F/zoxvMbH4/5itM8t8t1dm9+ZeflSktNx9Xlac23K55eS16f4908J758S3z8lvX9KfvuU8qXk9Snm/VPs+6e8r356X/30vvrpffXT++qn99VP76uf31e//DiofHw1yWzPPz74OMc2nOMazqGGc3zDOeHdc/779p//7z/9+1//6Z//9q//cTvn1//7f//tX/7zr3//t4///M//7//s/88///tf//a3v/7vf/w///73f/nX//V///1f//Fvf/+XX//fX7aP//mft0jS/nG7O+D+4fcNxv8ZXYh/RJf8P/yOq2//v0m3/9+mf7hfif8n3W7k/EEx/j7h9xlbyLcjojnuUf4+ztEfLh83C369FJk/vNlf5nbJ9/GRif/6J5P/sPSIun/9k6U/bH7EpL//Kf7h7BFQ/nrd2wTIHq97e5NwRHe//ylsfwS/jzbFP1I+epLz0/P+f98imNs89slvf5B/WpR+D8j8YcNjsfl1js9/hOOcnP4wm7sJdxPv/wc=",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "load",
        "notify_set_public_teardown_function_call_wrapper",
        "debug_log_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "FPC"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::fee_entrypoint_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::fee_entrypoint_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "refund_recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::_pay_refund_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::_pay_refund_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::pull_funds_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::pull_funds_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "FPC::get_accepted_asset_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::get_accepted_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::fee_entrypoint_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::fee_entrypoint_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::_complete_refund_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::_complete_refund_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "142": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "191": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "192": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "194": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "195": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "197": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "199": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "203": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "227": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "229": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "272": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "287": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "289": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "290": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "300": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "304": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "306": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "307": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "316": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "341": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "345": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "346": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "362": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "363": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "375": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "395": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fees/fpc_contract/src/main.nr",
      "source": "mod config;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// Fee Payment Contract (FPC) allows users to pay for the transaction fee with an arbitrary asset. Supports private\n/// and public fee payment flows.\n///\n/// ***Note:***\n/// Accepted asset funds sent by the users to this contract stay in this contract and later on can\n/// be pulled by the admin using the `pull_funds` function.\n#[aztec]\npub contract FPC {\n    use crate::{config::Config, utils::safe_cast_to_u128};\n    use dep::uint_note::uint_note::PartialUintNote;\n    use aztec::{\n        macros::{functions::{initializer, internal, private, public}, storage::storage},\n        prelude::AztecAddress,\n        state_vars::PublicImmutable,\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    /// Initializes the contract with an accepted asset (AA) and an admin (address that can pull accumulated AA funds\n    /// from this contract).\n    #[public]\n    #[initializer]\n    fn constructor(accepted_asset: AztecAddress, admin: AztecAddress) {\n        let config = Config { accepted_asset, admin };\n        storage.config.initialize(config);\n    }\n\n    /// Pays for the tx fee with msg_sender's private balance of accepted asset (AA). The maximum fee a user is willing\n    /// to pay is defined by `max_fee` and is denominated in AA.\n    ///\n    /// ## Overview\n    /// Uses partial notes to implement a refund flow which works as follows:\n    /// Setup Phase:\n    /// 1. This `fee_entrypoint_private` function:\n    ///     - Transfers `max_fee` of AA from private balance of the user to the public balance of this contract,\n    ///     - prepares a partial note for the user (which will later on be used to refund the user any unspent fee),\n    ///     - sets a public teardown function, where at the end of the tx a partial note will be finalized\n    ///       with the refund amount (also denominated in AA),\n    ///     - sets itself as the `fee_payer` of the tx; meaning this contract will be responsible for ultimately\n    ///       transferring the `tx_fee` -- denominated in fee juice -- to the protocol, during the later \"teardown\"\n    ///       phase of this tx.\n    ///\n    /// Execution Phase:\n    /// 2. Then the private and public functions of the tx get executed.\n    ///\n    /// Teardown Phase:\n    /// 3. By this point, the protocol has computed the `tx_fee` (denominated in \"fee juice\"). So now we can\n    /// execute the \"teardown function\" which was lined-up during the earlier \"setup phase\".\n    /// Within the teardown function, we:\n    ///     - Compute how much of the `max_fee` (denominated in AA) will be refunded back to the user. Since\n    ///       the protocol-calculated `tx_fee` is denominated in fee juice, and not in this FPC's AA, an equivalent\n    ///       value of AA is computed based on the exchange rate between AA and fee juice,\n    ///     - finalize the refund note with a value of `max_fee - tx_fee` for the user.\n    ///\n    /// Protocol-enshrined fee-payment phase:\n    /// 4. The protocol deducts the protocol-calculated `tx_fee` (denominated in fee juice) from the `fee_payer`'s\n    /// balance (which in this case is this FPC's balance), which is a special storage slot in a protocol-controlled\n    /// \"fee juice\" contract.\n    ///\n    /// With this scheme a user has privately paid for the tx fee with an arbitrary AA (e.g. could be a stablecoin),\n    /// by paying this FPC. This FPC has in turn paid the protocol-mandated `tx_fee` (denominated in fee juice).\n    ///\n    /// ***Note:***\n    /// This flow allows us to pay for the tx with msg_sender's private balance of AA and hence msg_sender's identity\n    /// is not revealed. We do, however, reveal:\n    /// - the `max_fee`,\n    /// - which FPC has been used to make the payment,\n    /// - the asset which was used to make the payment.\n    // docs:start:fee_entrypoint_private\n    #[private]\n    fn fee_entrypoint_private(max_fee: u128, nonce: Field) {\n        let accepted_asset = storage.config.read().accepted_asset;\n\n        let user = context.msg_sender();\n        let token = Token::at(accepted_asset);\n\n        // TODO(#10805): Here we should check that `max_fee` converted to fee juice is enough to cover the tx\n        // fee juice/mana/gas limit. Currently the fee juice/AA exchange rate is fixed 1:1.\n\n        // Pull the max fee from the user's balance of the accepted asset to the public balance of this contract.\n        token.transfer_to_public(user, context.this_address(), max_fee, nonce).call(&mut context);\n\n        // Prepare a partial note for the refund for the user.\n        let partial_note = token.prepare_private_balance_increase(user, user).call(&mut context);\n\n        // Set a public teardown function in which the refund will be paid back to the user by finalizing the partial note.\n        FPC::at(context.this_address())\n            ._complete_refund(accepted_asset, partial_note, max_fee)\n            .set_as_teardown(&mut context);\n\n        // Set the FPC as the fee payer of the tx.\n        context.set_as_fee_payer();\n    }\n    // docs:end:fee_entrypoint_private\n\n    /// Executed as a public teardown function and is responsible for completing the refund in the private fee payment\n    /// flow.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn _complete_refund(\n        accepted_asset: AztecAddress,\n        partial_note: PartialUintNote,\n        max_fee: u128,\n    ) {\n        let tx_fee = safe_cast_to_u128(context.transaction_fee());\n\n        // 1. Check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#10805): Nuke this check once we have a proper max_fee check in the fee_entrypoint_private.\n        assert(max_fee >= tx_fee, \"max fee not enough to cover tx fee\");\n\n        // 2. Compute the refund amount as the difference between funded amount and the tx fee.\n        // TODO(#10805): Introduce a real exchange rate\n        let refund_amount = max_fee - tx_fee;\n\n        Token::at(accepted_asset).finalize_transfer_to_private(refund_amount, partial_note).call(\n            &mut context,\n        );\n    }\n    // docs:end:complete_refund\n\n    /// Pays for the tx fee with msg_sender's public balance of accepted asset (AA). The maximum fee a user is willing\n    /// to pay is defined by `max_fee` and is denominated in AA.\n    ///\n    /// ## Overview\n    /// The refund flow works as follows:\n    /// Setup phase:\n    /// 1. This `fee_entrypoint_public` function:\n    ///     - Transfers the `max_fee` from the user's balance of the accepted asset to this contract.\n    ///     - Sets itself as the `fee_payer` of the tx.\n    ///     - Sets a public teardown function in which the refund will be paid back to the user in public.\n    ///\n    /// Execution phase:\n    /// 2. Then the private and public functions of the tx get executed.\n    ///\n    /// Teardown phase:\n    /// 3. At this point we know the tx fee so we can compute how much of AA the user needs to pay to FPC and how much\n    /// of it will be refunded back. We send the refund back to the user in public.\n    ///\n    /// Protocol-enshrined fee-payment phase:\n    /// 4. The protocol deducts the actual fee denominated in fee juice from the FPC's balance.\n    #[private]\n    fn fee_entrypoint_public(max_fee: u128, nonce: Field) {\n        let config = storage.config.read();\n\n        // We pull the max fee from the user's balance of the accepted asset to this contract.\n        // docs:start:public_call\n        Token::at(config.accepted_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), max_fee, nonce)\n            .enqueue(&mut context);\n        // docs:end:public_call\n\n        context.set_as_fee_payer();\n        FPC::at(context.this_address())\n            ._pay_refund(context.msg_sender(), max_fee, config.accepted_asset)\n            .set_as_teardown(&mut context);\n    }\n\n    /// Pays the refund to the `refund_recipient` as part of the public fee payment flow. The refund is the difference\n    /// between the `max_fee` and the actual fee. `accepted_asset` is the asset in which the refund is paid.\n    /// It's passed as an argument to avoid the need for another read from public storage.\n    #[public]\n    #[internal]\n    fn _pay_refund(refund_recipient: AztecAddress, max_fee: u128, accepted_asset: AztecAddress) {\n        let actual_fee = safe_cast_to_u128(context.transaction_fee());\n\n        assert(actual_fee <= max_fee, \"Max fee paid to the paymaster does not cover actual fee\");\n        // TODO(#10805): Introduce a real exchange rate\n        let refund = max_fee - actual_fee;\n\n        Token::at(accepted_asset)\n            .transfer_in_public(context.this_address(), refund_recipient, refund, 0)\n            .call(&mut context);\n    }\n\n    /// Pulls all the accepted asset funds from this contract to the `to` address. Only the admin can call\n    /// this function.\n    #[public]\n    fn pull_funds(to: AztecAddress) {\n        let config = storage.config.read();\n\n        assert(context.msg_sender() == config.admin, \"Only admin can pull funds\");\n\n        let token = Token::at(config.accepted_asset);\n\n        // We send the full balance to `to`.\n        let balance = token.balance_of_public(context.this_address()).view(&mut context);\n        token.transfer_in_public(context.this_address(), to, balance, 0).call(&mut context);\n    }\n\n    /// Note: Not marked as view as we need it to be callable as an entrypoint since in some places we need to obtain\n    /// this value before we have access to an account contract (kernels do not allow for static entrypoints).\n    #[private]\n    fn get_accepted_asset() -> AztecAddress {\n        storage.config.read().accepted_asset\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fees/fpc_contract/src/utils.nr",
      "source": "pub(crate) fn safe_cast_to_u128(field: Field) -> u128 {\n    field.assert_max_bit_size::<128>();\n    field as u128\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "89": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "98": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
