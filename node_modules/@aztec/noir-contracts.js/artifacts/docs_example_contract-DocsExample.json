{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "DocsExample",
  "functions": [
    {
      "name": "initialize_public_immutable",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "points",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3dbuI6EMffhWsuPDP+7Kusjqp+sBUSgorSIx1VffdjWBJYMsFl4u6CMjcVFP/xzC8Tz9gOycfkefb4/nI/X/5cvU3ufnxMFqunh818tczvPj6nk8f1fLGYv9wf/3titn8Awk7w9vqw3L5/2zysN5M7iuCnk9nyefuSbP6Kn/PFbHLnzOe009iZaPaN88vYNvaWaRwduH3j6MgcN/5nOgFE3hx3MCfBeXMwEe0bY3IHc8B7pnWI1Bgfsm3njQ8eU9PY+4KnADY1hgA49Ke+EozI11DB19Q2NgC/+brtwuL3d/H9Xjj37V14M7gLgmCbxmhMIe4iRmzOeTK2MECY2A4QQL4Ud95gG3fe0mnc+TAeXwMN9xVbg4iMK/iaYgMmpYOnkLi22T1qrScfD9+NKTDtfWpahyM7iOIvV+MfdhUMNb6Ccb7gbEi2+e6QEh5cjcRZ4hpXLRy+GQ3XFiFBM+CjSYXWrh3Cj1Pttu0WYkSFOBxiUIiDISaNxAoQNRIHQ0SjkVgBoleIgyGCUYjDITqFOBxiUoiDIaJViMMh6rTvSxBT2Df24DoQrZ7OwyE6UojDIerpPByi10isAFEjcTjEoJFYAaKu4gyHGEEhDoeoqzjDISZdxakAUVdxKkDUad9giHlDXyEOh6jFdhfiFgzo5lMPGC2KeTCohW4PGC0ZeDCkBWkPGKtgeDCarnkwVte7esDoVIMHo7tGfWB0jOHB+NFmJYzNlQBIBrtgRjvGFMCMdxemBGa0k8gCmPHulpTAjHYSWQKjgy8PJung2wNmtAXeeTDWaMT0gNF0zYMZ7y5BCcxoL1gogMHRrvmWwFgFw4PRdM2DIR18e8Do4MuDsTq77gGjEcODcaNN16G96xSGk59/XdZ6h9Eqxi9gzL40N4UCH2IHox9txquKMehJXQXjaJdk62Ic7QLuZRhDaO9qF1I3U0dNMVUwjna2WRXjeO+iVBfjaOclNTE6owVPFYyaYqpg1IKnBkbQaKyCUQueGhhRC54qGLXgqYFxvL+sqYtRU0wVjJpiamC0mmKqYNRo/BLGZJqdQUjYxeg0U9fAWOMBGEhNF4S+hDESNK0j4eFXPuxzHoicaY+QS78x31lvb9r6dMvWh5tmH26afbxp9lX2OP6a9VW2Fv6e9eGGrfcGbtp6f8vW4x+3/pLHR+UiC7h669fzoLyN12x8BGhKywhoT42v8lP57zPepHTO+Csnj741ntyp8f66yReMv2XyAa875is+rM6H6z5Q/b5m44NjC2kw2LpsfOe+d4E/sYoqtngBaB/lmcfRzgVegb9OrqSKJFJFiYovKXOsHMImdmjkg8GqqL3hYH4Zu6ogUfE3VyuqnEiVJCoS+WVFFvJXpYPD9ig7G7oqL1H1nCklVZSo+Cl9UZUkqijqq+f8yksprSp27hwTkxeoEj/ZKKqSRAVWpJLQSPxWcVElYkg959dhUTIvwnZU1ohUVqSKEpVDkcpLVF5Ew4vIB1FfQUQ+iMhHEfnYQ962S/rkOqNN6snLJVUSqMAYK5KBkcmcSIYkk0mSc95wAZnMiWRW1htflAbbPrPZ+q6Iz2OHPaPjB9i3Ij4cSyJ/uQj4C1ZLIisRCUAAX/mWREEw5QDoyZZFmRfJeiK+KJP1ZmW9WVlvTtabk/XmZcfNy3rryZtFmZXJ0uVDDvAT2mSa0S1XeIxIcHoiXwKf7wmBJKIgEPFz2ZLICUCQkYhEPfHI2wWEFLphhHzBXBJJenKlAZsVSWLPC5IQBpCIBIkVI0pEQSCSFAsoKRZIUiyQpFigi4uFz/z234f1/OFxMXvLku2n78unzXy13L/d/PfafPK4ni8W85f71/Xqafb8vp7dL1ZP288mZv/nRw6vKUa3K6zyW6AwBYu7kXL7afT505h7zT3/Dw==",
      "brillig_names": [
        "initialize_public_immutable"
      ]
    },
    {
      "name": "increase_legendary_points",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "simple_macro_example",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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vZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672att6raeu9mrbeq2nrvZq23qtp672ak95rPr5haDKZwrCTLDm29DM520/DSlv5Mh0UcgsnyAonygonyQoniwrnrGc+KhwjKxwrKxwnKxySFY6su3KSdVdOsu7KSdZdOcm6K2dZd+Us666cZd2Vc++78rdnXN3iIWHxeGHxBGHxRGHxJGHxlDdQv9WKH8OsNb4Sz81qb0f4If5x9wJvy897ud/E9HgTy/ImLjzeJLinNyn8Ii+5fWMgtz3v+7SVt1Pdjj3XNvf47X02H/E74fH7g3/wzn2Nn5TH75XHH5THH5XHn5THn3XHbzbl8Rvl8Utff2vxK19/jfL11yhff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+t8vXXKl9/rfL11ypff63y9dcqX3+d8vXXKV9/nfL11ylff53y9dcpX3+d8vXXKV9/nfL11ylff0n5+kvK119Svv6S8vWXlK+/pHz9JeXrLylff0n5+kvK11+vfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z99crX36B8/Q3K19+gfP0NytffoHz9DcrX36B8/Q3K19+gfP0NytffqHz9jcrX36h8/Y3K19+ofP2NytffqHz9jcrX36h8/Y3K19+kfP1NytffpHz9TcrX36R8/U3K19+kfP1NytffpHz9TcrX36x8/c3K19+sfP3NytffrHz9zcrX36x8/c3K19+sfP3Nutdft+lef92me/114ve/qsWve/11m+711ynf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3/+KlO9/Rcr3vyLl+1+R8v2vaNO9/pL4/a8eLx3iLein+EsX71GHFB4vnOhjrtLXas65Sl/XOecqvQbgnKv0eoFxruL39uKcq/A6xGefHnO138+VYt7joOTScbHNsXB1jPsrx/wIw93G3ckIr3AGkhFeOw0kQ7LJRE92jz9s4Xsyzu3XOnoK2paIB7+H7OP2dLErXW1zPl5529Knq+8YhReHWjAKrzu1YBRe0mrBKLxa1oJReCGuBKP0/QO1YBRuH7RgFO41tGAUbky0YCRg5MAIF8OCES6GBSNcDAtGuBgWjHAxHBil78KqBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAdG6XtZa8EIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBUfqJAFowwsWwYISLYcEIF8OCkYCRAyNcDAtGuBgWjHAxLBjhYlgwwsVwYJR+rooWjHAxLBjhYlgwwsWwYCRg5MAIF8OCES6GBSNcDAtGuBgWjHAxHBiln06lBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAdG6Wf8acEIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBUfpJqVowwsWwYISLYcEIF8OCkYCRAyNcDAtGuBgWjHAxLBjhYlgwwsUwYPTSz5vWghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgOj9JPttWCEi2HBCBfDghEuhgUjASMHRrgYFoxwMSwY4WJYMMLFsGCEi+HAaOFiWDDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgdHAxLBjhYlgwwsWwYISLYcFIwMiBES6GBSNcDAtGuBgWjHAxLBjhYjgw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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "read_note",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "comparator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::collections::bounded_vec::BoundedVec",
            "fields": [
              {
                "name": "storage",
                "type": {
                  "kind": "array",
                  "length": 10,
                  "type": {
                    "kind": "struct",
                    "path": "types::card_note::CardNote",
                    "fields": [
                      {
                        "name": "points",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 8
                        }
                      },
                      {
                        "name": "randomness",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "owner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "len",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6y+LX39d+/pPngm/zvW7xa/fL379YfHrp8WvPy5+/dLX3971L77+0uLrLy2+/sbF19+4+PobF19/4+Lrb1x8/Y2Lr79x8fU3Lr7+xsXX37j4+psWX3/T4utvWnz9TYuvv2nx9Tctvv6mxdfftPj6mxZff9Pi629efP3Ni6+/efH1Ny++/ubF19+8+PqbF19/8+Lrb158/c2Lr79l8fW3LL7+lsXX37L4+lsWX3/L4utvWXz9LYuvv2Xx9bcsvv7Wxdffuvj6Wxdff+vi629dfP2ti6+/dfH1ty6+/tbF19+69vqbtrXX37Stvf6mbe31N21rr79pW3v9Tdva62/a1l5/07b2+pu2tdfftC2+/rrF11+3+PrrFl9/3eLrr1t8/XWLr79u8fXXLb7+usXXX7f4+usXX3/94uuvX3z99Yuvv37x9dcvvv76xddfv/j66xdff/3i629YfP0Ni6+/YfH1Nyy+/k7aSYrv+hdff8Xvf9W7/sXX38X3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V2nx/a/S4vtfpcX3v0qL73+VFt//Ki2+/1VafP+rtPj+V3nx/a/y4vtf5cX3v8qL73+Vt7XX37z4/ld58f2v8uL7X+XF97/Ki+9/lRff/yovvv9VXnz/q7z4/ld58f2v8uL7X+XF97/Ki+9/lRff/yovvv9VXnz/q7z4/ld58f2v8uL7X+XF97/Ki+9/lRff/yovvv9VXnz/q7z4/ld58f2v8uL7X+XF97/Ki+9/lRff/yovvv9VXnz/q7z4/ldZ/P5Xj5dO+XbRT9ffOni/6lTS44ULfdQqfa2eWKv4fbVm1ip9BphZq/R5YWat0meLmbWSplqT349NpVGr9JllZq3S55uZtUqfhWbWqmpu6tSqam56Xav4/dBm1qpqburUqmpu6tSqam7q1EqGahU+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",
      "brillig_names": [
        "read_note"
      ]
    },
    {
      "name": "is_legendary_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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uhT33sJeSiR9Oc2fOy2cO03OnfbgodIcwu20uzcPb6elc6et507LZ05zD953c5nz3q9eJuK+nPaA5GVNezvNLUv6clo8d1o6d1o+N7dy6rQHG6Evl7XRu0HGL6e5c6f5c6eFc6fJudPiudPSudMePI293JaF3eLvq+Qffl5Tj57dbvsl5Q1f8ui58J98yfO1SPfoGfKWX+Ff/xXhp19xPU3OnRbPnXbuEvlgfa56Wj53Wjl1WljOnebOnebPnRbOnXbuRhrO3Ugfbe4Vb4/prPd79x21t35d9p9drneP2Xx8xaMtu1p+hXv9V/jXf0V4/VfI678ivv4r0uu/Yn39V+TXf8Xr/7rj6/+64+v/uuPr/7rj6/+64+v/uuPr/7rj6/+64+v/uuPr/7rjj/+6f5+WlnOnuXOn+XOnhXOnybnT4rnT0rnT1nOn5XOnnauS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1WynquS9VyVrOeqJJ+rknyuSvK5KsnnqiSfq5J8rkryuSrJ56okn6uSfK5KyrkqKeeqpJyrknKuSsq5KinnqqScq5JyrkrKuSopp6rEL8u509y50/y508K50+TcafHcaencaeu50/K5085ViTtXJe5clbhzVeLOVYk7VyXuXJW4c1XizlWJO1cl7lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1Xiz1VJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyXhXJXIuSqRc1Ui56pEzlWJnKsSOVclcq5K5FyVyLkqkXNVEs9VSTxXJfFclcRzVRLPVUk8VyXxXJXEc1USz1XJuezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1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",
      "brillig_names": [
        "is_legendary_initialized"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAABR8pAgACAHteZ5IKOAECAyQCAAMAAACJIwAAAyMtCAEDJwIEBAIAEAEEAScDAwQBACgDAgQfJIBHgEcABAEoAAOARwAFLQ0FBBwMBAUCHAwFAwAeAgAEASkCAAUAO5rKBy8MAAUABicCBwAACjgGBwgkAgAIAAAA6iUAAAVIKAIABgDerTAMAAYABS0IAQUnAgYEBAAQAQYBJwMFBAEAKAUCBi0MBggtDgcIACgIAggtDgcIACgIAggtDgcIKwIABgAAAAAAAAAAAgAAAAAAAAAALQgBCCcCCQQFABABCQEnAwgEAQAoCAIJLQwJCi0OBwoAKAoCCi0OBwoAKAoCCi0OBwoAKAoCCi0OBgotCAEGAAABAgEtDgUGLQgBBQAAAQIBLQ4IBS0IAQcAAAECAS4KgEUABy0IAQgAAAECAS4KgEQACCcCCQQKLQgACi0MBgstDAUMLQwHDS0MCA4tDAQPABAACQAlAAAFWi0EAAAnAgkECi0IAAotDAYLLQwFDC0MBw0tDAgOLQwDDwAQAAkAJQAABVotBAAALQ0ICQsoAAmARAAKJAIACgAAAiQnAgsEADwJAQsnAgkECi0IAAotDAYLLQwFDC0MBw0tDAgOABAACQAlAAAGgy0EAAAtDQYJLQ0FCi0NBwstDgkGLQ4KBS0OCwcuCoBGAAgBKAAKgEcABi0NBgUtCAEGJwIHBAQAEAEHAScDBgQBACgGAgctDAcILQ4ECAAoCAIILQ4DCAAoCAIILQ4FCCcCAwAHLgiARQACIwAAArcNKAACgEMABCQCAAQAAATwIwAAAswnAgMEACcCBQQDADgDBQQtCAECABABBAEnAwIEAQAoAgIELQ4DBAAoBAIELQ4DBCcCBAQDADgCBAMAKAICBS0NBQQnAgYEAgA4BQYDOw0AAwAEIwAAAyMnAgICVScCAwJuJwIEAmsnAgUCbycCBgJ3JwIHAiAnAggCcycCCQJlJwIKAmwnAgsCYycCDAJ0JwINAnInAg4CeycCDwJ9LQgBECcCEQQcABABEQEnAxAEAQAoEAIRLQwREi0OAhIAKBICEi0OAxIAKBICEi0OBBIAKBICEi0OAxIAKBICEi0OBRIAKBICEi0OBhIAKBICEi0OAxIAKBICEi0OBxIAKBICEi0OCBIAKBICEi0OCRIAKBICEi0OChIAKBICEi0OCRIAKBICEi0OCxIAKBICEi0ODBIAKBICEi0OBRIAKBICEi0ODRIAKBICEi0OBxIAKBICEi0ODhIAKBICEi0OCBIAKBICEi0OCRIAKBICEi0OChIAKBICEi0OCRIAKBICEi0OCxIAKBICEi0ODBIAKBICEi0OBRIAKBICEi0ODRIAKBICEi0ODxILIIBEgEYAAiQCAAIAAATvJwIDBB4tCAEEJwIFBB4AEAEFAS0MBAUqAwAFBSdGSLL1QRe9ACgFAgUAKBACBicCBwQbLgQABoADLgQABYAELgQAB4AFJQAAB5YnAgYEGwA4BQYFLgqARwAFACgFAgUtDgEFACgFAgU8DQQDJhwMAgQAADgDBAUAKAYCBwA4BwIILQ0IBDAMAAQABQEoAAKARwAELQwEAiMAAAK3KACABAR4AA0AAACABIADJACAAwAABUcqAQABBfeh86+lrdTKPAEBAiYqAQABBR8KLSfcgoeiPAEBAiYlAAAFHy0NAwYtDQQHCygAB4BEAAgkAgAIAAAFgCcCCQQAPAkBCQsoAAaAQwAHJAIABwAABg8jAAAFlS0NAQYtDQIHLQ0DCC0NBAkNKAAIgEMACiQCAAoAAAW6JQAAB9wuBAAGgAMoAIAEBAAEJQAAB+4uCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiARwAFDjgIBQYkAgAGAAAF+iUAAAh8LQ4KAS0OBwItDgUDLQ4JBCMAAAaCJwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAABoMtBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAAfuLgiABQAJACgJAgoBKAAKgEUACy0OBQstDgkBLQ4HAi4KgEcAAy0OCAQjAAAGgiYlAAAFHy4IgEUABSMAAAaTDSgABYBDAAYkAgAGAAAHAyMAAAaoLQ0BBS0NAgYtDQMHLQ0ECC0NBgkAKAkCCS0OCQYnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARwAGJAIABwAAByEjAAAHjS0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAAB+4uCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAHjS0MBgUjAAAGkwEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAH2y4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAAHqiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAgJIwAACBQuAIADgAUjAAAIey4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAhnLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAg2KAGABQQAAQMAgAYAAoAGIwAACHsmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_public_immutable",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::leader::Leader",
            "fields": [
              {
                "name": "account",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "points",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3djuw6dqX7LnVdFyI5xZ9+lcaBYbvdjQIKdsN2H+Cg4Xc/sVakFJE7FcFMbUbMSfK7MVZ5SxnkN2ZIcwwqqP/7l//xL//0f/7XP/ztX//nv/3HX/7bf/+/f/n7v/3zP/7n3/7tXy//6//+11//8k///re///1v/+sf7v/ff1l+/R/nyu8T/uN//+O//vrf//Gf//jv//mX/+YWceGvf/mXf/0fv/+d/OWP/M+//f1f/vLfSvmvv345POX4cXBeZD80xoNDV79+HLquy36oE/df/89f/+L80mA0OaRtNGt5PhoJ5eNQifnraFyL0WTZRlPy89HEZWMTffw6Gt9gNMX7j4NLWCujycvHoWk5UCocjibkZYPvQonx+Wh8WdzH0WG5O9gtHx8i7/iQ9R0fEt/xIekdH5Lf8SHlDR8Slnd8iHvHh/h3fMg7vvHhHd/48I5vfHjHNz684xsf3vGND+/4xss7vvHyjm+8vOMbL+/4xss7vvHyjm+8vOMbL+/4xss7vvHyjm/8+o5v/PqOb/z6jm/8+o5v/PqOb/z6jm/8+o5v/PqOb/z6jm/8+o5vfHzHNz6+4xsf3/GNj+/4xsd3fOPjO77x8R3f+PiOb3x8xzc+vuMbn97xjU/v+Mand3zj0zu+8ekd3/j0jm98esc3Pr3jG5/e8Y1P7/jG53d84/M7vvH5Hd/4/I5vfH7HNz63+MaHZY37h5R09yFy/ZD4jg9J7/iQ/I4PKW/4kLK840NafOPD5a9tH+J9+fQhX4++WMhtSBdT4e+OzkfLlXlb6lvD3ZdjvX45in//8PO+ZHm5XubK8NeY9sXfmMN+9Lpexx86H790Pv618/HHzsefOh9/7nz8pevx+2XpfPyu8/H3ff/1i/n7b5KtWVrTKvfjP7AS6/5clF+Te35wXrdh5HTXWIVDj+L258v8r9ZrO1r80cH55mc+HfobuAD8vcDNdzijATffko0G3HwPORpw803vaMDNd+mDAXfmbcVowM37oNGAmzduowHHab4ZuAD8vcBxmm8GjtN8M3Cc5puB4zTfDByn+V7gHqf5ZuA4zTcDx2m+GThO883ABeDvBY7TfDNwnOabgeM03wwcp/lm4DjN9wIPOM03A+/Aabob8Pycocv7D0lc8aHyp52UbZc5t95t0Pbx2GXowBNqoenAvWmhEdA8QtOBI9JC04F30ULTgcvQQtOBH9BC00HnroRGOuixtdDQDT9EQzf8EA3d8EM0AppHaOiGH6KhG36Ihm74IRq64Ydo6IYfoVnphh+ioRt+iIZu+CEauuGHaAQ0j9DQDT9EQzf8EA3d8EM0dMMP0dANP0IT6YYfoqEbfoiGbvghGrrhh2gENI/Q0A0/REM3/BAN3fBDNHTDD9HQDT9Ck+iGH6KhG36Ihm74IRq64YdoBDSP0NANP0RDN/wQDd3wQzR0ww/R0A0/QpPphh+ioRt+iIZu+CEauuGHaAQ0j9DQDT9EQzf8EA3d8EM0dMMP0dANP0JT6IYfopm4G/YlbmjC4pYqyCQ7SHf3t/PRSOKSPw6O/m6HkCxX6hM32orUJ+7hFakL1BWoT+w8FKlPbGoUqU/slxSpT2zFFKlP7PLUqAf7b4UekjreVIM63lSDOt5Ug7pAXYH6xN708kVPO/VSG4hzye9/3JXl7q8792qVJvayHak0sfftSKWJvXJHKk3srftRqYdXqaNSD+9fR6UeXtqOSj286R2Veng9PCr18E55VOrhRfSo1MPb61Gph1feo5Ije/iuSn5Zt5E4/3tqT1XyF1U/Dvcu30HJ6ejotOxHJ397XDr+VsmTPfSgEtlDDyqRPfSgEtlDDyoJKnWgEtlDDyqRPfSgEtlDDyqRPfSgEtlDByoFsoceVCJ76EElsoceVCJ7+LZKIeddJZHayoWP+1h8jOvt6OIPEfrtj1/Wz++PXo6ODmkfeSjh09G/VRVUHVBVso0RVSULGVFVspMRVSVrGVFVspkBVRWynBFVJfsZUVWyohFVJVsaUVVB1QFVJVsaUVWypRFVJVsaUVWypRFVJVsaUNWVbGlEVcmWRlSVbGlEVcmWRlRVUHVAVcmWRlSVbGlEVcmWRlSVbGlEVcmWBlQ1ki2NqCrZ0oiqki2NqCrZ0oiqCqoOqCrZ0oiqki2NqCrZ0oiqki2NqCrZ0oCqJrKlEVUlWxpRVbKlEVUlWxpRVUHVAVUlWxpRVbKlEVUlWxpRVbKlEVUlWxpQ1Uy2NKKqZEsjqkq2NKKqZEsjqiqoOqCqZEsjqkq2NKKqZEsjqkq2NKKqZEsDqlrIlkZUlWxpRFXJlkZUlWxpRFUFVQdUlWxpRFXJlkZUlWxpRFXJlkZUlWxpPFVlIVsaUVWypRFVJVsaUVWypRFVFVQdUFWypRFVJVsaUVWypRFVJVsaUVWypQFVdWRLI6pKtjSiqmRLI6pKtjSiqoKqA6pKtjSiqmRLI6pKtjSiqmRLI6pKtjSgqp5saURVyZZGVJVsaURVyZZGVFVQdUBVyZZGVJVsaURVyZZGVJVsaURVyZYGVDWQLY2oKtnSiKqSLY2oKtnSiKoKqg6oKtnSiKqSLdlQ1cu6I8w1VaXsqq7LUr6qSrY0oqpkSyOqSrY0oKpCtjSiqmRLI6pKtjSiqmRLI6oqqDqgqmRLI6pKtjSiqmRLI6pKtjSiqmRLA6q6ki2NqCrZ0oiqki2NqCrZ0oiqCqoOqCrZ0oiqki2NqCrZ0oiqki2NqCrZ0oCqRrKlEVUlWxpRVbKlEVUlWxpRVUHVAVUlWxpRVbKlEVUlWxpRVbKlEVUlWxpQ1US2NKKqZEsjqkq2NKKqZEsjqiqoOqCqZEsjqkq2NKKqZEsjqkq2NKKqZEsDqprJlkZUlWxpRFXJlkZUlWxpRFUFVQdUlWxpRFXJlkZUlWxpRFXJlkZUlWxpQFUL2dKIqpItjagq2dKIqpItjaiqoOqAqpItjagq2dKIqpItjagq2dKIqpItjafq5f+HqgOqSrY0oqpkSyOqSrY0oqqCqgOqSrY0oqpkSyOqSrY0oqpkSyOqSrY0oKqObGlEVcmWRlSVbGlEVcmWRlRVUHVAVcmWRlSVbGlEVcmWRlSVbGlEVcmWBlTVky2NqCrZ0oiqki2NqCrZ0oiqCqoOqCrZ0oiqki2NqCrZ0oiqki2NqCrZ0oCqBrKlEVUlWxpRVbKlEVUlWxpRVUHVAVUlWxpRVbKlEVUlWxpRVbKlEVUlWxpQVSFbGlFVsqURVSVbGlFVsqURVRVUHVBVsqURVSVbGlFVsqURVSVbGlFVsqUBVV3JlkZUlWxpRFXJlkZUlWxpRFUFVQdUlWxpRFXJlkZUlWxpRFXJlkZUlWxpQFUj2dKIqpItjagq2dKIqpItfVvVuLhd1XQ/8ENVL3/S7VDuVX1QA3nZaiC5UjvaL2U72vv06ejfqgqqDqgq2dKIqpItjagq2dKIqpItjagq2dKAqiaypRFVJVsaUVWypRFVJVsaUVVB1QFVJVsaUVWypRFVJVvqUVUJYTtacm1NMIr/ODjGWwWEeDTLclttXO6GcXxwdPvR0a9L5WiXXNyL6jLHUPvrZecdi7sr3aOD82Vt9OPg7KO/P/h3mRO2UeYTlDnpI2U+fpln4ljKfIIyJ5+mzCcocwJ7ynyCMmcFgzKfoMyFMqfMxy9z1rgo8wnKnEU/ynyCMmcVlDKfoMxZBaXMJyhzVkEp8/HLvLAKSplPUOasglLmE5Q5q6CU+QRlziooZT5BmQtlTpmPX+asglLmE5Q5q6CU+QRlziooZT5BmbMKSplPUOasglLmp8vcr2kv81z70y7HfdS//i2fjr8UY1xYq6QYzRQjK4oUo5liZN2PYjRTjKzOUYxmilEoRorRSjGy0kUxmilG1qMoRjPFyKoRxWimGFnboRjNFCMrMBSjlWJ0rMBQjGaKkRUYitFMMbICQzGaKUZWYGwUY9ofrrr88/PRv3USdOpCJ3L7PnQi0u5DJ9LePnQiCO1DJzLCLnTyxGd96ESy1IdOhC596EQe0YdOgk5d6EQe0YdO5BF96EQe8V2dQkh+ZyKrr5B3l8HsaxUup9tvneOhTovfdfL+7tjfKpFG9KASWUQHKgWSiO+qJEvaxy1OUkWluNy2drjxc1mu3EkWdLiTFOhwx/nrcBe4q3DHmetwx2nrcMc563DHC+twx92qcBf8qg53/KoOd/yqDnf8qg53gft3uUcpO/dY/dGKD2kD70O5W/vK+cepseBue1AJL9yDSjjnHlTCZ/egEq68A5VWPHwPKuH4e1CJfKAHlUgTelBJUKkDlcgeelCJ7KEHlcgeelCJ7OFVKonbN4kSWT6p9Js8eYIS+UhGoEUe369FHi+vRR5/rkVeIK9EHh+tRR5vrEUev6tFHg+rRR4Pq0Q+4WG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyGc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBL5gofVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4fVIZ8WPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSeYeH1SKPh9Uij4fVIo+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSLv8bBa5PGwWuTxsFrk8bBa5AXySuTxsFrk8bBa5PGwWuTxsFrk8bBK5AMeVos8HlaLPB5WizweVou8QF6JPB5WizweVos8HlaLPB5WizweVom84GG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyK94WC3yeFgt8jN72CA7+ZBi7eiYN/DhsqB0x325kpzZk7YlKZBsRHJmz9iW5MwesC3JmT1dW5Ize7S2JGf2XE1Jxpk9VFuSM3uitiTxOK1I4nFakRRINiKJx2lFEo/TiiQepxVJPE4rknicRiQTHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5IZj9OKJB6nFUk8TiuSeJxWJAWSjUjicVqRxOO0IonHaUUSj9OKJB6nEcmCx2lFEo/TiiQepxVJPE4rkgLJRiTxOK1I4nFakcTjtCKJx2lFEo/ThmRe8DitSOJxWpHE47QiicdpRVIg2YgkHqcVSTxOK5J4nFYk8TitSOJxGpF0eJxWJPE4rUjicVqRxOO0IimQbEQSj9OKJB6nFUk8TiuSeJxWJPE4jUh6PE4rknicViTxOK1I4nFakRRINiKJx2lFEo/TiiQepxVJPE4rknicRiQDHqcVSTxOK5J4nFYk8TitSAokG5HE47QiicdpRRKP04okHqcVSTxOI5KCx2lFEo/TiiQepxVJPE4rkgLJRiTxOK1I4nFakcTjtCKJx2lFEo/TiOSKx2lFEo/TiiQepxVJPE4rkgLJRiTxOK1I4nFakcTjtCKJx2lFEo/TiGTE47QiicdpRRKP04okHqcVSYFkI5J4nFYk8TitSOJxWpHE47QiicdpRDLhcVqRxOO0IonHaUUSj9OKpECyEUk8TiuSeJxWJPE4rUjicVqRxOM0IpnxOK1I4nFakcTjtCKJx2lFUiDZiCQepxVJPE4rknicViTxOK1I4nEakSx4nFYk8TitSOJxWpHE47QiKZBsRBKP04okHqcVSTxOK5J4nFYk8ThtSJYFj9OKJB6nFUk8TiuSeJxWJAWSjUjicVqRxOO0IonHaUUSj9OKJB6nEUmHx2lFEo/TiiQepxVJPE4rkgLJRiTxOK1I4nFakcTjfJOkhMV/HC1hjZ9IHoxE0obEre5uJPlo3HHJHwdHf/eXs1w1wj3Z1whfZl4jj+OzrxFe0r5GuFT7GuF/7WskaGReIzy7fY1IA+xrRM5gXyNyBvsakTOY1yiQM9jXaOqcIW9HB/Hrp6N/s5na31fYTO2rK2wENg/ZTO0jK2ym9m8VNlP7pgqbqf1Khc3UPuE5G5m6P6+woS9+zIa++DEb+uLHbAQ2D9nQFz9mQ1/8mA198WM29MWP2dAXP2Sz0hc/ZkNf/JgNffFjNvTFj9kIbB6yoS9+zIa++DEb+uLHbOiLH7OhL37IJtIXP2ZDX/yYDX3xYzb0xY/ZCGwesqEvfsyGvvgxG/rix2zoix+zoS9+yGbuN9pX2NAXP2ZDX/yYDX3xYzYCm4ds6Isfs6EvfsyGvvgxG/rix2zoix+ymfst6BU29MWP2dAXP2ZDX/yYjcDmIRv64sds6Isfs6EvfsyGvvgxG/rih2ymfnO2hBub6r4YLm17V/jl9pd99gfH5p1HDqVybNkFKuXzsb/1mbk370Gfmf1BD/rM7FF60EfQx7Q+M3u1HvSZ2S/2oM/MnrUHfWb2zT3oM7N3t6+PW6Z+LX0XApEgGBdo6ggh71vTZnE1gXzeN5sNQe6OPkSyul38NS+fjr6Cnzob0AQvgNcBP7Wb1wQ/tU3XBD+1/9YEP7Wx1gQ/tWNWBO+mdsKa4Kd2uJrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuA9zlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHfMC5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce56oAXnKsSeJyrEnicqxJ4nKsSeAG8DnicqxJ4nKsSeJyrEnicqxJ4nKsO+BXnqgQe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgM+4lyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41x1wCecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74jHNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAV9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrirg3YJzVQKPc1UCj3NVAo9zVQIvgNcBj3NVAo9zVQKPc1UCj3NVAo9z1QHvcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464D3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQd8wLkqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgBecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74FeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqAz7iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAJ5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviMc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBX3CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuKuD9gnNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAe9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgPc5VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB3zAuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqAF5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDvgV56oEHueqBB7nqgQe56oEXgCvAx7nqgQe56oEHueqBB7nqgQe56oDPuJclcDjXJXA41yVwONclcAL4HXA41yVwONcXwJefCofR0tYfeVoJ2n/26u7G3c+mmVc8sfB0ce7Y+VDUjzxcJLitoeTFB8/mqSJhGA4SckehpOUVGM4SclLhpNUkHQ0Scl4hpOU9Gg4SUmPhpOU9Gg4SUmPRpM0kx59V9KwD8TFJVRE8n5ZPo72Ej5LegVPxqMEniRGCTx5iRJ4AbwOeLIHJfAkBErg8fFK4HHbSuDxxDrgC85VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VBXxYcK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464B3OVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQe8x7kqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgA84VyXwOFcl8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wgnNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAb/iXJXA41yVwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAR5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviEc1UCP7NzzesOvvwa6t3RVzgzu8sqnJkdYBWOAOcxnJmdVBXOzG6nCmdmR1KFM7NrqMKZubOvwckzd99VOHTIT+DQIT+BQ4f8BI4A5zEcOuQncOiQn8ChQ34Chw75CRw65MdwCh3yEzh0yE/g0CE/gUOH/ASOAOcxHDrkJ3DokJ/AoUN+AocO+QkcOuSHcGShQ34Chw75CRw65Cdw6JCfwBHgPIZDh/wEDh3yEzh0yE/g0CE/gUOH/BiOo0N+AocO+QkcOuQncOiQn8AR4DyGQ4f8BA4d8hM4dMhP4NAhP4FDh/wYjqdDfgKHDvkJHDrkJ3DokJ/AEeA8hkOH/AQOHfITOHTIT+DQIT+BQ4f8GM7U74OvwqFDfgKHDvkJHDrkJ3AEOI/h0CE/gUOH/AQOHfITOHTIT+DQIT+GM/V7p6tw6JCfwKFDfgKHDvkJHAHOYzh0yE/gzNwhF7fucGLtaJfyx8H+btdTn/3BsXnnkUOpHFvyNuRSPh97FWjmLr0LgWZ2Cl0INLNbKWkbtjhZKkf7FPymUCr3R8cjiS5oN428i5+O/g1+6vcYq4Kf2WWpgp/ZwamCn9kdqoIXwOuAn9nVqoKf2jFrgp/aCWuCn9rhaoLHueqAn/o9xqrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgp36PsSp4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74qd8Brgoe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgO+4FyVwONclcDjXJXA41yVwAvgdcDjXJXA41yVwONclcDjXJXA41xVwK8LzlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHvMO5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce56oD3OFcl8DhXJfA4VyXwOFcl8AJ4HfA4VyXwOFcl8DhXJfA4VyXwOFcd8AHnqgQe56oEHueqBB7nqgReAK8DHueqBB7nqgQe56oEHueqBB7nqgNecK5K4HGuSuBxrkrgca5K4AXwOuBxrkrgca5K4HGuSuBxrkrgca464FecqxJ4nKsSeJyrEnicqxJ4AbwOeJyrEnicqxJ4nKsSeJyrEnicqw74iHNVAo9zVQKPc1UCj3NVAi+A1wGPc1UCj3NVAo9zVQKPc1UCj3PVAZ9wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgM85VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB3zBuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHuaqAjwvOVQk8zlUJPM5VCTzOVQm8AF4HPM5VCTzOVQk8zlUJPM5VCTzOVQe8w7kqgce5KoHHuSqBx7kqgRfA64DHuSqBx7kqgce5KoHHuSqBx7nqgPc4VyXwOFcl8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wAeeqBB7nqgQe56oEHueqBF4ArwMe56oEHueqBB7nqgQe56oEHueqA15wrkrgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgV5yrEnicqxJ4nKsSeJyrEngBvA54nKsSeJyrEnicqxJ4nKsSeJyrDviIc1UCj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBn3CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGuSuBxrkrgca5K4HGuOuAzzlUJPM5VCTzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUHfMG5KoHHuSqBx7kqgce5KoEXwOuAx7kqgce5KoHHuSqBx7kqgce5qoBPC85VCTzOVQk8zlUJPM5VCbwAXgc8zlUJPM5VCTzOVQk8zlUJPM5VB7zDuSqBx7kqgce5KoHHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqA9zhXJfA4VyXwOFcl8DhXJfACeB3wOFcl8DhXJfA4VyXwOFcl8DhXHfAB56oEHueqBB7nqgQe56oEXgCvAx7nqgQe56oEHueqBB7nqgQe56oDXnCuSuBxrkrgJ3au4vajxZX46egrnIndZR2OAOcxnIldWh3OxE6qDmdit1OHM7EjqcOZ2DVU4awTd/Z1OBN333U4dMhP4NAhP4EjwHkMhw75CRw65Cdw6JCfwKFDfgKHDvkxnEiH/AQOHfITOHTIT+DQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75MZxEh/wEDh3yEzh0yE/g0CE/gSPAeQyHDvkJHDrkJ3DokJ/AoUN+AocO+TGcTIf8BA4d8hM4dMhP4NAhP4EjwHkMhw75CRw65Cdw6JCfwKFDfgKHDvkxnEKH/AQOHfITOHTIT+DQIT+BI8B5DIcO+QkcOuQncOiQn8ChQ34Chw75IZw887vm63DokJ/AoUN+AmfmDllc2OAktxzAEeA8hjNzh1yFM3OHXIUzc4dchTNzh1yFM3OHXIMz8zut63Bm7pCrcGbukKtw6JCfwBHgPIZDh/wEDh3yEzh0yE/g0CE/gUOH/BjOzO/OrcOhQ34Chw75CRw65CdwBDiP4dAhP4FDh/wEDh3yEzh0yE/g0CE/hjPzOzrrcOiQn8ChQ34Chw75CRwBzmM4dMhP4NAhP4FDh/wEDh3yEzh0yI/hzPwuwDocOuQncOiQn8ChQ34CR4DzGA4d8hM4dMhP4NAhP4FDh/wEDh3yYzhTv1OvCocO+QkcOuQncOiQn8AR4DyCU+wH7DFtR68xh3s41wnYb/GXm7pL/DqBJs2UD1tVhJByZQIhlmU7Oi/3v/yNH2Mq9sbUJlxrPCZncEze4JiCwTGJwTGtBscUDY4pGRyTweu4GLyOrwav46vB6/hq8Dq+GryOrwav46vB6/hq8Dq+GryOrwav46vB63g0eB2PBq/j0eB1PBq8jkeD1/Fo8DoeDV7Ho8HreDR4HY8Gr+PJ4HU8GbyOJ4PX8WTwOp4MXseTwet4MngdTwav48ngdTwZvI5ng9fxbPA6ng1ex7PB63g2eB3PBq/j2eB1PBu8jmeD1/Fs8DpeDF7Hi8J1PKf96LK4gzF5g2MKBsckBse0GhxTNDimZHBM2eCYiu6YnP/jmPyyKFzH8/60Vyh++TSmr0fn/ZmnHG6PPPnsD469dDkfx5by+djrXN1Ec/UTzTVMNFeZaK7rRHONE801TTTXPNFcyzxzdRP1TW6ivslN1De5ifqmNtv8W5lr3I51l0b/YLJDNU61yQ7VOdUmO1TrVJvsUL1TbbJDNU+VyXqF7qn4tE92TZXJPv8932UCrvcJ+N4nEHqfgPQ+gbX3CcTeJ5B6n0DufQKl8wmE3u/EofcbWTB/I3u6NcBlAoeXUVlS+ThLfm85sJ21HA7I3ZYp892jHfFoQE7WvKGR+8mWo6O9i9vR3uVb53r8p4tso/5ltp4fnNwmbIp3o1iPjpW8/d31foOL9WMZ9nirWxh+xuG253/WkA4YZhj+aYYFhn+W4fEWIDD8EUMHwz/N0MPwTzMMMPzTDGVWhsuNYakwDP72cHNwsh8dwtFuXW5JYQ9Y78Yc1qOjsyt7ciuVY+OuZQzx07FXLVe0HEbLaX3bgFpO6x8H1NK6j92P9n6RmpbFb8P+9cOTdT/cl/QxXeuWs+10V+vusPF0rRu5xtO17rkaT9e6PWo8XZlrutab/R9MV1LZBiI55IPJWu+Gm07WervYdLID9VP1yQ7UTVUnGwfqpeqTHaiTqk+290VxjX0CfzgBf5uAT18nYP7prtoEzD/dVZuA+ae7ahMw/3RXbQLmn+5KEvcJrHI/gYMrtOwD8SLyZbbJ/KNgTWdr/gnuprM1/5Rc09na7x5azlammq39vqTlbO03MS1na7/j+dFsfb7N9qtFSPbbo5azHayXej7bPFYvta5bn+zXGJ4fHJdlX95c3NcveR6r8foJmrXsYc0xmrG6tHX/ealfk3t+cF62P5zlbh0/lA8yY3V0LckIZB6QGatTbElmrK6yJZmxOtCGZMpgHc1PyKzbM2Y5xU9kjpZBwjbmy4rI7Q/L0TYJPm+9Q1g+HXolPlij1AHxifsvJeIT93VKxAXibyY+cR+qRHzi/laJ+MR9sxLxsdLjHoiPlWDbJ+4WPOe7ieM5300cz/lu4njONxN31Pi3iF8CqJ343TPFh8Rz3gbx6b0+h3/YXT57+8uXf6e7HVk/Hrh2ji+FeYkEiaxLRNRjXiKyIfMSESaZl4j0ybxExFXWJbL/GgQkIhAzLxHpgnmJSBfMSyRIZF0i0gXzEpEumJeIdMG8RKQL5iUiXbAukf1XOyER6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJhHTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iVaSRfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXaJIumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEiXSBfMSkS6Yl4h0wbxEpAvWJcoDf4vy84NT3I5N6RP0K5iBa/fPgRHAHIPpIAVyNzCVuT7709fpdpCotJxuB+lEy+l24PRbTrcD19xwuqUDB9pyuh24ue9PV5ZQPg6W5ddQn/7pIHsLGCTfDXt1H3A66AD14HTQBerBEeA8hjNUN9gazlC9Y2s4Q3WareEM1Ze2hjNUF9sWju/hXfF6cOiQn8CZpkO+Tneanvc6XZlrutP0pdfpTtNpXqc7Te94ne5Y3aDbFy4kOKn86bzIx8E53ND4fLRoWPL2h0v5fOwV41h9oxZGN1aHqYZxrF5UDeNYXasaxrG6YTWMAsYWGMfq3tUwjuUK1DCO5TbUMOJimmDExbTA6HExTTDiYppglLEwum2pQZw/CLR6eIN7y+kO1ofVpjtYv1Sb7mB9TW26g/Uflen28PboltMd7H5em+5g6WFtuoOlfLXpylzTnaur6uEtsC2nO1dX1cPbSVtOd66uqoe3Zrac7lxdVQ9vc2w53bm6qh7eMthyunN1VT28/a7ldOfqqnp4K1vL6c7VVfXwtrCW052rq+rhLVYtpztXV9XD25VaTneurqqHt/60nO5cXVUPb6NpOd25uqoe3pLScrpzdVU9vL2j5XTn6qp6eKtEy+nO1VX18LaDltOdq6vqYRf+ltOdq6vqYXf4ltOdq6vqYdfyltOdq6tKMtd05+qq0lxdVZqrq0pzdVVprq4qz9VV5bm6qh7eYtFyunN1VT28caLldOfqqsZ6j0R9unN1VWO9R6I+3bm6qrHeI1Gf7lxd1WBvhqhOd66uarC3N1SnO1dXNdgbFqrTnaurGuwtCNXpTtVVhcHeVFCd7lRdVRjsbQLV6U7VVYVF5pruVF1VGOxtAtXpTtVVhdHeJlCb7lxd1Wi789emO1dXNdpu97XpztVVjbZ7fG26c3VVo+3GXpvuXF3VaLub16Y7V1c12m7htenO1VX5uboqP1dXNdfe6mGuvdXDXHurh7n2Vg9z7a0e5tpbPcy1t3qYa2/1MNfe6mGuvdXDXHurh9H2Vn/Ze47idqxbFv/p4CtHXknYhiPvJGzDkZcStuHIWwmbcBxtY3w1jtO8Fvw63Wle332drsw13Wmaz+t0p+kRr9OdppW7Tneajus63Wkao9/THW0L+tp0p3n98XW6c3VVo21BX5uuzDXdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaqrktG2oK9Nd6quSkbbgr423am6KllkrulO1VXJaFvQ16Y7VVclo21BX5vuXF3VaFvQ16Y7V1c12hb0tenO1VWNtgV9bbpzdVWjbUFfm+5cXdVoW9DXpjtXVzXaFvS16c7VVY22BX1tunN1VaNtQV+b7lxd1Whb0NemO1dXNdoW9LXpztVVjbYFfW26c3VVo21BX5vuXF3VaFvQ16Y7V1c1z07x1+nO1VXNs+/6dbpzdVXz7GJ+ne5cXdVce6vLXHury1x7q8tge6vHULbp5iVU/vSPXriQtxmW8vnYK8axujU1jGN1gWoYx+ouX4fx+VtUZLDN69U4DrYrvh7HsRptPY5jdfB6HMeyBnocZSiOef/TkqXGMcXwcXBKtxnKRmYse9KSzFiOoyWZsUzEEzLX6Y7V7FenO1ZPXpvuWK8+WJ2s28EuHsRRY736oD7doRrR+nSH6hfr05W5pjtUr1af7lANWH26Q3VV9ekO1VXVpztUV3U/Xe/81+mO9eqD+nSH7aqOpztsV3U83WG7quPpylzTHaurSi7tB+dyMN2xuqrqdMfqqqrTHaurqk53rK6qNt2xXn1Qn+5YXVV1umN1VdXpjtVVVacrc013rq5qrFcf1Kc7V1c11qsP1hyW7eASc+VPS9nZ3D/enN3BsT4t/uNgn/zNa20Yx+rWtDCO9aoGPYxjdZeNMF7RjNWJNkUzVtfaFI2A5hGasbrhpmjG6pybohmry/4RmktWvx0s+QDNxB15Dc3EXfZzNOtYr+Noi2bibriGZuJuuIZm4m64hkZA8wjNxN1wDc3E3fC67t1wlgM0M3fDFTQzd8MVNDN3w8/RjPUalbZoZu6GK2hm7oYraGbuhitoBDSP0MzcDVfQ0A0/RDNNN3yd7jQd7nW603Stv6c71qtn6tOdpru8TneajvE63aG6wLgs20BiiO5gujLXdIfq1urTHaoDq093qK6qPt2huqr6dIfqqqrTHevVM/XpDtVV1ac7VFdVn+5cXdVYr56pT3eurmqsV8/UpztXVzXWq2fq052rqxrr1TP16c7VVY316pn6dOfqqsZ69Ux9unN1VWO9IqY+3bm6qrFeuVKf7lxd1VgvMKlPd66uaqzXgdSnO1dXNdbLNerTnaurGus1GPXpztVVjfVui/p05+qqxnq3RX26c3VVY73boj7dubqqsd5tUZ/uXF3VWO+2qE93rq5qrHdb1Kc7V1c11rst6tOdq6sa690W9enO1VWN9W6L+nTn6qrGerdFfbpzdVVjvduiPt25uqqx3m1Rn+5cXdVY77aoT3eurmqsd1vUpztXVzXWuy3q052rqxrr3Rb16c7VVY31roj6dOfqqsZ6T0N9unN1VWO9T6E+3bm6qrHee1Cf7lxd1VjvJ6hPd6quKo71HoH6dKfqquJY+/3XpztVVxUXmWu6U3VVcaz98+vTnaqrimPtc1+f7lxd1Vj70denO1dXNda+8fXpztVVjbW/e326c3VVY+3DXp/uXF3VWHur16c7V1c11t7q9enO1VWNtbd6fbpzdVVz7a0e59pbPc61t3qca2/1ONfe6nGuvdXjXHurx7n2Vo9z7a0e59pbPc61t3qca2/1ONfe6nGuvdXjXHurx7n2Vo9z7a0e59pbPc61t3qca2/1ONje6pK3g+Pq/MF0x+qqQtrVvZxY+dN5kY+Dcyj7sT77g2NL3v5wKZ+PvWIcq1tTwzhWF6iGcazuUg3jWF2rFsbB9sRXwzhWl62GcazuXQ3jWK5ADaOAsQVGXEwTjLiYJhhxMU0w4mKaYMTFtMA42Dso1DDiYr6HMW7HumXxBxyxMW044mPacBQ4NuGIk2nDESvThuNY3eOay8YxuhpHt5YlbLNciwv78R+Lp4O9Y+EJnOt0x7pXVqc71C0tpbQdnNJdZ378p32K68fRPqVw/6evbIa6TTVmM9StpzGboaKxxmyGyrsasxmqDWnLZqw3TjRmM1Tc1JjNUN3rT9kUv7HJd83fzmaoVrcxG4HNQzYT98XBL5uhCt6nr2wm7ourbCbui6tsJu6Lq2wm7osvbJZnbMZ6q8QP2Yjbjg7il69sJu5vqmwENg/ZzNzf1NjM3N+Eknc2bnn+p9eStpvaWsrBhXvmZugnIOOy3wHjcuBGxnp7x3sq8hjkzG2WhL0FldX9qa92GuuNI+8BeVSRaax3mfwU5P40RJCSv7KZuvGvsJm68a+wEdg8ZDN1439js949JLWzmbnxr7GZuZevsZm5Pa+xmbnjDreBrC49/9Mu5s0DuiR3O7yEciU51vtZfkgy7dvfhFTCn/MuY7355YUgK7FEGuudMu+pyGOQMjPI/U+HP6zEH1wkl7I/yO3CcnCRnLm9zV52kqXyp2UHIv7zzeaA+i2Cc5fsfD867NRnbpz1qM/ckutRn7nZ16M+s41Qoz7Wu5q6oT6z0dOjPrMr/BH1sJlCuZ/hznFmU9iS41g/IG/6g9002KuqGsMZa9uqxnDG2oyqMRw2CXgMZ7BXbDWGM9Z2UI3hTLO9xBk402xGcQaOTA0nyA3O6u/gHB/t746OX1DO3U83RTl3990U5dy9+g9QitsDHPF3D1NsIOfu6xuCnNsDtAM52MvjFEHO7S0agpzbhzQEObdnaQhSANkGJO6mEUi8TSOQOJtGIHE2jUBO7mweBREHfzvvv0W4JPtL7W+XvE3yQv3uVbyru4If7MWBHYGf3Dm1AX9FObl3aolycvf0NBBu8+o2t785IHhfKnBcXrb9RV129yjzIZzlBmeJ93CuE0jmJ+BvE/i63Vhq87oyzQmUzifQ5hVdmhNwvU/Am5+AxNsluvKrMS/7vcKLfP35XZt3R3UzW5lqtutUs7XfPbScrf1Wo+Vs7fclLWdrv4lpONtkv+P50Wx9vs32q0VI9tujlrMdrJeqzHasXmpdtz7Zr/FPbpfR5j1kXaKpbYCRxurSVhd2NKmyQWRetj+c5W7M28/A0lgdXUsyY3V/LcmM1Sm2JDNWV9mQTB6rA21JZrCO5idk1m0YOcVPZA7+sAu3xci7XZHl6G3F/rZ51vLp0CtxgfibiU/cfykRn7ivUyI+cb+oRHziPlSFeF4m7uJ+Qny5vf3R3T3DcEg8520QxVV3Gbp89v54R75Ef/vxvqQPicYKP4eUaKzEdkiJMGXmJRIksi4Rts+8RPhE8xJhLM1LhBM1L9HESzOdSORIF8xLRLpgXiLSBfMSkS6Yl0iQyLpEpAvmJSJdMC8R6YJ5iUgXzEtEumBdIk+6YF4i0gXzEpEumJeIdMG8RIJE1iUiXTAvEemCeYlIF8xLRLpgXiLSBesSBdIF8xKRLpiXiHTBvESkC+YlEiSyLhHpgnmJSBfMS0S6YF4i0gXzEpEuWJdISBfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXaKVdMG8RKQL5iUiXTAvEemCeYkEiaxLRLpgXiLSBfMSkS6Yl4h0wbxEpAvWJYqkC+YlIl0wLxHpgnmJSBfMSyRIZF0i0gXzEpEumJeIdMG8RKQL5iUiXbAuUSJdMC8R6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJMumCeYlIF8xLRLpgXiLSBfMSCRJZl4h0wbxEpAvmJSJdMC8R6YJ5iUgXrEtUSBfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXKKykC6Yl4h0wbxEpAvmJSJdMC+RIJF1iUgXzEtEumBeItIF8xKRLpiXiHTBukSOdMG8RKQL5iUiXTAvEemCeYkEiaxLRLpgXiLSBfMSkS6Yl4h0wbxEpAvWJfKkC+YlIl0wLxHpgnmJSBfMSyRIZF0i0gXzEpEumJeIdMG8RKQL5iUiXbAuUSBdMC8R6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJhHTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQL1iVaSRfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXaJIumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEiXSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXKJMumJeIdMG8RKQL5iUiXTAvkSCRdYlIF8xLRLpgXiLSBfMSkS6Yl4h0wbpEhXTBvESkC+YlIl0wLxHpgnmJBImsS0S6YF4i0gXzEpEumJeIdMG8RKQLtiUKy0K6YF4i0gXzEpEumJeIdMG8RIJE1iUiXTAvEemCeYlIF8xLRLpgXiLSBesSOdIF8xKRLpiXiHTBvESkC+YlEiSyLhHpgnmJSBfMS0S6YF4i0gXzEpEuWJfIky6Yl4h0wbxEpAvmJSJdMC+RIJF1iUgXzEtEumBeItIF8xKRLpiXiHTBukSBdMG8RKQL5iUiXTAvEemCeYkEiaxLRLpgXiLSBfMSkS6Yl4h0wbxEpAvWJRLSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLliXaCVdMC8R6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJIumCeYlIF8xLRLpgXiLSBfMSCRJZl4h0wbxEpAvmJSJdMC8R6YJ5iUgXrEuUSBfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXaJMumBeItIF8xKRLpiXiHTBvESCRNYlIl0wLxHpgnmJSBfMS0S6YF4i0gXrEhXSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBeItIF8xKRLhiXyC2kC+YlIl0wLxHpgnmJSBfMSyRIZF0i0gXzEpEumJeIdMG8RKQL5iUiXbAukSNdMC8R6YJ5iUgXzEtEumBeIkEi6xKRLpiXiHTBvESkC+YlIl0wLxHpgnWJPOmCeYlIF8xLRLpgXiLSBfMSCRJZl4h0wbxEpAvmJSJdMC8R6YJ5iUgXrEsUSBfMS0S6YF4i0gXzEpEumJdIkMi6RKQL5iUiXTAvEemCeYlIF8xLRLpgXSIhXTAvEemCeYlIF8xLRLpgXiJBIusSkS6Yl4h0wbxEpAvmJSJdMC8R6YJ1iVbSBfMSkS6Yl4h0wbxEpAvmJRIksi4R6YJ5iUgXzEtEumBdojiwdc3PD05xOzalT9B/g0kDG8Y/B2Zgm/bnwHRgjtwNTGWuz/70dbodGI2W05W5pttBA9xyuh00ky2n20Fj1nK6HSyh/GS663Z/c8WHyp++LE6U7ej1rgO8/Okrmw4aQC02uYMeUI1NB23gq9j4nPamMZdSOTr4krdJXtYK96PjB8jB2kY9kIM1pHogBZDfBBli2UHmdAfy67HidujiXfoCfbCGuw/og7X9P4O+T9IXt1SOzvscc7hN0eejiLLkbRilfD72Cn0w89EH9IktkB70ib2VGvQysWnTgz61G9SCPrVz1II+tcvUgi5Afz/0qR2pFnQcqQJ0HKkCdBypAnQc6duh+wVH+grocTvWLYs/oI4l1aCOJ9WgjinVoC5QV6COLdWgPrMvLbcF56VK3UnaUa7u7m/no5HEZVufjv7udyJZPrDP7EwVsc/sTRWxz+xO9bC7mf2pIvaZDaoidgH7S7DLdnBc3QF2OpnXYN9/4RtjPsBOJ/Nd7Kvbh70G+YT9ipLupBXKHt5T3gtKuohmKGfOrn94i9oHckG5Vm5Rl4/PchtK+eNj+L6Ht3mPCV4ArwN+5hBbFTw5thL4if1fWELawZfaQJ7/Zs338C7rPkBO7OeaguzhvdA2QDoX152Ji3ebyDnnjv760x9q+x7e9jwm+Imdoi74iZ3ii8E3+1W97+HdzIg0sQP9qUjJ73/clSVURPIp7Q9ppbstJTfwEztQXfA4UCXwONYXgW/6YEQP70hGJt/De5KRyffwrmRk8j28LxmZfA/vTEYm38MbX6eQ6fmzmD28r3IKmZ4/u9nDOys7lan2KFgP76IcFT0dmRp6uiw19AL6V92Smz7H1MObIRHql1B4kU6EYl2mE6FYx+lEKPz9d4Xyy7qT97+n9lQofxH243Dv8h2UXw9jfD06LfvRyfs/yhTx913IRBbQhUzkBgoyXdGTG6ihF9BroScJUEOPt1dDj1tXQ4//fhV6vz/X4C//PkCPo9ZCn3DJaujp69XQ0+G8Cv0qy4Z+XY/Q0+GooafDaYL+CpOepR3MTBfSECaJ+rdheld2mP7+mnnm5/OZjFwJPJ20EngB/IvAt9uLIJOkdyASjvScSNEddEB4zIYwcY0NYeIavw0z5LzDFKnukhH9nvnFcHd0+XjHVsFjvgV9OkCPI30HevEH6PGkL0O/j8XHuH5CfzSWuOxjiXcIy3I4z7SHPDmHytHZb9PM4j4dey0B3PH0JSCUwOwlQAowfQmQMUxfAiQj05cAec70JUAKNXkJhIU0bPwSWLcn3vOaDkqAVG78EpD9KnAH8FYCpIMzlUAMByVALtBhCfg1bFD8uvoDWfH6Xcp62+o/uvVAVvz7kLLiyYeUFZ89oqwO7zykrPjhIWXF4w4pKwanx+ii3J6QLUe5tMPgDCkrBmdIWTE4I8rqMThDyorBGVJWDM6QstIy2ZDVy7ojzGtF1hBz2I6OuRzISss0oqyBlmlIWWmZhpSVlqlDWSXsb/SUkA+eZQr80rFHWcse9UvJ+UBWQdauZV2X5egizJOHQ8rKwtyQsrIwN6SspExDykrKNKKsQso0pKykTEPKSso0pKykTEPKKsg6oqykTEPKSso0pKykTEPKSso0pKykTCPKupIyDSkrKdOQspIyDSkrKdOQsgqyjigrKdOQspIyDSkrKdOIskYMjg1Z3f5SquDW6o81wi5rCEePf0cMTu+yloMfa0QMzpCyCrKOKCsGZ0hZMThDyorBGVJWltGHlJVl9BFlTSyjDykrKdOQspIyDSkrKdOQsgqyjigrKdOQspIyDSkrKdOQspIyDSkrKdOIsmZSpiFlJWUaUlZSpiFlJWUaUlZB1hFlJWUaUlYMzjtkTb4ia4rb5vsp3WiLv6pU8Cs9qIT96EEl3MSrVEppO9znJVRUKpdO8ePoIku6HX048MuN6nYfuzs4HY2jZLfPcvHPD3ZuSbs47hOU/FEw+BSFgrmiF9C/CH32ZUe/LgfoWad6GfooO/o7ght6WbhDfRv9GvZx+zW5CvqStnchucXd3RguA7+S51L/bfJxcTv5dD/wQ/KXP7nfk/29yX3Q7+XtraCXv11qRzu330acpMrRuWxQilsOvnzccqYvAaKu6UuAh6+GL4FSwt4MLPlTDXw9OJZ9lrG4ilvNly7w4+Dso/+jo7y4XaqL6npZdfEoGtX1uupiwYjqell1ORa6qK7XVRcLdFTX66qL2Jbqel11EU1TXa+rLqG6Jq6uaw0Qe1MD5N7UAOn08DXgFr/sRSBLpdVwJe4PuJQyyoN94gmbxi/0kMNNTP/1aufJhCgCT3QzWRGUgyIgYaEIvFAEFAFJCEXgiUJoDD1ZCEXgeaCOIvA890YRBBJDiiCQGFIEgcSQIggkhhRBICyiCAJhUY9F4Jd9ExTvPxfBVVbinyFlJdAZUlYimhFlFUKXIWUlRhlSVoKRLmWVdZc1LQeyEnUMKasg64iy4ltHlHWlE+5S1v1XKz78YSRXWemEe5Q1rPu39dOrNXZZ6YSHlJVOeEhZBVlHlJXV2SFlZb11SFnxrUPKynrrkLKy3tqjrBK2Z5m85FA5Osr2xpQYb6s9IR7NMq8bkpzLp2N/l0skvaJcflAupGKUyw/KhbSNcrk7ttzeyba4Ujl4vdTGpo3LUjk6xrDs4wjuoBaJCKlFK7Uo1CK1aKQWCWOpRSu1SIJMLVqpRWJvatFKLZLVU4tWapEFBmrRSC0mVi+oRSu1yNIItWilFll3oRat1CLrLtSilVoUapFaNFKLrLtQi1ZqkXUXatFKLbLuQi1aqUXWXahFK7XIugu1+J5aTGGvknQh8rUWM+su1KKVWmTdhVq0UotCLVKLb6rFvO61eIf7VotkOtTim2pR/H5dvIz/oBbxLtSikVosPBtBLb6pFvO6AUk5HtUiz0ZQi6drUfZd31dxy0F1CdVFdb2sunh+gep6XXXhXqmu09WV9mxkzcvBWlrhGQOq63XVxVMDVNf56orLXl2+5jBdWPyuTlj+4DGPgN+kv/w7utrx67ozdGtcvt6p1wUPS7WbrfZ9lr+qvTYaJ3ndBy85fV1VWR3pIdX+rmp3fv/jwa0H117HtZdqtFONQjVSjWaqkXySarRTjeSZVOP5arzXJh1UF3km1fW66iLPpLpeV108G0h1vay6PL9UorpeV1389ojqel11sdZAdb2uusjHqK7T1VX2F3+tJa8H1UXeRXW9rrrIu6iu11UXeRfVdba64rI/HRqdO+q7yLuorpdVVyDvorpeV13kXVTX66qLvIvqel118aws1fW66hKqi+p6WXWR1VNdL6suoe+iuk5Xl5O0V9fBHker0HdRXa+rLqG6qK6XVRd9F9X1uuriGQmq63XVxTMSVNfrqotnJKiu89W1Hx39H34t+/Xo7GWrkuyjvw16K0UeqKAUbZTiytMXlKKRUuRRDUrRSCmyvkApGilFFiMoRSOlKJQipfiWUnRx3V9bc/n3XTHuec7KSgfVaKcaWRmhGu1UIyspVKOdamTlhWp8WzUmd6vGfFCNkZiRanxXNcYsezWm5eBJ5kjSSDW+qxqTv92pk8SDaiRspBrtVKNQjVSjmWokb6Qa7VQjeSPVaKcayRupRjvVSN5INdqpRh72phrfVo053qrxDvhejYnnvalGO9XIWgzVaKcaWYuhGt9VjXlZ9mrMv4b6pRpZi6Ea7VSjUI1Uo5lqZC2Ganxb33j3RFl2vna8v0l/+Xd0tePXNe8J0rqWclDtrPVQ7fNUO2tJVPs81c5aFdU+T7WzFka1T1PtmbU2qn2eamctj2qfp9pZK6Ta56l21iKp9nGqfV9dWuOyHFS7UO1Uu9Vq32f5q9pro3GSbwLJH//+tdrJZKj2Yap9zbdqT/lrtRcyGap9nmonk6Ha56l2MhmqfZ5q5xlIqv1t1b7e/XYmHlUjzyhSjXaqkWcIqUY71cgzflSjnWok76UarVTjZf2NaqQazVQjeSnVaKcayTOpRjvVyDNgVOO7qjHvvC//XtNBNQrVSDWaqUbWYqhGO9XIWgzVaKcaWYuhGu1UI+k31fiuaiy3X6bEEuVrNTrSb6rRTjWS8FCNb6vGeLtTl1QOqpGnJqjGN1Vj8m5/T+vl3+vXavSsDFKNb6vGNdyqMS8H1cjKINV4uhr9mvZqzOlPHH2tRbpGatFKLQq1SC2+pRZdjrdfdF3+feCnPauCVKOdamRVkGq0U42sClKNdqqRrJFqtFONrFFTjWaqMbBGTTXaqUbWYahGO9XIOgzVaKcaWYmhGt9VjcndhE+rO6hGoRqpRjPVyFoM1WinGlmLoRrtVCNrMVSjnWpkLYZqtFONrMVQjWaqUViLoRrtVCNrMVSjnWoUqpFqfFM15mV/Y2rO7uAXWoKnphrfVY3l7tpYwtG1EU9toxqTyF6N8vnoq1DYzT6EWnFinQiFSelEKJ6l6kQoHjPqRChBKBtCpZsHSe5AKB5O6UQontvoRCjil06EIpnoRCiSiT6EivgoI0KVW3te4oFQdH02hMqyZfM+r+FAKLq+ToSi62si1BUmnVlDmHRP7WAm1l4awmR9pCFMeu+GMFln+DbM4vfnkXwpqdJIxeW2HfWdMcnyAV4ArwMeR6gEHoenBB7HpgQed6cDPtNvvwr8/jhEvPt9wA28AP5F4OPtOeh8AJ6u5rvgQ0h+ZyKrr4B3l8Hse0K5nG6/Q4iHCxLL9sd98v7u2KtM9EBdyETH1IVM9FcKMl3Rk7VroS8k82ro8RVq6En91dCzRqCGXkD/MvT7j5adK4t72ogWl7aRF3f3Y+FNJtx3FzLhvruQCW/RgUwXa45MJmTye0hSvM9fZKJ760ImQaYeZKLTayLTFSb9WEOYrFk0hMnKQkOY9PPtYDrS/4YwyfO/DXN1N5jrXVJ5g4kfbAgT19YQpgCzHUwcUEOYOKCGMHFADWHigBrCxAG1g+lxQA1h4oAawsQBNYSJA/o2zFj2BY5fCdEnmAd/3Zft11MhuNs7rj+WOLwAXgc8zkoJPC7sVeAvx+/gPz1C8vVYcbtI4t2Xx0087q4DkXCN50TyRx0QrvH7MHO5g/l1I8gUcI3fhpmCu8Fc3Z+7uQYcphJ43KgSeJzrq8C361SCIJJ9kXDE50SK7qADwuX+oJ3MdzAPnhwKuNHvwpQl7eMWJ39ua6cUcJhK4HGjOuAF56oEHueqBB7nqgSefvtV4J/um5h4d/jLwD/dNzHxLvDvgw9hX7CQ8IeXLX093qe0/fXLP/MfrT3v9tYCT1ejBJ6u5kXgXYphn2eK8hU9ibwaegG9Fnq6eTX0ZO1q6OnoX4Y+3XYrvPy7/BE9b8V9IfqUb+hz/IKeDufb6OWGUlYvn9BfYQow28GkC2kIk76iIUzW8BvCJMFuCJMeth1M3mTcEibpcUOY+KVvw4yy/8BDYg7/VfFLT4+/wscxKcIX4OvBx5G9CP4FxDZwH5a7RxNy/kCPf1NDj9tTQ483VEOPk3wHeue/os/4TjX0uFQ19HjaV6EPe57gQ1k/oT84+umrc1PG/XYhkyBTDzLhqBVkuqLHUauhx1GrocdRq6HHUWuh5833euhx1K9Cv8o2Tb/e79uyo8dRq6HHJauhF9BroaevV0KfFzqcF6G/rI75/a/fH72jp8NRQz9zhxNkRx9SrBxd4jZHtyy3GNJn/0Fy5oalLUmBZCOSM4fjPyJ5t4v5r71P7y6rywfKmcPuxihnbnIbo5w5jG6McuZwuS3KqV+U3hjlzNaoMUqsTjOUeJ1mKAWUrVDidpqhxO00Q4nbaYYSt9MMJW6nFcqpX4reGCVupxlK3E4zlLidZigFlK1Q4naaocTtNEOJ22mGErfzTZSyuG1zXHEiByhxO61QTv0y78YocTvfRelS2VGW5RPKg7/99B3ReeqXcytix0WpYBewvwR7s1dt56lftd2JRDjE70rkw971+Ls3cR1LJLlsf1uK95Wj17T96bXc4ft4lH3q94L3ohGe1r5GmGXzGk39YvJeNMLev0ajst40iuVrrjL1O8xVwWPxXwS+7BeaxR8kiSKAfxF4v4OXfAAe6/4q8PuwlzUegMeQK4HHZSuBxzp/F3zYdwyV8AeUPzv6Ch4/rAN+xeQqgce5vgS8k7Tv17C6+91YjsYdl21FIvq7v5zlQyRcbgci4Yg7EEkQyb5IOO0ORMKVdyASfsaCSLIdHFf3VaRId2dBpLj96RjzgUh0d68RaXX7JNcgn0S6ghfA64CnC1MCT2elBJ71jhfdiPdhX8CvlRvxZbBZbgMvXx7QjayOdCET3qMHmRIrL13IxDpNFzJN7eXzdnQQv346+gpnZkeR9wcqQ1nkAM7EXY24/WhxJX6FM/Obxi8XqP3ZouSWAzgTX3PqcCbO7epwZGI46fbIXl6WytF5n2MOtyn+evnG12PLfhss5fOxV+gT3wX1oE+cqelBnzhP04M+cx+pBn3irEsN+szvqdaDPrMTU4M+s8NTgz6zc1SDLkB/P3QcqQJ0HKkCdBypAnQc6SugV94HXLCk76deFjypBnVMqQZ1XKkGdWypBvWZLVLl6YyyzGxlqnBmthxVODNbA79PUrzkAzgzd/A1ODO/d74OZ+Z+uApn5ra1Cmfm7rIKRyaGE9Zt2CJ3HfLx0THu2xLkW5vu/fIBcuZuuinImTvvpiBn7tKfPCZ84JT3XdOdK3d/et1IztzSNyU59cvGKz+XKVO/PrwKZ+ZfoVXhzLyTS9m3QLjMsXa0S9s90y+3Y48D1HbrxWXqF4d3IdDMv+PsQqCZd5CxIVBlPWnqd6f3odDMu8z0odDMG8x0odDUL5DvQ6GZbXQfCs3s5cu+g6s4qeVpPoVt4x+f7t8YvcRDjdYtq7uglE9HX8FPnRNoghfA64Cf2te/ELzbNwDP3sUD8FP7dU3wU9twTfBTu2tN8FObZkXwU7/GXRX81BZXEzzOVQk8zlUJvABeBzzOVQk8zlUJPM5VCTzOVQk8zlUH/NTvZlcFj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3N9Dfi4TzKn7A/A41yVwONcdcBHnOtrwF+gbeBLdgfgca5K4HGuSuBxrkrgBfA64HGuSuBxrkrgca5K4HGuSuBxrjrgE85VCTzOVQk8zvUl4Mvil4+jyxLWA/A4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wGeeqBB7n+iLwqWzg3VIOwONclcDjXJXAC+B1wONclcDjXJXA41yVwONclcDjXHXAF5yrEnic6zfBh9sLdYPPsQLepdtIUpT7YV+5Y1x1uONbdbgL3FW441p1uGNadbjjWXW4Y1l1uONYX8P9cgXfbNayVIYdl2VbH4yL+6NIcvmviKQu0lp2K3wsEk74RSLtL4X1S/DPhy07bPF3PyoP5fDSWNzt2lj8bdi+pA9NcdnjaYqDH09TQdPhNCV5GE9TUo3xNCUxGU9T0pjxNCXpGU5TRzA0nqbkSONpSo40nqbkSONpKmg6nKbkSONpSo40nqbkSONpSo40nqbkSMNp6smRxtOUHGk8TcmRxtOUHGk8TQVNh9OUHGk8TcmRxtOUHGk8TcmRxtOUHGk4TQM50niakiONpyk50niakiONp6mg6XCakiONpyk50niakiONpyk50niakiMNp6mQI42nKTnSeJqSI42nKTnSeJoKmg6nKTnSeJqSI42nKTnSeJqSI42nKTnScJqu5EjjaUqONJ6m5EjjaUqONJ6mgqbDaUqONJ6m5EjjaUqONJ6m5EjjaUqONJymkRxpPE3JkQxoGrYXH0rKnzS9akQuZF8jcp6XaOTdPknv7kayvW8yCtxVuJOX6HAn09DhTu7wIu4h7NxLadj7hpK3KYpz+9Fhv2OTOoymKJnDYIomEofRFCVvGE1R0onRFCXLGE1RQdHBFCV/MaDo80w4kdXY12jmFCDknbr49dPRVzgzG+oanDyzN63CmdnmSbjBSbFytEvbjf6yBrkf67M/ODbvPHIolWPLrlApn4+9CjSza+tCoJlNWBcCCQIpCxS3Y92y+AOFZvZIfSg0s0PqQ6GZ1737UGhmB9uHQjPb6C4UKjN7+ScKXeHg5Z/AwUc/gTO1h83bJEMWV7vw+bxfoUKQu6MPkVwytx28xE9HX8EL4HXAT205NcFP7SRfCH7df0EW1rwcgJ/aIGqCn9r3aYKf2s7pgb9YN8DrgJ/aAWqCn9pdaoLHuSqBF8DrgMe5KoHHuSqBx7kqgce5KoHHueqAdzhXJfA4VyXwOFcl8DhXJfACeB3wOFcl8DhXJfA4VyXwONfXgC9h/238ZWH7ADzOVQe8x7kqgce5vgS8+Bt4v/oD8DhXJfA4VyXwAngd8DhXJfA4VyXwOFcl8DhXJfA4Vx3wAef6IvCpbODDH8D/7OirTPjcLmTCFXchEx7agExO9s0v3eruxp2PZhmXbdOD6O9+2ZjlQ1JB0tEkxfcPJymJwnCSklUMJykpyGiSCv6xP0llOziu7kBSQdLuJI1+kzTmA0npeC1IurodyXr/t/P6IRNdbBcy0Zl2IRPdZhcysUJnot3YJ3mRaa20G5ep3YZSfEn78fEq6srq34Ci4vUGFJWVxQFFZR1yQFEFUb8pariBj0uoyfTk6Ct40hMl8OQhSuBJOF4C3vtlex2ql3DwANFKZqEEnhRCB3wkKVACj5tXAo/jVgKPK1YCL4DXAY9zVQKPc1UCj3NVAo9zVQKPc9UBn3CuSuBxrkrgca5K4HGuSuAF8Drgca5K4HGurwG/+u1ovx7tHZBwrq8BL6Hs4ONSOTrv/HK44fPZHxxb8jbFUj4fexUURzyYoDjtsQTNOPjBBCUZGExQEofBBCXJGExQQdCxBCV5GUxQEp3BBCUpGkxQkqLBBCUpGkvQQlI0mKAkRb0JGvdfRy+LP1CUqGg0RcmKRlNUUHQwRUmLRlOUuGg0RXGjr1F0jWlXtNQ3QixL2P74Wu629L3u7+OXadqd63RlrumOdaMsYa/lIlL50z7FbSA+pXD/p69sxrrltGUzVtjfls1YuXlbNmPd9JuycWOluW3ZjBWMtmUzVsTYls1Y3esP2ZTt9Rs+O/nKRmDzkM3UfXGFzcR9cbh0MLdhp69sJu6Lq2wm7ourbCbui2ts/MR9cbj9MPaYzcT9zSUV3f50uDjLr2wENg/ZTNzfVNnM3N/U2Mzc34SSdzZuef6n17K/k2Et5eDCPXMz9BOQcdnvgHE5cCN+5s7pZEUeggwzt1m3VfAgd2+fPfXVDhNnlWdBHlfkxMFmkBR3kCV/ZTN1419hI7B5yGbqxr/CZurG/8ZmvXtca2czc+NfYzNzL19jM3N7XmEjM3fcwe9PQK4uVf50zJsHdEnuHmkM5YPkzJ1iyntkk0r4c95FZm4rfwKyFkuIAPKnFXkMcuaG9fanwx9W4g/+9FL2P+3CcnCRnLm9zX4fdi6VPy07kEu8+InjwTBuEZy7ZOf70WGnPnPjrEd95pZcj/rMzb4a9XVmG6FHfeaUX4/6zEZPj/rMrvBH1MNmCiXlrx34KnBswpEfg1852v7p8MqOgF3IxD5/XcjEfgk2ZApyk+nulTnxwdH+7uj4R1EjO/gNKCq7+A0oKhv5dSequN3Y/vpp3hdJ2clvOEkFSUeTlL38hpOU/GY4Scl6hpOUXGg4ScmQRpM0kSANJyn50XCSkh4NJynp0XCSCpLakPRRFH/wt3PYf2Tl7rR58LfLPsuL/nezXN1HCZA2TV8CpFNDlcBVVPKpAUUloTIu6m+ZMn72uzL5vDezIUgF/OULsP10UsJalUnSrVG+e7zsMp+Do6NsB8e7bXxclg9J8bP9SZo2fvHXf/8iKX52OEkFSUeTFH86nKT4zQ4ldbuk8UBS3OZwkuI1h5OUpyH6kzRuUUOM+aukhachhpOU9Gg4SUmPhpOU9Gg4SQVJR5OU9Gg4SUmPhpN0Zl8aZJc0pFg5WsLibyLdHf3rZTh/VqSnK6Bhmdlp2hHpabQelpm9YzcizewGuxFpZn/XjUiCSBZEerbqEJaZPVg3Is3sqroRaeZVdjsiPTWzYZl53bwbkUgc7IvkSBw6EInEoQORSBw6EInEoQORBJHsizSzT1rCLtJSagNxEmVb9bv8O9/99V/vRflyvF/ztp/E5Z93UHL+QD+z+1FGP7On0UXvZ3Yqyuhn9h/K6Gd2FcroZ/YKr0Wf9u21fJLlAL2AXgv9zCuJyuhnXh9URo+b1UIf6OtfhT6WbeCXf4YD9HQ4r0Kf83a4L8t6gF5A/xr0l0j09tf9QV8f6HDU0NPhqKGnw3kZ+uT3v54/32Z/dvRVKNL9ToRiLcCEUDGv+4+q8t3ey9eNQoPgL7qQiTWGLmRiPcKGTGWHEotPX2TC2XchkyBTDzKRGHQhE+lCFzKRRHQhEzlEFzKRQhiR6ba1S1m/yLSSQnQhEylEFzKRQnQhEylEFzIJMvUgEymEgkxX9HihF6GvPqO24m+00Ec8ixp6fMir0H96HlkO0OMt1NDjF9TQC+i10NPXvwy9v6EPNfsVfNl+EBqCkz/ar8jqYhcysbrYhUw4ahsyhVh2mfJ95vSTY6+S4tRHkzSRAAwnKclCd5KK2++l4t1XSUkshpOUJGQ4SQVJ3y/pFT0Jy8vQx7SjT/kAPanJy9DnfQ0plYNffCeSkHdU/SF60g019KQQWugzPuRV6PO6TfPyzyP0+AU19AJ6LfT09Wro6etfhl78c/R0OC9DX9m1r7AeooaedQs19PT1augF9Froic++jT6EZUd/gVJB71Jaw3b85d83LB9LJYX4TA09zaUSelloLl+HPuUb+rvXfm/oaS7V0NNcqqEnNFZDL6DXQk9orIae0FgNPW5WDT1uVgu9o6//Nvol7eMWJ6mCPt62qlndXXgmH+Dp6l8Ffj865vUAPD29EngBvA54+nkl8HTzLwPvdvDxADy9vBJ4Onkl8KxKvQp83B42izF/Be9Zk1ICj3NVAo9zVQKPc1UCL4DXAY9zVQKPc1UCj3PVAR/o478LPoR9M3gXZPUV8M7lvK9ZubLcvzH169HFpW3kxX3ZnEkCXX8XMuERbMjk3QaleP9VJhxFFzIJMvUgE26lC5nwNkZkCm6XKXz5sUfACXUhEyt+XcjE+mAPMgkpRBcykUJ0IRMphBGZFn9ryPMXmUghupBJkKkHmUghupCJFKILmUghupCJFKILmUghepBpJYXoQiZSiC5kEmT6pky++H2HQl/Kn/yJ9YoTehX45797XPE2SuBxK0rg8R9K4HEULwP/9AenEY+gBJ6uXwk8q4mvAv/8pxmR9UEl8AJ4HfA4VyXwOFcl8DhXJfA4VyXwOFcd8Ik+/tvg4+J28Ol+4IfgL3/S7VDiWjnap3J7Kf0fdrK9CkXfb0Oo7LfFMJ9DPhBKEKoPofAVnQiFDzEi1A7cZ5cOhMK3dCIUPqcTofBFfQiVWQHsRChWDDsRimSiE6FIJjoRShCqD6FIJjoRimTCiFD7Lxou/zyIkDLJRCdCkUx0IhTJRB9CFZIJI0LtI78IVQ6EIpnoRCiSiU6EIpkwIpTkXag1HAglCNWHUCQTnQhFMtGJUCQTnQhFMtGJUCQTXQi1LiQTnQiFj7IhVNw3Yrr87VI7WkLYjr4s0leOjnL7nchtpSvEo1mWvNWLW+6GcXxw9OsGMPpc+9O/9praf96Ss1s+HX+tRqEaqcZ3VaPchL+/Nt6qEUdMNdqpRmw/1WinGsk2qEaVaoz+oBoJcKjG91Wj3KoxrbW/Xnbesdw/aHh0cPb7387+rtDdVufkX9T5BHXuiA+p8xnqnOfCqPMZ6pzH6qjzGeqc1TTqfIY6F+qcOp+gzlkBpM5nqHPWFqnzd9V58TvAy7/jp+Ov1UjKTTW+7apbbs+kleXgmTRPdkE1vu3a6G7Cl+AOqpGOlGq0c22kb6QaVfrGcFSNPJNGNdqpRp5JoxrtVCOemmo0U42B57uoxrdVY7jl6kXkoBp5CotqtFON5I1Uo51q5IkmqtFONQrVSDWaqUbWYqhGO9XIWgzV+LZqrK1TB9ZiqEY71chaDNVopxpZi6EazVSjsBZDNdqpRtZiqEY71chaDNVopxpZi6Ea7VSjUI1Uo5lqJG+kGk9Xo9uPvhTmUqvG5MP+x9NlCgfVSN5INdqpRvJGqvFt1RjDrRpT+VqNK3kj1WinGskbqUY71UjeSDXaqUbyRqrxXdUYll2ddCmUg2oUqpFqNFONPPtNNdqpRp79phrfVo1yV43relCNrMVQjXaqkbUYqtFONbIWQzWaqcbIWgzVaKcaWYuhGu1UI2sxVKOdamQthmp8WzWG+2o8eENHFKqRajRTjazFUI12qpG1GKrxbdW4z/HXvw+e4YmsxVCNdqqRtRiq0U41shZDNZqpxsRaDNVopxpZi6Ea7VQjazFUo51qZC2GanxbNaa7aiwH79JKQjVSjWaqkbUYqtFONbIWQzW+qxrF7W/oSOIP9uFJrMVQjXaqkbUYqtFONbIWQzWaqcbMWgzVaKcaWYuhGu1UI2sxVKOdamQthmp8WzUu99V48A7WLFQj1WimGlmLoRrtVCNrMVTju6rR59vethLW2vES3H68HO6wl1m7oXrNVm9Yb9W7uurxed0HLznlg2pnbYhqN1vtq9yqPR5lAqwlUb1dXKuPqrew9kT19lu9rFVRvf1WL2tbVG+/1ctaGNVrtnpTvFVv8X8+oyhCtVPtVqu93K7VshyshhTW5qjeHq7Vx9XLWh7V22/1spZH9fZbvazNUb39Vi9rc1Sv1eoVl27VG8Kfzijiwloe1W622sPdtVrWg+plLY/q7eJafVi9rOVRvf1WL2t5VG+/1StUL9XbbfWyNkf1WqjeazWy1kY12qlG1s6oRjvVyFoY1fi2alxv1ejzclCNrG39K9VopRoda09Uo51qZC2JarRTjawNUY12qpG1HqrRTjUK1Ug1mqlG1mKoRjvVyFoM1WinGskbqcY3VWMscS+qWFL5Wo2evJFqfNe1cbkJf/l3PKhG8kaq0U41kjdSjXaqkbyRanxb31iWu2r0B9UoVCPVaKYayRupRjvVSN5INdqpRp79phrtVCPPflONdqqRtRiq0Uw1BtZiqEY71chaDNVopxqFaqQaT1bjeqmNTRuXpXJ0krj97cs/D56ZCKSN1KKVWiRrpBat1CJJI7X4plqMbtM9XRLug1okZ6QWrdQiKSO1aKQWhYyRWrRSiySM1KKVWhRqkVp8Ty2ueauStJaDrFvw0dTim2oxlW3QKQd3UIv4aGrRSi3io6lFI7W44qOpRSu1iI+mFq3UIr+ZphbfVIt5dXstxnBQi/ximlq0UotCLVKLRmqR5xepRSu1yPOL1KKVWmTdhVq0Uousu1CLVmqRdRdq0UgtRtZdqEUrtUi+SC2+qRbvn188WneJQi1Si0ZqkXyRWrRSi+SL1KKVWiRfpBbfVYtxf04npvy1FhPP6VCLb6rFtPNLyclBLeKjqUUrtSjUIrVopBbx0dTiu/rFkm61uB7UIj6aWrRSi/hoatFILWbWo6nFd/WL+6ulL/886BczvwOkFt9Vi3e/A3ShcrSTvO5DkXyUR2bySGr3TbWbXdxr92idJpNHUosK19HDWhRqkVo0UovkkdSilVokj6QWrdQieSS1aKUW+d0gtWikFgt5ZI+16GVD6H1aPh19lZWorkdZg9/+tg8SDmQl9RpSVkHWEWUli+ny3ppvsv5hJFdZiTWGlJWEYEhZMdtDysp+NwPKmhYe1RtSVlKmIWUlZRpSVlKmIWXFt35b1mW9yfp7ahX0S97jeH8Xx+f0gR5vqYYe/6eGHo/2MvSyr0X7NXxCfzAWXzahQrj7EXO8yuTwXF3IhIeyIVOIZZcppzuZfnLsVVL803CS4p2Gk1SQtDdJxe33UvHuq6SszA8nKenGcJKSmrxK0nB7fjSkpSLpmjb913IHMH+oRMDSg0pkMR2o5IlielCJJKYHlQhXXqWS3FYa5f6vH6oUy75EGstdk+eOhpK9bLyzj/6rqMQrA4oqiDqeqEQsA4pKyDKgqMQsA4pKKjOgqIQ444ka8KmvEnX1+8LF6tdPol7R06O+DL3sjy6v68GzgYH708vQ74f7NeYD9NxFtNAL+b4aekJ7hWv9iTuD0A91IhRZvAmhYl43hDGn2x5vH0/RiCBTDzLhRbqQiQTchkxlhxKL//LooJBpdyETKUAXMpEY9CDTSrrQhUwkEV3IRA7RhUykEEZk2pc5Y1m/yiTI1INMpBBdyEQK0YVMpBBdyEQK0YVMpBAKMv1GH/FC30Xvkt//uCtL7T1R7pKubYev7v7H9Ucjj7cvyOrujpUPmfBCNmRKu2PN64FMgkw9yIQX6kImvFAXMuGFjMi0/3QhxwOZ8EJdyIQX6kGmxIqsDZni7W28+UAmVmS7kIkUoguZSCG6kEmQqQeZSCG6kIkUoguZSCF6kClP7Jt8uW2gvLilJlPL9aM8sQ96Kfbn0Wie2NdoYp/Yp2hiF7BrYJ/YR7wW+9MEOE/sCzSxT9zna2KfePXwpdgrdmni1UBF7AWXqoIdl6qCHZeqgh2XqoJdwK6BHZeqgP1C4BB72t/vfhf/++wPPiDvyHMolWNL3qiU8vnY62CipcEkS4PJlgZTDA3mwTvslQbjLA3GWxpMsDQYsTQYS1dgZ+kK7N57BY77XXVZ/MFosqnRFEuj8Yup0ThTo/GmRnN8tZFS9pZy9c9720ubtg1H7lrsy9CunxBf/gnp5Z+QX/4J5dWfEJaXf4L785+wbg4sp/jpEw5c0lI2K+PdcjtaDr8zeXsBSHG+9ocvxnL7w7LcVlDDPlE/y0TDLBOVWSZav96nTxO9nhVPnZXOnCXu1dcp8S//hPDyT5CXf8LLOwN5eWcgaZKvteRZJlommei6zDJRd+YusfpTZ4VTZx1eRdLu2FJOd9PKHyflMyeVykklfD0pLmdOcidOOv51bPBlOysEd9thKn6c5M+cFM6cdHhPDOG2mBLy/V5if/3BsdcPWF/9AfHVH5D+7AeI2zUQ775+QH71B5QXf8Dxc5o+pW3d8fLP/OWkdOakfOakBzfAn6wBXo74OHi9XxTd1gAfPM3U9CPc6z/Cv/4jQtOPkOXgI+T1H7G+/iPi6z8i/fmPiMt2YYg+HnxEfv1HlFd/RFmW13+Ee/1H+Nd/RHj9R8jrP2J9/UfE139Eev1H5Nd/xOu/3e713273+m+3e/23273+2+1afC+e/k63uBYV9fSJsPJgLXd1+7Nya5BPH3E9zZ07zZ87LZw77cH1d3+y73LaWsHnis877eLLHw1FebTE2vZD4js+JL3jQ/IbPiS4l381Q4tr2NNfcpYQXv8R8vqPWF//EfH1H5Fe/xH59R/R4n7y9JeBRZbXf4R7/Uf4l994Jbz+I+T1H7G+/iPi6z8ivf4j8us/4vXd4rq8/iMOi3Zdt9R0zfednvs4aT1zUjxz0nGpLGmf1a9/lz92JA9ePbOksrewS3bxy2nl1GnHa0b109y5044vlksO4Xba3dtGttPCudPk3GnrudMe6FZu711ZLtz+eNqDjWaXkrf3rzi3LF9IPtj4tHpaOHfaem5u8dxpD744pYS7Qa5fTsvnTiunTnuwH1n1NHfuNH/utHDutOMvzuXQcjvN31fJX39eUw92n2n8IfEdH5L+/Ic8X4ssD3bRaPoR5eUf8WA98clHXE9z507z5047d4l8sD5XPW09d1o8d1o6d1o+d1o5cdq6LMu509y50/y50x78HmrdL6wp3f9e96i99WnZH7VK3n/5iPT6j8iv/4jy8o949EvPlh/hXv8R/vUfEV7/EfL6j1hf/xGv/3a713+73eu/3e71327/+m+3f/2327/+2+1f/+32r/92+9d/u/2Pv93X09K50/K508qp08Jy7jR37jR/7rRw7jQ5d9p67rRzVRLOVUk4VyXhXJXIuSqRc1Ui56pEzlWJnKsSOVclcq5K5FyVyLkqkXNVsp6rkvVclaznqmQ9VyXruSpZz1XJeq5K1nNVsp6rkvVclcRzVRLPVUk8VyXxXJXEc1USz1VJPFcl8VyVxHNVEs9VSTpXJelclaRzVZLOVUk6VyXpXJWkc1WSzlVJOlcl6VyV5HNVks9VST5XJflcleRzVZLPVUk+VyX5XJXkc1WSz1VJOVcl5VyVlHNVUs5VSTlXJeVclZRzVVLOVUk5VyXlVJW4ZTl3mjt3mj93Wjh3mpw7bT13Wjx3Wjp3Wj532rkqceeqxJ2rEneuSty5KnHnqsSdqxJ3rkrcuSpx56rEnasSf65K/Lkq8eeqxJ+rEn+uSvy5KjmXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as7l726c9mrO5e9unPZqzuXvbpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736c9mrP5e9+nPZqz+Xvfpz2as/l736B9lrWfYfcRZxB6c9qJJ9S7/LV8t/Ou1oT+NGb0y5DGe1NZxoazjJ1nCyreEUU8N5lMVrDcfZGo63NZxgazi2rsre1lXZ27oqe1tXZW/rquxtXZWDratysHVVDu++Kj992ddlPMHYeMTYeFZj44nGxpOMjed4A/VLOPlx2qVNWyvjuWT5tzdKx/TH3QsuH1Le8CHHq8OtP8Q1+ZAQbx8Sw92HHPwiL4dtY6Cw3O/7tBxvp7rse64t4e7V3u5j/N74+Nedf1xD+Dr+0Pn4pfPxr52PP3Y+/tT5+HPn4y99j39dOh+/9ftvbfyd33/Xzu+/a+f337Xz++/a+f137fz+u3Z+/107v//Gzu+/sfP7b+z8/hs7v//Gzu+/sfP7b+z8/hs7v//Gzu+/sfP7b+r8/ps6v/+mzu+/qfP7b+r8/ps6v/+mzu+/qfP7b+r8/ps6v//mzu+/ufP7b+78/ps7v//mzu+/ufP7b+78/ps7v//mzu+/ufP7b+n8/ls6v/+Wzu+/pfP7b+n8/ls6v/+Wzu+/pfP7b+n8/lv6vv+Gpe/7b1j6vv+Gpe/7b1j6vv+Gpe/7b1j6vv+Gpe/7b1j6vv+Gpe/7b1g6v/+6zu+/rvP7r+v8/us6v/+6zu+/rvP7r+v8/us6v/+6zu+/rvP7r+/8/us7v//6zu+/vvP7r+/8/us7v//6zu+/vvP7r+/8/us7v/+Gzu+/ofP7b+j8/hs6v/+Gzu+/ofP7b+j8/hs6v/+Gzu+/ofP7r3R+/zW//1Vt/J3ffzvf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/yp0vv9V6Hz/q9D5/leh8/2vQuf7X4XO978Kne9/FTrf/0o63/9KOt//Sjrf/0o63/9Klr7vv9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V9L5/lfS+f5X0vn+V2J+/6vbn47pMui78R8dvI065nj7w1k+5mr9Xt1yrtbv6y3nar0HaDlX6/1Cy7la7y0aztX6PmBrWfNtrv75XF0pvmwDKSXcBu5L+piv8b6l+XyN9znN52u8L2o+X5lsvsZ7qebzNd5PNZ+v8Z4qXaL/j6NTXOLz+YawHRvkbtD+iGNctyGvabk7OBwd7S8g9zEv+dPRV4zG27VeMBrvBDvBaH2zu14wGu9de8FovCXuBaPxTrsXjALGFhiN+4JeMBq3G71gxMU0wYiLaYIRF9MCo/UtQ3vBiItpghEX0wQjLqYJRgFjC4y4mCYYcTFNMOJimmDExTTBiItpgdH6xsu9YMTFNMGIi2mCERfTBKOAsQVGXEwTjLiYJhhxMU0w4mKaYMTFtMBoffv6XjDiYppgxMU0wYiLaYJRwNgCIy6mCUZcTBOMuJgmGHExTTDiYhpgXK2/BKQXjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYFhitv0qpF4y4mCYYcTFNMOJimmAUMLbAiItpghEX0wQjLqYJRlxME4y4mBYYrb+QrheMuJgmGHExTTDiYppgFDC2wIiLaYIRF9MEIy6mCUZcTBOMuJgWGK2/1rMXjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYFhitvxy5F4y4mCYYcTFNMOJimmAUMLbAiItpghEX0wQjLqYJRlxME4y4mBYYrb9avReMuJgmGHExTTDiYppgFDC2wIiLaYIRF9MEIy6mCUZcTBOMuJgWGCMupglGXEwTjLiYJhhxMU0wChhbYMTFNMGIi2mCERfTBCMupglGXEwLjAkX0wQjLqYJRlxME4y4mCYYBYwtMOJimmDExTTBiItpghEX0wQjLqYFxoyLaYIRF9MEIy6mCUZcTBOMAsYWGHExTTDiYppgxMU0wYiLaYIRF9MCY8HFNMGIi2mCERfTBCMupglGAWMLjLiYJhhxMU0w4mKaYMTFNMGIi2mAMS64mCYYcTFNMOJimmDExTTBKGBsgREX0wQjLqYJRlxME4y4mCYYcTEtMDpcTBOMuJgmGHExTTDiYppgFNsYL6scecOYXXmOcfVL2tj4Nd796aOjnfhtIE7S7eicjhRyedlG7crtYB+PRh0Wv2N3csMelnJwdHZRPo7O/k6kC6mDoyUt4eNoSb9KZPvb6/ohqXFHhaQ/l9S4u0PSn0tq3Gki6c8lNe56kfTnkhp34Ej6Y0m98TQASX8uqfFkAkl/LqnxlARJfy6p8cQGSX8uqSDpaJKSHg0nKenRcJKSHg0nKenRcJKSHn1PUnFlG7VkX5F0Xdy+ArpIug0kXqkHAh4N6mQwGtSJSTSok2RoUBeoK1AnD9CgjmXXoI6r1qCO8dWgjjdVoC54Uw3qQ3nTKDv1nEKFenZp+9P5U1p2SbSubIZykI3ZDOXzGrMR2DxkM5RnasxmKGfTmM1Q/qMxm6FcQmM2pnr530NaTTW61yGZ6gKvQzLVfF2HZKrnuQ5J7A3J1B3+OiRTN9brkEzdz65DMnUbuQ7J3tU72rt6R3tX72jv6m3rnffXIdm7ett6F/t1SPau3rbeEX4dkr2rt613V/8ekq33QF+HZO/qbev9xNch2bt623pv7nVI9q7ett7neh2Svau3rfeMXodk7+pt6/2X1yHZu3rbei/jdUj2rt623hd4HZK9q7et99hdh2Tv6m3r/WrXIdm7ett679d1SPau3rbeR3Udkr2rt633JF2HZO/qbev9Pdch2bt623qvzHVI5q7eydb7Tq5DMnf1Trbew3Edkrmrd1rMXb2TrXctXIdk7uqdbL0D4Dokc1fvZGtv+t9DsrXP+3VI9q7etvYfvw7J3tXb1r7Y1yHZu3rb2pf4OiR7V29b+8Jeh2Tv6m1rX87rkOxdvW3ti3gdkr2rt6196a5Dsnf1trUv2HVI9q7etvZlug7J3tXb1qY71yHZu3rb2q7lOiR7V29bG31ch2Tv6m1ri4jrkOxdvW1tLnAdkr2rt62fpV+HZO/qbeun0tch2bt62/ph8HVI9q7etn4Gex2Svau3rR99Xodk7+pt77eWyd5vLZO931ome7+1TPZ+a5ns/dYy2futZbL3W8tk77eWyd5vLZO931ome7+1TPZ+a5ns/dYy2futZbL3W8tk77eWyd5vLZO931ome7+1TI1+07RvpHf5t0t3Q/r9IT///c31NH/utHDuNDl32nrutHjutHTutHzutHLqtJ//huB62rkqKeeqpJyrknKuSsq5KinnqqScq5JyrkrKqSrJy3LuNHfuNH/utHDuNDl32nrutHjutHTutHzutHNV4s5ViTtXJe5clbhzVeLOVYk7VyXuXJW4c1XizlWJO1cl/lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJX4c1USzlVJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk4VyVyrkrkXJXIuSqRc1Ui56pEzlWJnKsSOVclcq5K5FyVrOeqZD1XJeu5Kjlen5G4n/bptX+30+T4NHc7zS//9TwTuLTAHwdfvof7sf7XVvhfji15CzRK+XzsdTirreFEW8NJtoaTbQ2nmBrO8VqJ3nCcreF4W8MJtoZj66ocbV2Vo62rcrR1VY7vvirvryF2y+IPxlNsjSctxsbjjI3HGxtPMDaeH1+br6et506Lp05rtDHf06W+3GirvcqH+Hd8SHjHh8g7PmR9x4e0eShB3O1D1nL3IT9bCb8OKdkbUrY3pPLuIYkr2/tgxH+tpEZb0DUckLM2oLc/TFa7Ab5/97nqiMTciFZzI4rmRpTMjSibG1ExNqLy/m3nqiNy5kZk7ZpdFmvX7LK8/Zrt12XZ/vYqpfa3y7r/6ZLd3QTCxwTW3icQe59A6n0CufcJlM4noLANX+MJuN4n4HufQOh9AtbvxBfHuR29hM8TOIh6Ky+gLc76fbvxdK3f5RtP13pP0Hi61juIxtO13m+0na633p00nq71XuaH090dcPZLPpiu9c6n8XSt90mNpytzTXewrqo23cG6qtp0B+uqatMdrKuqTXesrsq723TX2tGpyPaj+VSKrxwdVv9xsLi7BmY5Ota7cuO3lE9H/8YexuruusE+VpfZDfaxut1usI/VdXeDXcCugX0sF9IN9rHcUDfYx3Jl3WAfyx12gx2XqoFdcKkq2HGpKthxqSrYcakq2AXsGthxqSrYcakq2HGpKthxqSrYcaka2Fdcqgp2XOorsPtw4yf+ADsuVQU7LlUFO327CnY6mVdgT24D4lNYvmKPdDIq2OlkVLDTyahgp5NRwS5g18BO3q6Cnb5dBTt5uwp28nYV7KZes3mAxu+7dad0F6EWdzSQtGx/2qV4p2g4+tN5PzinUDnWB78d7EX+9C+1k6n3QE9D3dSrrqehbupt3tNQN/XC8mmoC9QVqJt67fw01ONI1KPft1tNKVZIhmVx+0ByfDP3BHcV7hnuKtwndqh5ixzcslSxu7hj9yH9Wex5YouqiX1ij6qJfWKTqol9YpeqiV3AroF9Yp+qiX1io3pjE7xPb+Y+sVFV5T6xUdXkXoxf3tey7hNYSrjnfh2/8etkdfzGrzfV8Rv/3sZ1f6tpXMPB+I0HNc/HH5fFeOJRHb/x6KA6fuMevDp+42a2On7pfPzG77/V8Ru//1bHb/z+Wx1/1/ffy/g7v/+6zu+/rvP7r+v8/us6v/8qvEeu7fg7v/+6zu+/rvP7r+v8/us6v//6zu+/vvP7r+/8/us7v/8qvHHsbH4Y092vhI5z81J82QZSSrgN3Jf0Md9+8uo28+0n324z337y8Pp8JZVtHJJDPpit8e6h8WyN9xptZxuMdyaNZ2u8j2k8W+NdT+PZGu+RGs9W+pnt/e9nto4wdNQhHY6/o47ncPwddTCH4++oJzkcf0ddxtH4paO+4XD8HXUCh+Pv6N5+OP6O7taH4zd+/02rbFuZpHj3WPBhtxHCdmyQu0H7Iy5x3Ya8puXu4HB0tL9Y6X3Md+93/nX0b4yr9Z9CmcAYlrIFEuETj8Oj0z7i23OXEj54W/8N1Gi8rf/4aTTe1n/1NBpvboPv5W39d06j8bb+A6fReFv/YdNovK3/oGk03tZ33BiMd8Rfvpc3/vK9vPGX7+WNv3wvb4H3W3njL9/LG3/5Xt74y/fyxl++lzf+8q28J94LfF22fadWWT4deyUjkHlAZt69ympkhtpOrCmZoTb8akpmqC25mpKZd3fnCpmJN2CukZl3j+QamXm3Ma6RmbgHjtsOimvJlWPFrxtG8Vk+mY4rx3nvZD9718pta8mQPm8teeXIe/eacCy8Sa8NR96N14Yjb7trw5H317XhKHBswpF3zLXhOG961pbjvFnbK995GG9v7b77JdiNOu5Hgzpe6f3UnfXt0Aeljg/ToI5r06COx9OgLlBXoI5/fAF1727U19rRqcj2t1O529vq+Oiwbk9Uibt72dNydKx35SbjHbxfR1/Vx/XOrD5efWb1yQxmVp/sYmL1rb/SBvVfqj5ZzszqkynNrD7Z1szqC+pPrD5Z38zqk/XNrD5Z38zqk/XNrD5Z38TqW399Juq/VH2yvpnVJ+ubWX2yvpnVF9SfWH2yvpnVJ+ubWX2yvoHV9+Emo/gD9cn6ZlafrG9i9a2/tBz1X6o+Pf/A6ie3wfMpLAfq0/PPrD49/8zq0/PPrD49/8TqC+v7M6vP+v7M6uP3Z1af9f2Z1RfUn1j9ebO+4rc5lnWtHLsuaX/JgFvua8V/cJw3NWvLcd78qS3HeZOcthwnzkTy9qoUt9y9JfIBSOduINf4FeQ6cbzQFuTETr0tyIlNb1uQE/vHtiAFkG1ATvwEQ1uQEz8M0BbkxOvqbUFOvET9E5De3d6w4sPnN6wc/Ona/s4rPkgDe8Q1qWDHY6lgx5GpYMe/qWAXsGtgxxuqYMdJvgJ7L78ljfjfqeXHtU8tP+nBzPInUoyp5SdNmVp+Up2p5Sddmlp+Qf6Z5Sdtm1p+Ur+p5Sf1m1p+Ur+p5Sf1m1n+TOo3tfykflPLT+o3tfykflPLL8g/s/ykflPLT+o3tfykflPLT+o3svy13eMzqd/M8hdSv6nlx/dPLT+d/8jy13aTLHT+U8tP5z+1/HT+E8vvFzr/qeVnvX9q+Vnvn1p+fP/U8gvyzyw/6/1Tyz+U749edvlTVdGybEf7sobK0bIsW7XIIveldd3d1LuhbqM/IhmWxe0DyVXu4fZNCunzN+lKcqg7kirJoS7uqiSHWh1RJTnUQoMqyXnv3a1JDhV/a5L0QyXJqiSHCmVVSQ6Vb76U5I9elFnZN/Zik+Guwl3grsIdt6XDHW+mwx0np8Md36fDHZeowj3gKV/CvZNfpfmAE55bf/z73PqTI8ytv6D/1PqTq8ytP/nO3PqTM82tP3nX3PqTu02tv5D/za0/+d/c+pP/za0/+d/c+gv6T60/+d/c+pP/za0/+d/c+pP/za0/+d/U+q/kf3PrT/43t/7kf0PrX9mZ2q/kf3PrL+g/tf74/6n1j/T/Q+tf26Mu0v/PrT/9/9z60//Prb+g/9T6s/4/t/6s/8+tP/5/bv1Z/59bf9b/p9Y/TZz/uSVvA3FrqhwtqWwDkSzL3dEf7yhIEydpjUlOnEk1JjlxutOYpExMMu0kva+RXN1+51vdGg9ITpw4NCY5sXdvTHJiF9yY5MR+sjHJiZ1ZW5J5Zo/TluTMHqctyZk9TluSM3ucn5D84Vs2aztHZ4G7Cnf8kw533JYOd7yZDnecnA53fJ8K94JL1OGOp3wJ915+gVpwwnPrj3+fW39B/6n1J8+YW39ylbn1J9+ZW39yprn1J++aWf+wkLvNrT/539z6k//NrT/539z6C/pPrT/539z6k//NrT/539z6k//NrT/539T6O/K/ufUn/5tbf/K/ufUn/xta/8oO9MEJ+k+tP/nf3Prj/6fW39P/D61/ZQfKy8TRf2r96f/n1l/Qf2r96f/n1p/1/7n1Z/1/bv3x/3Prz/r/1PoH1v/n1t+4/1/LuomUsqvov/olfRy8+vvdSpfDaglhO9qFfNMop4ODJWx6Sr7jIeUDo4CxBUbjbrQXjMZNXS8YjXujXjAatxi9YDTeqVvBuK7bDNd4gFGMN7y9YDS+bmwGY1q2v5zKAUbjy6+9YMTFfA9j2W4xcQkHGAWMLTDiYn6K0bkDjLiYJhhxMd/CGNMGJOblACMupglGXMz3MOZt0LHIV4wrLqYJRlzMtzBeVl62Ybh8gBEX0wQjLuanGH08wChgbIERF9MEIy7mexjLNui8HN2pcTFNMOJivoUx71/qfHinxsW0wBhxMd/DGMKG8e43fDeMuJgmGHExP8W4HiQ8ERfTBKOA8TsYi9uOLUftd8TFNMGIi/kexv3n9kUO1mIiLqYJRlzM9zDuz/CUePSlxsW0wJhwMT/FmA6iiYSLaYIRF/MtjJfRbY+UuSUeNOAJH9MIpMwLUvw2ECd3P0g7BBlc3kAGV+5+2RWPRh2WeJvj3TOR4deP5L4enZbtIaGLHu7T0VeRJvZJ/Yg0sQvrR6SJPV4/Ik3sIPsRaWJ/2o1IeWL3249IE3vrfkSa2Ln3I9LEqUA/Igki2ReJxKEDkUgcOhCJxKEDkUgcOhCJxMG+SIXEoQORSBw6EInEoQORSBw6EEkQyb5IJA4diETi0IFIJA4diETi0IFIJA7mRZKFxKEDkUgcOhCJxKEDkUgcXiKS9/vRkisiZRdvL5BZbkcfvxJG0rL9mFySu+1tENb1Q1JB0tEkJc0YTlKyj+EkJSkZTlJyldEkdXjH7iTdNzq8/DMeSCpI2pmkeZ+kXA4/kJSOV19SKy82deWm+t17YbcXm17+AsVCsXy3WOjSKZZvFwv9P8Xy7WJhfZdi+W6xeNaZKZZvFwuZBcXy7WJh3Z1i+XaxsP5PsXy7WIRioVi+WywkuBTLt4uFBJdi+XaxkOBSLN8uFhJciuXbxUKCS7F8t1gCCS7F8u1iIcGlWL5dLCS4FMu3i4UEl2L5drEIxUKxfLdYSHAplm8XCwkuxfLtYiHBpVg2ZXy4qS7+oFhIcCmWbxcLCS7F8t1iEXIWiuXbxYIbolg2ZZLbZPQpLAfFghuiWL5dLLghiuXbxYIboli+XSy4IYrlu8Wy8jwLxfLtYuF5Forl28VCzkKxfLtYeJ6FYvl2sQjFQrF8t1hIcL9XLGHZiyV4+VQsV5Ckm41Akvw1Akkq1ggkiVEbkJE0pRFIkoZGIHHhjUDiUBuBFEB+C6T3aQeZc8W9ZZe2UedPXi9/+KCID1LBjmtSwY7HUsGOI1PBjn/TwJ5weyrY8YYvwf74VS5X7DhJFez4ThXsAnYN7LhUFey4VBXsuFQV7LhUFey41Fdg72X7h4xbnlp+XPvU8pMeTC0/KcbU8gvyzyw/qc7U8pMuTS0/KdfU8pO2TS0/qd/M8hdSv6nlJ/WbWn5Sv6nlJ/WbWn5B/pnlJ/WbWn5Sv6nlJ/WbWn5Sv6nlJ/WbWP51IfWbWn5Sv5Hlr7w0ZV1I/aaWn9Rvavnx/VPLT+c/svyV7XZXR+c/tfx0/lPLT+c/tfx0/lPLL8g/s/ys908tP75/avlZ759aftb7p5af1O978kvY5ZfsKvIHtw8kOLnjdwTEJdlguxTvDj4aR5StruIa7g/9raYnxBtJTTK5vtTchYl3N4hdTSK2ztTcXoeSloPvJonZN9V05aamr6i5Lnu7si6S7tW8UheoK1AnH9KgTiyjQZ00RIM6IYQGdby/AvWAR9egjpfWoI7n1aCON9WgLlBXoI43fQF1KSXv1NfyX09TNVnLlmJLlOWrRBhZ8xLhes1LhEU2LxF+2rpEgvk2LxFO3bxE2HrzEpEBmJdIkMi6RKQLtiQKXyUiXTAvEemCeYlIF8xLRLpgXaKVdMG8RHR0JySKFYmc7ANxEvJzieIi25+OS1meH+wuR2xHX/59P8lNURrA0RSlXxxNUdrL0RSlGx1M0UjzOpqirKR1rWj5qigLb6MpyjrdaIoKig6mKJnRaIqSGQ2maJ75PrrkB4pe0cx8Q6qgmfnKXkEz1CVSStjQrPe/IjpG45Zt6xfn7iYZfr0y6cvR4vbt2ERuV8hydKziq53yUKE6euahInX0zEMF6uhZhorT0bMMFaajZxkqSkfPMlQAgJ5F0HMoPYeKWtCzkA+NpSf50Fh6kg+NpSf50Eh6xoV8aCw9yYfG0pN8aCw9yYfG0lPQcyg9yYfG0pN8aCw9yYfG0pN8qCs9fd4egPZh8Qd6kg8NpacjHxpLT/KhsfQkHxpLT/KhsfQU9BxKT/KhsfQkHxpLT/KhsfQkHxpLT/KhofT05ENj6Uk+NJae5ENj6Uk+NJaegp5D6Uk+NJae5ENj6Uk+NJae5ENj6Uk+NJSegXxoLD3Jh8bSk3xoLD3Jh8bSU9BzKD3Jh8bSk3xoLD3Jh8bSk3yoKz2T20j7FJYDPcmHhtJTyIfG0pN8aCw9yYfG0pN8aCw9BT2H0pN8aCw9yYfG0pN8aCw9h8qH1rQdvEZfKnqG/S/L3TCOX8B6eKiT/AFxqFDmCcTfs12Hiiyqsx3K0FdnO5Tdrc52KDNYna1MNduhjER1tkO12dXZDtWEVmc7VIt2cRDbbHMKlRYtu53N5S/HT43xlc1QnVdbNnGoPq0xm6G6uh+yibKx8Us+YDNUD9iYzVAdY2M2ApuHbIbqRhuzGap3bcxmqE63MZuZ++Iam4n7Yu9ubFb3ic1bo/fa1v9p4v68G40m9gndaDSxX+lGo4l9UzcaCRqZ12hiH9mNRhP72W40mthXd6PRxP6+G43IGcxrlMkZ7GtEzmBfI3IG+xqRM9jXSNDIvEbkDPY1ImewrxE5g32NyBnsa0TOYF6jQs5gXyNyBnWNfLjBloMt2wo5g32NyBnsa4Q/sq8RfZ26RpUtItJCX2dfI/o6+xrR19nXiL7OvkaCRuY1Yv3Ivkb4I/sasX5kXyPWj8xr5Ez1ddchib0h6d61Q62SXQ5bubkst589X5Kl6/hj5+NPnY8/dz7+0vf4/dL5+F3n4/edjz90Pn7pfPyd33995/df3/n913d+//Wd339D5/ff0Pn9N3R+/w2d33+VX9b858ff+f33/S/jDS5s78QIriyVv+1D3GbrQ0qfAqDrBFLvE8i9T6B0PoH3v1Cz9QRc7xPwvU8g9D4B6X0Cq/UJ+H0CIrV1j9pu5EnM37fbTtf8Xb7tdM33BD+b7vOtZ5OY7yCaTnc132+0na757qTtdM33Mm2na77zaTtdmWu6g3VVtemO1VV18hPTtI7V3XWDfawusxvsY3W7vWCPY3Xd3WAfq/vvBvtYLqQb7GO5oW6wC9g1sI/lDrvBjktVwY5LVcGOS1XBjkvVwJ5wqSrYcakq2HGpKthxqSrYBewa2HGpKthxqSrYcakq2HGpr8Be2Qw0JVyqBvaMS1XBTt+ugp1O5hXYaxswZToZFex0MirY6WQ0sBc6GRXs5O0q2MnbVbDTt6tgF7BrYCdvV8H+fpd6cc4bdp995W+vbge5uvU2XRc+tqIpqfcJ5N4nUPqeQH7/e4daT8D1PgHf+wRC7xOQ3iew2p6Ad7etaHxItf6hstdHXozft1tP1/hdvvV0jfcEP53u8x/Q58V4B9F4us54v9F6usa7k9bTNd7LtJ6u8c6n9XRlrukO1lXVpjtWV9XJY3DZjdXddYN9rC6zG+xjdbu9YPdjdd3dYB+r++8G+1gupBvsY7mhbrAL2DWwj+UOu8GOS1XBjktVwY5LVcGOS9XAHnCpKthxqSrYcakq2HGpKtgF7BrYcakq2HGpKthxqSrYcamvwF7ZZCEHXKoGdsGlqmCnb1fBTifzCuyVnyZmoZNRwU4no4KdTkYD+0ono4KdvF0FO3m7Cnb6dhXsAnYN7OTtKtgVXGrZDg7hbkucX3/7OqRibkgK73OtDuntvZAse+Ihy1r7vjw7+joB3/sEgu0J/LqVfRwdc3J3f/k6fOl7+Gvfw4/Gh1+W7ZYUi09fhp/6Hn7ue/il6+G//71zbYdv/M5bG77x+25t+NbvupXhW7/rVoZv/a5bGX7fd93U91039X3XTX3fdXPfd93c9103933XzX3fdXPfd93c9103933XzX3fdXPfd93c9123mL/ryh5TlfXr8M3fdZ8P3/xd9/nwzd91nw/f/F33+fDN33WfD//Ft61fH1Ksb8He6aptWLY5+uDcp6Ov2Hk0RAW7gF0DO4+GvAK7z2XHvvgD7PyAQQU7P2BQwc4PGFSw8wMGDeyDvUyiG+z8gEEFOy5VBTsuVQW7gF0DO3ZJA7vn7e4amYzn7e4q2Hm7uwp2AbvGtZ23u6tgj2DXwJ7AroE9g10DewG7AnaFneLBfsGOS1XBjktVwY5LVcGOXdLA/v5tbS+T2iYbFhcqf3sta97QZHfbhbq4o4OjpI+D15zu/7TrOcARh0bmNfJoZF6jgEbm70eCRuY1WtHIvEYRjcxrlNDIvEYZjcxrVNDIukYrOYN9jcgZ7GtEzmBfI0Ej8xoN1TP4ZdfIr7GikZN9JcNJuh2d0xF077c/HULON5Bx7TkKjEO1I8j/U/mH6nSQ/6fyD9VEIf8P7/1xqHUg5P+p/IL8M8s/1OoV8v9U/qEWxpD/p/IPteaG/D+Vf6jlPOT/qfykfjPLn0j9ppaf1G9q+Yl9ppYf4/c9+V2++1lUrMh/Qe33o+VWLGEpPa8QJGwixfLtYsFUUizfLhYsKMXy3Z4lY1gplm8XC/aWYvl2sfAIDMXy7WIhOaFYvl0sQrFQLN8tFh7GoVi+XSwkuBTLt4uFBJdi+XaxkOBSLN8uFhJciuW7xVLIWfSLxcVbsSy5Ir+ksg378s/bSMK6fkhKGtKbpHm/Wsg9kZukgqS9Sbq/Pkxy8AeSkiwMJyn+fzhJcenDSYqXHk5SHO9YkqZl4cmi7iTdJ3lRdzmQlOd/hpOU9Gg4SUmPhpNUkHQ0SUmPhpOU9Gg4SUmPRpPUGe94k8/bn05pqUjqot/YuHQnkguH3F3aquXXT7ArR3sX1x1JSBXunfw87qK/8fYY/V+sv6D/1Pobb7zR/8/p//x5qYv+xrt09H+x/sZbevR/sf7GV4/R/8X6G19qRv/X6u+Nr0uj/4v1N76Ijf4v1p/8b279yf/m1l/Qf2r9yX+m1j9M3P8ti9sHkmtH+7AvAHsR14v+tfw/TNz/of9F/4n7P/S/6C/oP7L+1fv/xOu/6H/Rf+L+H/0v+k+8/ov+F/0nXv9F/4v+E6//on9aZOL1X/S/6E/+N7f+5H9z60/+N7f+5D9T678O1f9d5rPrH0tF0Zy3aNwtS1X+MX/+sw7V/iH/T+UfqvtD/p/KP1Tzh/w/vfcL8s8s/1CtP/L/VP6hVn6R/6fyD7Xwi/w/lX+odV/k/6n8Qy37Iv8P5Y+kflPLT+o3tfykflPLL8g/s/wTt377wTmFmvpj/t4nTdz5oX6auPFD/TRx3ze++rX7fpp4sRf1k6D+xOpPvNSL+mnilV7UTxMv9KJ+mnidF/UTWd/E6meyvpnVJ+ubWX3SnpnVf3/Xty7bKw/9KqX2t3PZo+olDBOw5wJ2BexlAbsGdgd2hWt78WDXwB7AroFdwK6BfQW7BvYIdg3sCewa2HGpKthxqQrY3YJLVcGOXdLAfvxeSUkbRrnfcK0sHyf5MyeFMyfJ0Umr24pi9eHTSUdx9+3XITnflHD54xPWl39CfPknpJd/Qn75J5RXf0JYXv4J7uWf4F/+CeHln/Dy73R4+Xc6vPw7fbzh8yrbbWWV9PVyKcdo03ZSlOXgpHjmk44vOev2pr41ysFJx1eRvN3P1hIOTionTjreLrN2kjtzkj9zUjhzkpw56firkJf9pAOdjrccqp2UzpyUn58Ul6M5HVdEKvtJ+etJx1spRLfRi6EcnOQqn3T0fTr+2XblSxjDmZPOfN3jIfJLH7RN6tKwHKEop047/h1j/TR37jR/7rRw7jQ5d9p67rR47rR07rQHVZLTftqdUbmdVuqnHbT5eTl3mjt3mj932nGVXGzVdlo4uvBkOXfaeu60eO60dO60fO60cuq04+cH6qc90C3ucod0cJc5zvjdrce73JAPvgHlAZKyf99kWQ9OK/XTvn5N/bKcO82dO82fO209d9oxSdmfBHNyl8PcTiunTnPHJCUu+2kxHpwWHpx2m1taDk57MLc92rn0yuHgtHLqNL+cO+24SqTsm/dfErSD0/y508K50+TcaeuDb/eu2+rXg9PiudPSuUHmc6eVU6eF5dxp7sx10h8nGfXTwrnT5Nxp6dSVK5y7coVzVy5ZzpwWlnScx+5Pk8kllNtPC+v6cVo+d9rh3CT7/bQcDk47virXT3PnTvPnTjtOtvOS9tP8cnCanDttPXdaPHdaOndaPndaOXWaX86d5s6d5s+ddq5KHmT7frsCreF20raqEx7E9ZWTyomTHoTqlZPcmZP8mZPCmZPkzEnrmZPimZPOVMTxLWktW/HFu8XV20nlxEnHt6PaSe7MSf7MSeHMSXLmpPXMSfHMSenMSWcqQs5UxHqmIh7se34JIrdVk3RU58eBsos3GxdTPjitnDrtOFSun+bOnXbcMqe0b5aYij84LZw7Tc6dtp47LZ47LZ07LZ87rZw67UEGXj3NnTvtXJWkc1WSzlVJOlcl6VyVpHNV8iADL8vu/oo/Oq2cOu04lQ63x45CkbsVtOXwB5iXL/stDI357rpa0sHxsWxHp7tQ8tIsfAwpHA9J/D6k6CpDqja4x/l46w9Z3/Eh8R0fkt7xIfkdH1Le8CHHawatP8S940P8Oz7kHd/48o5vfHnHN/54jSiU/QEBcUuqfEi+LON/HH35jLu27/Dhz2rQdvwbCd0hZXtDKtaGJMdLebpDcvaG5O0NKdgbktgb0mpvSOau3rKYu3rLYu7qLYu9q7ezd/V29q7ezt7V29m7ejuF61JZ9yHdPft2G9L7v3GV3lt8i2+clZ9puXL7mdvdEwVbOCTezTRZP9Nkw0yTlZkmu8402TjTZNNMk80zTbZMNNkwUwcVZuqgwkwdVJipgwozdVBhpg4qzNRBhZk6qDBTBxVm6qBkpg5KZuqgZKYOSkbqoHy4TVb8wWRlpsmO1EFVJzvSfbY22XWkq3HlqX5ZR7oaVyc70tW4OtmRrsbVyY50Na5OdiQ/W53sSH62OtmR7rPVyY7kZ2uTjSP52epkR2oqKi8BkjhSU1GdrMw02aEs3vPtqiWO1FRUJztSU1Gd7FDmvTbZkZqK2mTTSE1FdbIjxTLVyY7UQVUnO1RIXpuszDTZmTqopPBznsqPC5LCjwt2tS7/LF+HlN//c57KLnOSnb0heXtDCvaGJPaGtNob0vt/9FT7hVFO9oaU7Q3J3k/DymJvSM7ekLy9IQVrQ1of7LC++H2fpSV+3b5ufbDDevW04827XNh3hnOSD04L506Tc6et50473rzLxR2Jy0dIHu2Mf9u+vxx8mlvOnebOnebPnRbOnSbnTlvPnfZgz3O/y33/hqjbaencafncaeXUaQ92xq+e5s6d5s+d9mDP89s7BtZcDk6Tc6et506L505L507L504rp057sDN+9bQHF4XbRoDBH3zfQjh3mpw7bT13Wjx3Wjp3Wj53Wjl1miznTnPnTjtXJXKuSuRBlexv+3NhPbgEyXrutHjutHTutHzutHLqtHU5d9q5BmM912Cs5xqM9VyDcRzkpX3LvcvC19eTjkOkW0Ba1oNPOo55aifJmZPWMyfFMyelMyflMyeVU+aknLNC5ZwVOran9dPCudPk3GnrudPiudPSudPyudNOVUk8Z5jjsfN9fu2Ix7637Ja++KOTTlwG4vHGbLVPymdOKidOOna7tZPcCRDOnzkpnDnpWKc9LijpoIyOPW7tpHjmpNrl+vCkfAZEOXHSsbOtnXSmIvyZivBnKsKf+eb69cxJ8cxJ6cxJP62I/7r8z//3H//9b//4T3//l/+4nPLrv/6ff/3n//zbv/3rx//8z//vf2//5Z/+/W9///vf/tc//O9//7d//pf/8X/+/V/+4e//9s+//ttflo//89+Tj8tfk8/uMpxf8l+6v/TXSy+3Xv53+P3fJV7++xp//fdfJ1zWa/NfL7lp+PX/+H2Gv/SFl/9TLmO7jO//Bw==",
      "brillig_names": [
        "get_public_immutable"
      ]
    },
    {
      "name": "get_imm_card",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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XOLrvyK9/ivy67+ivPoryrK8/ivc67+ixf3k6Q/iyhJe/xXy+q9YX33jLUt8/Vek139Ffv1XlJd/hVte/xXu9V/hX/8V4fVfcVi067qlpmu+7/Tcx0n5zEnlxEkPFuaWtM/q17/LHzqS8mCZa0llb2GXy1L0l9P8udPCudPk3GnHF8slh3A77e4lG9tp8dxp6dxp+dRp4YFu5fa6kaVE9+W0ByRL3l474tyyfCH54D0J1dPiudPyubmVU6c92MB5KSXcDXL9cpo7d5o/d1o4d5qcO209d1o8d9rxH87l0HI7zd9XyV9/XlMPtptr/CXlDV9yvOb3sy95vhZZHmz61vQr/Ou/Ivz0K66nybnT1nOnnbtEPlifq56Wz51WTp0Wl3OnuXOn+XOnhXOnnbuRxnM30gdLHWndL6wp3f9M9ai99WnZnzBK3v/xKx4sdTT9Cvf6r/Cv/4rw+q+Q13/F+vqviK//ivT6r8iv/4rX/3Xn1/9159f/defX/3Xn1/9159f/defX/3Xn1/9159f/defX/3XnH/91/z6tLOdOc+dO8+dOC+dOk3OnredOi+dOS+dOy+dOO1Ml67Is505z507z504L506Tc6et506L505L507L5047VyXuXJW4c1XizlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLPVYk/VyX+XJX4c1Xiz1WJP1cl/lyV+HNV4s9ViT9XJeFclYRzVRLOVUk4VyXhXJWEc1USzlVJOFcl4VyVhHNVIueqRM5ViZyrEjlXJXKuSuRclci5KpFzVSLnqkTOVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkrWc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclcRzVRLPVUk8VyXpXJWkc1WSzlVJOlcl6VyVpHNVks5VSTpXJelclaRzVZLPVUk+VyX5XJXkc1WSz1VJPlcl+VyV5HNVks9VST5XJeVclZRzVVLOVUk5VyXlXJWUc1VSzlVJOVcl5VyVnMte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt25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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "initialize_private_immutable",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "points",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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0YRMpBAtyNTVg8w7lokUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZVlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBpo0UogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakCmRQjQhEylEEzKRQjQhEylEEzIJMrUgEylEEzKRQjQhEylEEzKRQjQhEylECzJlUogmZCKFaEImUogmZCKFaEImQaYWZCKFaEImUogmZCKFaEImUogmZCKFaEAmmUghmpCJFKIJmUghmpCJFKIJmQSZWpCJFKIJmUghmpCJFKIJmUghmpCJFKIFmQIpRBMykUI0IRMpRBMykUI0IZMgUwsykUI0IRMpRBMykUI0IRMpRBMykUK0IFMkhWhCJlKIJmQihWhCJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIFmSaSSGakIkUogmZSCGakIkUogmZBJlakIkUogmZSCHeJFOUZUeYSjJJ3mVapil/l4kUogmZSCGakIkUogWZhBSiCZlIIZqQiRSiCZlIIZqQSZCpBZlIIZqQiRSiCZlIIZqQiRSiCZlIIVqQaSGFaEImUogmZCKFaEImUogmZBJkakEmUogmZCKFaEImUogmZCKFaEImUogWZFpJIZqQiRSiCZlIIZqQiRSiCZkEmVqQiRSiCZlIIZqQiRSiCZlIIZqQiRSiBZk2UogmZCKFaEImUogmZCKFaEImQaYWZCKFaEImUogmZCKFaEImUogmZCKFaEGmRArRhEykEE3IRArRhEykEE3IJMjUgkykEE3IRArRhEykEE3IRArRhEykEC3IlEkhmpCJFKIJmUghmpCJFKIJmQSZWpCJFKIJmUghmpCJFKIJmUghmpCJFKIBmT7+O2RqQSZSiCZkIoVoQiZSiCZkEmRqQSZSiCZkIoVoQiZSiCZkIoVoQiZSiBZkCqQQTchECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTJEUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakGkmhWhCJlKIJmQihWhCJlKIJmQSZGpBJlKIJmQihWhCJlKIJmQihWhCJlKIFmQSUogmZCKF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dadfr+7by9K1l+VLL8vTtZeFay+L1142X3uZXHvZcu1l67WXXauSfK1K8qUqSdN07WXh2svitZfN114m1162XHvZeu1l27WXpWsvu1Yl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViXhWpWEa1USr1VJvFYl8VqVxGtVEq9VSbxWJfFalcRrVRKvVUm8ViXztSqZr1XJfK1K5mtVMl+rkvlalczXqmS+ViXztSqZr1WJXKsSuVYlcq1K5FqVyLUqkWtVIteqRK5ViVyrErlWJcu1KlmuVclyrUqWa1WyXKuS5VqVLNeqZLlWJcu1KlmuVcl6rUrWa1WyXquS9VqVrNeqZL1WJeu1KlmvVcl6rUrWa1WyXauS7VqVbNeqZLtWJdu1KtmuVcl2rUq2a1WyXauS7VqVpGtVkq5VSbpWJelalaRrVZKuVUm6ViXXstd0LXtN17LXdC17Tdey13Qte03Xstd0LXtN17LXdC17Tdey13Qte03Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfC17zdey13wte83Xstd8LXvN17LXfJK95v0bhuFj5zx42UmV7Ef6hZzjl5cdHeWr9aCQfJbp1hrO5ms4yddwsqvhnGXmtYYTfA0n+hrO7Gs44ms4vj6Vk69P5eTrUzn5+lROvj6Vs69P5ezrUzn7+lTO1p/KPz/jKmdxNp7F2XhWZ+PZnI0nORvP8QHqId3PGYkxLIXxhHWb9uGv27+eXrBMx/d7td8kWLxJVHmTeX28yTo/vcnBL/LSfD8YaJ6ez32ajo9TnfYz16b58dv7HD7HPzsf/7LzX5d5/j5+aXz8S+PjXxsf/9b4+FPj489tjz9MjY8/ND5+7/tvafyN77+h8f03NL7/hsb339D4/hsa339D4/tvbHz/jY3vv7Hx/Tc2vv/Gxvff2Pj+Gxvff2Pj+29sfP+Nje+/c+P779z4/js3vv/Oje+/c+P779z4/js3vv/Oje+/c+P779z4/iuN77/S+P4rje+/0vj+K43vv9L4/iuN77/S+P4rje+/0vj+uzS+/y6N779L4/vv0vj+uzS+/y6N779L4/vv0vj+uzS+/y6N779r4/vv2vj+uza+/66N779r4/vv2vj+uza+/66N779r4/vv2vj+uzW+/26N779b4/vv1vj+uzW+/26N779b4/vv1vj+uzW+/26N77+p8f03Nb7/psb339T4/psa339T4/tvanz/TY3vv6nx/Tc1vv/mxvff3Pj+mxvff3Pj+29ufP/Nje+/ufH9Nze+/+bG99/c9v4bprb33zC1vf8G9+dflcbf9v4bprb339D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VaPz8q9D4+Veh8fOvQuPnX4XGz78KjZ9/FRo//yo0fv5VbPz8q9j4+Vex8fOvYuPnX8Wp7f03uj//6vGn1+1j0E/jP7r4Puo1rY8/nORzrt73as25et/XNefqvQfQnKv3fkFxru7P9tKcq/M+ZMlLesw1/jxX2fJ9HJLmtF8c83Zw9bbd//KWH8OYP153I+O8w6lIxnnvVJGM+CazLRLv41+n9Wcy83y/dpanQccj4utyH/KyTU8Xz0dXx5z3vzxN6cvVN4zOm8NWMDrvO1vB6LylbQWj8265FYzOG/FGMHo/P7AVjM7tQysYnXuNVjA6NyatYBQwamDExahgxMWoYMTFqGDExahgxMVoYPR+CmsrGHExKhhxMSoYcTEqGAWMGhhxMSoYcTEqGHExKhhxMSoYcTEaGL2fZd0KRlyMCkZcjApGXIwKRgGjBkZcjApGXIwKRlyMCkZcjApGXIwGRu9PBGgFIy5GBSMuRgUjLkYFo4BRAyMuRgUjLkYFIy5GBSMuRgUjLkYDo/fnqrSCERejghEXo4IRF6OCUcCogREXo4IRF6OCERejghEXo4IRF6OB0fvTqVrBiItRwYiLUcGIi1HBKGDUwIiLUcGIi1HBiItRwYiLUcGIi9HA6P0Zf61gxMWoYMTFqGDExahgFDBqYMTFqGDExahgxMWoYMTFqGDExWhg9P6k1FYw4mJUMOJiVDDiYlQwChg1MOJiVDDiYlQw4mJUMOJiVDDiYhQwzt6fN90KRlyMCkZcjApGXIwKRgGjBkZcjApGXIwKRlyMCkZcjApGXIwGRu9Ptm8FIy5GBSMuRgUjLkYFo4BRAyMuRgUjLkYFIy5GBSMuRgUjLkYDY8TFqGDExahgxMWoYMTFqGAUMGpgxMWoYMTFqGDExahgxMWoYMTFaGCccTEqGHExKhhxMSoYcTEqGAWMGhhxMSoYcTEqGHExKhhxMSoYcTEaGAUXo4IRF6OCERejghEXo4JRwKiBERejghEXo4IRF6OCERejghEXo4FxwcWoYMTFqGDExahgxMWoYBQwamDExahgxMWoYMTFqGDExahgxMVoYFxxMSoYcTEqGHExKhhxMSoYBYwaGHExKhhxMSoYcTEqGHExKhhxMRoYN1yMCkbnLmbJS7pjTCH/jHGJ03ZnE5f16U8fXR0k3gcSZHtcnbYjhUKa7qMO+XFxXI9GPU9xxx7kgX2e8sHVKazyeXWKTyJ9kDq4WrZp/rxatn9K5P63l+VTUueOCkl/L6lzd4ekv5dUkLQ3SZ27XiT9vaTOHTiS/l5S52kAkv5eUufJBJL+XlLnKQmS/lrS5DyxQdLfS0p61J2kpEfdSUp61J2kgqS9SUp61J2kpEevSSoh30ctKRYkXaaw3wGdZHsMZP2kTsBTgzoZTA3qxCQVqGeSjBrUCRtqUCcPqEEdy16DukC9AnWMbw3qeNMa1PGmNah35U1X2amnbS5QT2G7/+n0JS37SLRubLpykKpsZOrK5ymz6cqNKbPpyjMps+nK2SizEdicsunKJSizcdXL34bkqtG9DclVF3gbkqvm68+Qgque5zYkV63GbUiudvjbkFxtrLchudrPbkNytY3chuTv0zv4+/QO/j69g79Pb1/PvL8Nyd+nt69nsd+G5O/T29czwm9D8vfp7evZ1bch+fv09vVM5duQ/H16+3rW721I/j69fT2D9jYkf5/evp6NehuSv09vX8/svA3J36e3r2dJ3obk79Pb1zMOb0Py9+nt69l7tyH5+/T29Uy425D8fXr7elbZbUj+Pr19PUPrNiR/n96+nu10G5K/T29fzxy6Dcnfp7evZ+HchuTv09vXM1puQ/L36e3r2SG3Ifn79Pb1TIvbkPx9evt61sJtSP4+vX09A+A2JH+f3r7Opr8Nyd+nt68z029D8vfp7ess79uQ/H16+zrX+TYkf5/evs7VvQ3J36e3r3NNb0Py9+nt61zJ25D8fXr7OtfvNiR/n96+zlW7Dcnfp7evc61uQ/L36e3rXKHbkPx9evs6keY2JH+f3r7OMrkNyd+nt69TMG5D8vfp7ev8hNuQ/H16+/rl/W1I/j69ff1m+zYkd5/ei69fKN+G5O7Te/H1e9zbkNx9ei+Tu0/vxdePPm9Dcvfpvfj7reXi77eWi7/fWi7+fmu5+Put5eLvt5aLv99aLv5+a7n4+63l4u+3lou/31ou/n5rufj7reXi77eWi7/fWi7+fmu5+Put5eLvt5aLv99aLv5+a7ko/YBoP0jv499hexrS7U1+/eH352W//0HK7WXh2svitZfN114m1162XHvZeu1l27WXpWsvu1Yly7UqWa5VyXKtSpZrVbJcq5LlWpUs16pkuVYly7UqWa5VyXqtStZrVbJeq5L1WpWs16pkvVYl67UqWa9VyXqtStZrVbJdq5LtWpVs16pku1Yl27Uq2a5VyXatSrZrVbJdq5LtWpWka1WSrlVJulYl6VqVpGtVkq5VSbpWJelalaRrVZKuVUm+ViX5WpXka1WSr1VJvlYl+VqV5GtVkq9VSb5WJflSlazTdO1l4drL4rWXzddeJtdetlx72XrtZdu1l6VrL7tWJeFalRzfDJF1f9mXx/49XhaPXxYeL4vT//o5E0jT/iDC+XGYbPznKPxv1+Z0DzRy/nrtbTizr+GIr+Esvoaz+hrO5ms4yddwsqvhHN+QqDec4Gs4vj6Vo69P5ejrUzn6+lSO1p/K+2OIwzTFg/FszsaTnI0n+xrPPDkbT3A2nl9/Nt9eNl97mVx7mc63In681bcqnWv385sonVRXeJNg8SbR4k1mizcRlTeR8HiTJT+9ye/uhN+GtPgb0upvSJv1kCTk+/NgJB5UUvI2oOxsQPZnvZU2QPuj3oojiu5GNLsbkbgb0eJuRKu7EW3uRpTcjSh7G9Hq7jN7dfeZXeF8t2Wa7n97kVz623nZ/3RO4WkC8+cE5tYnIK1PYGl9AmvrE9han0BqfQK58QlUOE9PeQKh9Ql434lTnu9XT/PXCRxEvYUH0K6b931bebred3nl6XrvCZSn672DUJ6u935DebreuxPl6XrvZX453d0Bpzil79NN3jsf5el675OUp9tZV1WabmddVWm6MtZ0O+uqStPtrKsqTbevriqGx3SX0tVblvuP5recY+HqeYmfF0t4amCmo2tjyA9+U/5y9Q17X91dM9j76jJbwZ776nabwd5X190M9r66/2aw9+VCmsEuYK+BvS9X1gz2vtxhM9hxqVWw41KrYMelVsC+TbjUKthxqVWw41KrYMelVsEuYK+BHZf6/7b3dTuS88ix7+LrueBP8u9ZDMOw9ywOFlh4jT32AXzxvbvV0y1Ks5VqlnJURYoZN4ue/RQlMiJFZgYlsgvtqFK70I4qtQvtqFK70I4q9RW0O7/xR+6RdosqtQvtqFK70E6gvQftyGReQXuyKyEuecPQjkymC+3IZHrQ7pDJdKEdmUwX2uG3d6EdfnsX2gm096AdfnsX2uG3d6F9qBOJGWpc3a07pZ2FWizXkGWxbG1HijtFPffTuV6ck29c67xbL3ZEv/uldnJDHbqshvWhzpXWwrof6uhsNawPdTq4GtaHOgBdDetDnfGuhnWaifXo6narKcUGk94YWxuS45t5D+C9C+8RvHfhXXGFmlfLwRrTpN3GSrvz6bdpV1yi9qRdcY3akXZSXKT2pF1xldqTdsVlak/aFdepPWknvYn7xo13Lr2Zd8WFalfeFReqPXkPgw/voYTaAVP8nvfP9g8+TjbbP/h402z/4M9tDPVU0xg80/7BjZpm+wd3PJrtH9w6aLU/Dl6DN9s/eDHbbP/gVWGz/YPPv832Dz7/Nts/+PzbbP/N59948/k33nz+jTeff9PN59908/k33Xz+TTeffzuc9HZt+28+/6abz7/p5vNvuvn8m24+/+abz7/55vNvHnz+3fmHcf+2Z23/ffxnvv2Dz7/N9t/Hf+bbP/j822z/4PNvs/2Dz7/N9g8+/7baXwaff5vtH3z+bbZ/9LeSAq0f3i5rFXHffmYl2q/Xeto12nG8xHrA/Mdur9vFnrvalVJ/2exOI/y4+pPG0V/cHYJGb0pZf/kXPtirU23x9pYAfS37l9Hf2J2L72xGf1V3Nr5Hf0d3Nr4xDb6X79Hfyp2NbwLfb+V79NdwZ+N79NdvZ+N79O9DZ+Mb9eV7+UZ9+Va+LerL9/KN+vK9fKO+fC/fqC/fyzeB77fyjfryvXyjvnwv36gv38q307snSDDrLgmBzC/XfjKjd9uOFjN6d9ZoMUNg5oCZqbanuJSZqTaQuJQZvXsRtpjRu11gixm9O/o1mFG8M3yLGcU5cFz3+wklN64lF1YayWX6pej45FHvTHZuZ/BtIySfft0I6ZNHnBJzDY849+UaHnGSyyU8at729lIecdrKNTzi/JRreMSJKNfwSODxEh71em2vPKEnbmdM7r4E21hH9dODddRKPVhHZdWDddRhHVgPqNp6sI4arwfrqAh7sI768QWsj3ImvC2bjDvy1jPh8+gHAUD9l6qPWl2z+vAMNKsP70Kz+vBQNKsPL0ex+qMfvgP1X6o+vC3N6sNj06w+vD7N6hPUV6w+vD7N6sPr06w+vD7N6sPr06w+vD7F6o9+0CfUf6n68Po0qw+vT7P68Po0q09QX7H68PomVt/5TUZyjPrw+jSrD69PsfqjHywO9V+qPnL+idVPdiXPJW8Y9QnqK1YfOb9m9ZHza1YfOb9m9bG+r1l9rO8rVr+g3tesPtb3NauP9X3N6uv1+opb+1hCaFwbTKqHDFizj5WvcwMKgcdLeNTrP13Lo14n51oeFXsieT0qxZrdKZEHRFq7ERkiQ6Rie+FaIhVX6lcSWYziovdaIhXXj9cSqbgUu5ZIxW8wXEskgchriFS8rn4tkYqXqM8Q6ex2worzv56wwvx0Y3/nYlAHdaEdVVMX2lFj9aDdoiLrQjvqty60o9rrQjtqwy60E2h/Ae03+Za0WNS/quVH1a5afrgHquWHi6FafrgpmuV3cHVUyw93SbX8cLlUyw+3TbX8BPk1yw/XT7X8cP1Uyw/XT7X8cP1Uyw/XT7P8Hq6favnh+qmWH66favnh+qmWnyC/Zvnh+qmWH67fzPI3do8vHq6favnh+mmWn1D3q5afIP/E8jd2k1xuDPk1y4/MX7X8yPxVy4/MX7X8WO/XLH/Aer9q+VH3q5Yf6/2q5cd6v2r5p6r7o6Mqf2oqWsx6tVseg8bVZMwaLWRoH1pfu5vGqabRU0x6Y2xtSG7y7rcnyadfn6RPJqeakboyOdXg3pVJApMXMTnVQkNXJvXO3VczOZX93ZXJqZzkrkxOZcr2ZDJN5W++lMlTB2W29o1NqIj68I76qQ/vqLb68E7gvQvvqOT68I66rw/vqBL78I6a8iW83+WrtIRKWLX+GfW7bv3hI+jWH36Gbv3hq+jWn6C/av3hM+nWH36Xbv3hu+nWH/6fbv3h/6nWv8D/060//D/d+sP/060//D/d+hP0V60//D/d+sP/060//D/d+sP/060//D/F+kdj4P9Nrf/3O1Mv+sP/060//D/d+qP+160/8v+p9f9+j7pFf+T/qvW3yP9164/8X7f+yP9164/1f936E/RXrT/qf936Y/1ft/5Y/9etv2L/z5q8NsSG1LiaUlkbQpnM7mr3xaRiJ+1aJp1iT+piJhW7Oxczqdgnsaky6VyLyWDrzBdsiAyTih2Hi5kkMHkRk4qr4IuZVFxPXsyk4srsYiY11zjXMqm5xrmUSa+5xrmWSc01zhkmT56y+f3O0QvvqIj68I76qQ/vBN678I7arA/vqOT68I66rw/vqBL78I6a8iW83+ULVEIlrFt/1O+69YePoFt/+Bm69Sfor1p/+Du69YfPpFt/+F269Yfvplt/+H+q9Q/w/3TrD/9Pt/7w/3TrD/9Pt/4E/VXrD/9Pt/7w/3TrD/9Pt/7w/3TrD/9Ptf4R/p9u/eH/Ta1/awf6CP9Pt/7w/3Trj/pft/7I/6fWv7UDZUL+r1t/5P+69Uf+r1t/5P+69Sfor1p/rP/r1h/1v279sf6vW3+s/6vWPw9e/4cSVpFStg39gzPp6+Lg9ruVGjZavF+vtj5vGuXEXEx+1ZPyjg8qXzQOXkbfhcbBq9G70Eig8QoaB6+N7kLj4CXGXWgcPFMfhcYQ1h6GyNE4eMJ7FxoHXzcehsZk1l9O5ZHGMvjy611oRBXzHI1lnWKi8QyNqGIuoRFVzFkarWVoJNB4BY2oYp6iMaaVkJgNQyOqmEtoRBXzHI15bXQsxNCIKuYSGlHFPEXjsvKyNsPmBxqtQRVzCY2oYs7S6CJDI6qYS2hEFXMJjQQan6KxrI3OhhgaUcVcQiOqmKdozPWhzuxMjSrmEhpRxTxHo/crjbtv+DYaUcVcQaNFFXOWxmAYGlHFXEIjqpinaCx2vbZw6bdFFXMJjQQan6Kxfm5fyDI0ooq5hEZUMc/RWN/hKZF7qFHFXEIjqpizNCbGmrCoYq6g0aGKeYrGpXXrK2WLK8Yk4A51zEVEKq5kyK0NsbT7II0l0tu8Eult2X3ZFblWexO3Pu7eifQfH8k9Xp3M+pKQT7uU6uPqT5EU10n3EYkg0vgiKa7x7iOS4gryPiIprk/vI5Li6vc+IimurW8jkldcud9HJMWuwH1EguNwA5HgONxAJIJI44sEx+EGIsFxuIFIcBxuIBIchxuIBMdhfJEIjsMNRILjcAOR4DjcQCQ4DjcQiSDS+CLBcbiBSHAcbiASHIcbiATH4QYiwXEYX6QAx+EGIsFxeIlIztWrKTdEyjZuB8iY7Wr+SBhKZv2YnJLd9jbwIXxJCn9iOknhZkwnKUHS2SSFUzKdpPBVppMUtePtJK0bHS5/xkdJIzLeu0maaydpuZyRFBlvf0lHOdjUlk313bmw68GmS+QhWBAszwYLsnQEy9PBgvwfwfJ0sGB9F8HydLBgnRnB8nSwwLNAsDwbLAnr7giWp4MF6/8IlqeDBT4rguXpYIGDi2B5OlgIwYJgeTZY4OAiWJ4OFji4CJangwUOLoLl6WCBg4tgeTpY4OAiWJ4NlgwHF8HydLDAwUWwPB0scHARLE8HCxxcBMvTwUIIFgTLs8ECBxfBsirj/KY6OSZY4OAiWJ4OFji4CJZng6XAZ0GwPB0sqIYQLKsyya4yuuQNEyyEYEGwPBssqIYQLE8HC6ohBMvTwYJqCMHydLDgfRYEy9PBgvdZECxPBosz8FkQLE8HC95nQbA8HSx4nwXB8nSwwMF9Lli8qcHiHf0SLJ9EEoi8hkg4fxcRCVfsIiLhGF1EJNyUi4iE03ANkRZV+EVEokK9iEhUb88R6VyqRObcqN6yTWur8y+1Xv6qgyzqoC60E2jvQTtqrC60oyLrQjvqty60o9rrQjtqw5fQfnyUy0/aHSrJLrSj7uxCO6rULrSjSu1CO4H2HrSjSu1CO6rULrSjSn0F7TfZ/sE5VMuq5UfVrll+D/dAtfxwMVTLDzdFtfxwdVTLT5Bfs/xwuVTLD7dNtfxw/VTLD9dPtfxw/TTLT3D9VMsP10+1/HD9VMsP10+1/AT5NcsP10+1/HD9VMsP10+1/HD9VMsP129m+RuHprgA10+1/HD9VMtPkF+z/Mj8Z5a/td1uQOavWn5k/prlj8j8VcuPzF+1/FjvVy0/1vtVy0+QX7P8WO9XLT/W+1XLD9fvOfnJV/kp24b83taGeEs7/jhCbKKVbJvi7mKuHZHWuIrB7y/9VBMm3kxqwpO7l5pVmLibIFY1Eyy2m6m5HoeSzOOzmeCYPammLZuarqFmMDVdCYbSXs1P1mFU9WAd/lAP1gmsd2AdbkgP1mFC9GAdtX8P1lGj92AdtXQH1jNq3h6sozbtwTpq0x6sozZ9AetUSq6sh/LHt64ahbK62BTJPEpEkGh0iVD1Di8RSuThJUI9PbxEKL6HlwiV+ugSFZT1w0sED2B4iWAYDC8R3IWxJPKPEhEkGl0iuAvDSwR3YXiJ4C4MLxHchcEl8gYZnUCi2JDIUm2IJZ+/lygaWn86mmK+v9guV6xXL3/vO7kqSlB0MkWRL86mKNLL2RRFNjqbokheZ1MUK2m3VrQ8KGqx8Dabolinm01RLOvNpig8o9kUJSg6l6Je8zxq8oGin9RonpAa1Gge2RvUTDVEUvErNWH/FRFPjTXr1i/W7jrpP45Meria6r5wRLvdagp3rbfb1jbul2s/OZ/K+L4J51NZ0zfhfCrz+CacT2Xv3oTzqQzYe3BOU1mkN+F8quLrJpxPVdXdhPOpysWbcE7g/O2cow59knNbt2InanDe71hnT6hx59IT9fNceqI2n0tP1P1T6RngKcylJ/yKufSEFzKXnvBZ5tKToOdUesIfmktP+ENz6Ql/aC494Q/NpSf8oan0jPCH5tIT/tBcesIfmktP+ENz6UnQcyo94Q/NpSf8obn0hD90Kz2d34TZv69Z9YQ/NJee8Iem0jOh/pxLT+S3t9Iz1TNEXfKG0RP57Vx6Ir+dS0/kt3Ppifx2Kj0z1j/n0hPrn3PpifpzLj2x/jmXngQ9p9JzKn8opHr8VnSloaevv0y7ZvCby7KXWspfJE5lynxD4mdvp7Ismr2dqqBv9naqcrfV27kOh2/2dqpSqdnbqQqJZm+nSrObvSVVvZ0qRYtUd/7OyTdStGwrN8svx18S409upsq8LuZmqjztYm6myupOchPXY4ezM5nhZqoc8FJuyEyVMV7MzVT55cXcTJWNXszNVLnrxdwQuDnkRnNe3OJGcV7s7MZNsL9w81brvfFpA811LvWkGimuE26jkeJ65S4azXUa9KQaKa7fbqOR4jryNhoprmdvoxFBo+E1Ulzf30Yj+AzjawSfYXyN4DOMrxF8huE1cvAZxtcIPsP4GsFnGF8j+Azja0TQaHiN4DOMrxF8hvE1gs8wvkbwGbpr1NiyjRx8huE18vAZxtcI9dH4GiGv665RY4sI8sjrxtcIed34GiGvG14jQl43vkZYPxpfI6wfja8R6qPxNSJoNLxGWD8aXqMwVF732aSh0pjPJvWdtX0rkm32a7jZTNtnz4uz9Nl+f/P2083bH27e/njz9qebtz/fvP3l3u3vfDj877ff3rz9N59/483n386HO/9++28+/8abz7/x5vNvvPn8G28+/6abz7/p5vNvuvn8m94+/3rr1zMxvC2m8dvOx7W3zqf0iwH02QG6ewfC3TsQ796BdPcO5Lt3oNy8A+8/I/DqDti7d8CN3gFXO0DUWvdo7UZOefh5+9ruDj/LX9vd4XOCc91tbD2bh88gru3u8PnGtd0dPju5trvD5zKXdrcMn/lc293h86RruztZVtXq7lxZ1V0+MX3/4Vyg/YP2ubLM29A+V7Z7G9rnyrpvQ/tc2f9taJ+rCrkJ7cHMVQ3dhva5qrLb0D5XdXgb2lGldqGdQHsP2lGldqEdVWoX2lGldqEdVWoX2lGl9qDdokrtQjuq1C60o0rtQjuq1C60E2jvQTuq1FfQ3tgMNFhUqV1oR5Xag3aHvL0L7chkXkF7YwOm8P6DcED7B+3IZLrQjkymC+3IZLrQDr+9C+3w23vQ7pG3d6EdfnsX2uG3d6H9/VXqUjmvtLvsGr+9LH+tRC5u6dZd691XB+juHQh370C8ewfS3TuQ796BcvMOvP84l6s7YO/eATd2B5zdtqJxPrXyh8ZeH4EGn7ev7u7gs/zV3R08Jzjb3e8/oA80eAZxdXcHzzeu7u7g2cnV3R08l7m4u2HwzOfq7g6eJ13d3cmyqlZ358qq7vIa3PuPowHtH7TPlWXehva5st3b0D5X1n0b2ufK/m9D+1xVyF1oj3NVQ7ehfa6q7Da0z1Ud3oZ2VKldaCfQ3oN2VKldaEeV2oV2VKldaEeV2oV2VKk9aE+oUrvQjiq1C+2oUrvQjiq1C+0E2nvQjir1FbS3NllIqFK70I4qtQftGXl7F9qRybyC9taniR1ObwXtC+3IZLrQjkymC+3IZLrQDr+9C+3w23vQXpC3d6EdfnsX2uG3d6G9Q5Va1ou9322J8/Hbn02K4zUpjdekt+dCZKrjQSa0npfvrv7sQLl3B+L7z98814GYwzoGxZzs7pc/m2/v3Xx37+b7wZtfzDolxeLSQ/Pp3s0P925+vHfz072bP/jM22r+4PNuo/l29Fm30fzRZ91G80efdRvNv/es+/7zlq5t/r1nXXvvWdfee9a195517b1nXXfvWdfde9Z195513b1n3fefDXRt8+8967p7z7pu+FmXqk1VwmPzh591v2/+8LPut833w8+63zd/+Fn3++YPP+t+3/wXT1ufN8GrIR9XX71q683aR+et/eXqn7SPvnH8rLTj1ZAutOPVkFfQ7nKptBvH0I4PGLrQTqC9B+34gKEL7fiAoQvt+IChC+34gKEL7ahSe9A+2SEft6EdVWoX2lEudaEdp7v38GQCTnfvQXvE6e5daMfp7j3G9ojT3bvQ7kF7D9oJtPegPYD2HrRH0N6D9gTae9COKrUL7ahSe9CeUKV2oR3lUhfa3z6lLp1aO+uN9Y3fDiXklZpst12oi+UuXpaGvy4OOe1/2t7ZwEkZGg2vUYFGo2v0/r2kodHZ+ShbaDS8Rg4aDa+Rh0bDa0TQaHiNAjQaXqMIjYbXCD7D+BrBZxhfI/gMw2tUUMOOr9FUOQOV1fkKgVJDI2vNuu5h7a6T/uOQx4eryVbWiTYeSxnL2ytT5RfQs0yVi0DPMlXeMr+ejfkzmanWUqCnmSpnhZ5mqjUa6GmmWs+Bnoag51R6TrVOBD0N/KG59IQ/NJee8Iem0tPCT5hLz6nyIWfqGpgLsaUn1S9FLKXt6pw40p1bf9r7nDciI9fqu7xqnexU6RPkPyv/VNkW5D8r/1TJGeQ/O/dPtdYH+U/K76ZK5SH/WfmnWkmE/Gfln2rhEfKflX+qdUrIf1Z+gvya5Yfrp1p+uH6q5Yfrp1p+2D6a5fco/J6T3+bdtnOxIf9CtatX0xYs/OLwbVYIPMpEBMvTwUIIFgTLs8GCEhTB8nTOgoIVwfJ0sKC8RbA8HSx4BQbB8nSwwDlBsDwbLITXaxAsTwcLXsZBsDwdLHBwESxPBwscXATL08FCCBYEy7PBAgcXwfJ0sMBn6R8sNm7BYnJDfkplbfby59YSH8KXpHBD7iZprqMF7RmpkgZ4FreT1PkqqXeMpHAWppMU9f90kqJKn05SgqSzSYqKdzpJ8WbR7SStnVzUNYykeP9nOknhHk0nKdyj2SSNcI+mkxTu0XSSwj2aTlK4R9NJOnjGm1xefzol05DURrdyY9NOJOtZ3m1ao+XjE+zG1c7GUCnxqcH7bT6Pi4Onx9D/tfqnwXNp6P9i/QdPvKH/7+nfel8qDZ6lQ/8X6z94Sg/9X6w/QX/V+g++1Az9X6z/4OvS0P/F+g++iA39X6w//D/d+sP/U61/hv+nW3/4P7r1V5z/GWNrQ3LraufrArAjsnfRv+X/Z8X5H/Rf9Fec/0H/mIri/E+D/q35vyhe/4X+i/6K83/ov+iveP0X+i/6E/RXrb/i9V/ov+iveP0X+i/6w//TrT/8P936w//TrH828H906z9V/pdM/UgzxdJQNOfVGrfGNOWf8vOfbKZK/yD/Wfmnyv4g/1n5p0r+IP/Jud9OtfYL+c/KP1XqD/nPyj/Vyi/kPyv/VAu/kP+s/AT5Ncs/1bIv5D8rP1w/1fLD9VMtP1w/zfI72D6q5Vec+tWLc/It9af83ic7xZkf1HeKEz+o7xTnffOr35z3FS/2Qn2vOOmH+l7xUi/U94pXeqG+V7zQC/U9QX3F6sPr06w+vD7N6sPr06w+3B7F6hO9Xf1g1iMPXaDS+u1cqlVt/DQGOwXQ3oP2CNp70J5Ae4+xPYP2HrQX0N6B9mBAew/aLWjvQbsD7T1o96C9B+0E2nvQjiq1C+2oUrvQjnKpB+38uZKUVhppv+FaMV+gLAEVAYg/9izYNSiC87+AOLt7+zok500Jm7/uYF9+B/fyO/iX34Fefofw8jvEl98hvfwO+eV3KK++Q3n5M11e/kyXlz/T/IbPgdZpJVB6GC6L4alNKyiSYUBOcid+yAnrSX0hEgPiR5G8zmeheAYUJKAoASUJKEtARQDitwFrgfhHIZsKYnTitxxqgbwERN+DouH6xEdEKhWUGRAbEdGu7EVfGFBq3Il7nvjPthsPoS0CkJM87o6l3Lqwdsq6yFDBf47ahkUZLMlgWQYrIhj/rUYbZmUwJ4N5GewgSnKqsF2hssFCGxYZWJTBkgyWZTA+SpayaoV5buAhI4NZGczJYF4GIxksyGBRBjvQLVa5fWJmGd7jt1uOZwMxT0A4oKTU541MYGChDWMe0xBlsCSDZREsWhmMZ5Lqm2CWdj7MBgsyGM8kRVNhkRkUYjmAbX1LzCScDvpWrR1LmYnJFGSwKIPxUUKlbt6/OGgMLMtgRQTjHaI2zB483VW34JjHNDsZzMsaSTJYkMGiDJZE4yTvZLRhRQTjPYc2zItGriIbuYps5CpRAEuGr22W2nSl5KP8+WNnS3AuN20ud3R//OphLLfIr79Fefkt+Crr2lvY19/Cvf4W/vW3oJffgn+TKUZfPYm4e5x8XGFWBnMymJfBSAYLMliUwZIMlmWwIoJFWZREWZREWZREWZREWZREWZREWZREPkoSreuJMe0S7wpLrG7LPLKOCcn4yMCsDOZkMC+DHQyONVs5gBX+bpQqLDECZCODWRnMyWB837ypTHrHUMKni22YlcGcDMZHia+fdyUfEgMjGSzIYFEGS03YbupeYdYc6JY3WMkMzMpgTgbzMhjJYLwAVE/gS+Q9AysiGL9ylHJY87OUIwfjg4tirnfbmdQbLMpgSQZjE4wUbRUgusTAigjGVx1tmJXBnAzG6xZyjZJQmMeUX6ZJqb5hlTIz5Vt+maYJ45dp2jArgzkZzIseHH6Zpg0LMliUwZIMlmWwIoLxyzRtmJXBqPm8cVHCL5y0YVEGSzLYwTgZ6xMQEzNR8SXtksRXJpefZmAkgwUZLMpgSQbLMlgRweLBjFPSBgsMzMpgTgY70C3U4EqB61tsjsr218eUeQOYcn29afmbi+F4MNLZ+O3gH2XzYZTNh0k2HybZfJhk8+FBCdyCHSy0LDlAXcZbJnZGuYOllieAQQqMUmCSArMUyC+6xODrOkgMXD12sOzyBNBKgU4K9AfAZDdg5oC8jjHWJHgZFgyTPPM17nKx25q6VCIMMEuBRQZ0xkiBVgp0UqCXAukAmHeflDAVtuNfUH0GGKXAg8jJ24P8cWwoA8xSYBEC7VHk7B6rbF1r6nWJ6vVuyUBb14eQtxX5UArTMDtqw9yoDfOjNoxGbVgYtWFx1IalURuWezWsDrAhGsM0rFzUMO93DSvtWqhWk8vf9jEvco46NaxRpDkXRm1YHLVhadCG+aPsIuw/A+aAVgp0UqCXAkkKDFJglAKTFHiUl/q0BRizTuh8EQIP3sp/AmilQCcFHgRA2aaSj5elGWCQAg/kKNsr8x/v6z4C+Zeg7Mdq1gr8WEVggE4K9FIgSYFBCoxSYJICsxRYDoB1iXT5OzPZCO8hfwDTBiwtp/XK9/lctOM1yY3XJD9ek2i8JoXxmhTHa1IarknpYFzatmn5+Ptxvcmlg+fC1QWn5W9uJDz4VOcj19mA5BlglAIPaHdx11Ru1j74YOcJYBECs5ECDwZzb2qGmbxjqtGDD3eeAHop8GD48rQDBibkDlaUngBGKTBJgVkKLELgwYrSE8CjyPF7IJMLFScFeinwKHI2L2j5m3k6SpACoxSYpMAsBRYZ0BsjBR5FTtoBi2GATgr0UuBB5NBumiPnGWCQAqMUmKTALAUWIfBgDesJ4EHkkNkDiQE6KdBLgQeRs8x/G9CHP1qW3dKCatlx06K34aIb+d3njaFppDe9RG/jRQ0LtDUsclGRXsAAe6P8rhuVN93ImXfdyF50o7q94fJ3cb8fpc5d1LCyMbAMDsyN/PUM8Deid90ovOtG8V03umgkIZu2G3l/QZReNPKQ3zFAgblReQED3I28edeN7Ltu5N51I8FI8gkkKTBIgVHm9nifpMAsBRYhkIwUaKVAJwV6KZCkwCRb+fIHS2bJ7E7EMyYywCIEBiMFHqxglmJ2QCZ1P1ikewLopUCSAoMUGKXAJAVmKbAIgbyJSqmeI0Zp/zLH4qZ9wpwMxopP2VVY9hyMZLAgg0UZjN89PZtUYc4wsCyDFRGMt0zbMCuDORnMy2AkgwUZLMpgoigh3ncM9T324DfQ137+C8hJQF4CIgkoSEBRAkoSUJaAigB0sJlzAySJiIPNnOt3dnG37LmBvAREElCQgKIElCSgLAEVAehgM+cGyEpAkohwkohwkojgK2CX6keUy6I8E+dHb2ZuG3juPzveYF4GIxksyGAHdWnaypniGFiSwbIMVkSwo3q0BbMymJPBvAxGMliQwWRRQrIoIVmUkCxKgixKgixKDirdYupXIsVxMC+Dsbr57cCpJc3dnZ1gLOfDLcsY2zbYMe/G1ZLYt6vWq9NuO+rFjvpqUuKbRK42affxCt+kZoLLV75X36S84Sb8a69X38S+4ybuHTfx77gJveMm4R03ie+4yTue+PiOJz6+44nnXyhdSv11qF8qvNS4SbZxe2l1d3IBf+xfy2gjfoOOvk1y4zXJj9ckGq9JYbwmxfGalMZrUh6vSWW4JuXxRu883uidxxu983ijdx5v9M7jjd55vNE7jzd6lw7jUn0RcPkzMk16/xPXyr3LFU/cKAd027IdcL47S6aaQyVo6mzU1NmkqbNZU2eLns4GYzR11mrqrNPUWa+ps6Sps4oyqGAUZVDBKMqgglGUQQWjKYOymjIoqymDspoyKKspg7KaMiirKYOymjIoO1MG5fzWWXJMZ2fKoJqdnSmDanXWzTTPNjs702jceKs/uJlG42ZnZxqNm52daTRudnam0bjVWT9TPdvs7Ez1bLOzM82zzc7OVM82O0uaOjtTUuHrO0VL4miZzs6UVDQ7O1NS0ezsVCVePYFp6TdT9dBMSUWzszMlFc3OTlW8tzo7U1LR7Cxp6uxMtkyzszNlUM3OTmWStzo7lUne6qymDCp0+Jzn+48LQujwcUFVa/mzME2i9zfp+13mQgjjNSmO16Q0XpPyeE0qwzUpvv+jp8YXRiHa8ZrkxmvScJ+GhUjjNSmM16Q4XpPScE3it2WwxtV9lkx83L4uHBz81oTxm3dZX3eGs5QZWJLBsgxWRLCD495srJTYzFBycPSar9sHLn9ydyMZLMhgUQZLMliWwYoIdnDYWtiOj11qYwZmZTAng3kZjGSwIINFGYyPkhDrhnIhM2/1HRyu1oQVCSweHKzWhFkZzMlgXgYjGexgUNg2AvQuM7Akg2UZrIhgB6ehNWFWBnMymJfBSAYLMpgsSqwsSg5OA/P14FzrQ2JgRQQ7OKmrCbMymJPBvAxGMpgowYguymBJBhMlGJE38lLdci9RZEBszzaDtATuTkkCyhJQEYB4M6MFshKQk4C8pDiJkWSwIINFGSzJYFkGKyLYwUHkTZiVwZwMJosSWcEc+cq3MXbwdW+pJX1xHEgyDPAbszXuxG+d1gJ5CYgkoCAhQjJcZ8lwzVe5pdoFJTFhxNe4DRBf4bZAreGaBUmGa762bYFIApJERJFERJFERJE8uUUwgSdjJCArAZ2NiOVf9uNKvkpx2a6ncrocNz/Thk+o+7iWf7HMLQPzCrXF/wr98U/8C1rfgpZ/+eOmUtrWYHembqCfQPoJZEMrG1cN3m1Ys+wG9zUbX5LT/aVLh/gK6qofz7/743n9/msZCP/xx8tv//jqOCXzjy3na7ZLfnz5R/hG1nrSQS7lqR6XejBs2ZVabKPssnBQT0S0Zle92PyzYfG4YU1s+riYn02XXHtlY/lzey/k6xg+fjZtgZIElCWgIgDxs2kLZCUgJwF5CYgkIElEFElEFElEFElEFElEWGNEKCtCORGKj4ql6lhRy1T9iOKLFlPfLlpGwPiISiJUFqGKBMW7u0sqVb5FBf5elCoqPTJvowiVRKgsQfGWXfKmcujdIxu8Y9dEJREqi1B8bHhf303cO5griv+us4myIpQToXwTFd0j6kCvvKFKfkQlESqLUEWCIiNCuQM7pkYUef+IKhIU/0pqymHNgFOODIp/KinmzTEqj6goQiURild5WShaUYs//4gqEhTvODdRVoRyIhSvV8g1NkJ5fCp5XzalWiukzMzmvC3bQvGubBNlRSgnQnnJk8I7sk1UEKGiCJVEqCxCFQmKf3mpibIiFDWfLyY2+PqziYoiVBKhDsbDWGN+f+zpiuLrtQ+3bUUlS48oEqGCCBVFqCRCZRGqCFDOHMwpdRV4QYVHlBWhnAh1oFeoEZUC06/YHHvtr08l4ydRDuvkv/z9GLfuoMrLdVcCboR3RjLfOSOZ75w1IpQVoZwI5U+jln/lj2sPlliX8mV7S9XbB9kOllibMCeDeRmMZLAgg/Gm6OJ511eNYngsqA7eSW7CsgxWRLCDd5JjSHaD5UeYlcEOmIw1B7YxmYfU+eAt4WVdf+vbfnn8W8e3DSsi2MFbwk2YlcGcDOZlMDqA5bjBHovog7eEm7Aogx1ESd6e7mVN6UkXuA0rItiBE7x0aPfkZOtas69LVK93KdrW9SHk7V3dUB5rdWMHbZcbtF1+0HbRoO0Kg7YrDtquNGi7cq92bd+IRMOsRJWL2uX9rl2lXQXVEnL52z76d9YM2q7QqV3fV40Hq2EDtCsN2q48aLvKmO1yR/lE2CWXkcF5IY6EuCDERSEuCXFZiCsynD8YT7NPW1w9vf76BM4JcV6IIyHuQPeyzbOxxEdn1CcZjg50KHFrZ0mP+QO/89uyiLR9A5os824Fv4naE7ggxEUhLglxWYgrMlwwQpwV4twBri4hL3/nx7wuHMXLFmdp/94tPy/EUtOhWOzuVcnMbmVF2wYKO8vMfrWIhmtRGK5FcbgWpeFalIdrURmtRdEM16KD8Wjb/u7j74eVOnvwNV9ydalu+ZsZ/w6+y0vOb+Omo8c19IMP85q4g2Wj5OKuncy8frBu1MY5Ic4LcQejt6+fcSx/u8d6+WDtqI2LQtzBeOVphwuPcXawfNTGFRnuYAGpjbNCnBPivBB3FC9+j3vMd3IQ4qIQdxQvm2+2/P34POQsxBUZrhghzgpxTojzQtxRvKQdrjyO8yUIcVGIO4gX2s1j5B7nh4PlsjauiHAH7+A8gbNCnBPivBB3EC9k9jjmHZ4gxEUh7iBeXN7mW/Lhj5Y/5229nph57+D9H8F96svuy9+hub7QfpupXNSuQFu7Ht99PHgn6Tf7z93Hvuk+7k338W+6D110nxS3+xT32/F5sJ5zvl1l6/8yJjzeJ17ff/Y+6U33yW+6T3nPfdxF4wfZtN3H//7boO6i8Yb8rv/0+Eascy/oP3cf/6b70JvuE950H8H48ROXhLgsxBWRX+O8EeKsEOeEOC/EkRAXhLgoxCUZTriu5ehAP2PqfLr8HR9xTojzQhwd9K+YHe4xLz9YR2vjohCXhLgsxBUZLhghzgpxToBb/lU+rj6aHOsrX7sH4sNW//kgnYfQeUg4D4nnIek8JJ+HlNOQo0njO4g9Dzmvvj+vvj+vvj+vvj+vvj+vvj+vvj+vPj/luGrIuN0wvkLseYg7D/HnIaz6S9awQnap1goJ5yHxPCSdh+TzkHIawk8g30PseYg7D/HnIefVD+fVD+fVD+fVD+fVD+fVj+fV51eEXa2/XSj/COEXZymsKQPt9thbIf78XXj1Uz2+d/dB2Arhzzuxa8P2X+P9XOd/7MTxJnpH39Ltft4/DMb8Oui3EH4J9HuIPQ9x5yH+PITOQ8J5CH/yTj3mz++3E/yC5POQchrCr05+D7HnIe48xJ+H0HkIKyW5enwhPUjJrz9+D0nnIaz629oauYehhV9w/BZy8HFeA2MFGCfAeAGGBJggwEQBJp2ekw4+Pvoew5djV74S5s3L72Bffgf38jv4l9+BXn6H8PI7xJfe4Y+PhwhOEJwgOEEnIXCC4ATBCYIT9CQEThCcIDhBcILgBMEJghMEJwhOEJyg4Zygn8douaPtheshRmkPDd8YO7+AEv0CYvK1smaQYdcRl+nYBrryBvHVN0ivvkF+9Q3Ki29wcJLGhTewr76Be/UN/Ktv8Oon2b/6SfZXPMn1cNbgyi83eLw2bWcTprL7csdl7pe3LJvsr0eQPl7rbFkHd+dM+eXqfzmyLWfsaNbS0aKko2S0dNRq6ajT0lGvpaOkpaNBS0e1ZEakJTMiLZkRacmMgpbMKGjJjIKWzChoyYyClswoaMmMgpbMKGjJjIKWzCjMkxk5v3WU3D92NM6TGTU6Ok9m1OjoPPNoo6PzjLqpHtfp0u71rbWj84y6jY7OM+p+39E0z6jb6Og8o26jo/PUo42OzlOPNjo6zzza6Og89Wijo/PUo993NM8z6npTP2fwu4Ne147OM+o2OjrPqNvo6DyjrquHfC59fqhe8jyjbqOj84y6jY7OU482OjpPPdro6EQu4LcdLRO5gN93dCIX8PuOzpMZNTo6T2bU6KiWhOHgk7ilxWvbHyueg0/iGpgkwGQBppzH8CeUNDBWgHECjBdgSIARxAF/ckYo677icXdqYMUkASYLMOU8hj9pooGxAowTYLwAQwJMEGAEceAEceAEccB/rNPwdA7Pno51S/K4OxGkopIIlUWoIkEdnAWQ0naEQHmcI45OAmignAjlRSgSoYIIFUWoJEJlEapIUEEUG0EUG0EUG0EUG0EUG0EUGwenRBdTt8gqjkElCergJGFT084lT3scD/lXM5ooXi/r62izhOojyotQJEIFEYrXa+lvRWWGDf758nUiWv58vNfBOcQtlBWhnAjlRSgSoYIIxesVXFU5UHpEJREqi1BFgjo4c7iFsiKUE6H42AixjlEhl0cUiVBBhIoiVBKhsghVJKiD84VbqIMRYJtTvHt8vg7OCG6hSIQKIlQUoZIIlUWoIkAdnQrcQlkRyolQXoQ6iI26j8tSoaVHVBChogiVRKgsQhUJ6uAE3RZKkjkcnW7bQnkRSpI5HJwHmmhN2RLFRwzbvs10LYG5DwkwQYCJAkwSYLIAU85jvKQuOTotsoVyIpQXoUiECiJUFKGSCJVFqCJBkSg2SBQbB9scfDtO8D5SMeuAVByDETzzvK/TuE85j+E9nQbGCjDuPAdBMCYHwZjMOzmllvglPcYO7+M0MEmAaY3JHEYwJvNeUQNjBRhBHERBHERBHETBcxoFc3MUzM1RMDfHs3Hwx8cSysel/FpfLtUByKXstqn92CDxj+Wf///f/v6Xf/v3v/75/y2gj//63//xp//6y9/+4+uf//U//7n+l3//+1/++te//N9//c+//+1Pf/4///33P//rX//2p4//9k/m63/+ORmXfiRDeenJR5yl6O2PFKks//Y//7txy3+37l8+z/f4Zwox/aCQfv4fPxE+LQif/M9+/ezWx3XLuo6zH//Xz55+/JTLP3yuP0M/lnv88fMm/4ig+n85+uF+XhW2/yv98O7j/4obsPxw9PF/pbVXH3ubL+PNVx9i/pHqjd3HbZb7fLV+yRSXf6YPdK7oxVt2hb7QwfyIpqLDcvnnP3+io13+6espuD9bs0xsi+P6hV7Wp3/Yz9v9/I/LVLksua34Ja/+sazqbIen/M4P2K39SxdLWiEl/7DG1yYv//TG7ILw58+mhYUluJYA+18=",
      "brillig_names": [
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "CardNote"
            },
            {
              "fields": [
                {
                  "name": "points",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "DocsExample::simple_macro_example_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "DocsExample::simple_macro_example_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "DocsExample::get_imm_card_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "points",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::card_note::CardNote"
              }
            }
          ],
          "kind": "struct",
          "path": "DocsExample::get_imm_card_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "points",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "DocsExample::initialize_public_immutable_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "DocsExample::initialize_public_immutable_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "points",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "DocsExample::initialize_private_immutable_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "DocsExample::initialize_private_immutable_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "DocsExample::increase_legendary_points_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "DocsExample::increase_legendary_points_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "124": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "126": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "129": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "132": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "141": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "151": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "182": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "184": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "185": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "187": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "188": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "192": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "193": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "196": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "203": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "220": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "265": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "282": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "283": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "284": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "297": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "299": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "300": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "309": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "338": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "339": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "355": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "356": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "358": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "368": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/docs/docs_example_contract/src/main.nr",
      "source": "mod options;\nmod types;\n\nuse aztec::macros::aztec;\n\n/// This is a contract with no real functionality. It is only used in documentation to showcase concepts of Aztec.nr.\n#[aztec]\npub contract DocsExample {\n    // how to import dependencies defined in your workspace\n    use aztec::{\n        macros::{functions::{private, public, utility}, storage::{storage, storage_no_init}},\n        messages::logs::note::encode_and_encrypt_note,\n        note::note_interface::NoteProperties,\n        prelude::{\n            AztecAddress, Map, NoteViewerOptions, PrivateContext, PrivateImmutable, PrivateMutable,\n            PrivateSet, PublicImmutable, PublicMutable,\n        },\n        protocol_types::traits::Hash,\n    };\n\n    // how to import methods from other files/folders within your workspace\n    use crate::types::{card_note::CardNote, leader::Leader};\n\n    #[storage_no_init]\n    struct Storage<Context> {\n        // Shows how to create a custom struct in PublicMutable\n        // docs:start:storage-leader-declaration\n        leader: PublicMutable<Leader, Context>,\n        // docs:end:storage-leader-declaration\n        // docs:start:storage-private-mutable-declaration\n        legendary_card: PrivateMutable<CardNote, Context>,\n        // docs:end:storage-private-mutable-declaration\n        // just used for docs example to show how to create a private mutable map.\n        profiles: Map<AztecAddress, PrivateMutable<CardNote, Context>, Context>,\n        // docs:start:storage-set-declaration\n        set: PrivateSet<CardNote, Context>,\n        // docs:end:storage-set-declaration\n        // docs:start:storage-private-immutable-declaration\n        private_immutable: PrivateImmutable<CardNote, Context>,\n        // docs:end:storage-private-immutable-declaration\n        // docs:start:storage-public-immutable-declaration\n        public_immutable: PublicImmutable<Leader, Context>,\n        // docs:end:storage-public-immutable-declaration\n        // docs:start:storage-minters-declaration\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage-minters-declaration\n    }\n\n    // Note: The following is no longer necessary to implement manually as our macros do this for us. It is left here\n    // for documentation purposes only.\n    impl<Context> Storage<Context> {\n        fn init(context: Context) -> Self {\n            Storage {\n                // docs:start:storage-leader-init\n                leader: PublicMutable::new(context, 1),\n                // docs:end:storage-leader-init\n                // docs:start:start_vars_private_mutable\n                legendary_card: PrivateMutable::new(context, 3),\n                // docs:end:start_vars_private_mutable\n                // just used for docs example (not for game play):\n                // docs:start:state_vars-MapPrivateMutable\n                profiles: Map::new(\n                    context,\n                    4,\n                    |context, slot| PrivateMutable::new(context, slot),\n                ),\n                // docs:end:state_vars-MapPrivateMutable\n                // docs:start:storage-set-init\n                set: PrivateSet::new(context, 5),\n                // docs:end:storage-set-init\n                private_immutable: PrivateImmutable::new(context, 6),\n                public_immutable: PublicImmutable::new(context, 7),\n                // docs:start:storage-minters-init\n                minters: Map::new(\n                    context,\n                    8,\n                    |context, slot| PublicMutable::new(context, slot),\n                ),\n                // docs:end:storage-minters-init\n            }\n        }\n    }\n\n    // docs:start:initialize_public_immutable\n    #[public]\n    fn initialize_public_immutable(points: u8) {\n        let mut new_leader = Leader { account: context.msg_sender(), points };\n        storage.public_immutable.initialize(new_leader);\n        // docs:end:initialize_public_immutable\n    }\n\n    // docs:start:read_public_immutable\n    #[utility]\n    unconstrained fn get_public_immutable() -> Leader {\n        storage.public_immutable.read()\n        // docs:end:read_public_immutable\n    }\n\n    // docs:start:initialize-private-mutable\n    #[private]\n    fn initialize_private_immutable(randomness: Field, points: u8) {\n        let new_card = CardNote::new(points, randomness, context.msg_sender());\n\n        storage.private_immutable.initialize(new_card).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n    }\n    // docs:end:initialize-private-mutable\n\n    // docs:start:state_vars-NoteGetterOptionsComparatorExampleNoir\n    #[utility]\n    unconstrained fn read_note(comparator: u8, amount: Field) -> BoundedVec<CardNote, 10> {\n        let mut options = NoteViewerOptions::new();\n        storage.set.view_notes(options.select(CardNote::properties().points, comparator, amount))\n    }\n    // docs:end:state_vars-NoteGetterOptionsComparatorExampleNoir\n\n    #[private]\n    fn increase_legendary_points() {\n        // Ensure `points` > current value\n        // Also serves as a e2e test that you can `get_note()` and then `replace()`\n        // docs:start:state_vars-PrivateMutableGet\n        let card = storage.legendary_card.get_note().note;\n        // docs:end:state_vars-PrivateMutableGet\n        let points = card.points + 1;\n        let new_card = CardNote::new(points, card.randomness, context.msg_sender());\n\n        // docs:start:state_vars-PrivateMutableReplace\n        storage.legendary_card.replace(new_card).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n        // docs:end:state_vars-PrivateMutableReplace\n    }\n\n    // docs:start:private_mutable_is_initialized\n    #[utility]\n    unconstrained fn is_legendary_initialized() -> bool {\n        storage.legendary_card.is_initialized()\n    }\n    // docs:end:private_mutable_is_initialized\n\n    // docs:start:get_note-private-immutable\n    #[private]\n    fn get_imm_card() -> CardNote {\n        storage.private_immutable.get_note()\n    }\n    // docs:end:get_note-private-immutable\n\n    /// Macro equivalence section\n    use dep::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs;\n    use dep::aztec::context::inputs::PrivateContextInputs;\n    // docs:start:simple_macro_example\n    #[private]\n    fn simple_macro_example(a: Field, b: Field) -> Field {\n        a + b\n    }\n    // docs:end:simple_macro_example\n\n    // We mark the following function as a contract library method because it is mandatory that a contract function has\n    // a macro applied to it. Since this function is not used and is only for documentation purposes, we mark it as a\n    // contract library method to avoid compilation error.\n    #[contract_library_method]\n    // docs:start:simple_macro_example_expanded\n    fn simple_macro_example_expanded(\n        // ************************************************************\n        // The private context inputs are made available to the circuit by the kernel\n        // docs:start:context-example-inputs\n        inputs: PrivateContextInputs,\n        // docs:end:context-example-inputs\n        // ************************************************************\n        // Our original inputs!\n        a: Field,\n        b: Field, // The actual return type of our circuit is the PrivateCircuitPublicInputs struct, this will be the\n        // input to our kernel!\n        // docs:start:context-example-return\n    ) -> PrivateCircuitPublicInputs {\n        // docs:end:context-example-return\n        // ************************************************************\n        // The hasher is a structure used to generate a hash of the circuits inputs.\n        // docs:start:context-example-hasher\n        let mut args_hasher = dep::aztec::hash::ArgsHasher::new();\n        args_hasher.add(a);\n        args_hasher.add(b);\n        // docs:end:context-example-hasher\n        // The context object is created with the inputs and the hash of the inputs\n        // docs:start:context-example-context\n        let mut context = PrivateContext::new(inputs, args_hasher.hash());\n        // docs:end:context-example-context\n        // docs:start:storage-example-context\n        let mut storage = Storage::init(&mut context);\n        // docs:end:storage-example-context\n        // ************************************************************\n        // Our actual program\n        let result = a + b;\n        // ************************************************************\n        // Return values are pushed into the context\n        // docs:start:context-example-context-return\n        let mut return_hasher = dep::aztec::hash::ArgsHasher::new();\n        return_hasher.add(result);\n        context.set_return_hash(return_hasher);\n        // docs:end:context-example-context-return\n        // The context is returned to be consumed by the kernel circuit!\n        // docs:start:context-example-finish\n        context.finish()\n        // docs:end:context-example-finish\n        // ************************************************************\n    }\n    // docs:end:simple_macro_example_expanded\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "85": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "86": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "91": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
