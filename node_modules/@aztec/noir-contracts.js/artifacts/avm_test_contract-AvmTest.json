{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "AvmTest",
  "functions": [
    {
      "name": "n_new_note_hashes",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "num",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQdAIBEgEQELgiARAABJQAAAEwlAAAATSgCAAEEgEUnAgIEADsNAAEAAiYlAAAAjycCAwQAJwIEBAEtDAMCIwAAAGUMOAIBAyQCAAMAAAB4IwAAAHcmHAwCAwAyAgADADgCBAMtDAMCIwAAAGUoAIAEBHgADQAAAIAEgAMkAIADAAAAtyoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "lZFRC4MgFIX/y332Qesaq78yIqwsBNEwG4zov89aI1nrYS/ilfMdD+fO0Mp66itlOjtCcZ9B20Z4ZU2Y5oVA7ZTWqq/iZ6DrwSjbgHEQZp1HL5yHgiGlKQFp2vc9Cyad0hIKTpeSAEvoBYZ4YBxPGL/AEnZgmMYYOcmR40eNPDuiZeyHOEeW7+IcOYvFW6D870DlEqaHcErUWu4Fd5Npor79c5Bf1Q/ONrKdnFyXEPcf/k9uJE2DbbB+AQ==",
      "brillig_names": [
        "n_new_note_hashes"
      ]
    },
    {
      "name": "elliptic_curve_add",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "lhs",
            "type": {
              "kind": "struct",
              "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
              "fields": [
                {
                  "name": "x",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "y",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_infinite",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "rhs",
            "type": {
              "kind": "struct",
              "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
              "fields": [
                {
                  "name": "x",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "y",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_infinite",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "is_infinite",
                "type": {
                  "kind": "boolean"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABAMnAgcEBicCCAQAHxgACAAHgEQdAIBGgEYBHQCASYBJAS4IgEQAAS4IgEUAAi4IgEYAAy4IgEcABC4IgEgABS4IgEkABiUAAACDJQAAAIsuBAABgEouBAACgEsuBAADgEwoAgAEBIBKJwIFBAM7DQAEAAUoAIBDBAADJiUAAAFMJAIAAwAAAS4jAAAAnSQCAAYAAAEMIwAAAKotCAENJwIOBAQAEAEOAScDDQQBACgNAg5CP8AAAQACAAMABAAFAAYADicCAQQBADgNAQMtDQMCJwIBBAIAOA0BBC0NBAMBKAANgEMABC0NBAEtDAIKLQwDCy0MAQwjAAABHS0MAQotDAILLQwDDCMAAAEdLQwKBy0MCwgtDAwJIwAAAT8tDAQHLQwFCC0MBgkjAAABPy0MBwEtDAgCLQwJAyYoAIAEBHgADQAAAIAEgAMkAIADAAABdCoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "1ZbRCoMgGIXfxWsvtNSyVxljWFkIYmE1GNG7z2KFzLH7/yb65Xj4OKCeFbW6XvqHcd0woeq2Ijs0ajaDC9O6YVR7Y63pH/EyIvuHFuTYMI3K7fM0Kz+jilLOJUbatcd/wYJJZ6xGVcY3nMoZKU41y8tLTMUPsSDstBZEkv9iGhQXCJFcxPI7DvwMOL+EzV8Cz78Enr+EnX9GKSh+mfAL2PwZ8PwzDps/h/X+pvzQ84d1/yf8rADMv4XpqbxRtdWfqtotroma6/wa9VeJHf3Q6Hbxeq+zUZPdD5LIsSiDbbB+Aw==",
      "brillig_names": [
        "elliptic_curve_add"
      ]
    },
    {
      "name": "assert_same",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "2716768074203347595": {
            "error_kind": "string",
            "string": "Values are not equal"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAAUSUAAABSLgQAAYBGKAIAAgSARicCAwQBOw0AAgADJiUAAABvCjgBAgMkAgADAAAAaSUAAACYJwIBAAEmKACABAR4AA0AAACABIADJACAAwAAAJcqAQABBfeh86+lrdTKPAEBAiYqAQABBSWz5itgAzqLPAEBAiY=",
      "debug_symbols": "lY/dCsMgDIXfJddeqND151XGKLZNiyAq/gyG+O4zY7Cyu96EnJCTk6/Ahks+Zm13F2G6FzBuVUk721SpDJagjdHHfB4DpzL0n/3olSUZkwoJpqETggHajVrZtQu7NghTx+uDwSivewTnV021qacKWi0Gvxx7tusJK708/hH64FbcckBi/WEKSpeCyRv9Ikj0TI4to+W8AQ==",
      "brillig_names": [
        "assert_same"
      ]
    },
    {
      "name": "elliptic_curve_add_and_double",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "is_infinite",
                "type": {
                  "kind": "boolean"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAUSUAAABSLgQAAYBELgQAAoBFLgQAA4BGKAIABASARCcCBQQDOw0ABAAFJiUAAAC3JwIBAQAsAgACAClBsJKN8blIAnN3OzY5faPklUMKKno4V2Ybx6RGyU9NLAIAAwATrn6TjIkjCL7w9F7nOG2qLTtEc0mn0KEbWqTPvmkHLC0MAQQtDAIBLQwDAi0MBAMmKACABAR4AA0AAACABIADJACAAwAAAN8qAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "XYzBCoAgEET/Zc8dKrrUr0SE2iYLomIahOy/p9AhvAy8ecxkOFAmvZM93QXLmsE4JSI5WyhzBzKQMaT3pr5FICENfngmq342Ph6bvQ9O4ZEC1qfqoK8xlFzHqRvnjZk3fgE=",
      "brillig_names": [
        "elliptic_curve_add_and_double"
      ]
    },
    {
      "name": "note_hash_exists",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "note_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAAUSUAAABSLgQAAYBGKAIAAgSARicCAwQBOw0AAgADJiUAAABkMTgAAQACAAMtDAMBJigAgAQEeAANAAAAgASAAyQAgAMAAACMKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "bY/RCoMwDEX/Jc99aFanq78iQ6pGKZRWah0M8d9XZW5l8yXkhsMlZ4GOmnmote3dBGW1gHGtCtrZmJaVQeO1MXqo0zPwbdyKnZ9GZbc4BeUDlChEXjAg2+27xNjRa0NQXvnK/nHk2UFjJj5wjiewFHjAUuQ8he9rTA/ltWoMvV/vZ9smJuE50o/U6F1L3exp0/uaYZwVSnbJYm2sfgE=",
      "brillig_names": [
        "note_hash_exists"
      ]
    },
    {
      "name": "n_new_nullifiers",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "num",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQdAIBEgEQELgiARAABJQAAAEwlAAAATSgCAAEEgEUnAgIEADsNAAEAAiYlAAAAjycCAwQAJwIEBAEtDAMCIwAAAGUMOAIBAyQCAAMAAAB4IwAAAHcmHAwCAwA0AgADADgCBAMtDAMCIwAAAGUoAIAEBHgADQAAAIAEgAMkAIADAAAAtyoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "lZHRCoMgGIXf5b/2IstMe5UxwspCEA2zwYjefdYayVoXuxF/Od/xcP4ZWllPfaVMZ0cobzNo2wivrAnTvCCondJa9VX8DMl64ARvwDgIs86jF85DiQkmBIE07fteBJNOaQllnix3BDhNLjCWHxjPT1h+gdH0wBiJMXSSkyL9qEkRRaP4h5jTjO5iTimLxVsg/neg+xKmh3BK1FruBXeTaaK+/XOQX9UPzjaynZxclxD3H/5PGcqyYBusXw==",
      "brillig_names": [
        "n_new_nullifiers"
      ]
    },
    {
      "name": "read_storage_map",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHxgAAwACgEcuCIBHAAElAAAASyUAAABoLgQAAYBIKAIAAgSASCcCAwQBOw0AAgADKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACCycCAgAALQgBAycCBAQEABABBAEnAwMEAQAoAwIELQwEBS0OAgUAKAUCBS0OAgUAKAUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUAEAEGAScDBQQBACgFAgYtDAYHLQ4CBwAoBwIHLQ4CBwAoBwIHLQ4CBwAoBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgqARQAFLQgBBgAAAQIBLgqARAAGJwIHAAQnAggECS0IAAktDAQKLQwDCy0MBQwtDAYNLQwHDgAQAAgAJQAAAjQtBAAAJwIHBAgtCAAILQwECS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAAI0LQQAAC0NBgELKAABgEQAByQCAAcAAAGkJwIIBAA8CQEIJwIBBActCAAHLQwECC0MAwktDAUKLQwGCwAQAAEAJQAAA2ItBAAALQ0DAQEoAAGARgAELQ0EAwo4AwIBCygAAYBEAAIkAgACAAAB9SUAAAR1LwwAAwABHAwBAwQcDAMCABwMAgEEJigAgAQEeAANAAAAgASAAyQAgAMAAAIzKgEAAQX3ofOvpa3UyjwBAQImJQAAAgstDQMGLQ0EBwsoAAeARAAIJAIACAAAAlonAgkEADwJAQkLKAAGgEMAByQCAAcAAALuIwAAAm8tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAonAgsBASQCAAoAAAKZJQAABIcuBAAGgAMoAIAEBAAEJQAABJkuCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiARgAFDjgIBQYkAgAGAAAC2SUAAAUnLQ4KAS0OBwItDgUDLQ4JBCMAAANhJwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAAA2ItBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAASZLgiABQAJACgJAgoBKAAKgEUACy0OBQstDgkBLQ4HAi4KgEYAAy0OCAQjAAADYSYlAAACCy4IgEUABSMAAANyDSgABYBDAAYkAgAGAAAD4iMAAAOHLQ0BBS0NAgYtDQMHLQ0ECC0NBgkAKAkCCS0OCQYnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARgAGJAIABwAABAAjAAAEbC0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAABJkuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAEbC0MBgUjAAADcioBAAEFAtxuJ4B2Ep08AQECJioBAAEFxWvEWg4QAAI8AQECJi4BgAOABgsAgAYAAoAHJACABwAABLQjAAAEvy4AgAOABSMAAAUmLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABRIuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAABOEoAYAFBAABAwCABgACgAYjAAAFJiYqAQABBUWnynEZQeQVPAEBAiY=",
      "debug_symbols": "7Z1tbxoxDMe/C695ESexE/erTNNEWzohIVrRdtJU9bvvQNzBONMM5zQJxW8qrviPfb9L4sT39DF7XN6///yx2jw9v87uvn3M1s8Pi7fV86bb+vicz+63q/V69fPH6b9nbvcHHO8Fry+LzW779W2xfZvdhRDjfLbcPO4+Yu5+4mm1Xs7u0H3OR8bgKByMASAMxoAoWSMdjL3zg22AJNgmjngwTsxHa5+lOAL6g3EEOto6ydYDQx+Gd1ywRs8HYwzuL9vv8xlANIS1CLMhrETogyGsRWitsBZhsFZYjdBaYS3C6A1hLUIyhJUIEQxhLUI0hJUIyRnCWoTREJYRcjoYE+AIYbaOXI3QKjW1CNk6cjVCa4WVCL2zVliN0FphLUKwSk01wmQIKxF6q9RUI7RKTS3CYJWaaoS2wKtFGK1SU40wGsIzhHssdkpJwoI2BRax2LRWwkI2SRCx2PRTwpIsmYtYLEGLWKyeJWGxs0YyFmstEhY7uyNhCa7RTNR1kz6McBLHgKXRsaWABay1iFgaHVtKWBotLBSwtHpWo4Sl0aViAUuwIVfEYkOuiKXRyX8BS6uV/xIWS9ASllYr/yUsjVb+C1harfyXsNgKWsRiCVrCkmzIFbHYkCthybaCFrFYa5GwcKMJOsEQRjq7b+066z3ERtP5VRCByPV7SCmfQ4yu0Sw3KUSw7jwBxEaLrZNC9I2WZq+DmNKwh4n9GKIllgkgNrqqnBRiq08nmhZio2uQSSFGm+JMANESSz1EtCnOBBCtJU4A0aY49RDJpjj/AJFdX08E9mOIybLzBBAnGBMh596Fj1iAiMj9Yp6yj4M1s0SR+oum08m6HyjuY8/uhmPPtxs7083Gjq48aCRfin3o2gDJ/eVCCCeHPvaUEQZrAjH24RF3iSh/bdzFwcfRCz2dmu/3Nf33ffXHfSUqhc/DT3s4gukazz568Dcd/U2zl6+OAOf7NNUlztF9/ShfPFBUiaS6bDzUfCGOar4o33RWUnFQqbJCRc7LKhpoQB7RIPkB8RCGByp0H8e+fNKo5AeqFFWoUrFGFVX7hV6jkh/BWlTJNHDojIAxjVTy1LWoyhpVDioVa1TyzX1FlcZXchf2i4b5LubRfXYJQKUijcpHlYo1qqCiIVeJS6qoYogX+tdxfRJ8HqtQpWKNioJKlTSqCyNASaWikVXks86XijyryLOGfHYXyA8zMwiYxqqkUck3JBZVrFF51KiCU6myRhU1eTnL7zgoqdCpVCpf8mWQKfYTvRTpXMNy9joWjRjzWJOu18j5rqBBhYav13gFA/ntP19rglesS/hCbiyoLuTGkoo0KlT5QpUvUvkila+k8pVUxyurfF3IjSWVZlXN8pz669FFXrF2A0jfS/xIA04xJHWxR4UnrwlP7sUlESlE8iMeCyAiKkSo8YQy8qGuwAkFEStEpPFEpRFaEiVN20usEGVSiBg0ouvTNYBcNSqJNJ4UM4NOgxqR4jjB1ZODz27z12K7Wtyvl4c3qj69bx5OXrD69vtlefau1Zft88Py8X273L119fjC1V239MHPPYb9oew2ux4+747pPrbdtxi7b6nz2nn+Aw==",
      "brillig_names": [
        "read_storage_map"
      ]
    },
    {
      "name": "set_opcode_u32",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABVKQIAAQRAAAAAJigAgAQEeAANAAAAgASAAyQAgAMAAAB9KgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "XYzBCoAgEET/Zc8dskOHfiUi1DZZEBXTIGT/PYUO4WXgzWOmwIEqm53c6S9Y1gLWa5nIu0qFB1CRrCWzd/UtI0ll8cMzO/2z6QnY7UP0Go8csT01B2MLUXMV8zCJjZk3fgE=",
      "brillig_names": [
        "set_opcode_u32"
      ]
    },
    {
      "name": "set_opcode_big_field",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABrLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADLACAQwAAAAAAAAAAAAAAAAAAAACZEjRWeJCrze8SNFZ4kKvN7yYlAAAAdy4IgEMAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAnyoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "XYzBCoAgEET/Zc8dqkvQr0SE2ioLomIahOy/p9AhvAy8ecwUOFFmc5DT/oJ1K2C9Eom8q1R4ABnJWjJHV98ikpAWP9TZqZ9NT8BuH6JXeOaI7ak5GFtMNbdpGeZ5Z+adXw==",
      "brillig_names": [
        "set_opcode_big_field"
      ]
    },
    {
      "name": "get_address",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQAmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/dCoMwDIXfJde9aKStP68iQ6pGKZRWah0M8d1XRTbZvAk54eOQb4We2mVsjBv8DFW9gvWdjsa7lNaNQRuMtWZsrmfg+8jlwc+Tdnucow4RKsSSSwbk+mPPZOoYjCWoJN/YHy5Knp+0KFF9YIU3cCFEccKFUOIKP7aUnjoY3Vo6Xx8W111M4muiH6kp+I76JdCu9zXDNGtULMNUm6rf",
      "brillig_names": [
        "get_address"
      ]
    },
    {
      "name": "create_different_nullifier_in_nested_call",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nestedAddress",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAASyUAAABxKAIAAQSARicCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABqDQCAAInAgMAAQA4AgMEKQIAAgDZfQyKJwIFBAInAgcEAwA4BQcGLQgBAwAQAQYBJwMDBAEAKAMCBi0OBQYAKAYCBi0OBQYnAgYEAwA4AwYFLQwFBi0OAgYAKAYCBi0OBAYnAgIEAgAoAwIGLQ0GBScCBwQCADgGBwQ5A4iAQ4BDAAEABAAFIAIAASECAAInAgMEAC0IAQUAKAUCCC0NCAcnAgkEAgA4CAkGIjwAAwACAAYtDAIHJwIJBAMAOAcJCAAQAQgBJwMFBAEAKAUCCS0OBwkAKAkCCS0OBwktDAcEBigEAgQkAgABAAABkSMAAAFoLQ0FAQAoAQIBLQ4BBQAoBQIGLQ0GAicCBwQCADgGBwE8DQECIwAAAZEKOAQDASQCAAEAAAGnJwICBAA8CQECJigAgAQEeAANAAAAgASAAyQAgAMAAAHQKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1ZrdiuowEMffpddeZD6STHyVw2GpWpdCqVL1wEF899MWW4t6Vlh2tzM3YmQy8//NSCZpc842xer0/lbW290hW/46Z9VunR/LXd2OzpdFtmrKqirf36Y/Z677AJB+wmGf1934cMybY7YE8QiLrKg3/Xem1sm2rIps6d1l8WDOEfFqzZHjaBzgiXEKFK7GKQSZGv9eZID4XFBwfhQUQKaC+mnxU9PoP9F84Ns05I/xARDiYA7I/mZOT8zJ8ZBbcj7cJ4BBn6SgTpLXlyWvL0vB6ZPk1UmK+rIUFWYpqZMkrE+SqJOUSJ8kdVlCp24ngE5dQ0FQ13YRZlkq02BNGMPHG15wbYcZfDskvidAZ57Afg2SdQJi8wTma+DnaCIUZCAgwVcEkWgkiP6RYI6ewzRklfjV4wNw4sJIIOTuCWY58zDAjUBeESQYH0q45OWBwJsnSNYJIpsnEOsEQuYJrNeAnPXVtD0yWCcA8zUA8zVA8zVA+zWwvqugWc5oX0tgvqMxWidQdsLpJen6Y/eSdK0WnaQ4x4bW4+Cc/MvDNVCS0TcjPRCIdQJB8wTROkGyXgN2X/MehIRvURxOCfoo4SeiAP9IlPTtUS7t6E/elPmqKq43n7anej25CHX8uy/u7kTtm9262JyaorsdNbkY1fXYGBeCrdvW9T8=",
      "brillig_names": [
        "create_different_nullifier_in_nested_call"
      ]
    },
    {
      "name": "enqueue_public_from_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7VbRasMwDPwXP+fBkm3Z6q+MMdI2LYGQlDQdjJJ/nx1qt2uyjrCuUNhLiOw76yQfto9iXSwP27ey3jR7sXg5iqpZ5V3Z1D46ClDD2H6X1yHcd3nbiQVqB5ko6rX/JVB9JjZlVYgFU5+NwBpAn8AajExgkv1rJkD/dQIzlQAcm0gCluASKywwgrNx6oRmUucURk2AlXVRjoIEBcWDHLqHHNIyyXH2thxgwy6tTWAuGzSGI2hDsfegnbnup332AtzjC7Ao09rOqtsFsDERDOguDGQH+Twpn6XGlMLzfpAPFNGMkn/hZ5T3kIPASQ7RQ+2A8OwF4OMLuJuffbRsy6oqt29f7h0ZPnry6DYqXg3G0rUdNc2n2PkUN5/CMyk+guEGniRqGzeXUI9aiv/d8+F73pb5siqCocLsoV5Ff/mw+9jFmejAXdusivWhLYIXzzYMTyCFmcZw+objzkBm6LxBYQghQ0qt/47Re2Gf",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "n_new_l2_to_l1_msgs",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "num",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQdAIBEgEQELgiARAABJQAAAEwlAAAATSgCAAEEgEUnAgIEADsNAAEAAiYlAAAAkScCAwQAJwIEBAEtDAMCIwAAAGUMOAIBAyQCAAMAAAB4IwAAAHcmHAwCAwA4DAADAAMAOAIEAy0MAwIjAAAAZSgAgAQEeAANAAAAgASAAyQAgAMAAAC5KgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "lZHfCoMgGMXf5bv2wj+rrFcZEVYWgliYDUb07tOI5la72I145PyOH+dboJX13FfKdMMExX0BPTTCqcF4tawIaqu0Vn0VPwMOB8FkA6ZRmKAnJ6yDgtwo5wikabd7TnxIp7SEIsFriYBQfI2xhB4YS+kJS35gOH1jlMcYOtlpdmO7m2YcH+aUXJjznB/RGLMPd5iIkb8nKlevHsIqUWu5N9zNpokKd89RfnU/2qGR7Wxl2EK8AP8/5YgxH+ujXw==",
      "brillig_names": [
        "n_new_l2_to_l1_msgs"
      ]
    },
    {
      "name": "emit_public_log",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "emit_public_log"
      ]
    },
    {
      "name": "get_chain_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQMmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoQgEEX/ZZ590BYt+5VYwmoKQTTMFpbo31ejJdntZZg7HC5zNhiwW6dW29EtUDcbGNeroJ2NadsJdF4bo6c2PwNNo+QHv8zKprgE5QPUrGDlgwDa4dgrGTtGbRBqTnfyh3Mp5UkLSi9YsBu4EvxbXYmS5vBzj+mlvFadwfP1cbV9ZhLeM/5Izd71OKwek95lxuJsmCAFi7Wx+gM=",
      "brillig_names": [
        "get_chain_id"
      ]
    },
    {
      "name": "n_new_public_logs",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "num",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQdAIBEgEQELgiARAABJQAAAEwlAAAATSgCAAEEgEUnAgIEADsNAAEAAiYlAAAA5ScCAwQAJwIEBAEtDAMCIwAAAGUMOAIBAyQCAAMAAAB4IwAAAHcmHAwCAwAnAgYEAScCCAQDADgGCActCAEFABABBwEnAwUEAQAoBQIHLQ4GBwAoBwIHLQ4GBycCBwQDADgFBwYtDAYHLQ4DBwAoBQIHLQ0HBicCCAQCADgHCAM3DQADAAYAOAIEAy0MAwIjAAAAZSgAgAQEeAANAAAAgASAAyQAgAMAAAENKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "zZbdaoQwEIXfJddeJDG/vkpZlqhxCYQoUQtFfPfG7daG2l4s7IA34sic+eZICGdBra3n29WFrh9R9bYg3zdmcn1I1bIWqI7Oe3e75p8R3h4Ek7tgHEzY6nEycUIVYUzwAtnQfr2rNKRz3qKK4/VSIELx3zJOyS7jJTnI+D80Vf7IsMhlxaFdKfFo1hTvrYLcCSUGJ4B7YOAeGAMnaGgCB/fAwT2IEpygoAmSghMkNEGBe1ACmqBfcmtIvBPKnHBs1ZKq717J9WEdfq519JnWoZida51z/R3y/Nm5rKl6N9GZ2ttH7Onm0GQpaPoY7K9ANMS+se0c7RaN8lSU+EwUnKSxafQn",
      "brillig_names": [
        "n_new_public_logs"
      ]
    },
    {
      "name": "emit_nullifier_and_check",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2749144489913102783": {
            "error_kind": "string",
            "string": "Nullifier was just created, but its existence wasn't detected!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABvNAIAAR4CAAIAMzgAAQACAAMnAgEBASQCAAMAAABuJQAAAJgmKACABAR4AA0AAACABIADJACAAwAAAJcqAQABBfeh86+lrdTKPAEBAiYqAQABBSYm7FkVfjG/PAEBAiY=",
      "debug_symbols": "nZLbqoMwEEX/Jc95cOLk5q+UQ/ESS0CiRD1wEP/9JEWr2Bvty5AJezIrmz2RyhTj5Wxd3fYkO02kact8sK0L3TRTUnjbNPZy3l+TJBbJr/q+y11s+yH3A8mAAzBKjKuu5xTDG7VtDMl4MtM7OUq2qlGivIkFPBBrkYpFrIVQe/EPJVI/5mEJ3ngYe8ejE7nyaBCveRSiWsQKBR54FD7xR6jNH81e8wCXKw+INH3jD0/Xr+owd+DR7Ik/uPMnQmw8cUp+MwUJ/3xsDt1v7m1eNGZJXz26chfG4a8zh1x2vi1NNXoTE7qFE0I9MaBMRBqIjaRMhx1hzz8=",
      "brillig_names": [
        "emit_nullifier_and_check"
      ]
    },
    {
      "name": "set_read_storage_single",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAASyUAAABMLgQAAYBFKAIAAgSARScCAwQBOw0AAgADJiUAAABjJwICAAEwDAABAAIvDAACAAEmKACABAR4AA0AAACABIADJACAAwAAAIsqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "5ZPdaoQwEIXfJde5yORfX2VZlqhxCYQoUQtFfPfGoqltZX2AvRlmwsfJnGFmRo2tpufDhbYbUHmbke9qM7oupGpeMKqi8949H8dnRNag4ZsfehPWchhNHFFJOWUY2dCsKWdJoXXeolKQBf+DgRPYYOBUZRgkP6E11XSjNSM80xLOYKLFDgOTr2EASXbplB/aTvgdIy3fxmpBz60Kma0qcWEVuMg/KHJhVSWDG620gNfdK0mLHZZSX1nlBcuNCPprMvclVR8mOlN5u+16O4X6sPrjZ2//XEEfu9o2U7TrPfycAqR4gwJTnmST9Bc=",
      "brillig_names": [
        "set_read_storage_single"
      ]
    },
    {
      "name": "new_note_hash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "note_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABQMgIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAeCoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "bY/RCoMwDEX/Jc99WGZT0V+RIVWjFEortQ6G+O+r4jbZ9hJyw+GSs0DHzTzUxvV+grJawPpWR+NdSssqoAnGWjPU5zNctpHTzk+jdlucog4RSsyIUAC7bt/zLHX0xjKUdFnFDy5JvmhJSr1hhX/gQmJxwIUkPMO3NaW7DkY3lo/X+9m1J5P4GPlLagy+5W4OvOl9zDDNCpW4YqpN1U8=",
      "brillig_names": [
        "new_note_hash"
      ]
    },
    {
      "name": "u128_addition_overflow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACBKwIAAQb/////////////////////JwICBgEAOAECAw44AQMEJAIABAAAAHwlAAAAqi0MAwEmKACABAR4AA0AAACABIADJACAAwAAAKkqAQABBfeh86+lrdTKPAEBAiYqAQABBUWnynEZQeQVPAEBAiY=",
      "debug_symbols": "nVHRCoMwDPyXPPfBdOuc/ooMqRqlUFqpdTCk/762DCZ7W1+OXMjlQu6AiYZ96ZWZ7QZtd4C2o/TKmsiOwGBwSmu19Oc2VAlqkee3VZpENy+dhxZRiIYBmSnX9TXumJUmaLkIDwbNrUSFFZbJytywzA2b/2Uhsqd0Sg6aPi+fdzOeEvCvlX7CWJ0dadodpVi+iWDEjnPG63xNInd2qaJH9HkD",
      "brillig_names": [
        "u128_addition_overflow"
      ]
    },
    {
      "name": "get_version",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQQmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99MJW24q/IkKpRCqWVWgdD/PdVcVvZ9hJyw+GSs8FA3Tq1xo1+gbrZwPpeR+NdStvOoAvGWjO1+RmKYyhx8sus3RGXqEOEGjkXJQNyw7nLKnWMxhLUotjZDy5RvmiJir9hiX/gSqG44EqVmMO3PaW7DkZ3lq7Xx9X1mUl8zPQlNQff07AGOvQ+Zphmg5JxTLWp+gk=",
      "brillig_names": [
        "get_version"
      ]
    },
    {
      "name": "nested_call_to_add_n_times_different_addresses",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "addrs",
            "type": {
              "kind": "array",
              "length": 23,
              "type": {
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBcJwAABAMnAgIEFycCAwQAHxgAAwACgEUoAgABBIBFJwIDBBctCAECJwIEBBgAEAEEAScDAgQBACgCAgQuBAABgAMuBAAEgAQuBAADgAUlAAAAfi0MAgElAAAAxCUAAADxKAIAAQSAXCcCAgQAOw0AAQACAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAADDLgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAACSJiwAgEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAoAIBEBAADJiUAAAKSJwIDAAEnAgQAAikCAAUAqmNIoScCBwQDJwIJBAMAOAcJCC0IAQYAEAEIAScDBgQBACgGAggtDgcIACgIAggtDgcIJwIIBAMAOAYIBy0MBwgtDgUIACgIAggtDgMIACgIAggtDgQIJwIDBAAnAgQEFycCBQAAJwIHBAEtDAMCIwAAAXkMOAIECCQCAAgAAAGMIwAAAYsmACgBAgkAOAkCCi0NCggKOAgFCSQCAAkAAAKEIwAAAawtDQYJACgJAgktDgkGACgGAgstDQsKJwIMBAIAOAsMCTkDiIBDgEMACAAJAAogAgAIIQIACS0IAQsAKAsCDi0NDg0nAg8EAgA4Dg8MIjwAAwAJAAwtDAkNJwIPBAMAOA0PDgAQAQ4BJwMLBAEAKAsCDy0ODQ8AKA8CDy0ODQ8tDA0KBigKAgokAgAIAAACaSMAAAJALQ0LCAAoCAIILQ4ICwAoCwIMLQ0MCScCDQQCADgMDQg8DQgJIwAAAmkKOAoHCCQCAAgAAAJ/JwIJBAA8CQEJIwAAAoQAOAIHCC0MCAIjAAABeSgAgAQEeAANAAAAgASAAyQAgAMAAAK6KgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1ZrdjqpADMffhWsuptN2PnyVk80GFTckBA3qSU6M736ACLiyrokh2t4YRzvMj3+Ydkp7Stb58vj1WVSb7T5Z/Dkl5XaVHYpt1YxO5zRZ1kVZFl+f1z8npv2w5LoJ+11WteP9IasPyQI8I6ZJXq277943F9kUZZ4s2JzTiXnAwBfrQICjMf5gjIbgYoyG3WDs4PyRJpZBGpA0hRwLA/JGGpA0hYI0hQJJA4rCgKI0haIwhdCgNKAgDAisNCAvDMhKU8gKi/aIwkIHorDgiijNMZKw0IH+zrZv/hiAyLproHZavLMXiO04zZmbaWTguWnPrQZ39gdd3Rsb97vYkd3FOEYYTK2z3RJWWFwhFOY1CYXFFaI3ZJGxf+DQ+m9AU2Mw4E0PYizShN/p5mejnJ918zvl+vvX5xboQs+PwT7i9yOI8Tzlf71DJOwVbQ4g/hF/MG7gD2hu+cPr/ScBjPzhEX8EHvgjhwk/6+aPRjk/KeePqvnZ6Nafwenmt7r9J1vl+qNy/VG5/qRcf9J9fmDWfX5gVh6/OOjm95L8TwsUJD3QHZAkD9EBvf7IypZ6IH6YcgLGPsEGIIu3/G9IGeblD6r53RvKufPyK9d/ntosD+/VAgf3Oz94N17ajw6FXAc0T212RqB5SqFzArEwoCcqjx/nZvQ3q4tsWeaXfsHNsVpdtQ8e/u3ym07CXb1d5etjnbc9hWM7YetCLKaIDUxXmANrUrDcLNIs9B8=",
      "brillig_names": [
        "nested_call_to_add_n_times_different_addresses"
      ]
    },
    {
      "name": "nested_static_call_to_set_storage",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABlKAIAAQSARCcCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABmB4CAAEAJwICABQpAgADAITxfm8nAgUEAicCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBgQDADgEBgUtDAUGLQ4DBgAoBgIGLQ4CBicCAgQCACgEAgYtDQYFJwIHBAIAOAYHAzoDiIBDgEMAAQADAAUgAgABIQIAAicCAwQALQgBBQAoBQIILQ0IBycCCQQCADgICQYiPAADAAIABi0MAgcnAgkEAwA4BwkIABABCAEnAwUEAQAoBQIJLQ4HCQAoCQIJLQ4HCS0MBwQGKAQCBCQCAAEAAAGBIwAAAVgtDQUBACgBAgEtDgEFACgFAgYtDQYCJwIHBAIAOAYHATwNAQIjAAABgQo4BAMBJAIAAQAAAZcnAgIEADwJAQImKACABAR4AA0AAACABIADJACAAwAAAcAqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "1ZrBjuIwDIbfpWcOduwkDq+yWo0KlFGlqqACK63QvPumCEoXZqcXdmpfUINM8n82im3V52JTrU7vb3W73R2K5Y9z0ezW5bHetXl1/lgUq65umvr9bfx1Af0HQrj84LAv2359OJbdsViiQIJFUbWb/hkR8ibbuqmKpc+PT+acIF6tOWEYjAN+YizMcjUWDjw2/rkoEPEfgqLcBTF+LQjRA97M0dNdkqdPzEmYrtYkXp4kBXWSnFcniUCfJH1eYn1eYtYnKamT5PV5yevzUiB9kkSdpOj0SYrqJIk+L4m+SiDpSyhJX9pNs1yVKd2qYhD/dVWMQOJuewP3G/5F4IDNE5iPAZJ5ArFO4MzHgGZIIpwT/I0AE04RRKKBIPrHHt3N0cSwoyEGzocpAoEwEAjBEwHPQeDgThCnCBL6gSA9ZTQ3R4v0WgJP5gnEOkFw5gmidYJoPgZi/jYV87dpMh+DZD0GBNZjQGA+Bmi9qiC0XlWQs57RyAXrBMo6nIskXX/sXpKyHuQiaY6CloaGn2myuUZKgxTMffkjwSxNxWsJgnWCiOYJzMdAXvMeJMThoseQaEzQn/KiF0BTp8g3nMJA//2Uj7z6VXZ1uWqq63jU9tSuR9NSx9/76mFwat/t1tXm1FX9CNV4eirLjbyIKW+bt/4D",
      "brillig_names": [
        "nested_static_call_to_set_storage"
      ]
    },
    {
      "name": "returndata_copy_oracle",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843573301573771605": {
            "error_kind": "string",
            "string": "Returndata copy failed"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEUlAAAAPyUAAABsKAIAAQSARScCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMmJQAAAvoeAgABACkCAAIA4i2ObScCBAQBJwIGBAMAOAQGBS0IAQMAEAEFAScDAwQBACgDAgUtDgQFACgFAgUtDgQFJwIFBAMAOAMFBC0MBAUtDgIFJwICBAEAKAMCBi0NBgUnAgcEAgA4BgcEOQOIgEOAQwABAAQABSACAAEhAgADJwIEBAAtCAEGACgGAgktDQkIJwIKBAIAOAkKByI8AAQAAwAHLQwDCCcCCgQDADgICgkAEAEJAScDBgQBACgGAgotDggKACgKAgotDggKLQwIBQYoBQIFJAIAAQAAAXojAAABUS0NBgEAKAECAS0OAQYAKAYCBy0NBwMnAggEAgA4BwgBPA0BAyMAAAF6CygABYBEAAMkAgADAAABkycCBgQAPAkBBiECAAMtCAEGACgGAgktDQkIJwIKBAIAOAkKByI8AAQAAwAHLQwDCCcCCgQDADgICgkAEAEJAScDBgQBACgGAgotDggKACgKAgotDggKLQwIBQYoBQIFJwIDAAEnAgcAAicCCAADJwIKBAMnAgwEAwA4CgwLLQgBCQAQAQsBJwMJBAEAKAkCCy0OCgsAKAsCCy0OCgsnAgsEAwA4CQsKLQwKCy0OAwsAKAsCCy0OBwsAKAsCCy0OCAsLKAAFgEQAAy0IAQcAAAECAS0OAwcnAgMBAS0MBAEjAAACbgw4AQUEJAIABAAAApIjAAACgC0NBwEkAgABAAACkSUAAAMjJi0NBwgkAgAEAAACoyUAAAM1JwILBAMAOAYLCgA4CgELLQ0LBA0oAAGARAAKJAIACgAAAsslAAADNScCDAQDADgJDAsAOAsBDC0NDAoKOAQKCwQ4CAsELQ4EBwA4AQIELQwEASMAAAJuKACABAR4AA0AAACABIADJACAAwAAAyIqAQABBfeh86+lrdTKPAEBAiYqAQABBfehG2Dj8uFVPAEBAiYqAQABBcVrxFoOEAACPAEBAiY=",
      "debug_symbols": "1ZvbTuMwEIbfJde98HgOHvMqK4QKFFSpalEpK60Q775JtzlsGhqtN7bsG0TQTP7PY8cztvFn9bx5/Hh92O5fDu/V3Y/Pand4Wp+2h3399Pm1qh6P291u+/ow/HNlmh8AeHZ4f1vvm+f30/p4qu5UHa2qzf65+dVT/YqX7W5T3bH5Wl0ZkzfuYkwepDMWmDBWIm3fTEJD4/tVjaPTOGJbJw96G0dRuVMA7I1xwhgNwcUYDcsYx7qscNDmhZNXdCiv6JBkhcOQF05e0ZG8oiOcFY4zeeFQXjg+KxzNKzqaV0b3yZOEb4sjtG6mOAJTf2oXazAWr8oj7wqmt6bk2FsjJdMDFE1fdOxt6gSB0q6xENXO0TvEjt7xFT1iYnrCNppI5Obo1UhHr2iu6FPPmATQ0+scvQfu6D3rmD75kmZZeimZPvmCaVl6LpleTNH0RcfeFT1jatEzphYde1907H3JsUdTcuzRlFwpIJRcKSCUnK0QfMn0Ga1OGhzKZyCfcfKZFRocTl2Usm0PYZFnF8KAvl30Q30Uhlf0XDS9L5leqGj6omPvFjh/4G5/T1nlNj046bbTnOvfTHLGUckKx1NeOD4nHDLTW5++c/L11u9tnLkNSjKTJYA31H4DHoDnNG6XGTRdoC6sIfE1rEmgwfE1MEE7preOF9ZIMHY5QTs4QTskQTskQTtcgrnEJZhLNME3OP2vGAtrTKbM2qnX4L80GqfptD/nFKDEhkKcQpQgRAlClCyGOGmAE4YoYYjSN+lixskFOE2fq805SYCThChNH97MOYUMIxcyYF1I52rIMNJvOhdt7yS3Jy8LXaVsQQeF+1nAc2wBH1dAvpvcFhOw9v8FLLTrIWutGQmQWUAAuRMQHgv8a4gaJ7YhTho5VhK7M5yJLbDAF2ep7222IwE1sQVit8DHboGnuALO2MgCYGILLNHJLP2kRCMBa2ILxG4Bxm4BLj1Mh4nh2ta5Ngu64Z7dHxQfN0c5otgCGlPgq374uT5u14+7zeXC38vH/mlw/+/0620zugr4djw8bZ4/jpvmUuDgPmAzroBwBaT3zX2886NfAUOtU2v9Bg==",
      "brillig_names": [
        "returndata_copy_oracle"
      ]
    },
    {
      "name": "l1_to_l2_msg_exists",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "msg_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "msg_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAAUSUAAABSLgQAAYBGKAIAAgSARicCAwQBOw0AAgADJiUAAABkNTgAAQACAAMtDAMBJigAgAQEeAANAAAAgASAAyQAgAMAAACMKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "bY9BCoMwEEXvMussTGPUeBUpEnWUQEgkxkIR795EbBtaN8P84fGZt8GA3Tq1yox2gbrZQNteemVNSNtOoHNKazW16RmyOKry4JdZmhgXL52HmvKiqAigGY5d8NAxKo1Q82wn/zhj+ZtmpfjABb2ARcXpCQuRsRS+7yE9pFOy03i+Pq6mT0z8c8YfqdnZHofVYdT7mtEwGyrILQ+1ofoF",
      "brillig_names": [
        "l1_to_l2_msg_exists"
      ]
    },
    {
      "name": "debug_logging",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw0AAQACJiUAAAT9JwIBAmonAgICdScCAwJzJwIEAnQnAgUCICcCBgJlJwIHAngtCAEIJwIJBAoAEAEJAScDCAQBACgIAgktDAkKLQ4BCgAoCgIKLQ4CCgAoCgIKLQ4DCgAoCgIKLQ4ECgAoCgIKLQ4FCgAoCgIKLQ4ECgAoCgIKLQ4GCgAoCgIKLQ4HCgAoCgIKLQ4ECicCAgQAJwIJBAMAOAIJBy0IAQEAEAEHAScDAQQBACgBAgctDgIHACgHAgctDgIHJwIHBAMAOAEHAicCAgQAACgIAgcAKAECCy0NCwonAgwEAgA4CwwJPjsABwAJAAoACScCBwJjJwIIAm8nAgkCbicCCgJkJwILAjonAgwCeycCDQIxJwIOAn0tCAEPJwIQBAwAEAEQAScDDwQBACgPAhAtDBARLQ4DEQAoEQIRLQ4GEQAoEQIRLQ4HEQAoEQIRLQ4IEQAoEQIRLQ4JEQAoEQIRLQ4KEQAoEQIRLQ4LEQAoEQIRLQ4FEQAoEQIRLQ4MEQAoEQIRLQ4NEQAoEQIRLQ4OEScCDQABJwIQAAInAhEAAycCEgAEJwIUBAQnAhYEAwA4FBYVLQgBEwAQARUBJwMTBAEAKBMCFS0OFBUAKBUCFS0OFBUnAhUEAwA4ExUULQwUFS0ODRUAKBUCFS0OEBUAKBUCFS0OERUAKBUCFS0OEhUnAg0EBAAoDwIQACgTAhQtDRQSJwIVBAIAOBQVET47ABAAEQASAAsnAg8CdycCEAJoJwIRAmwnAhICYScCFAJyJwIVAnktCAEWJwIXBBAAEAEXAScDFgQBACgWAhctDBcYLQ4PGAAoGAIYLQ4QGAAoGAIYLQ4IGAAoGAIYLQ4RGAAoGAIYLQ4GGAAoGAIYLQ4FGAAoGAIYLQ4SGAAoGAIYLQ4UGAAoGAIYLQ4UGAAoGAIYLQ4SGAAoGAIYLQ4VGAAoGAIYLQ4LGAAoGAIYLQ4FGAAoGAIYLQ4MGAAoGAIYLQ4OGC0NEwsAKAsCCy0OCxMAKBYCCwAoEwIQLQ0QDicCFQQCADgQFQw+OwALAAwADgAPJwILAmInAgwCaScCDQIKJwIOAgknAhACLScCEwJmLQgBFScCFgQlABABFgEnAxUEAQAoFQIWLQwWFy0OBBcAKBcCFy0OEhcAKBcCFy0OCxcAKBcCFy0OAxcAKBcCFy0OBRcAKBcCFy0OEhcAKBcCFy0OCRcAKBcCFy0OChcAKBcCFy0OBRcAKBcCFy0OCRcAKBcCFy0OBhcAKBcCFy0ODxcAKBcCFy0OERcAKBcCFy0ODBcAKBcCFy0OCRcAKBcCFy0OBhcAKBcCFy0OAxcAKBcCFy0ODRcAKBcCFy0ODhcAKBcCFy0OEBcAKBcCFy0OBRcAKBcCFy0OExcAKBcCFy0ODBcAKBcCFy0OFBcAKBcCFy0OAxcAKBcCFy0OBBcAKBcCFy0ODRcAKBcCFy0ODhcAKBcCFy0OEBcAKBcCFy0OBRcAKBcCFy0OAxcAKBcCFy0OBhcAKBcCFy0OBxcAKBcCFy0OCBcAKBcCFy0OCRcAKBcCFy0OChctDQEDACgDAgMtDgMBACgVAgMAKAECBi0NBgUnAgcEAgA4BgcEPjsAAwAEAAUAJCYoAIAEBHgADQAAAIAEgAMkAIADAAAFJSoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "1ZzdSiNBEIXfZa5z0V39U12+yrIsUaMEQpSoC4v47jsJxnVXJyEfi6m+ESP9TR3qHGt+M8/D9eLy6fbHcn1z9zBcfHseVndX88fl3Xr89PwyGy43y9Vqefvj/Z+HsP1Rbbf+4X6+3n58eJxvHoeLZrnMhsX6evuryriFm+VqMVxYffk+GzQDBtRpoE4DdQzUMVAnhkygBqCYCEQqCakkpFISAlUA5UigAqASCERiVEhgKzG3EnOVmKsKoEbMbSRGRsw1EiMyjYRMI5mYRqG1PTT+97xBJbzMPiyOul8rIb0tFbVP1raQ99tNdmSttfq61uzvtVvhExOxA+G9dlx67bhop8In9pAdCO+147nXjufaqfASexVeOhVeQ6/CHXe87tfGEOSDcnXc8iPKu+1567bnE9dJelBuvSq3XnuewqnKd5ABKJJKkVQSUklIpUQqJVIpk0q5AagkApFKlVSqpJIKgSqAWiRQAZAFApEYGQhsDolAwNwchUAKIIkEAjHKKRCoEIiYS6ZRJtMok2mUCzG3khjVz82NJe6h8frR4R3/fzvDyRo9ifHUmeapM81TZ8xTZ8xRZ0pw1JkSiiMxMXgS46kz4qkzE6dBZxJjjsSk5ElMcyQme+pMVkdiiqfdQfG0o6yehl71tDuonoaeetod6BcPvYMXQUtLrtS46o256o2pIzU1iCs1rnoTT1WzhUQIRColUimRSplUyqTSyYcoO6gCqJJKlVRSUkkLgQxALROoAejkObyDQIw0CIGAuRojgYC5evKJ+Q7KBAIx0pQIBGKkZBopmUZKppGSaaSVmFtJjCoxV0mMlJjbSIwaMddIjAyY20Ik0OfmStK3w5v4Vec6beJpifOImXgK40xi2teKOXjE2iaeUD+XGle9mThcPpca9aQmu+pNOVXNDlIAVVKpkkpKKimp1EiliRu6h6GJG69HIFDJQiQQqTRxY/AIlAlkADp5wO+gBqAkBAKBtUzMzcTcQswthUDE3EpiVIm5SmJEppGRaWRkGhmZRmbA3HGfFRCVEWWEiglRjVAiiFJCpYioSqiMXM4oURm5XFCiCnK5okRV5LKiRClyuaFENeSyoUQZctlIomJIiCKJilEQRRIVJSKKJCqmgKiCKORyzohCLheUqIJcrihRFbmsKFGKXG4oUQ253FCiDLlsJFESBFEkURIjokiiRAKiCqI+dznJG5Wjx69AR5m4z9SD8tar8onLgy6UH7yUOErXbqWXfrs+cQ+0B+kTz4V0Ib3Prr+MH3/ON8v55Wrx+nrHm6f11bu3PT7+ul/88+LH+83d1eL6abPYvgLyz9sfd5dvReNMtI4bHjf+Gw==",
      "brillig_names": [
        "debug_logging"
      ]
    },
    {
      "name": "nullifier_exists",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAASyUAAABMLgQAAYBFKAIAAgSARScCAwQBOw0AAgADJiUAAABjHgIAAgAzOAABAAIAAy0MAwEmKACABAR4AA0AAACABIADJACAAwAAAIsqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "fZBBCoMwEEXvMussnDrGxKuUUqJGCYQoUQtFvHuj2GpbcTNkwpvP449Q6nyo78ZVTQfZdQTbFKo3jQvbODHIvbHW1Pf9N0TzELjwXavcvHa98j1kSOlFMtCuXN4kQ0ZlrIYsiSb2h5OM0pUmifwDczyABZFYYUGc9vCNgeDHPlzGmw+m5z6YpG8f5HF87iOTmFZYhrsvnylsD+WNyq1eq6wGV+ya7Z+t/im59U2hy8Hrue6taQzzipJdKMSG6Bc=",
      "brillig_names": [
        "nullifier_exists"
      ]
    },
    {
      "name": "set_opcode_small_field",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABbLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADKwCAQwASNFZ4kKvN7xI0VniQq83vJiUAAABnLgiAQwABJigAgAQEeAANAAAAgASAAyQAgAMAAACPKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "XYzBCoAgEET/Zc8dqkvQr0SE2ioLomIahOy/p9AhvAy8ecwUOFFmc5DT/oJ1K2C9Eom8q1R4ABnJWjJHV98ikpAWP9TZqZ9NT8BuH6JXeOaI7ak5GFtMNbdpGeZ5Z+adXw==",
      "brillig_names": [
        "set_opcode_small_field"
      ]
    },
    {
      "name": "nested_call_to_nothing_recovers",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "7542120476223899226": {
            "error_kind": "string",
            "string": "Nested CALL instruction should return failure if target contract does not exist"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw0AAQACJiUAAADJJwICBAAnAgQEAwA4AgQDLQgBAQAQAQMBJwMBBAEAKAECAy0OAgMAKAMCAy0OAgMnAgMEAwA4AQMCJwICAAEnAgMAKicCBAQAACgBAgctDQcGJwIIBAIAOAcIBTkD6AACAAIAAwAFAAYgAgABJwICAQAKOAECAyQCAAMAAADIJQAAAPImKACABAR4AA0AAACABIADJACAAwAAAPEqAQABBfeh86+lrdTKPAEBAiYqAQABBWiq/pz+hoZaPAEBAiY=",
      "debug_symbols": "vZXbaoQwEIbfJde5yJhJYvZVSlk8xCUgKh4KRXz3RltUdpGyc5EbcWQ+P4aQ+WdWunx63H1TtQO7fcysbots9G0TqnnhLO99XfvH/fyZifWh7dY/dFmzlsOY9SO7gZZGcOaa8vcdwj8qXzt2U2L55MwgiSK5UpIrTSmUlSSK5AIhaZghYZDQME3CEqBhVzadHJiVZ4y/tgs4LCKRuLdr2CwSoliizIJRZsEosygRxaJiWHSUWczFCkEwuwUl/GcxUu4Wo14tFxsHNRwWbZ8vc5rQMJrNqvexJVRfWe+zvHZ/SVlNTXEKzvG7c08Z2vVt4cqpd2uaHkEK64FLyxG3tRkKVBxNcATPDw==",
      "brillig_names": [
        "nested_call_to_nothing_recovers"
      ]
    },
    {
      "name": "get_transaction_fee",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQImKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99aHWtwV+RIVWjFEortQ6G+O9rh2yy+RJyw+GSs8FA3Tq1xo1+gbrZwPpeR+NdStvOoAvGWjO15zPwPCr55pdZuxyXqEOEWhQcJQNyQ94Fx9QxGktQS76zP1xioQ5a4q38wEpcwCixPGBUvDrD9z2lhw5Gd5aO18fV9SeT+JzpR2oOvqdhDZT1vmYizUYoVohUm6pf",
      "brillig_names": [
        "get_transaction_fee"
      ]
    },
    {
      "name": "nested_static_call_to_add",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgMEAicCBAQAHxgABAADgEUuCIBFAAEuCIBGAAIlAAAAUSUAAAB+LgQAAYBHKAIAAgSARycCAwQBOw0AAgADLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMmJQAAAcEeAgADACkCAAQAqmNIoScCBgQDJwIIBAMAOAYIBy0IAQUAEAEHAScDBQQBACgFAgctDgYHACgHAgctDgYHJwIHBAMAOAUHBi0MBgctDgQHACgHAgctDgEHACgHAgctDgIHACgFAgQtDQQCJwIGBAIAOAQGAToDiIBDgEMAAwABAAIgAgABIQIAAicCAwQALQgBBQAoBQIILQ0IBycCCQQCADgICQYiPAADAAIABi0MAgcnAgkEAwA4BwkIABABCAEnAwUEAQAoBQIJLQ4HCQAoCQIJLQ4HCS0MBwQGKAQCBCQCAAEAAAGZIwAAAXAtDQUBACgBAgEtDgEFACgFAgMtDQMCJwIGBAIAOAMGATwNAQIjAAABmScCAQQBCjgEAQIkAgACAAABtCcCAwQAPAkBAwEoAAWARAACLQ0CASYoAIAEBHgADQAAAIAEgAMkAIADAAAB6SoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "1drdquIwEAfwd+m1F5mPJBNfZVkOVeuhUKpUXVjEd99W7AfWPd4cemZuxMqY/vgjk8Tmmu2KzeXzo6z3h1O2/nXNqsM2P5eHur263lbZpimrqvz8mH6cue4FCO5fOB3zurs+nfPmnK0hCvlVVtS7+3vv20H2ZVVka+9uq1k5Jxcf1ZwgDMUBXhQLszyKhQNPi3+vWlD4DwhpBCX6GiSRU3+PKOM9PL0oJuF+aBIvzyD2ykDeaQNpSyhoSyiwNlBSBoraEoraEhLSBhJloITaQFEXCJ2yhNApm+0RlE0dCMomVwRljRFR2dSB+AONMfXF7MR/vQAHR4I9xLGnZz+RcX+07Wc07jee//LbB4Y4bKAhwTt/pAHioueZf/GGyEhD/ujDO7+4MPiF3Mwvy/vRjf74zp9g+HPEpXn/j2TcH237BY37g21/AuN+2/mTs90/CWz3TwLj+aPx/NF4/mQ8f7K9fiC2vX4gNj5/Lf+A63v9qvYvHShq+kHfQZo6RAeS5ZesNGzimd5umYFS/9AcoN1tz/zBtj85435v2s/Odv7svuWhRGLo/WnSI176IYZx6DjOARzuIGBtIG0JYVQGItQGCouDRPpZsn0bn0HMmkC39upP3pT5pioeB932l3o7Ofd2/nssno7AHZvDtthdmqI7DDc5B9f1P4GVhHbYduh/",
      "brillig_names": [
        "nested_static_call_to_add"
      ]
    },
    {
      "name": "get_da_gas_left",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQsmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99MDrt6q/IkKpRCqWVWgdD/PdVKVvZfAm54XDJ2WCgbp1aZUa7QN1soG0vvbImpG1n0DmltZra9AzZMXh58ssszREXL52HGnPOBQMyw7mLe+gYlSaoy2xnfzhHcYs0zzP+gSu8gAUWRYQFlkUKP/aQntIp2WmKr4+r6RMT/5rpR2p2tqdhdXTofc0wzAYrlmOoDdVv",
      "brillig_names": [
        "get_da_gas_left"
      ]
    },
    {
      "name": "external_call_to_assertion_failure",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABlKAIAAQSARCcCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABih4CAAEAKQIAAgDDUVdGJwIEBAEnAgYEAwA4BAYFLQgBAwAQAQUBJwMDBAEAKAMCBS0OBAUAKAUCBS0OBAUnAgUEAwA4AwUELQwEBS0OAgUnAgIEAQAoAwIGLQ0GBScCBwQCADgGBwQ5A4iAQ4BDAAEABAAFIAIAASECAAInAgMEAC0IAQUAKAUCCC0NCAcnAgkEAgA4CAkGIjwAAwACAAYtDAIHJwIJBAMAOAcJCAAQAQgBJwMFBAEAKAUCCS0OBwkAKAkCCS0OBwktDAcEBigEAgQkAgABAAABcyMAAAFKLQ0FAQAoAQIBLQ4BBQAoBQIGLQ0GAicCBwQCADgGBwE8DQECIwAAAXMKOAQDASQCAAEAAAGJJwICBAA8CQECJigAgAQEeAANAAAAgASAAyQAgAMAAAGyKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1drdiuowEAfwd8l1LzKZSTLxVQ6HpWpdCqVK1QMH8d03FavFyvZmV2dupJUx+fFH8tHmZNbV8vj5Ubeb7d4s/pxMs12Vh3rb5rvTuTDLrm6a+vNj/LWx/QfYcPnBfle2/f3+UHYHswjBh8JU7bq/jCE3sambyiy8PReTYko2Xospwb04wJNiJuJrMVOgcfHfwgDAcw7RwImWvucAOBg8+Zr8vRyflKMluFaj9eER5Kw0kBcGQmkJobiEkjAQkTSQtIS8tIQ8CwMFlAaKwkDRSQNJS4ilzfb8hqkjDdXo4sziCSxEO7RtHU6WT8kq92vPP6n2O0vK/crzd6+fMjAM+zFEdnP+iHjzRz/1h5f7CYdEkSjO+dmGm5/RPvrfsJchgLuf5/wJ/M2fPE/8Xrk/6fa/YWP1s37W7feo3K88/6h8/IzKx09Wnj8rzz8pzz9pz1/3+iE/nVDu1z1/ITjdflH7lwtI0h/6ApI0QvQgev2S1buhbfSzW+b89opvbZPDiZ91+71T7o+6/UF5/vEn3mEg070P68b+Sx/h9/tgekEf6Zf7OOe7f2VXl8umup592Rzb1egozOH/rno4FbPrtqtqfeyq/nzM+GhMxkYoYsjN5qa/AA==",
      "brillig_names": [
        "external_call_to_assertion_failure"
      ]
    },
    {
      "name": "add_storage_map",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "5V3ZbuM4EPwXP/uB3TyanV9ZLAY5nIGBIAlyLLAI8u9LayLJiUj3pleaFc2XQTxgqat4NIsUJb1tbnZXrz9/7O9vH543F3+8be4eri9f9g/36dfb+3Zz9bS/u9v//HH83xtz+AeQO8Dz4+X94ffzy+XTy+bCmhC3m939zeHPiOkSt/u73ebCm/ftpDCYYD8KA4AdCoP3739uN2Dd8iGWV+Hs8iFo8RAelg8RFg8RllcR/PIhZui0EPvCgM5/CjEt7T2bj9IhohtKM2cKU4CPskRxvHBwHXeierlHXy93thVzjyJ3Bom788OQIvMpRIZOtD13in68dIAsd+S+cAjxdOHEg8ex7TEcF09a0bjfrhVHrSFI9Hm4NMLIw1r/iz3XzB6qrnv4F3VPp9k76oehi+O0Y7m7PrqFr78wf0vLXt9h9vpplPfXT575P038WPB5c4Yo+LxZQ/jlQ/DiIYJbPsTyKsguH2KGTvs/OQ+Mvl7ubKvlbg1UzD2I3K3E3Zk+AjgkwUVEC70BjfaoWgouwgzVkmzEVxeRaP5u9hhxYG/cafbRxJ5HBCsapmBw0Bqc/eK1LWQzU5LqebToNFLCX1WEqIMFFcwaHczpYKyCOV00FzUwZ7KZLe0ffYDQjCvZ1Mi5EcyDTSfmsTTGXIe2vu9GDsY+hyZXNtnwvvNjWg4Jpf2wdPTWfCrb6aQ2dAI2orOR9sRG2hMbaU8LjehspD1dI+OzYC/OTqdvxA/ld3Wq1MnUrzbBT3RG04hO14jORvotN9Ke3EZ7etNGe3pzPj7hpE5opD2hkfGJvg2dtg0/5G1oQ6c7n/2E0zorHZ8d90pz6IG7r3Se67hX6kUO3EOl+0od90r3/g7cqdJ82nGvOEfWuk/Tca/Uaxy4c8X1zvX292DWnGcw9lvHaI94DNzX3N8F7rDm/i5xdxVzX7MXE7iv+h68xL3isbrqvQqJ+5rnJoG7q7jeXcU5ctX7BAL3Vd83l7iveb0qcA8V+8hQcY4MFY9VqnisUsU+MlZc73HNOZJgoEFfzjp9r/RBKa85o35LKYTQP4gD4ejpmkHpmnPYnEpp1af/Z1W66vP/8ypd88r2e0qJhqc+iSe5l/B8MpKkdM2OcF6l55N7BaV2za5nXqXnM8sISld96mRepc3MMr6ZNvXNzDKrfsrje0rZDM8xM06VrvrMyZxKY+HJV4PD8/kmTM7PxYKHlFD5kQLDK70A3MSZx8KML6AKc4qEChqUL7wIIIzvOIjT2iicDbLDwcX05zRW4VSOhGINqrDDJKFIg2KNLjZGhYoaFBSc5/CiMPCOpijWoEr3WU+jSk8DCyjSoEpPqgooVayilxgym488RbEGlX95lIQiVKFIg4qq2ohehVLVIRfG1zgTWZyMLzCFl4eIMFLBAHQwr4OxCoa6KkFdA1hdNKtrAKdrAKdrgMLdcOvcAPM0hRXMvQQrnLcWYaSCFe7AibCoghXOp0ow1kzVCeZ0MM0UD6mbqGD5o0Xkev+X1v1TUH5WG5cN7DOR8v1RArECFKwGRAoQaSqCggJUOBZ+etkChbdLyzBWwQo9XoSpohXeaizDdNFAFw100dDrYLpohdlThJEKlvffp1MO5pe3bPrsxpgBafIU5g2xEIk09PJjWgI5DSgqKoKtBqSIZE2+yodNCCafAZECBJpIICXsHAgVfc+iYhIqvJVRAikmVusUU7jNbzFJIFUkjSaNWbAas2C/bRbe08+/Lp/2l1d3u49v59y+3l8ffUrn5e/H3Zev6jw+PVzvbl6fdofv64yf1jk0ApLfIofOZaafgbaE3QScfoC322TRUswU9x8=",
      "brillig_names": [
        "add_storage_map"
      ]
    },
    {
      "name": "set_opcode_really_big_field",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABrLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADLACAQwASNFZ4kKvN7xI0VniQq83vEjRWeJCrze8SNFZ4kKvN7yYlAAAAdy4IgEMAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAnyoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "XYzBCoAgEET/Zc8dqkvQr0SE2ioLomIahOy/p9AhvAy8ecwUOFFmc5DT/oJ1K2C9Eom8q1R4ABnJWjJHV98ikpAWP9TZqZ9NT8BuH6JXeOaI7ak5GFtMNbdpGeZ5Z+adXw==",
      "brillig_names": [
        "set_opcode_really_big_field"
      ]
    },
    {
      "name": "assertion_failure",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "1065084222963340944": {
            "error_kind": "string",
            "string": "This assertion should fail!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw0AAQACJiUAAABiJwIBAQAnAgIBAQo4AQIDJAIAAwAAAGElAAAAiyYoAIAEBHgADQAAAIAEgAMkAIADAAAAiioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFDsfwdS2aVpA8AQECJg==",
      "debug_symbols": "zZPfCoMgFMbf5Vx7kaaZvUqMsLIQRMNsMKJ3n0XbYtsDeHPwkx/nH+dboVftMjbaDm6Gql7BuE4G7WxU64ag9doYPTbXb8j2UIiDnydpdzkH6QNUGDMmECjbH29OY45BGwUVYRv6wQtKyUkXlJdvmGX/4DwrXnBOyBW+IeA0sX4S20+Z2H4ESamfLaq79Fq2Rp2nPyy2uzghPCb1ZYrJu071i1e7PT7OwDHWWCBC45gYR0EYIjzWiHWe",
      "brillig_names": [
        "assertion_failure"
      ]
    },
    {
      "name": "conditional_move",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "x",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "y",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "b",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 1,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgQEAycCBQQAHxgABQAEgEQdAIBGgEYBKAIAAQSARCcCBQQBLQgBBCcCBgQCABABBgEnAwQEAQAoBAIGLgQAAYADLgQABoAELgQABYAFJQAAAPItDAQBKAIAAgSARScCBQQBLQgBBCcCBgQCABABBgEnAwQEAQAoBAIGLgQAAoADLgQABoAELgQABYAFJQAAAPItDAQCLgiARgADJQAAATglAAABOQAoAQICKAIAAwSARycCBAQBLgQAAoADLgQAA4AELgQABIAFJQAAAPIoAgACBIBHJwIDBAE7DQACAAMBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAATcuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAAQYmJiUAAAFvFgwDBC0MAQYkAgADAAABUi0MAgYuBAAGgAMoAIAEBAACJQAAAZguCIAFAAUtDAUBJigAgAQEeAANAAAAgASAAyQAgAMAAAGXKgEAAQX3ofOvpa3UyjwBAQImLgGAA4AGCwCABgACgAckAIAHAAABsyMAAAG+LgCAA4AFIwAAAiUuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAACES4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAAB4CgBgAUEAAEDAIAGAAKABiMAAAIlJg==",
      "debug_symbols": "nZDdCoQgEIXfZa69KNP+XiWWsJpCEA2zhSV69x2XhY29y5vhHOVz5DtgwmFfem1nt0HbHWDcqIJ2ltpxMhi8NkYv/fUYsjgKzj/Atiob+xaUD9DWjZAM0E4xVpyemLVBaJvyfDAoijoBEiIBknkKVN6FTmpP5bUaDH6dzbsdLwrDa8U/m6t3I067x+j1p5RGV+Ws4fErlIVgUlDO40UpWZXROlr5Bg==",
      "brillig_names": [
        "conditional_move"
      ]
    },
    {
      "name": "get_sender",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQEmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY9RCoMwEETvst/5yCqx0atIkairBEIiMRaKePeuxbbS9meYWR7Dzgo9tcvYWD+EGap6BRc6k2zwnNZNQButc3ZszmeQu1zUk58n4/c4JxMTVIhlqQSQ79lnEnPuGKwjqJTcxA+upJYHzVa/4QL/wFrhq1qrXJ7h68bpZqI1raPj9WHx3WlJuk/0NWqKoaN+ibTP+yxD1hoLkSHXcvUD",
      "brillig_names": [
        "get_sender"
      ]
    },
    {
      "name": "modulo2",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgIEAScCAwQAHxgAAwACgEQdAIBEgEQFLgiARAABJQAAAFIlAAAAUy4EAAGARSgCAAIEgEUnAgMEATsNAAIAAyYlAAAAZxwMAQMBHAwDAgUtDAIBJigAgAQEeAANAAAAgASAAyQAgAMAAACPKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "lY7LCsMgEEX/ZdYukrTSJL8SSjA6BkFUfBSK+O/VUGjoLpvL3GHmcDII3NK+KiNtgHnJoC1nUVlTWy4ENq+0Vvt6XkPXYhyP++CYaTVE5iPMfU/pRACNOObHvTKk0gjzQMuTwHS7/lVqezGv2KbxqyWT4SfL+Hb4J+y85SiSx6b+s+5rLkNHBlqxFf0B",
      "brillig_names": [
        "modulo2"
      ]
    },
    {
      "name": "return_oracle",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAZyUAAABvACgBAgIoAgADBIBEJwIEBAMuBAACgAMuBAADgAQuBAAEgAUlAAABNSgCAAIEgEQnAgMEAzsNAAIAAygAgEMEAAMmJQAAAXsnAgEAAScCAgACJwIDAAMnAgUEAycCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBgQDADgEBgUtDAUGLQ4BBgAoBgIGLQ4CBgAoBgIGLQ4DBgAoBAIDLQ0DAicCBQQCADgDBQE7DQABAAInAgEABCcCAgAFJwIDAAYtCAEEJwIFBAQAEAEFAScDBAQBACgEAgUtDAUGLQ4BBgAoBgIGLQ4CBgAoBgIGLQ4DBi0MBAEmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAF6LgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAAFJJigAgAQEeAANAAAAgASAAyQAgAMAAAGjKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "vZbbaoQwFEX/Jc8+5ORm4q+UMniJQ0BUvBSK+O9NepmRafswG2ZeJEeyXIYTkr2xxlfr+RT6dphZ8bKxbqjLJQx9rLY9Y9UUui6cT8fXjKcHkfkE5rHsUz0v5bSwwklOGfN9k4bE4yfa0HlWaL6/ZowEIRBikohJIiaFmBRi0hyBNAAZxGQgkwOgXCGQBSArEQgxOYFAwDYSnBAIaK4gjkB/N1doeYXoCGW/JhNx8aOIY2Uu0w19OdzjHUI+wWEf75BPWIf85xQQ9uIQ7najKIVAiEkjJm0ByEgEQkw5YsoRkxUIZADIEQLp+yHJ+b3QHqu3cgpl1fnvdNWufX0IW8v76G9y1zgNtW/WyacEdg1fqXVGZrlMd0D6k1xluYuKqPkA",
      "brillig_names": [
        "return_oracle"
      ]
    },
    {
      "name": "nested_call_to_add_with_gas",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "l2_gas",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "da_gas",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgUEBCcCBgQAHxgABgAFgEQuCIBEAAEuCIBFAAIuCIBGAAMuCIBHAAQlAAAAXSUAAABlLgQAAYBIKAIAAgSASCcCAwQBOw0AAgADKACAQwQAAyYlAAABqB4CAAUAKQIABgCqY0ihJwIIBAMnAgoEAwA4CAoJLQgBBwAQAQkBJwMHBAEAKAcCCS0OCAkAKAkCCS0OCAknAgkEAwA4BwkILQwICS0OBgkAKAkCCS0OAQkAKAkCCS0OAgkAKAcCBi0NBgInAggEAgA4BggBOQPoAAMABAAFAAEAAiACAAEhAgACJwIDBAAtCAEFACgFAggtDQgHJwIJBAIAOAgJBiI8AAMAAgAGLQwCBycCCQQDADgHCQgAEAEIAScDBQQBACgFAgktDgcJACgJAgktDgcJLQwHBAYoBAIEJAIAAQAAAYAjAAABVy0NBQEAKAECAS0OAQUAKAUCAy0NAwInAgYEAgA4AwYBPA0BAiMAAAGAJwIBBAEKOAQBAiQCAAIAAAGbJwIDBAA8CQEDASgABYBDAAItDQIBJigAgAQEeAANAAAAgASAAyQAgAMAAAHQKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1drdaupAEAfwd8l1LmZ2ZndnfZXDoUSNJRCiRD1wEN+90Zoopm0oiM7ciJFx/fkn7Ff2kC3L+f79rWpW6202+3PI6vWi2FXrprs6HPNs3lZ1Xb2/3X6cwekFIZy/sN0Uzel6uyvaXTbDEIPPs7JZnt+L7xpZVXWZzTwc81E5J4iXak4YhuKAXxQLs1yKhQPfFv/NM0T8BuRpACXAn0FC4offQLoW0xfFBIyXYgIf7kEOtIG8MhBpS4jUJZSUgZi1gbQl5LUl5EUZKJA2UFQGik4bSFtCom20F21DR9I2uCZtHWNSNnQ4eEHHmPoJOLk4MQFHwAg9BBzxyC+2/eiM+6NtvzOe/wuWDxT6NTGRuCl/pAEC0Y/9z+8QmfpEiTlO+QXC4BeCez8/v/9kxKtfpvwJh80RSF5GfrHt9864P9r2BzTuD7b90Xj+Yrz/FOP9ZzKef7KdP4Ht/AmM54+25w+EtucP5GyPX/SCB1wP9atav5xBmm7oE0jVCuMMev6U1TvuQX5yydw9Qew3CBDZ0b3/BUuGx/q9bX8E437j+Qs/wu+HfUHxEn72YwxD0zFeOxQOn6CkDJSUJcTgtIGiMtBjjkL9CiQy7IyLxBEoaQIdu6t/RVsV87q8HHRb7ZvFzbm33f9NeXcEbtOuF+Vy35anw3C35+C6fyYul9g12zX9AQ==",
      "brillig_names": [
        "nested_call_to_add_with_gas"
      ]
    },
    {
      "name": "test_get_contract_instance_matches",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_deployer",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_initialization_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "10235209936248515834": {
            "error_kind": "string",
            "string": "Contract instance not found when getting CLASS_ID!"
          },
          "10385728837058572758": {
            "error_kind": "string",
            "string": "Contract instance not found when getting INIT_HASH!"
          },
          "17485690947400700813": {
            "error_kind": "string",
            "string": "Contract instance not found when getting DEPLOYER!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHxgABgAFgEQuCIBEAAEuCIBFAAIuCIBGAAMuCIBHAAQlAAAAVyUAAABYKAIAAQSASCcCAgQAOw0AAQACJiUAAAEFNjgAAQAFAAYAHAwGBwAEOAcFCDY4AAEABQAHARwMBwkABDgJBQo2OAABAAUACQIcDAkBAAQ4AQULJwIBAQEkAgAGAAAAqCUAAAEuJAIABwAAALUlAAABQCQCAAkAAADCJQAAAVIKOAgCASQCAAEAAADYJwIFBAA8CQEFCjgDCgEkAgABAAAA7icCAgQAPAkBAgo4CwQBJAIAAQAAAQQnAgIEADwJAQImKACABAR4AA0AAACABIADJACAAwAAAS0qAQABBfeh86+lrdTKPAEBAiYqAQABBfKpp0YEFRONPAEBAiYqAQABBY4KxTVjpCz6PAEBAiYqAQABBZAhhVnyaDHWPAEBAiY=",
      "debug_symbols": "zZbBioMwEIbfJWcPM0lmkvRVlqXY1hZBtFi7sJS++8bSqlsNoTl5ESP/l3zGMM5NHIrd9bQt62NzEZuvm6iafd6VTe1Ht3smdm1ZVeVpO30soL849chfznndDy9d3nZig2BZZ6KoD/29A+PnOJZVITYE92wWl9LAMy2VlEMY9VIaeZzboP6X/s4EglyfklmdEgZ2ySk5KhmKKPGQlmx1TMkqes1tLc2UJK5PiVenpJZ3CQHxhSFwREkB8DOtgF1ESQKa1wuAsTMlDetTotUpUWiXrBqUvN9U6YFREsYqDbPLGJoJ5maY4STMBs6yNDxgCmiGuSTM6WVMm6FSIqGaYS4Fk4GaH8MCdTmKBT4AqfG8k4F3LFByo5hLwpROwwJnkqwdMNbuHdMqCSNMw/hz7O5HP3lb5ruqeHZax2u9nzRe3e+5eOvBzm2zLw7Xtui7sbERw766aM4IH393PyCbMfg1/Dp/",
      "brillig_names": [
        "test_get_contract_instance_matches"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "rZLLqoMwFEX/JeMM8vbEXymXEjWWQIgS9UIR/72xxCK1tBMnh5yw2CySPaPGVtPt6kLbDai8zMh3tRldF9I2LxhV0Xnvbtf9NSLroPzJD70J6zqMJo6opERQjpENzfNcsJTROm9RqdWCD3gBKsNAxAtV/AMqmcyolOSFUg7LH0ZUnCADvNhkpP4uI7jOqFBwkJFnyIDYZDR8l1FkexnF1EFGnSCjGcuw5vKHDJCMFuTtm5a0/pvoTOVtrlc7hXrXtvHe27fi9bGrbTNFu1Zw1740LxQw4yk2RT8A",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "test_get_contract_instance",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "10235209936248515834": {
            "error_kind": "string",
            "string": "Contract instance not found when getting CLASS_ID!"
          },
          "10385728837058572758": {
            "error_kind": "string",
            "string": "Contract instance not found when getting INIT_HASH!"
          },
          "17485690947400700813": {
            "error_kind": "string",
            "string": "Contract instance not found when getting DEPLOYER!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAAEKNjgAAQACAAMAHAwDBAAEOAQCBTY4AAEAAgAEARwMBAYABDgGAgc2OAABAAIABgIcDAYBAAQ4AQIIJwIBAQEkAgADAAAAliUAAAEzJAIABAAAAKMlAAABRSQCAAYAAACwJQAAAVcoAgABAARWCjgFAQIkAgACAAAAzScCAwQAPAkBAygCAAEAB4kKOAEHAiQCAAIAAADqJwIDBAA8CQEDKQIAAQAAEBESCjgIAQIkAgACAAABCScCAwQAPAkBAyYoAIAEBHgADQAAAIAEgAMkAIADAAABMioBAAEF96Hzr6Wt1Mo8AQECJioBAAEF8qmnRgQVE408AQECJioBAAEFjgrFNWOkLPo8AQECJioBAAEFkCGFWfJoMdY8AQECJg==",
      "debug_symbols": "zZbdioMwEEbfJddezEwy+emrLMtiW1sE0WLtwlL67htLtV1NkZ0rb8SR7ySHOOhc1b7YXo5fZX1ozmrzcVVVs8u7sqljdb1latuWVVUev14fK+gvju/58ymv+/Lc5W2nNsEjZKqo9/0t67jCoawKtWG4ZbMwkRvCpInGMJpUGq01jzQ6NH/Sn5nyZmU+YV0+4c35OD/4BMIFH6tp8LHeLPl4zYOP9zz1QdBrE/IrE8L0CQV2AwWAC0YawD7SGmxYMCLAYW0C52dGRKszcmsz0skzihoUnkrGvSrdMSfCDIswhjSG+MSi0gzzIszqNEZEI0aMU8yhDLNpzBCMmHF6inktw7wICyLJ2Hsy7E2XmIAjxrMuISQZ5kQYySQ1yDCTxtiO32SwwFPMaBnmRRhbEWbx/9gtVt95W+bbqngMf4dLvXuZBbufUzEZC09tsyv2l7boB8TnbIj9KzE2Y7z/xmLBPrMQ94j7/AI=",
      "brillig_names": [
        "test_get_contract_instance"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1065084222963340944": {
            "error_kind": "string",
            "string": "This assertion should fail!"
          },
          "2716768074203347595": {
            "error_kind": "string",
            "string": "Values are not equal"
          },
          "2749144489913102783": {
            "error_kind": "string",
            "string": "Nullifier was just created, but its existence wasn't detected!"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3005655821239716708": {
            "error_kind": "string",
            "string": "Storage value does not match input"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5356792413696267948": {
            "error_kind": "string",
            "string": "Nullifier doesn't exist!"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7542120476223899226": {
            "error_kind": "string",
            "string": "Nested CALL instruction should return failure if target contract does not exist"
          },
          "9191987771437846783": {
            "error_kind": "string",
            "string": "Nested CALL instruction should return failure on exceptional halt"
          },
          "10235209936248515834": {
            "error_kind": "string",
            "string": "Contract instance not found when getting CLASS_ID!"
          },
          "10385728837058572758": {
            "error_kind": "string",
            "string": "Contract instance not found when getting INIT_HASH!"
          },
          "13395485527885582986": {
            "error_kind": "string",
            "string": "Returndata should be empty when nested call exceptionally halts"
          },
          "13488375577656017388": {
            "error_kind": "string",
            "string": "Calldata copy failed"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17485690947400700813": {
            "error_kind": "string",
            "string": "Contract instance not found when getting DEPLOYER!"
          },
          "17843573301573771605": {
            "error_kind": "string",
            "string": "Returndata copy failed"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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hQASJwIRBBItCAASLQwQEwAQABEAJQAAzrAtBAAAJwIRBBItCAASABAAEQAlAAC6oy0EAAAtDBMQLQgBEScCEgQQABABEgEnAxEEAQAoEQISLQwSEy4KgHoAEwAoEwITLgqAgAATACgTAhMuCoB+ABMAKBMCEy4KgIUAEwAoEwITLgqAdQATACgTAhMtDgwTACgTAhMuCoCGABMAKBMCEy4KgHcAEwAoEwITLgqAfwATACgTAhMuCoB+ABMAKBMCEy4KgHgAEwAoEwITLgqAdQATACgTAhMuCoB/ABMAKBMCEy4KgIIAEwAoEwITLgqAfAATJwIMBBItCAASLQwREwAQAAwAJQAAzrAtBAAAJwIMBBEtCAARABAADAAlAAC72i0EAAAtCAEMJwIRBBEAEAERAScDDAQBACgMAhEtDBESLgqAgQASACgSAhIuCoCCABIAKBICEi4KgIUAEgAoEgISLgqAegASACgSAhIuCoB1ABIAKBICEi4KgH0AEgAoEgISLgqAdgASACgSAhIuCoCEABIAKBICEi4KgH0AEgAoEgISLgqAdQASACgSAhIuCoB6ABIAKBICEi4KgIoAEgAoEgISLgqAfgASACgSAhIuCoCEABIAKBICEi4KgIUAEgAoEgISLgqAhAASJwIRBBItCAASLQwMEwAQABEAJQAAze4tBAAAMSCARoBkAAwtCAERJwISBA4AEAESAScDEQQBACgRAhItDBITLgqAgQATACgTAhMuCoB6ABMAKBMCEy4KgIkAEwAoEwITLgqAdQATACgTAhMuCoCBABMAKBMCEy4KgIIAEwAoEwITLgqAhQATACgTAhMuCoB6ABMAKBMCEy4KgHUAEwAoEwITLgqAfQATACgTAhMuCoB2ABMAKBMCEy4KgIQAEwAoEwITLgqAfQATJwISBBMtCAATLQwRFAAQABIAJQAA0LYtBAAAJwIRBBItCAASLgiARgATABAAEQAlAADDKS0EAAAtCAERJwISBA4AEAESAScDEQQBACgRAhItDBITLgqAgQATACgTAhMuCoB6ABMAKBMCEy4KgIkAEwAoEwITLgqAdQATACgTAhMuCoCBABMAKBMCEy4KgIYAEwAoEwITLgqAfwATACgTAhMuCoB/ABMAKBMCEy4KgH4AEwAoEwITLgqAewATACgTAhMuCoB+ABMAKBMCEy4KgHoAEwAoEwITLgqAgwATJwISBBMtCAATLQwRFAAQABIAJQAA0LYtBAAAJwIRBBItCAASLgiARgATABAAEQAlAADDMy0EAAAtCAERJwISBBEAEAESAScDEQQBACgRAhItDBITLgqAgQATACgTAhMuCoCGABMAKBMCEy4KgH8AEwAoEwITLgqAfwATACgTAhMuCoB+ABMAKBMCEy4KgHsAEwAoEwITLgqAfgATACgTAhMuCoB6ABMAKBMCEy4KgIMAEwAoEwITLgqAdQATACgTAhMuCoB6ABMAKBMCEy4KgIoAEwAoEwITLgqAfgATACgTAhMuCoCEABMAKBMCEy4KgIUAEwAoEwITLgqAhAATJwISBBMtCAATLQwRFAAQABIAJQAAze4tBAAAJwISBBMtCAATLgiARgAUABAAEgAlAADDPS0EAAAtDBQRLQgBEicCEwQUABABEwEnAxIEAQAoEgITLQwTFC4KgH8AFAAoFAIULgqAcwAUACgUAhQuCoB1ABQAKBQCFC4KgIUAFAAoFAIULgqAggAUACgUAhQuCoB1ABQAKBQCFC4KgH8AFAAoFAIULQ4JFAAoFAIULgqAdQAUACgUAhQuCoCAABQAKBQCFC4KgIQAFAAoFAIULgqAfAAUACgUAhQuCoB1ABQAKBQCFC4KgHoAFAAoFAIULgqAigAUACgUAhQuCoB+ABQAKBQCFC4KgIQAFAAoFAIULgqAhQAUACgUAhQuCoCEABQnAhMEFC0IABQtDBIVABAAEwAlAADRFy0EAAA1IIBGgGQAEi0IARMnAhQEEgAQARQBJwMTBAEAKBMCFC0MFBUuCoCEABUAKBUCFS4KgHoAFQAoFQIVLgqAgQAVACgVAhUuCoB5ABUAKBUCFS4KgHUAFQAoFQIVLgqAfwAVACgVAhUtDgkVACgVAhUuCoB1ABUAKBUCFS4KgIUAFQAoFQIVLgqAggAVACgVAhUuCoB1ABUAKBUCFS4KgH8AFQAoFQIVLgqAcwAVACgVAhUuCoB1ABUAKBUCFS4KgIAAFQAoFQIVLgqAhAAVACgVAhUuCoB8ABUnAgkEFC0IABQtDBMVABAACQAlAADOTy0EAAAoAgAJACAgJwITBBQtCAAULQwJFQAQABMAJQAAw3gtBAAAJwITBBQtCAAULQwJFS4IgEYAFgAQABMAJQAAw7otBAAALQgBCScCEwQXABABEwEnAwkEAQAoCQITLQwTFC4KgIQAFAAoFAIULgqAhQAUACgUAhQuCoCCABQAKBQCFC4KgIMAFAAoFAIULgqAdgAUACgUAhQuCoB8ABQAKBQCFC4KgHoAFAAoFAIULgqAdQAUACgUAhQuCoCDABQAKBQCFC4KgHoAFAAoFAIULgqAdgAUACgUAhQuCoB5ABQAKBQCFC4KgHUAFAAoFAIULgqAdgAUACgUAhQuCoCBABQAKBQCFC4KgHkAFAAoFAIULgqAdQAUACgUAhQuCoCJABQAKBQCFC4KgIMAFAAoFAIULgqAfgAUACgUAhQuCoCFABQAKBQCFC4KgHoAFAAoCQITACgDAhYtDRYVJwIXBAIAOBYXFD47ABMAFAAVABYnAhMEFC0IABQAEAATACUAAJtOLQQAAC0MFQknAhMEFC0IABQtDAkVABAAEwAlAACbQi0EAAAtCAEJJwITBBMAEAETAScDCQQBACgJAhMtDBMULgqAgQAUACgUAhQuCoB6ABQAKBQCFC4KgIQAFAAoFAIULgqAhQAUACgUAhQuCoB6ABQAKBQCFC4KgHkAFAAoFAIULgqAdQAUACgUAhQuCoB4ABQAKBQCFC4KgHYAFAAoFAIULgqAfwAUACgUAhQuCoB/ABQAKBQCFC4KgHUAFAAoFAIULgqAhQAUACgUAhQuCoCCABQAKBQCFC4KgHUAFAAoFAIULgqAdgAUACgUAhQuCoB5ABQAKBQCFC4KgHkAFCcCEwQULQgAFC0MCRUAEAATACUAAM2NLQQAACcCEwQULQgAFC4IgEYAFS4IgGQAFgAQABMAJQAAxugtBAAALQwVCS0IARMnAhQEGgAQARQBJwMTBAEAKBMCFC0MFBUuCoCBABUAKBUCFS4KgHoAFQAoFQIVLgqAhAAVACgVAhUuCoCFABUAKBUCFS4KgHoAFQAoFQIVLgqAeQAVACgVAhUuCoB1ABUAKBUCFS4KgIQAFQAoFQIVLgqAhQAVACgVAhUuCoB2ABUAKBUCFS4KgIUAFQAoFQIVLgqAfgAVACgVAhUuCoB4ABUAKBUCFS4KgHUAFQAoFQIVLgqAeAAVACgVAhUuCoB2ABUAKBUCFS4KgH8AFQAoFQIVLgqAfwAVACgVAhUuCoB1ABUAKBUCFS4KgIUAFQAoFQIVLgqAggAVACgVAhUuCoB1ABUAKBUCFS4KgHYAFQAoFQIVLgqAeQAVACgVAhUuCoB5ABUAKBMCFAAoAwIXLQ0XFicCGAQCADgXGBU+OwAUABUAFgAZJwIUBBUtCAAVLgiARgAWLgiAZAAXABAAFAAlAADIMi0EAAAtDBYTACgDAhYtDRYVJwIXBAIAOBYXFDsNABQAFSMAAIYiJwICAlUtCAEDJwIEBBwAEAEEAScDAwQBACgDAgQtDAQGLQ4CBgAoBgIGLgqAgQAGACgGAgYtDgUGACgGAgYuCoCBAAYAKAYCBi4KgIIABgAoBgIGLgqAiQAGACgGAgYuCoCBAAYAKAYCBi4KgHEABgAoBgIGLgqAhAAGACgGAgYuCoB6AAYAKAYCBi4KgH8ABgAoBgIGLgqAegAGACgGAgYuCoB4AAYAKAYCBi4KgIUABgAoBgIGLgqAggAGACgGAgYuCoCDAAYAKAYCBi4KgHEABgAoBgIGLgqAjAAGACgGAgYuCoCEAAYAKAYCBi4KgHoABgAoBgIGLgqAfwAGACgGAgYuCoB6AAYAKAYCBi4KgHgABgAoBgIGLgqAhQAGACgGAgYuCoCCAAYAKAYCBi4KgIMABgAoBgIGLgqAjQAGCyCAXYBhAAIkAgACAACH3ycCBAQeLQgBBScCBgQeABABBgEtDAUGKgMABgUnRkiy9UEXvQAoBgIGACgDAgcnAggEGy4EAAeAAy4EAAaABC4EAAiABSUAAKHnJwIHBBsAOAYHBi4KgGIABgAoBgIGLQ4BBgAoBgIGPA0FBCYtDRUEACgNAgcAOAcCCC0NCAYnAhMEJy0IACctDAYoABAAEwAlAACk8C0EAAAtDCgHLQwpCAUoAAKAYwAGLgQABIADKACABAQAFyUAAKXwLgiABQATACgTAhcAOBcGGC0OBxgBKAAGgGIABC4EABOAAygAgAQEABclAACl8C4IgAUABgAoBgIHADgHBBctDggXLQ4GFS0NFgQFKAACgFwABgAoJgIIADgIBhMtDRMHASgABoBiAAgAKCYCFwA4FwgYLQ0YEwEoAAaAYwAXACgmAhkAOBkXGi0NGhguBAAEgAMoAIAEBAAiJQAApfAuCIAFABcAKBcCGQA4GQYaLQ4HGi4EABeAAygAgAQEACIlAACl8C4IgAUABAAoBAIGADgGCActDhMHASgACIBiAAYuBAAEgAMoAIAEBAAiJQAApfAuCIAFAAcAKAcCCAA4CAYTLQ4YEy0OBxYBKAACgGIABC0MBAIjAABuui0NDgoAKA0CFQA4FQIWLQ0WFCcCFwQoLQgAKC0MFCkAEAAXACUAAKTwLQQAAC0MKRUtDCoWBSgAAoBjABQuBAAKgAMoAIAEBAAXJQAApfAuCIAFABcAKBcCGAA4GBQZLQ4VGQEoABSAYgAKLgQAF4ADKACABAQAFyUAAKXwLgiABQAUACgUAhUAOBUKGC0OFhgtDhQOLQ0TCgUoAAKAXAAUACgnAhYAOBYUFy0NFxUBKAAUgGIAFgAoJwIYADgYFhktDRkXASgAFIBjABgAKCcCGgA4GhgbLQ0bGS4EAAqAAygAgAQEACIlAACl8C4IgAUAGAAoGAIaADgaFBstDhUbLgQAGIADKACABAQAIiUAAKXwLgiABQAKACgKAhQAOBQWFS0OFxUBKAAWgGIAFC4EAAqAAygAgAQEACIlAACl8C4IgAUAFQAoFQIWADgWFBctDhkXLQ4VEwEoAAKAYgAKLQwKAiMAAGfLACgNAhYAOBYCFy0NFxUtDRMWLQ0UFwsoABeAXQAYJAIAGAAAiuMnAhkEADwJARkLKAAWgFwAFyQCABcAAItyIwAAivgtDQ4WLQ0KFy0NExgtDRQZDSgAGIBcABokAgAaAACLHSUAAKXeLgQAFoADKACABAQABCUAAKXwLgiABQAaACgaAhsAOBsYHC0OFRwBKAAYgGIAFQ44GBUWJAIAFgAAi10lAACiWC0OGg4tDhcKLQ4VEy0OGRQjAACL5ScCFgQXLQgAFy0MDhgtDAoZLQwTGi0MFBsAEAAWACUAAM+oLQQAAC0NDhYtDQoXLQ0UGC4EABaAAygAgAQEAAQlAACl8C4IgAUAGQAoGQIaASgAGoBfABstDhUbLQ4ZDi0OFwouCoBiABMtDhgUIwAAi+UBKAACgGIAFS0MFQIjAABhhS0NDhMAKBMCFgA4FgIXLQ0XFBwMFBMAJwIWAQAtCAEUJwIXBAUAEAEXAScDFAQBACgUAhcnAhgEBEMDsAATgFsAGAAWABcFMIBWAAIAEy4IgF8ACiMAAIxPDSgACoBWABYkAgAWAACMdSMAAIxkASgAAoBiAAotDAoCIwAAX7YtDRUWADgTChcOOBMXGCQCABgAAIyQJQAAolgAKBQCGQA4GQoaLQ0aGAw4FxEZJAIAGQAAjLAlAACl3i4EABaAAygAgAQEACElAACl8C4IgAUAGQAoGQIaADgaFxstDhgbLQ4ZFQEoAAqAYgAWLQwWCiMAAIxPBSgACoBWABMtDQ4WATCAWgAKABcNKAATgEsAGCQCABgAAI0UJQAApd4AKBUCGQA4GRMaLQ0aGAEoABOAYgAZDjgTGRokAgAaAACNPCUAAKJYDSgAGYBLABokAgAaAACNUSUAAKXeACgVAhsAOBsZHC0NHBoBKAATgGMAGQ44ExkbJAIAGwAAjXklAACiWA0oABmASwAbJAIAGwAAjY4lAACl3gAoFQIcADgcGR0tDR0bASgAE4BcABkOOBMZHCQCABwAAI22JQAAolgNKAAZgEsAEyQCABMAAI3LJQAApd4AKBUCHAA4HBkdLQ0dExwMGBkEGDgZAhgcDBoZBAA4GBkaDjgYGhwkAgAcAACN/yUAAKJYGDgaAhgcDBsZBAA4GBkaDjgYGhskAgAbAACOICUAAKJYGDgaAhgcDBMZBAA4GBkTDjgYExokAgAaAACOQSUAAKJYDSgAF4BZABgkAgAYAACOViUAAKXeLgQAFoADKACABAQAESUAAKXwLgiABQAYACgYAhkAOBkXGi0OExotDhgOASgACoBiABMtDBMKIwAAXvotDQ4TDSgACoBZABUkAgAVAACOqiUAAKXeLgQAE4ADKACABAQAESUAAKXwLgiABQAVACgVAhYAOBYKFy4KgF8AFy0OFQ4BKAAKgGIAEy0MEwojAABeaC0IARYAAAECAS4KgF8AFgUoABSAVgAXBygAF4BWABkKOBkUGCQCABgAAI8YJQAAz4QuCIBfAAojAACPIw0oAAqAVgAYJAIAGAAAj5AjAACPOC0NEwotDRYXDSgAFIBZABYkAgAWAACPVSUAAKXeLgQACoADKACABAQAESUAAKXwLgiABQAWACgWAhgAOBgUGS0OFxkBKAAUgGIACi0OFhMtDAoUIwAAW6wAOBcKGQ44FxkaJAIAGgAAj6clAACiWA0oABmAaQAaJAIAGgAAj8cjAACPvC4IgF4AGCMAAI/zDSgAGYBpABokAgAaAACP3CUAAKXeACgOAhsAOBsZHC0NHBotDBoYIwAAj/MtDRYZGDgZAhocDBgZBAA4GhkYDjgaGBskAgAbAACQGCUAAKJYLQ4YFgEoAAqAYgAYLQwYCiMAAI8jLQ0JFQAoFQIXADgXChgtDRgWHAwWFQAnAhcBAC0IARYnAhgECQAQARgBJwMWBAEAKBYCGCcCGQQIQwOwABWAWwAZABcAGCcCGgQILgQAGIADLgQAGoAEJQAApr0FMIBLAAoAFS4IgF8AFCMAAJCcDSgAFIBLABckAgAXAACQwiMAAJCxASgACoBiABQtDBQKIwAAWkwtDRMXADgVFBgOOBUYGSQCABkAAJDdJQAAolgAKBYCGgA4GhQbLQ0bGQw4GBEaJAIAGgAAkP0lAACl3i4EABeAAygAgAQEACElAACl8C4IgAUAGgAoGgIbADgbGBwtDhkcLQ4aEwEoABSAYgAXLQwXFCMAAJCcLQ0JES0NExQAKBQCFgA4FgoXLQ0XFS4EABGAAygAgAQEABolAACl8C4IgAUAFAAoFAIWADgWChctDhUXLQ4UCQEoAAqAYgARLQwRCiMAAFmbBTCASwAKABQtCAEVAAABAgEuCoBgABUtCAEXAAABAgEuCoBGABcuCIBfABEjAACRug0oABGASwAYJAIAGAAAkiEjAACRzy0NExEtDRUUHAwUFwUcDBcVABwMFRQFLgQAEYADKACABAQAEiUAAKXwLgiABQAVACgVAhcAOBcKGC0OFBgtDhUTASgACoBiABEtDBEKIwAAWSktDRUYLQ0XGS0NFhoAOBQRGw44FBscJAIAHAAAkkQlAACiWA0oABuASgAcJAIAHAAAklklAACl3gAoGgIdADgdGx4tDR4cHAwcGgAEOBkaGwA4GBsaLQ4aFQUoABmAjgAYLQ4YFwEoABGAYgAYLQwYESMAAJG6LQ0WEQAoDgIUADgUChUtDRUTLgQAEYADKACABAQAiSUAAKXwLgiABQAUACgUAhUAOBUKFy0OExctDhQWASgACoBiABEtDBEKIwAAWEQtDREQJwITBBQtCAAULQwPFS0MDhYAEAATACUAANF4LQQAAC0MFRInAhQEFS0IABUtDBIWABAAFAAlAAC6ri0EAAAtDBYTLgQAEIADKACABAQACyUAAKXwLgiABQASACgSAhQAOBQKFS0OExUtDhIRASgACoBiABAtDBAKIwAAUSYtDRAPJwISBBMtCAATLQwOFC0MDRUAEAASACUAANF4LQQAAC0MFBEBKAARgGIAEy0NExIuBAAPgAMoAIAEBAALJQAApfAuCIAFABEAKBECEwA4EwoULQ4SFC0OERABKAAKgGIADy0MDwojAABQMQAoDgITADgTDBQtDRQSCygAEoBgABMkAgATAACVFiMAAJP2LQ0DEwAoEwITLQ4TAy0NCxMAKBMCEy0OEwsnAhQEAicCFgQDADgUFhUtCAETABABFQEnAxMEAQAoEwIVLQ4UFQAoFQIVLQ4UFScCFQQDADgTFRQtDBQVLgqARgAVACgVAhUuCoBkABUtDRMUACgUAhQtDhQTJwIVBBYtCAAWLgiAkgAXABAAFQAlAADFTS0EAAAtDBcULQ0TFQAoFQIVLQ4VEycCFwQYLQgAGC0MDxktDBAaLQwRGy0MEhwtDBQdLgiAYwAeLQwTHy4IgF0AIC4IgGAAIS4IgF0AIi4IgGAAIwAQABcAJQAAxWItBAAALQwZFS0MGhYnAhMEFy0IABctDBUYLQwWGQAQABMAJQAAxowtBAAALQwYEiMAAJUWASgADIBiABItDBIMIwAAR18tDREQLQ0PEi0NDhMMOBMNFCQCABQAAJVFJQAApd4AKBICFQA4FRMWLQ0WFAEoABOAYgAVDjgTFRYkAgAWAACVbSUAAKJYLQ4SDy0OFQ4uBAAQgAMoAIAEBAAYJQAApfAuCIAFABIAKBICEwA4EwwVLQ4UFS0OEhEBKAAMgGIAEC0MEAwjAABHDC0NERAtDQ8SLQ0OEwA4EwwUDjgTFBUkAgAVAACV0yUAAKJYDDgUDRMkAgATAACV5SUAAKXeACgSAhUAOBUUFi0NFhMuBAAQgAMoAIAEBAAYJQAApfAuCIAFABIAKBICFAA4FAwVLQ4TFS0OEhEBKAAMgGIAEC0MEAwjAABGVBwMDA4ALQgBDycCEAQCABABEAEnAw8EAQAoDwIQLQwQES0ODhEnAhAEES0IABEtDA8SABAAEAAlAACmfi0EAAAtDBIOJwIRBAEGKBECDycCEwQDADgRExItCAEQABABEgEnAxAEAQAoEAISLQ4REgAoEgISLQ4REicCEwQDADgQExIAKA4CEy4EABOAAy4EABKABC4EABGABSUAAKHnACgQAhItDRIRJwITBAIAOBITDjcNAA4AEQEoAAyAYgAOLQwODCMAADtiHAwMDgAnAg8EEC0IABAtDA4RABAADwAlAADDeC0EAAA4DAAOAA4BKAAMgGIADi0MDgwjAAA6jhwMDA4ANAIADgEoAAyAYgAOLQwODCMAADm6HAwMDgAyAgAOASgADIBiAA4tDA4MIwAAOOYcDAwRACcCEwQULQgAFC4IgGYAFS0MERYAEAATACUAANHvLQQAAC0MFRILKAASgGAAEQsoABGAXQATJAIAEwAAl6glAADS6icCEQQTLQgAEy0MDhQtDA8VLQwQFi0MEhctDAwYABAAEQAlAADS/C0EAAABKAAMgGIAES0MEQwjAAA4EgAoDAISADgSChMtDRMRJwISBBMtCAATLQwNFC0MDhUtDA8WLQwQFy0MERgAEAASACUAANMNLQQAAAEoAAqAYgARLQwRCiMAADOTLQ0ODQEoAAqAYgAPACgMAhEAOBEKEi0NEhANKAAPgGcAESQCABEAAJhdJQAApd4uBAANgAMoAIAEBAAGJQAApfAuCIAFABEAKBECEgA4Eg8TLQ4QEy0OEQ4tDA8KIwAAMu4tDRAOLQ0NDy0NDBEAOBEKEg44ERITJAIAEwAAmLMlAACiWA0oABKAVgARJAIAEQAAmMglAACl3gAoDwITADgTEhQtDRQRLgQADoADKACABAQABCUAAKXwLgiABQAPACgPAhIAOBIKEy0OERMtDg8QASgACoBiAA4tDA4KIwAAMf4tDQ4PACgMAhEAOBEKEi0NEhAAKA0CEgA4EgoTLQ0TEQo4EBESBDgPEhAtDhAOASgACoBiAA8tDA8KIwAAJQYtDQ8OLQ0NEC0NDBEAOBEKEg44ERITJAIAEwAAmXMlAACiWA0oABKAXAARJAIAEQAAmYglAACl3gAoEAITADgTEhQtDRQRLgQADoADKACABAQABCUAAKXwLgiABQAQACgQAhIAOBIKEy0OERMtDhAPASgACoBiAA4tDA4KIwAAJF0AKAkCDAA4DAUNLQ0NCicCDQQOLQgADi0MCg8AEAANACUAAKG8LQQAAC0MDwwtDQsKASgADIBiAA4tDQ4NLgQACoADKACABAQACyUAAKXwLgiABQAMACgMAg4AOA4FDy0ODQ8tDgwLASgABYBiAAotDAoFIwAAH6woAIAEBHgADQAAAIAEgAMkAIADAACacSoBAAEF96Hzr6Wt1Mo8AQECJiUAAJpJJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAKJqLQQAAC0MCAULKAADgGYAAQEoAAWAYgAGLQ0GAiQCAAEAAJs0IwAAmrsLKAADgGsAASQCAAEAAJsrIwAAmtALKAADgHQAASQCAAEAAJsiIwAAmuULKAADgIcAASQCAAEAAJr+JwIFBAA8CQEFJwIBBAUtCAAFLQwCBgAQAAEAJQAAw3gtBAAALQwCBCMAAJs9LQwCBCMAAJs9LQwCBCMAAJs9LQwCBCMAAJs9LQwEASYlAACaSTAEAAGARiYlAACaSS0IAQEAAAECAS4KgF0AAS0IAQIAAAECAS4KgGAAAi0IAQMAAAECASgCAAQAAiYtDgQDJwIFBAYtCAAGLQwBBy0MAggtDAMJLgiARgAKABAABQAlAACbty0EAAAtDAcELQwEASYlAACaSS8MAAQABS0MBQEmKgEAAQUptjwLdhQLZDwBAQImJQAAmkknAgYEBy0IAActDAEILQwCCQAQAAYAJQAAnYstBAAALQwIBQsoAAOAZgABASgABYBiAAYtDQYCJAIAAQAAnJsjAACcIgsoAAOAawABJAIAAQAAnJIjAACcNwsoAAOAdAABJAIAAQAAnIkjAACcTAsoAAOAhwABJAIAAQAAnGUnAgUEADwJAQUnAgEEBS0IAAUtDAIGABAAAQAlAADDeC0EAAAtDAIEIwAAnKQtDAIEIwAAnKQtDAIEIwAAnKQtDAIEIwAAnKQtDAQBJiUAAJpJMAQAAYBkMAQAAoBlJiUAAJpJJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAJ2LLQQAAC0MCAULKAADgGYAAQEoAAWAYgAGLQ0GAiQCAAEAAJ19IwAAnQQLKAADgGsAASQCAAEAAJ10IwAAnRkLKAADgHQAASQCAAEAAJ1rIwAAnS4LKAADgIcAASQCAAEAAJ1HJwIFBAA8CQEFJwIBBAUtCAAFLQwCBgAQAAEAJQAAw3gtBAAALQwCBCMAAJ2GLQwCBCMAAJ2GLQwCBCMAAJ2GLQwCBCMAAJ2GLQwEASYlAACaSS0NAQMtDQIEDSgABIBjAAUkAgAFAACdrSUAAKXeACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASAYgAFDjgEBQckAgAHAACd9SUAAKJYLQ4DAS0OBQItDAYBJiUAAJpJASgAAYBiAAMtDQMCHAwCAwQcDAMBABwMAQIELQwCASYlAACaSS0IAQMAAAECAS4KgF0AAy0IAQQAAAECAS4KgGAABC0IAQUAAAECASgCAAYAAhItDgYFJwIHBAgtCAAILgiAZgAJLQwBCgAQAAcAJQAA0e8tBAAALQwJBgsoAAaAYAAHCygAB4BdAAgkAgAIAACeoCUAANLqJwIHBAgtCAAILQwDCS0MBAotDAULLQwGDC0MAg0AEAAHACUAANL8LQQAACcCAwQELQgABC4IgGYABS0MAQYAEAADACUAANHvLQQAAC0MBQItDAIBJiUAAJpJLQgBAwAAAQIBLgqAXQADLQgBBAAAAQIBLgqAYAAELQgBBQAAAQIBKAIABgACEC0OBgUnAgcECC0IAAguCIBmAAktDAEKABAABwAlAADR7y0EAAAtDAkGCygABoBgAAcLKAAHgF0ACCQCAAgAAJ9uJQAA0uonAggECS0IAAktDAMKLQwECy0MBQwtDAYNABAACAAlAADUNi0EAAAtDAoHADgHAgYOOAcGCCQCAAgAAJ+wJQAAolgnAgcECC0IAAguCIBmAAktDAEKABAABwAlAADR7y0EAAAtDAkCCygAAoBgAAcLKAAHgF0ACCQCAAgAAJ/yJQAA0uonAgcECC0IAAgtDAMJLQwECi0MBQstDAIMLQwGDQAQAAcAJQAA0vwtBAAAJwIDBAQtCAAELgiAZgAFLQwBBgAQAAMAJQAA0e8tBAAALQwFAi0MAgEmJQAAmkknAgYEBy0IAActDAEILQwCCQAQAAYAJQAAomotBAAALQwIBQsoAAOAZgABASgABYBiAAYtDQYCJAIAAQAAoQkjAACgkAsoAAOAawABJAIAAQAAoQAjAACgpQsoAAOAdAABJAIAAQAAoPcjAACgugsoAAOAhwABJAIAAQAAoNMnAgUEADwJAQUnAgEEBS0IAAUtDAIGABAAAQAlAADDeC0EAAAtDAIEIwAAoRItDAIEIwAAoRItDAIEIwAAoRItDAIEIwAAoRItDAQBJiUAAJpJLQgBAgAAAQIBLgqAXQACLQgBAwAAAQIBLgqAYAADLQgBBAAAAQIBKAIABQACCi0OBQQnAgYEBy0IAAcuCIBmAAgtDAEJABAABgAlAADR7y0EAAAtDAgFCygABYBgAAELKAABgF0ABiQCAAYAAKGQJQAA0uonAgYEBy0IAActDAIILQwDCS0MBAotDAULABAABgAlAADUNi0EAAAtDAgBJiUAAJpJHAwBAgAtCAEBJwIDBAIAEAEDAScDAQQBACgBAgMtDAMELQ4CBCYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAoiwuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAofsmJQAAmkkcDAECAC0IAQEnAgMEAgAQAQMBJwMBBAEAKAECAy0MAwQtDgIEJioBAAEFRafKcRlB5BU8AQECJiUAAJpJLQ0BAy0NAgQLKAAEgF8ABSQCAAUAAKKMJQAApd4BKAADgGIABS0NBQQtCAEFJwIGBAIAEAEGAScDBQQBACgFAgYtDAYHLQ4EBy0OAwEuCoBiAAItDAUBJiUAAJpJLQgBBScCBgQEABABBgEnAwUEAQAoBQIGLQwGBy4KgGAABwAoBwIHLgqAYAAHACgHAgcuCoBgAActCAEGAAABAgEtDgUGLgiAXwAEIwAAoxwNKAAEgFwAAyQCAAMAAKOfIwAAozEtDQEDLQ0CBAEoAASAXAAFDjgEBQckAgAHAACjUyUAAKJYLQ4DAS0OBQItDQYBASgAAYBiAAMtDQMCASgAAYBjAAQtDQQDASgAAYBcAAUtDQUEHAwEBQEcDAUBABwMAQQBLQwCAS0MAwItDAQDJi0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAACjwiUAAKJYDSgACIBoAAckAgAHAACj1yUAAKXeACgFAgkAOAkICi0NCgcuBAADgAMoAIAEBAAEJQAApfAuCIAFAAUAKAUCCAA4CAQJLQ4HCS0OBQYBKAAEgGIAAy0MAwQjAACjHCUAAJpJJwIGBActCAAHLQwBCC0MAgkAEAAGACUAALkWLQQAAC0MCAULKAADgGYAAQEoAAWAYgAGLQ0GAiQCAAEAAKTiIwAApGkLKAADgGsAASQCAAEAAKTZIwAApH4LKAADgHQAASQCAAEAAKTQIwAApJMLKAADgIcAASQCAAEAAKSsJwIFBAA8CQEFJwIBBAUtCAAFLQwCBgAQAAEAJQAAw3gtBAAALQwCBCMAAKTrLQwCBCMAAKTrLQwCBCMAAKTrLQwCBCMAAKTrLQwEASYlAACaSRwMAQMGHAwDAgACOAECAywCAAQAEzEA1x/fNXkrFjZvT3aE31StfhSjKecPGO51PHb53G8EOAMEBQUwgFcABQADADgCAwQKOAEEAyQCAAMAAKVRJwIGBAA8CQEGLQwCAS0MBQImJQAAmkktDQEELQ0CBQ0oAAWAXAAGJAIABgAApXwlAACl3gAoBAIHADgHBQgtDQgGLQgBBycCCAQCABABCAEnAwcEAQAoBwIILQwICS0OBgkBKAAFgGIABg44BQYIJAIACAAApcQlAACiWC0OBAEtDgYCLQ0HAQAoAQIBLQ4BBy0MBwEmKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AGCwCABgACgAckAIAHAACmCyMAAKYWLgCAA4AFIwAApn0uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAACmaS4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAACmOCgBgAUEAAEDAIAGAAKABiMAAKZ9JiUAAJpJASgAAYBiAAMtDQMCLQgBAScCAwQCABABAwEnAwEEAQAoAQIDLQwDBC0OAgQtDQECACgCAgItDgIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAAKc8AwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuAoAHgAsBAIADgAiACy4CgAaACwEAgAkAAoAJIwAAptkmJQAAmkkLIIBdgGEAASQCAAEAAKdXJQAA1FUmJQAAmkktCAEBAAABAgEuCoBdAAEtCAECAAABAgEuCoBgAAItCAEDAAABAgEoAgAEAAHeLQ4EAx4CAAQAJwIGBAAnAggEAwA4BggHLQgBBQAQAQcBJwMFBAEAKAUCBy0OBgcAKAcCBy0OBgcnAgcEAwA4BQcGJwIHBAgtCAAILgiAkwAJABAABwAlAADFTS0EAAAtDAkGLQ0FBwAoBwIHLQ4HBScCCQQKLQgACi0MAQstDAIMLQwDDS0MBA4tDAYPLgiAXwAQLQwFES4IgF0AEi4IgGAAEy4IgF0AFC4IgGAAFQAQAAkAJQAAxWItBAAALQwLBy0MDAgLKAAHgF8AASQCAAEAAKhpJwICBAA8CQECJiUAAJpJLQgBAQAAAQIBLgqAXQABLQgBAgAAAQIBLgqAYAACLQgBAwAAAQIBKAIABAAB2S0OBAMeAgAEACcCBgQAJwIIBAMAOAYIBy0IAQUAEAEHAScDBQQBACgFAgctDgYHACgHAgctDgYHJwIHBAMAOAUHBicCBwQILQgACC4IgJAACQAQAAcAJQAAxU0tBAAALQwJBi0NBQcAKAcCBy0OBwUnAgkECi0IAAotDAELLQwCDC0MAw0tDAQOLQwGDy4IgF8AEC0MBREuCIBdABIuCIBgABMuCIBdABQuCIBgABUAEAAJACUAAMViLQQAAC0MCwctDAwIJwICBAktCAAJLQwHCi0MCAsAEAACACUAAMaMLQQAAC0MCgEnAgMEBC0IAAQtDAEFABAAAwAlAAC6ri0EAAAtDAUCJiUAAJpJHgIAAgoeAgADCycCBAJ6JwIFAignAgYCKS0IAQcnAggEEQAQAQgBJwMHBAEAKAcCCC0MCAkuCoB5AAkAKAkCCS4KgH4ACQAoCQIJLgqAiAAJACgJAgkuCoB+AAkAKAkCCS4KgHkACQAoCQIJLgqAegAJACgJAgkuCoB1AAkAKAkCCS4KgHcACQAoCQIJLgqAiwAJACgJAgkuCoB1AAkAKAkCCS0OBAkAKAkCCS4KgHoACQAoCQIJLgqAgwAJACgJAgkuCoCCAAkAKAkCCS0OBQkAKAkCCS0OBgktCAEEJwIFBAIAEAEFAScDBAQBACgEAgUtDAUGLgqAYAAGLQgBBQAAAQIBLQ4EBS0IAQQAAAECAS4KgF8ABC0IAQYnAggEIAAQAQgBJwMGBAEAKAYCCCcCCQQfADgJCAktDAgKDDgKCQsWDAsLJAIACwAAqwkuCoBeAAoAKAoCCiMAAKroLQgBCAAAAQIBLQ4GCC0IAQYnAgkEIAAQAQkBJwMGBAEAKAYCCScCCgQfADgKCQotDAkLDDgLCgwWDAwMJAIADAAAq10uCoBeAAsAKAsCCyMAAKs8LgiAXwABIwAAq2gNKAABgFkACSQCAAkAAK3WIwAAq30tDQQBLQ0FBi0NBgcAKAcCBy0OBwYLKAABgGIABiQCAAYAAKwfIwAAq6ctDQUBLQ0EBi0NCAQnAggECS0IAAktDAQKLgiAXQALABAACAAlAADUZy0EAAAtDAoHCygABoBfAAQkAgAEAACr7SUAAKXeLgQAAYADKACABAQAAiUAAKXwLgiABQAEACgEAgYBKAAGgF8ACC0OBwgtDgQFIwAArB8tDQUBKwIABAAAAAAAAAAAAQAAAAAAAAAAJwIJBAotCAAKLQwECwAQAAkAJQAAutMtBAAALQwLBS0MDAYtDA0HLQwOCC0IAQQAAAECAS0OBQQtCAEFAAABAgEtDgYFLQgBBgAAAQIBLQ4HBi0IAQcAAAECAS0OCActDQEIACgIAggtDggBASgAAYBiAAktDQkIJwIBBAktCAAJLQwECi0MBQstDAYMLQwHDS0MCA4AEAABACUAANMNLQQAACcCCAQJLQgACS0MBAotDAULLQwGDC0MBw0AEAAIACUAALtmLQQAAC0MCgEnAgUEBi0IAAYtDAEHABAABQAlAADFTS0EAAAtDAcEKQIAAQAAAw1AAjgCAQUCOAMBAh4CAAEAHAwEAwAnAgYEAScCCAQDADgGCActCAEEABABBwEnAwQEAQAoBAIHLQ4GBwAoBwIHLQ4GBycCBwQDADgEBwYtDAYHLQ4DBwAoBAIHLQ0HBicCCAQCADgHCAM5A+gABQACAAEAAwAGIAIAAQsoAAGAXQACJAIAAgAArbwlAADVYyECAAELKAABgF8AAiQCAAIAAK3VJQAA1XUmBygAAYBwAAoFKAAKgHAACwI4AQsJLQ0ICgAoBwIMADgMAQ0tDQ0LDSgACYBwAAwkAgAMAACuEiUAAKXeLgQACoADKACABAQAICUAAKXwLgiABQAMACgMAg0AOA0JDi0OCw4tDgwICygACYBuAAokAgAKAACuUSMAAK7pLQ0FCS0NBAotDQwLACgLAgstDgsMJwINBA4tCAAOLQwMDy4IgF0AEAAQAA0AJQAA1GctBAAALQwPCwsoAAqAXwAMJAIADAAArqAlAACl3i4EAAmAAygAgAQEAAIlAACl8C4IgAUACgAoCgIMASgADIBfAA0tDgsNLQ4KBS0NBgkAKAkCCS0OCQYtDgYILgqAYgAEIwAArukBKAABgGIACS0MCQEjAACraCUAAJpJJwIBAmotCAECJwIDBAoAEAEDAScDAgQBACgCAgMtDAMELQ4BBAAoBAIELgqAhgAEACgEAgQuCoCEAAQAKAQCBC4KgIUABAAoBAIELgqAcQAEACgEAgQuCoCFAAQAKAQCBC4KgHoABAAoBAIELgqAigAEACgEAgQuCoCFAAQnAgMEACcCBQQDADgDBQQtCAEBABABBAEnAwEEAQAoAQIELQ4DBAAoBAIELQ4DBCcCBAQDADgBBAMAKAICAwAoAQIGLQ0GBScCBwQCADgGBwQ+OwADAAQABQAJJwICAjotCAEDJwIEBAwAEAEEAScDAwQBACgDAgQtDAQFLgqAhAAFACgFAgUuCoB6AAUAKAUCBS4KgHgABQAoBQIFLgqAggAFACgFAgUuCoCBAAUAKAUCBS4KgHkABQAoBQIFLQ4CBQAoBQIFLgqAcQAFACgFAgUuCoCMAAUAKAUCBS4KgHMABQAoBQIFLgqAjQAFJwIFBAQnAgcEAwA4BQcGLQgBBAAQAQYBJwMEBAEAKAQCBi0OBQYAKAYCBi0OBQYnAgYEAwA4BAYFLQwFBi4KgEYABgAoBgIGLgqAZAAGACgGAgYuCoBlAAYAKAYCBi4KgGYABgAoAwIFACgEAggtDQgHJwIJBAIAOAgJBj47AAUABgAHAAstCAEDJwIFBBAAEAEFAScDAwQBACgDAgUtDAUGLgqAiQAGACgGAgYuCoB9AAYAKAYCBi4KgIIABgAoBgIGLgqAfwAGACgGAgYuCoB6AAYAKAYCBi4KgHEABgAoBgIGLgqAdgAGACgGAgYuCoCDAAYAKAYCBi4KgIMABgAoBgIGLgqAdgAGACgGAgYuCoCLAAYAKAYCBi0OAgYAKAYCBi4KgHEABgAoBgIGLgqAjAAGACgGAgYuCoCNAAYtDQQCACgCAgItDgIEACgDAgIAKAQCBy0NBwYnAggEAgA4BwgFPjsAAgAFAAYADycCAgIKJwIDAgknAgQCLS0IAQUnAgYEJQAQAQYBJwMFBAEAKAUCBi0MBgcuCoCFAAcAKAcCBy4KgHYABwAoBwIHLgqAdwAHACgHAgcuCoCEAAcAKAcCBy4KgHEABwAoBwIHLgqAdgAHACgHAgcuCoCBAAcAKAcCBy4KgHkABwAoBwIHLgqAcQAHACgHAgcuCoCBAAcAKAcCBy4KgHoABwAoBwIHLgqAiQAHACgHAgcuCoB/AAcAKAcCBy4KgH4ABwAoBwIHLgqAgQAHACgHAgcuCoB6AAcAKAcCBy4KgIQABwAoBwIHLQ4CBwAoBwIHLQ4DBwAoBwIHLQ4EBwAoBwIHLgqAcQAHACgHAgcuCoB7AAcAKAcCBy4KgH4ABwAoBwIHLgqAgwAHACgHAgcuCoCEAAcAKAcCBy4KgIUABwAoBwIHLQ4CBwAoBwIHLQ4DBwAoBwIHLQ4EBwAoBwIHLgqAcQAHACgHAgcuCoCEAAcAKAcCBy4KgHoABwAoBwIHLgqAeAAHACgHAgcuCoCCAAcAKAcCBy4KgIEABwAoBwIHLgqAeQAHLQ0BAgAoAgICLQ4CAQAoBQICACgBAgYtDQYEJwIHBAIAOAYHAz47AAIAAwAEACQmKgEAAQUls+YrYAM6izwBAQImJQAAmkkBKAABgGIAAy0NAwIBKAABgGMABC0NBAMBKAABgFwABS0NBQQtCAEBJwIFBAQAEAEFAScDAQQBACgBAgUtDAUGLQ4CBgAoBgIGLQ4DBgAoBgIGLQ4EBiYqAQABBbswVh+XPcHsPAEBAiYlAACaSS0IAQIAAAECAS4KgF0AAi0IAQMAAAECAS4KgGAAAy0IAQQAAAECASgCAAUAAbQtDgUEHgIABQAnAgcEACcCCQQDADgHCQgtCAEGABABCAEnAwYEAQAoBgIILQ4HCAAoCAIILQ4HCCcCCAQDADgGCAcnAggECS0IAAkuCICUAAoAEAAIACUAAMVNLQQAAC0MCgctDQYIACgIAggtDggGJwIKBAstCAALLQwCDC0MAw0tDAQOLQwFDy0MBxAuCIBfABEtDAYSLgiAXQATLgiAYAAULgiAXQAVLgiAYAAWABAACgAlAADFYi0EAAAtDAwILQwNCS0NCQIAKAICAi0OAgkLKAAIgFwAAiQCAAIAALVNJwIDBAA8CQEDASgACYBcAAMtDQMCASgACYBWAAQtDQQDASgACYBnAAUtDQUELQgBBScCBgQEABABBgEnAwUEAQAoBQIGLQwGBy0OAgcAKAcCBy0OAwcAKAcCBy0OBAcnAgMEBi0IAAYtDAUHABAAAwAlAACzwS0EAAAtDAcCIQIAAy0IAQUAKAUCCC0NCAcnAgkEAgA4CAkGIjSAXwADAAYtDAMHJwIJBAMAOAcJCAAQAQgBJwMFBAEAKAUCCS0OBwkAKAkCCS0OBwktDAcEBigEAgQnAgYEAycCCAQDADgGCActCAEDABABBwEnAwMEAQAoAwIHLQ4GBwAoBwIHLQ4GBycCBwQDADgDBwYtDAYHLgqARgAHACgHAgcuCoBkAAcAKAcCBy4KgGUABy0NBQYAKAYCBi0OBgUtDQMGACgGAgYtDgYDCygABIBcAAYtCAEHAAABAgEtDgYHLQ0FBgAoBgIGLQ4GBS4IgF8AASMAALa4DDgBBAIkAgACAAC23CMAALbKLQ0HASQCAAEAALbbJQAA1YcmLQ0HBiQCAAIAALbtJQAApd4nAgkEAwA4BQkIADgIAQktDQkCDSgAAYBcAAgkAgAIAAC3FSUAAKXeJwIKBAMAOAMKCQA4CQEKLQ0KCAo4AggJBDgGCQItDgIHASgAAYBiAAItDAIBIwAAtrglAACaSS0IAQMnAgQEBAAQAQQBJwMDBAEAKAMCBC0MBAUuCoBgAAUAKAUCBS4KgGAABQAoBQIFLgqAYAAFLQgBBAAAAQIBLQ4DBC4IgF8AAiMAALecDSgAAoBcAAMkAgADAAC3tiMAALexLQ0EASYAKAECBgA4BgIHLQ0HBS0NBAYkAgADAAC31SUAAKXeLgQABoADKACABAQABCUAAKXwLgiABQADACgDAgcAOAcCCC0OBQgBKAACgGIABS0OAwQtDAUCIwAAt5wqAQABBfKpp0YEFRONPAEBAiYqAQABBY4KxTVjpCz6PAEBAiYqAQABBZAhhVnyaDHWPAEBAiYlAACaSScCBgQHLQgABy0MAQgtDAIJABAABgAlAAC5Fi0EAAAtDAgFCygAA4BmAAEBKAAFgGIABi0NBgIkAgABAAC5CCMAALiPCygAA4BrAAEkAgABAAC4/yMAALikCygAA4B0AAEkAgABAAC49iMAALi5CygAA4CHAAEkAgABAAC40icCBQQAPAkBBScCAQQFLQgABS0MAgYAEAABACUAAMN4LQQAAC0MAgQjAAC5ES0MAgQjAAC5ES0MAgQjAAC5ES0MAgQjAAC5ES0MBAEmJQAAmkktDQEDLQ0CBA0oAASAVgAFJAIABQAAuTglAACl3gAoAwIGADgGBActDQcFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgBKAAEgGIABQ44BAUHJAIABwAAuYAlAACiWC0OAwEtDgUCLQwGASYlAACaSTY4AAEABQAGABwMBgcABDgHBQg2OAABAAUABwEcDAcJAAQ4CQUKNjgAAQAFAAkCHAwJAQAEOAEFCyQCAAYAALnYJQAAuBAkAgAHAAC55SUAALgiJAIACQAAufIlAAC4NAo4CAIBJAIAAQAAuggnAgUEADwJAQUKOAMKASQCAAEAALoeJwICBAA8CQECCjgLBAEkAgABAAC6NCcCAgQAPAkBAiYlAACaSR4CAAEAJiUAAJpJHgIAAQEmJQAAmkkeAgABAiYlAACaSR4CAAEDJiUAAJpJHgIAAQQmJQAAmkkeAgABBSYlAACaSR4CAAEGJiUAAJpJHgIAAQcmJQAAmkkeAgABCCYlAACaSR4CAAEKJiUAAJpJHgIAAQsmJQAAmkkBKAABgGIAAy0NAwIcDAIDAhwMAwEAHAwBAgItDAIBJiUAAJpJLQgBAicCAwQEABABAwEnAwIEAQAoAgIDLQwDBC4KgGAABAAoBAIELgqAYAAEACgEAgQuCoBgAAQtCAEDJwIEBAUAEAEEAScDAwQBACgDAgQtDAQFLgqAYAAFACgFAgUuCoBgAAUAKAUCBS4KgGAABQAoBQIFLQ4BBS4IgF0ABC0MAgEtDAMCLgiAXwADJiUAAJpJLQ0EBQsoAAWAXQAGJAIABgAAu4gnAgcEADwJAQcnAgUEBi0IAAYtDAEHLQwCCC0MAwktDAQKABAABQAlAADVmS0EAAAtDQEFLQ0CBi0NAwctDgUBLQ4GAi0OBwMuCoBhAAQBKAAGgGIAAi0NAgEmJQAAmkktCAECJwIDBAQAEAEDAScDAgQBACgCAgMtDAMELgqAagAEACgEAgQuCoBsAAQAKAQCBC4KgG8ABCcCBAQFLQgABS0MAgYAEAAEACUAALdHLQQAAC0MBgMnAgUEAwYoBQICJwIHBAMAOAUHBi0IAQQAEAEGAScDBAQBACgEAgYtDgUGACgGAgYtDgUGJwIHBAMAOAQHBgAoAwIHLgQAB4ADLgQABoAELgQABYAFJQAAoecAKAQCBi0NBgUnAgcEAgA4BgcDNw0AAwAFJwIDAkgnAgQCLCcCBQIhLQgBBicCBwQOABABBwEnAwYEAQAoBgIHLQwHCC0OAwgAKAgCCC4KgHoACAAoCAIILgqAfwAIACgIAgguCoB/AAgAKAgCCC4KgIIACAAoCAIILQ4ECAAoCAIILgqAcQAIACgIAgguCoCJAAgAKAgCCC4KgIIACAAoCAIILgqAgwAIACgIAgguCoB/AAgAKAgCCC4KgHkACAAoCAIILQ4FCC0IAQMnAgUEDgAQAQUBJwMDBAEAKAMCBScCBwQNADgHBQctDAUIDDgIBwkWDAkJJAIACQAAvZ8uCoBgAAgAKAgCCCMAAL1+LQgBBQAAAQIBLQ4DBScCAwQNLgiAXwABIwAAvbwMOAEDAiQCAAIAAMKsIwAAvc4tDQUCJwIHBA0GKAcCBScCCQQDADgHCQgtCAEGABABCAEnAwYEAQAoBgIILQ4HCAAoCAIILQ4HCCcCCQQDADgGCQgAKAICCS4EAAmAAy4EAAiABC4EAAeABSUAAKHnACgGAggtDQgHJwIJBAIAOAgJAjcNAAIABycCAgJBJwIDAi4tCAEGJwIHBC0AEAEHAScDBgQBACgGAgctDAcILQ4CCAAoCAIILgqAcQAIACgIAgguCoB/AAgAKAgCCC4KgIIACAAoCAIILgqAgQAIACgIAgguCoB8AAgAKAgCCC4KgHEACAAoCAIILgqAhQAIACgIAgguCoB+AAgAKAgCCC4KgIAACAAoCAIILgqAegAIACgIAgguCoBxAAgAKAgCCC4KgHYACAAoCAIILgqAfAAIACgIAgguCoCCAAgAKAgCCC0OBAgAKAgCCC4KgHEACAAoCAIILgqAfgAIACgIAgguCoCBAAgAKAgCCC4KgHEACAAoCAIILgqAdgAIACgIAgguCoBxAAgAKAgCCC4KgHwACAAoCAIILgqAdgAIACgIAgguCoB/AAgAKAgCCC4KgHYACAAoCAIILgqAigAIACgIAgguCoCLAAgAKAgCCC4KgHEACAAoCAIILgqAewAIACgIAgguCoB2AAgAKAgCCC4KgIMACAAoCAIILgqAcQAIACgIAgguCoB7AAgAKAgCCC4KgHYACAAoCAIILgqAgwAIACgIAgguCoBxAAgAKAgCCC4KgHYACAAoCAIILgqAiQAIACgIAgguCoB2AAgAKAgCCC4KgIsACAAoCAIILQ4DCAAoCAIILQ4DCAAoCAIILQ4DCC0IAQInAgMEAwAQAQMBJwMCBAEAKAICAy0MAwQuCoBgAAQAKAQCBC4KgGAABC0IAQMAAAECAS0OAgMtCAECAAABAgEuCoBfAAItCAEEJwIHBCAAEAEHAScDBAQBACgEAgcnAggEHwA4CAcILQwHCQw4CQgKFgwKCiQCAAoAAMDQLgqAXgAJACgJAgkjAADAry4IgF8AASMAAMDbDSgAAYBjAAUkAgAFAADBaCMAAMDwLQ0DAScCBAQCBigEAgInAgYEAwA4BAYFLQgBAwAQAQUBJwMDBAEAKAMCBS0OBAUAKAUCBS0OBAUnAgYEAwA4AwYFACgBAgYuBAAGgAMuBAAFgAQuBAAEgAUlAACh5wAoAwIFLQ0FBCcCBgQCADgFBgE3DQABAAQmLQ0EBwAoBwIHLQ4HBC0IAQcAAAECAS0OBAcuCIBfAAUjAADBjQ0oAAWAcAAIJAIACAAAwgojAADBoi0NAwUtDQcIJwIJBAotCAAKLQwICy4IgGEADAAQAAkAJQAA1GctBAAALQwLBy4EAAWAAygAgAQEAAMlAACl8C4IgAUACAAoCAIJADgJAQotDgcKLQ4IAwEoAAGAYgAFLQwFASMAAMDbLQ0CCA0oAAiASQAJJAIACQAAwiMjAADCmy0NBwgtDQIJDSgACYBJAAokAgAKAADCQCUAAKXeACgGAgsAOAsJDC0NDAouBAAIgAMoAIAEBAAgJQAApfAuCIAFAAsAKAsCDAA4DAUNLQ4KDS0OCwcBKAAJgGIACA44CQgKJAIACgAAwpIlAACiWC0OCAIjAADCmwEoAAWAYgAILQwIBSMAAMGNLQ0FAgAoBgIIADgIAQktDQkHHAwHCAAuBAACgAMoAIAEBAAOJQAApfAuCIAFAAcAKAcCCQA4CQEKLQ4ICi0OBwUBKAABgGIAAi0MAgEjAAC9vCUAAJpJHAwBAgAtCAEBJwIDBAIAEAEDAScDAQQBACgBAgMtDAMELQ4CBCYlAACaSTICAAEmJQAAmkk0AgABJiUAAJpJHgIAAgAzOAABAAIAAy0MAwEmKgEAAQVKVyZRmd+WrDwBAQImKgEAAQUmJuxZFX4xvzwBAQImJQAAmkkcDAECACwCAAMAAAAAAAAAAAAAAAAA//////////////////////////8OOAIDBCQCAAQAAMO5JQAA1qcmJQAAmkk4DAABAAImJQAAmkktCAEBAAABAgEuCoBdAAEtCAECAAABAgEuCoBgAAItCAEDAAABAgEoAgAEAAFBLQ4EAycCBQQAJwIHBAMAOAUHBi0IAQQAEAEGAScDBAQBACgEAgYtDgUGACgGAgYtDgUGJwIGBAMAOAQGBScCBgQHLQgABy4IgI8ACAAQAAYAJQAAxU0tBAAALQwIBS0NBAYAKAYCBi0OBgQnAggECS0IAAktDAEKLQwCCy0MAwwuCIByAA0tDAUOLgiAXwAPLQwEEC4IgF0AES4IgGAAEi4IgF0AEy4IgGAAFAAQAAgAJQAAxWItBAAALQwKBi0MCwcLKAAGgF8AASQCAAEAAMTUJwICBAA8CQECJiUAAJpJJwICBAAnAgQEAwA4AgQDLQgBAQAQAQMBJwMBBAEAKAECAy0OAgMAKAMCAy0OAgMnAgMEAwA4AQMCACgBAgQtDQQDJwIFBAIAOAQFAjkDCIBGgEaAcgACAAMgAgABCygAAYBdAAIkAgACAADFTCUAANa5JiUAAJpJHAwBAwQcDAMCABwMAgEEJiUAAJpJHAwFDAAAKAYCBS4EAAeAAygAgAQEAAElAADWyy4IgAUADS4IgAYADi0ODA4WDAgGHAwIBwAcDAYIAAQ4BwkGBSgACIBYAAcAOAYHCBYMCgYcDAoHABwMBgkABDgHCwYFKAAJgFgABwA4BgcJACgNAgotDQoHJwILBAIAOAoLBjkD6AAIAAkABAAGAAcgAgAEIQIABS0IAQcAKAcCCi0NCgknAgsEAgA4CgsIIjSAXwAFAAgtDAUJJwILBAMAOAkLCgAQAQoBJwMHBAEAKAcCCy0OCQsAKAsCCy0OCQstDAkGBigGAgYkAgAEAADGgyMAAMZaLQ0HAQAoAQIBLQ4BBwAoBwIDLQ0DAicCBAQCADgDBAE8DQECIwAAxoMtDAYBLQwHAiYlAACaSS0NAgMAKAMCAy0OAwILKAABgGIAAyQCAAMAAMa3JwIEBAA8CQEEASgAAoBcAAMtDQMBLQgBAicCAwQCABABAwEnAwIEAQAoAgIDLQwDBC0OAQQtDAIBJiUAAJpJLQgBAwAAAQIBLgqAXQADLQgBBAAAAQIBLgqAYAAELQgBBQAAAQIBKAIABgABNC0OBgUeAgAGACcCCAQCJwIKBAMAOAgKCS0IAQcAEAEJAScDBwQBACgHAgktDggJACgJAgktDggJJwIJBAMAOAcJCC0MCAktDgEJACgJAgktDgIJLQ0HAQAoAQIBLQ4BBycCAgQILQgACC4IgJIACQAQAAIAJQAAxU0tBAAALQwJAS0NBwIAKAICAi0OAgcnAgkECi0IAAotDAMLLQwEDC0MBQ0tDAYOLQwBDy4IgGMAEC0MBxEuCIBdABIuCIBgABMuCIBdABQuCIBgABUAEAAJACUAAMViLQQAAC0MCwItDAwIJwIDBAktCAAJLQwCCi0MCAsAEAADACUAAMaMLQQAAC0MCgEBKAABgGIAAy0NAwItDAIBJiUAAJpJHgIAAwAnAgUEBi0IAAYuCICSAAcAEAAFACUAAMVNLQQAAC0MBwQcDAQFACcCBgQDJwIIBAMAOAYIBy0IAQQAEAEHAScDBAQBACgEAgctDgYHACgHAgctDgYHJwIHBAMAOAQHBi0MBgctDgUHACgHAgctDgEHACgHAgctDgIHACgEAgUtDQUCJwIGBAIAOAUGAToDiIBYgFgAAwABAAIgAgABIQIAAi0IAQQAKAQCBy0NBwYnAggEAgA4BwgFIjSAXwACAAUtDAIGJwIIBAMAOAYIBwAQAQcBJwMEBAEAKAQCCC0OBggAKAgCCC0OBggtDAYDBigDAgMkAgABAADJZSMAAMk8LQ0EAQAoAQIBLQ4BBAAoBAIFLQ0FAicCBgQCADgFBgE8DQECIwAAyWUnAgIEBS0IAAUtDAMGLQwEBwAQAAIAJQAAxowtBAAALQwGAQEoAAGAYgADLQ0DAi0MAgEmJQAAmkkeAgABACcCAwQELQgABC4IgJEABQAQAAMAJQAAxU0tBAAALQwFAhwMAgMAJwIEBAInAgYEAwA4BAYFLQgBAgAQAQUBJwMCBAEAKAICBS0OBAUAKAUCBS0OBAUnAgUEAwA4AgUELQwEBS0OAwUAKAUCBS4KgGwABQAoAgIFLQ0FBCcCBgQCADgFBgM6A4iAWIBYAAEAAwAEIAIAASECAAItCAEEACgEAgctDQcGJwIIBAIAOAcIBSI0gF8AAgAFLQwCBicCCAQDADgGCAcAEAEHAScDBAQBACgEAggtDgYIACgIAggtDgYILQwGAwYoAwIDJAIAAQAAysUjAADKnC0NBAEAKAECAS0OAQQAKAQCBS0NBQInAgYEAgA4BQYBPA0BAiMAAMrFCygAA4BfAAEkAgABAADK3icCAgQAPAkBAiYlAACaSS0IAQQnAgUECwAQAQUBJwMEBAEAKAQCBS0MBQYuCoBgAAYAKAYCBi4KgGAABgAoBgIGLgqAYAAGACgGAgYuCoBgAAYAKAYCBi4KgGAABgAoBgIGLgqAYAAGACgGAgYuCoBgAAYAKAYCBi4KgGAABgAoBgIGLgqAYAAGACgGAgYuCoBgAAYtCAEFAAABAgEtDgQFLgiAXwADIwAAy4ENKAADgGkABCQCAAQAAMvFIwAAy5YtDQEDLQ0CBAEoAASAaQAGDjgEBgckAgAHAADLuCUAAKJYLQ4DAS0OBgItDQUBJi0NBQQtDQEGLQ0CBwA4BwMIDjgHCAkkAgAJAADL6CUAAKJYDSgACIBtAAckAgAHAADL/SUAAKXeACgGAgkAOAkICi0NCgcuBAAEgAMoAIAEBAALJQAApfAuCIAFAAYAKAYCCAA4CAMJLQ4HCQEoAAOAYgAELQ4GBS0MBAMjAADLgSUAAJpJJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAM0WLQQAAC0MCAULKAADgGYAAQEoAAWAYgAGLQ0GAiQCAAEAAM0IIwAAzI8LKAADgGsAASQCAAEAAMz/IwAAzKQLKAADgHQAASQCAAEAAMz2IwAAzLkLKAADgIcAASQCAAEAAMzSJwIFBAA8CQEFJwIBBAUtCAAFLQwCBgAQAAEAJQAAw3gtBAAALQwCBCMAAM0RLQwCBCMAAM0RLQwCBCMAAM0RLQwCBCMAAM0RLQwEASYlAACaSS0NAQMtDQIEDSgABIBtAAUkAgAFAADNOCUAAKXeACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASAYgAFDjgEBQckAgAHAADNgCUAAKJYLQ4DAS0OBQItDAYBJiUAAJpJJwIDBAAnAgUEAwA4AwUELQgBAgAQAQQBJwMCBAEAKAICBC0OAwQAKAQCBC0OAwQnAgQEAwA4AgQDACgBAgMAKAICBi0NBgUnAgcEAgA4BgcEPjsAAwAEAAUAEiYlAACaSScCAwQAJwIFBAMAOAMFBC0IAQIAEAEEAScDAgQBACgCAgQtDgMEACgEAgQtDgMEJwIEBAMAOAIEAwAoAQIDACgCAgYtDQYFJwIHBAIAOAYHBD47AAMABAAFABAmJQAAmkknAgMEACcCBQQDADgDBQQtCAECABABBAEnAwIEAQAoAgIELQ4DBAAoBAIELQ4DBCcCBAQDADgCBAMAKAECAwAoAgIGLQ0GBScCBwQCADgGBwQ+OwADAAQABQARJiUAAJpJJwIDBAAnAgUEAwA4AwUELQgBAgAQAQQBJwMCBAEAKAICBC0OAwQAKAQCBC0OAwQnAgQEAwA4AgQDACgBAgMAKAICBi0NBgUnAgcEAgA4BgcEPjsAAwAEAAUADyYlAACaSScCAwQAJwIFBAMAOAMFBC0IAQIAEAEEAScDAgQBACgCAgQtDgMEACgEAgQtDgMEJwIEBAMAOAIEAwAoAQIDACgCAgYtDQYFJwIHBAIAOAYHBD47AAMABAAFAAsmKgEAAQUohpKwR9z9QzwBAQImKgEAAQVkYYioxs+UyzwBAQImKgEAAQXJb5M7E53pFjwBAQImJQAAmkkuCIBfAAUjAADPuA0oAAWAXAAGJAIABgAA0CMjAADPzS0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGLQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBiAAYkAgAHAADQQSMAANCtLQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAACl8C4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAANCtLQwGBSMAAM+4JQAAmkknAgMEACcCBQQDADgDBQQtCAECABABBAEnAwIEAQAoAgIELQ4DBAAoBAIELQ4DBCcCBAQDADgCBAMAKAECAwAoAgIGLQ0GBScCBwQCADgGBwQ+OwADAAQABQANJiUAAJpJJwIDBAAnAgUEAwA4AwUELQgBAgAQAQQBJwMCBAEAKAICBC0OAwQAKAQCBC0OAwQnAgQEAwA4AgQDACgBAgMAKAICBi0NBgUnAgcEAgA4BgcEPjsAAwAEAAUAEyYlAACaSS0NAQMtDQIEDSgABIBpAAUkAgAFAADRmiUAAKXeACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASAYgAFDjgEBQckAgAHAADR4iUAAKJYLQ4DAS0OBQItDAYBJiUAAJpJKwIAAwAAAAAAAAAAAgAAAAAAAAAAJwIIBAktCAAJLQwDCgAQAAgAJQAAutMtBAAALQwKBC0MCwUtDAwGLQwNBy0IAQMAAAECAS0OBAMtCAEEAAABAgEtDgUELQgBBQAAAQIBLQ4GBS0IAQYAAAECAS0OBwYnAgcECC0IAAgtDAMJLQwECi0MBQstDAYMLQwBDQAQAAcAJQAA0w0tBAAAJwIBBActCAAHLQwDCC0MBAktDAUKLQwGCy0MAgwAEAABACUAANMNLQQAACcCAgQHLQgABy0MAwgtDAQJLQwFCi0MBgsAEAACACUAALtmLQQAAC0MCAEmKgEAAQUC3G4ngHYSnTwBAQImJQAAmkkcDAUGADAMAAYABCYlAACaSS0NAwYtDQQHCygAB4BdAAgkAgAIAADTMycCCQQAPAkBCQsoAAaAXAAHJAIABwAA08IjAADTSC0NAQYtDQIHLQ0DCC0NBAkNKAAIgFwACiQCAAoAANNtJQAApd4uBAAGgAMoAIAEBAAEJQAApfAuCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiAYgAFDjgIBQYkAgAGAADTrSUAAKJYLQ4KAS0OBwItDgUDLQ4JBCMAANQ1JwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAA1ZktBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAKXwLgiABQAJACgJAgoBKAAKgF8ACy0OBQstDgkBLQ4HAi4KgGIAAy0OCAQjAADUNSYlAACaSS8MAAQABRwMBQYEHAwGBAAcDAQFBC0MBQEmKgEAAQUOx/B1LZpWkDwBAQImJQAAmkktDQEEACgEAgQtDgQBLQgBBAAAAQIBLgqAYAAELQgBBQAAAQIBLgqARgAFLgiAXwADIwAA1KINKAADgHAABiQCAAYAANS8IwAA1LctDQQBJi0IAQYAAAECAS0OAwYkAgACAADU1iMAANUEAzCAcAADAAcDKAAHgGIACA8wgGIABwAJJAIACQAA1PslAADPci0OCAYjAADVBC0NBActDQYIDSgACIBwAAYkAgAGAADVISUAAKXeACgBAgkAOAkICi0NCgYcDAYIAC0NBQYEOAgGCQA4BwkILQ4IBAUoAAaAjgAHLQ4HBQEoAAOAYgAGLQwGAyMAANSiKgEAAQV/kIAtSEmQ/zwBAQImKgEAAQW55lMdg4GSijwBAQImKgEAAQX3oRtg4/LhVTwBAQImJQAAmkkuCIBfAAUjAADVqQ0oAAWAXAAGJAIABgAA1hQjAADVvi0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGLQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBiAAYkAgAHAADWMiMAANaeLQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAACl8C4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAANaeLQwGBSMAANWpKgEAAQVaAuQbtR6pnzwBAQImKgEAAQVoqv6c/oaGWjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAA1xojAADXiiQAgA0AANcnIwAA10AuAIADgAUBAIAFAAKADi4CgAuADiMAANeFKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAANeFIwAA194oAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAA194oAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAA2D4uAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAA2A0uAIAMgAYmAQCABgACgAcBAIAHAAKACCgBgAYAAAAoAYAHAAAAKAGACAEAASgAgAkEAAAoAIALAAAAKACADAQA/igAgAoEAH4oAIANBACAKACADgEAASgAgA8BAAAoAIAQBAACKACAEQQAAwcAgAWAEYAFDQCACYAFgBIkAIASAADYxiMAANoJBQCACYARgBMBAIATgAOAEwUAgAmAEIAUAQCAFIAEgBQBAIAUAAKAFQsBgBSAC4AWCwGAFYALgBcRAIAWgBeAFiQAgBYAANn8LgAAAYAWAQAAAYAMAAFDABGAFYAQgAqADoAWAQCAFoAKgBdDABGAFIAQgA2ADoAXAQCAFoAMgBgkAYAWAADZWwEAgBYAAoAWIwAA2UYuAYATgBkBAIATAAKAHC4BgByAGgEAgBwAAoAcLgGAHIAbLgCAGYAcLgCAGoAdLgCAG4AeAQCAFgACgBYNAIAWgBiAHyQAgB8AANmsIwAA2etCAACAGYAagBuAGYAagBuAGQsBgBaAD4AfJACAHwAA2d5CAACAHIAdgB6AGYAagBuAGQEAgBYAAoAWIwAA2ZdCAEeABoAHgAiAGYAagBuABgEAgAkAAoAJIwAA2LEm",
      "debug_symbols": "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hNu5OnCMyzvtL624WrSHIxBnGG7nMeYxTjDcTpwY40C/NLAcGsoHlgOB5UBgOeycXq5tPUdWSXo4wXA7pxLGOMNwO/OUIW7nytYxTiFcTVj/XhM2fqk5gTiQb6e953UWlbOkwQRBdB11ilL+eswvXK5VX5h1NEFoVlchVPhuglB3Lqt40ICyGcDDSYutP11yZ9JV9+YQz5QUz0v9PIvytcLqzVV5daG7oBqEMgQ1eiAkyzayqFSvKAFQbXR70A6qG9XKOqm+PcS8ofpzliFKEFR//l7Kth2vdFD9vH+Va+So1kP1dyCOuBhS2N9xN0L1z+QWuyaWasodVP+ag1sU3aN27qMaofr9zxClCKo/th2hKmRXZQTVIG80yBsEKeyPE2u9xo1KqYdiBCUQV3814BbViWzU7x2GqNZHXeN85S6q25bret1yH9VvlUOUApGN+6PJEarflkeofv8l7Rrnpf2aKf8DJf0IsCXjjTqjT9m5736EYgTVP18/RDUIBXlj54rsEUqgTLfsnJUY4xjDMcjHIJ+AfALyKcinYPkZyLfzysgYZxBu5/TuIJ7snJq1dI3kVnqojLSgndNyI64KKezPDYcoRlCERLydU0gjFENc/bG3rYtRJr0axYagBOKSUSTvohSqh/1xyAhlSG+48974ECUIKhcIBXEVyK5CEAopL6uP1o2/Lf/6//7jv//lH//pr//yHwvk4//+17/+83/+5d/+9fKv//n//d/r//mnf//LX//6l//zD//33//tn//lf/3Xv//LP/z13/754//9KV3+8T/FpP15Cee06Pnwlqac/qyp6PLvH9pENP1ZxNKH3uXfl7XRZn/OyxJ3/UD88RNLRuXPUq19/Id8+ab++eOftOhdNP//",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "nested_call_to_assert_same",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgMEAicCBAQAHxgABAADgEUuCIBFAAEuCIBGAAIlAAAAUSUAAAB+LgQAAYBHKAIAAgSARycCAwQBOw0AAgADLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMmJQAAAcEeAgADACkCAAQAEU/O6CcCBgQDJwIIBAMAOAYIBy0IAQUAEAEHAScDBQQBACgFAgctDgYHACgHAgctDgYHJwIHBAMAOAUHBi0MBgctDgQHACgHAgctDgEHACgHAgctDgIHACgFAgQtDQQCJwIGBAIAOAQGATkDiIBDgEMAAwABAAIgAgABIQIAAicCAwQALQgBBQAoBQIILQ0IBycCCQQCADgICQYiPAADAAIABi0MAgcnAgkEAwA4BwkIABABCAEnAwUEAQAoBQIJLQ4HCQAoCQIJLQ4HCS0MBwQGKAQCBCQCAAEAAAGZIwAAAXAtDQUBACgBAgEtDgEFACgFAgMtDQMCJwIGBAIAOAMGATwNAQIjAAABmScCAQQBCjgEAQIkAgACAAABtCcCAwQAPAkBAwEoAAWARAACLQ0CASYoAIAEBHgADQAAAIAEgAMkAIADAAAB6SoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "1drdquIwEAfwd+l1LzIfSSa+yrIcqtZDoVSpurCI776t2Frq2dObg87ciJUx/vgjk6TNJduW6/PnR9Xs9sds9euS1ftNcar2TXd1uebZuq3quvr8mH6cuf4FCG5fOB6Kpr8+nor2lK1Aopc8K5vt7X2UbpBdVZfZyrtr/lTOycV7NScIY3GAL4qFeRhaOPC0+HfegcJ/QBxGkAB+DxISP/4G0KOYvigmx3AvJufDHMReGcg7bSBtCQVtCQXWBkrKQFFbQlFbQkLaQKIMlFAbKOoCoVOWEDplsz2CsqkDQdnkiqCsMSIqmzoQ39AY07AAJ4wLC3BwEN0AcUjzJTgSGfdH235G437j+b9h+0Bh2BMTCS75I9Hoj/7Z//qGyDQkSsxxyS9uhDgh9+R/ff9kgIdflvwJ/OhPXub+SMb90bZf0Lg/2PYnMO63nT852/2TwHb/JDCePxrPH43nT8bzJ9vrB2Lb6wdi4/PXGx5w/ahf1f6lB0VNf+gbSFOH6EHy+iWrRx5AfnHLDJTG5/HASE/+YNufnHG/N+1nZzt/dj/yUMKP9wXFS/jeDzGMN+GmB2Q43EDA2kDaEsKoDESoDRReDhJxj6HjHMSsCXTtrv4UbVWs6/J+0G13bjaTc2+nv4dydgTu0O435fbclv1huMk5uL7/CeQSumG7of8B",
      "brillig_names": [
        "nested_call_to_assert_same"
      ]
    },
    {
      "name": "set_opcode_u64",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABZKgIAAQUQAAAAAAAAACYoAIAEBHgADQAAAIAEgAMkAIADAAAAgSoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "XYzBCoAgEET/Zc8dskOHfiUi1DZZEBXTIGT/PYUO4WXgzWOmwIEqm53c6S9Y1gLWa5nIu0qFB1CRrCWzd/UtI0ll8cMzO/2z6QnY7UP0Go8csT01B2MLUXMV8zCJjZk3fgE=",
      "brillig_names": [
        "set_opcode_u64"
      ]
    },
    {
      "name": "get_fee_per_da_gas",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQgmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoQgEEX/ZZ59UCnX+pVYwmoKQTTMFpbo31ejJdntZZg7HC5zNhiwW6dW29EtUDcbGNeroJ2NadsJdF4bo6c2PwNN41Ee/DIrm+ISlA9QMy4oJ4B2OHZexI5RG4S6pDv5w4Us5EkLKS5YsBtYVtW3uqKszOHnHtNLea06g+fr42r7zCS8Z/yRmr3rcVg9Jr3LjMXZMEE4i7Wx+gM=",
      "brillig_names": [
        "get_fee_per_da_gas"
      ]
    },
    {
      "name": "read_assert_storage_single",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "3005655821239716708": {
            "error_kind": "string",
            "string": "Storage value does not match input"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABpJwICAAEvDAACAAMKOAEDAiQCAAIAAABoJQAAAJImKACABAR4AA0AAACABIADJACAAwAAAJEqAQABBfeh86+lrdTKPAEBAiYqAQABBSm2PAt2FAtkPAEBAiY=",
      "debug_symbols": "5ZLdaoQwEIXfJde5yIybH32VUpaocQmEKFELRXz3TopdpZXC7u3ehEz4ZuYcchbWunq+XX3s+pFVbwsLfWMn30eqlpWzOvkQ/O16fGYiH1p+8+NgYy7HyaaJVQgGOXOxpSsKoAmdD45VUqz8DwxwkRsMoMUdBnU5obUpxEZrI/fRCs5gheUPrJT5HyYdZXEXIlEd8XfOjHgdq+rcqta71eJolXpKeKKnfLRnperDJm/r4LZwdnNsDlmdPgf3K7ZD6hvXzsnlAO/ZhfyhKDhKkgJZPiqOhnbQni8=",
      "brillig_names": [
        "read_assert_storage_single"
      ]
    },
    {
      "name": "pedersen_commit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "x",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "y",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "is_infinite",
                "type": {
                  "kind": "boolean"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "3ZrdquJADMffpde9mMwkmRlfZVkOftRDQVT8WFjEd9/6UfVY6UJJPOHcSCuT/v5J2iTWORSzarL//KiX89W2GP06FIvVdLyrV8vm7HAsi8mmXizqz4/Hrwt3+gAMZ4Pterw8nW93482uGKWMVBbVcnY6jL65xLxeVMUo8/F32RjFAUbkhxgNIfEQEg8hRRhiRAOMkhtihK+MKKR8NSIkuBmRO5adxRBSvC5uDtNtMeQLIWsTclAnJGWCd0GdoO4DqPsAUZvgQZ3A2oTg1AmkTtCuGh5RnaD+xL1umKIE7ScueAEfEHxLQAjPBBR4HihxS2D6QuguDo5bhwN4fpYToyU5CGhLTjYlh9iUHIlRR1KOqVuZnLclx1Z0wFZ0wFZ0JAY/STlkSk4w1UIpmOpZFEz1LEJTTYIkxmBBOWSrDJKtMsi2yiCbGr8oqpbBM0GgsjHlGyFTv8NIGa+LkdHdF/NFTjIlJwVbcmxFJ9uKTjYVHXamosPOVnTAVnTAVnQwfqec8CxHYoSRlMOm5EiMMJJyyJScGEzJyQITVe/bX84oMLNhaglE3CFkZUJ0qE6Q+JEW3J0Q/zNoM0I7aHPC/sXJtQlOjzN5fLGUsb3bvgzX8eykRJOz7+RPyWRqL8uPfxpdnPQ/JZOp1RBdJ5P+3ZmMHFonk4PnEhH43XIo9shBeLcczH1y2JQcQltysik5LFE+4N5PfewQkjZB4k1RPyGBOoG1CdmrE6IyITmvTtDOQwJQJ6jnwaM6IWsTJHZu9RNEdtv0E/R9UM8D6XagY3P2Z7ypx5NFdd3hPd8vpw8bvnd/19XT3u/1ZjWtZvtNddoFft8AfsonhFQC5UY5XE59CSE2mAb1Dw==",
      "brillig_names": [
        "pedersen_commit"
      ]
    },
    {
      "name": "bulk_testing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "args_field",
            "type": {
              "kind": "array",
              "length": 10,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "args_u8",
            "type": {
              "kind": "array",
              "length": 10,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "get_instance_for_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_deployer",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "expected_initialization_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10235209936248515834": {
            "error_kind": "string",
            "string": "Contract instance not found when getting CLASS_ID!"
          },
          "10385728837058572758": {
            "error_kind": "string",
            "string": "Contract instance not found when getting INIT_HASH!"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17485690947400700813": {
            "error_kind": "string",
            "string": "Contract instance not found when getting DEPLOYER!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AQAoDgIPLQwPEC4KgGMAEAAoEAIQLgqAZAAQACgQAhAuCoBkABAAKBACEC0OCRAAKBACEC0OCBAAKBACEC4KgG4AEAAoEAIQLgqAbAAQACgQAhAuCoBtABAAKBACEC4KgGMAEAAoEAIQLgqAZwAQACgQAhAuCoBlABAAKBACEC0OCRAAKBACEC4KgGoAEAAoEAIQLgqAYwAQACgQAhAtDgsQJwIPBBAtCAAQLQwOEQAQAA8AJQAASFotBAAAHgIADgAtCAEPAAABAgEuCoBXAA8tCAEQAAABAgEuCoBaABAtCAERAAABAgEnAhIA+i0OEhEnAhMEFC0IABQtDAwVLQwOFgAQABMAJQAARs4tBAAALQwVEgsoABKAWgATCygAE4BXABQkAgAUAAAIOiUAAEhIJwIUBBUtCAAVLQwPFi0MEBctDBEYLQwSGQAQABQAJQAASLstBAAALQwWEycCDwQKADgTDxAOOBMQESQCABEAAAiBJQAASNonAhIEEy0IABMtDAwULQwOFQAQABIAJQAARs4tBAAALQwUEQsoABGAWgASCygAEoBXABMkAgATAAAIwSUAAEhIHAwQEgAwDAASABEnAhEEEi0IABItDAwTLQwOFAAQABEAJQAARs4tBAAALQwTEC0IAQ4nAhEEEQAQAREBJwMOBAEAKA4CES0MERIuCoBtABIAKBICEi4KgGUAEgAoEgISLgqAYwASACgSAhIuCoBkABIAKBICEi0OCRIAKBICEi0OCBIAKBICEi4KgG4AEgAoEgISLgqAbAASACgSAhIuCoBtABIAKBICEi4KgGMAEgAoEgISLgqAZwASACgSAhIuCoBlABIAKBICEi0OCRIAKBICEi4KgGoAEgAoEgISLgqAYwASACgSAhItDgsSJwIRBBItCAASLQwOEwAQABEAJQAARgwtBAAAHgIADgAtCAERAAABAgEuCoBXABEtCAESAAABAgEuCoBaABItCAETAAABAgEnAhQA8S0OFBMnAhUEFi0IABYtDAwXLQwOGAAQABUAJQAARs4tBAAALQwXFAsoABSAWgAMCygADIBXAA4kAgAOAAAKPiUAAEhIJwIOBBUtCAAVLQwRFi0MEhctDBMYLQwUGQAQAA4AJQAASLstBAAALQwWDCcCDgJrJwIRAmMnAhICaC0IARMnAhQEDAAQARQBJwMTBAEA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",
      "debug_symbols": "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",
      "brillig_names": [
        "bulk_testing"
      ]
    },
    {
      "name": "to_radix_le",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "input",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAAbSUAAABuACgBAgIoAgADBIBFJwIEBAouBAACgAMuBAADgAQuBAAEgAUlAAAAwigCAAIEgEUnAgMECjsNAAIAAyYlAAABCCcCAgQCJwIEAQAtCAEDJwIFBAsAEAEFAScDAwQBACgDAgUnAgYECkMD8AABAAIABgAEAAUnAgcECi4EAAWAAy4EAAeABCUAAAExLQwDASYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAAQcuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAANYmKACABAR4AA0AAACABIADJACAAwAAATAqAQABBfeh86+lrdTKPAEBAiYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAABsAMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgKAB4ALAQCAA4AIgAsuAoAGgAsBAIAJAAKACSMAAAFNJg==",
      "debug_symbols": "tZRNCoMwEIXvMussjPlTr1JKiRolEKLEWCiSuzcpUqRdzybMhJd88xh4B4ym3+eH9dOyQXc7wC2DjnbxuTsSgT5Y5+z8uF5DVQ5KxefBtmpf+i3qEKGTlZQEjB9L2bD8xWSdgU5UifyJVUvbU6xapr5i2qQ7AVpX6AR8Dy02gXF0AroHju6Bo3sQ6B6kwiaoGp3QYBMa3D2k3D11sLp35gzJaffDJTPjazU/8bmGZTDjHkwJ0kuG5kkFI4rmuVmumSRcFg8l+Lgios64jHwD",
      "brillig_names": [
        "to_radix_le"
      ]
    },
    {
      "name": "assert_nullifier_exists",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "5356792413696267948": {
            "error_kind": "string",
            "string": "Nullifier doesn't exist!"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABrHgIAAgAzOAABAAIAAycCAQEBJAIAAwAAAGolAAAAlCYoAIAEBHgADQAAAIAEgAMkAIADAAAAkyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFSlcmUZnflqw8AQECJg==",
      "debug_symbols": "nZLbasQgEED/xWcfvDvmV0pZTGIWQUwwSaGE/Hu12K30sqX7Io6cmTk4c6DR9fv14uM0r6h7OlCYB7v5OeboODHqkw/BXy/tMyLl0PKdXxcbS7huNm2oowLAYOTiWO6GmFxj8sGhTpITf8MzoSstDFU3WNEfYBACKgxCiRZ+xgjILz6S33xA6/s+VOoPH6o4v+9jJBcVNrKpXH3gbx9DWeuTswx/JIsS+v+0M0cvNnnbB1enPe1xaIa/vS7uyx4saR7cuCdXNuJzGWj5fEYwk8WmyDCFGeQeuc8b",
      "brillig_names": [
        "assert_nullifier_exists"
      ]
    },
    {
      "name": "get_args_hash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "_a",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "_fields",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_args_hash"
      ]
    },
    {
      "name": "set_opcode_u8",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRJwIBAggmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "XYzBCoAgEET/Zc8dskOHfiUi1DZZEBXTIGT/PYUO4WXgzWOmwIEqm53c6S9Y1gLWa5nIu0qFB1CRrCWzd/UtI0ll8cMzO/2z6QnY7UP0Go8csT01B2MLUXMV8zCJjZk3fgE=",
      "brillig_names": [
        "set_opcode_u8"
      ]
    },
    {
      "name": "get_l2_gas_left",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQomKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99aDptp78iQ6pGKZRWah0M8d/XDtlk20vIDYdLzgYDdevUGjf6BepmA+t7HY13KW07gy4Ya83Uns/A81Dli19m7XJcog4RahSyEgzIDXlXiKljNJagLvnOfnDFxeWgFb/INyzxD1xxWRxwxa/FGb7tKd11MLqzdLw+rq4/mcTHTF9Sc/A9DWugrPcxwzQblExgqk3VTw==",
      "brillig_names": [
        "get_l2_gas_left"
      ]
    },
    {
      "name": "variable_base_msm",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "scalar_lo",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "scalar_hi",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "scalar2_lo",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "scalar2_hi",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "is_infinite",
                "type": {
                  "kind": "boolean"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABAMnAgUEBCcCBgQAHxgABgAFgEYuCIBGAAEuCIBHAAIuCIBIAAMuCIBJAAQlAAAAaSUAAACdLgQAAYBKLgQAAoBLLgQAA4BMKAIABASASicCBQQDOw0ABAAFKACAQwAAASwAgEQAAAAAAAAAAALPE151BqRdYy0nDUXxGBKUgz/EjYI/JywoAIBFBAADJiUAAAG1JwIFAQAtCAEGJwIHBAcAEAEHAScDBgQBACgGAgctDAcILgqAQwAIACgIAgguCoBEAAgAKAgCCC0OBQgAKAgCCC4KgEMACAAoCAIILgqARAAIACgIAggtDgUILQgBBScCBwQFABABBwEnAwUEAQAoBQIHLQwHCC0OAQgAKAgCCC0OAggAKAgCCC0OAwgAKAgCCC0OBAgtCAEBJwICBAQAEAECAScDAQQBACgGAgInAgMEBgAoBQIEJwIHBAQAKAECCC4EAAKAAy4EAASABC4EAAOABS4EAAiABiUAAAHeJwICBAEAOAECBC0NBAMnAgIEAgA4AQIFLQ0FBAEoAAGARQAFLQ0FAi0MAwEtDAIDLQwEAiYoAIAEBHgADQAAAIAEgAMkAIADAAAB3SoBAAEF96Hzr6Wt1Mo8AQECJgEAgAYAAoAHAQCABwACgAgoAYAGAAAAKAGABwAAACgBgAgBAAEoAIAJBAAAKACACwAAACgAgAwEAP4oAIAKBAB+KACADQQAgCgAgA4BAAEoAIAPAQAAKACAEAQAAigAgBEEAAMHAIAFgBGABQ0AgAmABYASJACAEgAAAl8jAAADogUAgAmAEYATAQCAE4ADgBMFAIAJgBCAFAEAgBSABIAUAQCAFAACgBULAYAUgAuAFgsBgBWAC4AXEQCAFoAXgBYkAIAWAAADlS4AAAGAFgEAAAGADAABQwARgBWAEIAKgA6AFgEAgBaACoAXQwARgBSAEIANgA6AFwEAgBaADIAYJAGAFgAAAvQBAIAWAAKAFiMAAALfLgGAE4AZAQCAEwACgBwuAYAcgBoBAIAcAAKAHC4BgByAGy4AgBmAHC4AgBqAHS4AgBuAHgEAgBYAAoAWDQCAFoAYgB8kAIAfAAADRSMAAAOEQgAAgBmAGoAbgBmAGoAbgBkLAYAWgA+AHyQAgB8AAAN3QgAAgByAHYAegBmAGoAbgBkBAIAWAAKAFiMAAAMwQgBHgAaAB4AIgBmAGoAbgAYBAIAJAAKACSMAAAJKJg==",
      "debug_symbols": "tZfbaoQwFEX/Jc8+JCcXzfxKKYOXOAii4qVQxH+vFhlsx5fuel7ESFa2S+PBM4siZNPjXjVlO4jb2yzqNk/Hqm3W0bxEIuuruq4e9+NlIbeDcvQNDF3abONhTPtR3BJvbCRCU2ynMa1LlFUdxM275T1aoRiAYoVADoASJClBkjyS5O3fIZIKgQAnUoRAwI4gQpwIcdKIk0acjEagBIAs4mSRp+eQ9+SQJKRGEFIjKJEIZBDIA5BHtpEHtpGWhEDAp6HV6cu1StEOWbLxE7JyiV4mG+vNPtk4I5+T1Z5guRNIsiewO2h2B83uYNgdDLuDZXew7A7nFfEfCfolwXMneHaH88J8YYKRmj2B3eH8x/PKhMur98+EZR19pH2VZnXYO69yavJDIzZ+duFXT9b1bR6KqQ9bd3ZozLZbjV2UqHXZdekv",
      "brillig_names": [
        "variable_base_msm"
      ]
    },
    {
      "name": "add_u128",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "b",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgMEAicCBAQAHxgABAADgEQdAIBEgEQGHQCARYBFBi4IgEQAAS4IgEUAAiUAAABfJQAAAGAuBAABgEYoAgACBIBGJwIDBAE7DQACAAMmJQAAAIEAOAECAw44AQMEJAIABAAAAHwlAAAAqi0MAwEmKACABAR4AA0AAACABIADJACAAwAAAKkqAQABBfeh86+lrdTKPAEBAiYqAQABBUWnynEZQeQVPAEBAiY=",
      "debug_symbols": "nZBBCsMgEEXvMmsX0SQtyVVKCSaZBEE0GC0U8e4dpQvprtmIf+DPG16EFeewT8ps9oTxEUHbRXplDaWYGMxOaa32qR5Dkx/e8FI4D2lyPr10HkbO+35ggGYt/3tHSzalEUbRpyej2u1SjV+j8eH/WqL0kk7JWeNXwxbMUlnx7wN/BB3OLrgGh1lVbYn4omNiKNdQaBvWCmIQ5wM=",
      "brillig_names": [
        "add_u128"
      ]
    },
    {
      "name": "get_timestamp",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQYmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99MM7W6q/IkKpRCqWVWgdD/PdVka1sewm54XDJ2WCgbp1abUe3QN1sYFyvgnY2pm1n0HltjJ7a9AzZMUp+8sus7BGXoHyAGvMiRwZkh3O/ydgxakNQ82xnP7goquqiBcfsDQv8A0tZlBcspeApfN9jeiivVWfoen1cbZ+YhOdMX1Kzdz0Nq6dD72OGcTYoWI6xNla/AA==",
      "brillig_names": [
        "get_timestamp"
      ]
    },
    {
      "name": "send_l2_to_l1_msg",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "content",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAASyUAAABMKAIAAQSARicCAgQAOw0AAQACJiUAAABYOAwAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAACAKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "bY/dCoMwDIXfJddetHVq9VVkSNUohdJKrYMhvvtScZv7uQk54eOQb4Ue22VstB3cDFW9gnGdCtpZSuuWQOu1MXpszmdgcUi+8/OkbIxzUD5AxTPJiwTQ9vueltQxaINQZWxLfnBRXNKDFoVkLzjnf+CylPmzmrH0g75ulG7Ka9UaPH4fFtudVMJ9wi+rybsO+8Vj9HurcZo1aQhBtVT9AA==",
      "brillig_names": [
        "send_l2_to_l1_msg"
      ]
    },
    {
      "name": "external_call_to_divide_by_zero_recovers",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "9191987771437846783": {
            "error_kind": "string",
            "string": "Nested CALL instruction should return failure on exceptional halt"
          },
          "13395485527885582986": {
            "error_kind": "string",
            "string": "Returndata should be empty when nested call exceptionally halts"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "external_call_to_divide_by_zero_recovers"
      ]
    },
    {
      "name": "nested_call_to_nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABlKAIAAQSARCcCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABiikCAAEARpBkuicCAwQBJwIFBAMAOAMFBC0IAQIAEAEEAScDAgQBACgCAgQtDgMEACgEAgQtDgMEJwIEBAMAOAIEAy0MAwQtDgEEJwIBAConAgMEAQAoAgIGLQ0GBScCBwQCADgGBwQ5A4iAQ4BDAAEABAAFIAIAASECAAInAgMEAC0IAQUAKAUCCC0NCAcnAgkEAgA4CAkGIjwAAwACAAYtDAIHJwIJBAMAOAcJCAAQAQgBJwMFBAEAKAUCCS0OBwkAKAkCCS0OBwktDAcEBigEAgQkAgABAAABcyMAAAFKLQ0FAQAoAQIBLQ4BBQAoBQIGLQ0GAicCBwQCADgGBwE8DQECIwAAAXMKOAQDASQCAAEAAAGJJwICBAA8CQECJigAgAQEeAANAAAAgASAAyQAgAMAAAGyKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1ZrbisJADIbfZa57MZnM0VdZlqVqlUKpUuvCIn33nRZ7WCv0xrXJjTgSk/9LZGZicxP7bHs9fuXl4XQRm4+bKE67tM5PZVzdmkRsq7wo8uPX9GMh2xeQtvvC5ZyW7fpSp1UtNmDBhERk5b59r8BGJ4e8yMTGyCaZm4MC15uD0mY0xyfmKDXcrVGa0beF5jMRAIacJCXpSaKXJaSXJdT0JAVykjS9LGl6WTJIT5InJ8kqepIcOUmOXpYcvZuAX+VACb01KvdH0hPfEpzsfUuFekZguBME9jUI/GsQmBMoqdkTsK+BWuPMQet7AvRqicAhDgTOzAnWOKI09llFrd0SgZd2IPAoHwlWaZE0wEjglwgCmIEgGD8jMOwJAneCVfq11xJ47gSrdIOvJWBfA8d+N3Xsd1PPvgaefQ0C+xoE/jXgfquI/8WwJ+B+oiEo7gTEOpxOEq0fdieJ1m7RStJrXGiN0r0ks9hcx0dnfvCtFc4IPHcCo9gTOO4Eln0NHLyEAL0eo0g1Jeii2HdE8fotUcK/R2ni6jut8nRbZPexnMO13E2mdOqfc/YwsHOuTrtsf62ydnRnOrUT5TpInI1uo+tf",
      "brillig_names": [
        "nested_call_to_nothing"
      ]
    },
    {
      "name": "read_storage_single",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABbJwIBAAEvDAABAAItDAIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "5ZJbCoMwEEX3Mt/5yMTmoVsppUSNEghRohaKuPcmxVpppRvoT8gNh8tkODPUppzaq/VNN0BxnsF1lR5t52OaFwJlsM7Z9rp/BpoOyZ/80Guf4jDqMELBqMwIGF+na85iQ2OdgYLThXzBiCe+woiSbjCK0wEtVUZXWiqOGy3wCBYsf8FCqN9wnCPPtkE4E3v8QkDRP/nqEtNNB6tLZ1YBmslXOx/Ge28+1OhDV5l6CiZJ8vYD09JQEZbF2lj9AA==",
      "brillig_names": [
        "read_storage_single"
      ]
    },
    {
      "name": "read_storage_list",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAZyUAAABoACgBAgIoAgADBIBEJwIEBAIuBAACgAMuBAADgAQuBAAEgAUlAAAArSgCAAIEgEQnAgMEAjsNAAIAAyYlAAAA8ycCAQACLwwAAQACJwIBAAMvDAABAAMtCAEBJwIEBAMAEAEEAScDAQQBACgBAgQtDAQFLQ4CBQAoBQIFLQ4DBSYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAAPIuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAAMEmKACABAR4AA0AAACABIADJACAAwAAARsqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "5ZXdioUgFIXfxesutv/ZqwzDwcoOglhYDQzRu48eOk3MRHdedRNt/XTtJeJaUGvq+fmwvutHVH0syPWNnmzvY7WsBaqDdc4+H8dhBOmDQb0WjIP2qR4nHSZUESFlgYxv069icYvOOoMqDmvxD8aY8Q3GWMIOY8FOaFlS2GhZcrzTAp/Bgqg3LER5Dcc+FN0b4UQc8c8Cxfn7eCVwI6/8Pl4pPvUqQby9SgLXXi/glwLPrcAgu0J2Dzy7B57fg8qtIGh2hTKrwhqrLx2srp3ZwrSbfXPI1ul7MH9idgh9Y9o5mBS4v1mbzoKygrHUd7o+8cnhECWizA8=",
      "brillig_names": [
        "read_storage_list"
      ]
    },
    {
      "name": "get_block_number",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQUmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY9bCoMwEEX3Mt/5MKZ54FakSNRRAiGRGAtF3Huj2Da0/gxzh8Nlzgo9tsvYGDf4Gap6Bes7HY13Ka0bgTYYa83Y5Gco9iH5wc+Tdnucow4RKloyJgmg64+dy9QxGItQ8WIjf7hgjJ60YDf+gQW9gJVUb1iposzh+5bSQwejW4vn68PiuswkPif8kZqC77BfAu56XzOaZk0FKWmqTdUv",
      "brillig_names": [
        "get_block_number"
      ]
    },
    {
      "name": "nullifier_collision",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABUNAIAATQCAAEmKACABAR4AA0AAACABIADJACAAwAAAHwqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "vZDdCoMgGIbv5Tv2IJ0/s1uJEVYWgmiYDUZ077NoLbaOO/nwlYeXl2eCRldjVxrX+gHyYgLraxWNdylNM4IqGGtNVx6/IVuOYCs/9MotcYgqRMgxo4wg0K5Z34KmjtZYDTnLZvSHU0E+dGLFDnN8Akt+4xssOb8f4QcCIc/3MCL2PYzKi/bMKT1VMKqyelPZjq4+mI2vXv9I7oOvdTMGvej+msbpFlggQlJtqn4D",
      "brillig_names": [
        "nullifier_collision"
      ]
    },
    {
      "name": "nested_call_to_add",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgMEAicCBAQAHxgABAADgEUuCIBFAAEuCIBGAAIlAAAAUSUAAAB+LgQAAYBHKAIAAgSARycCAwQBOw0AAgADLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMmJQAAAcEeAgADACkCAAQAqmNIoScCBgQDJwIIBAMAOAYIBy0IAQUAEAEHAScDBQQBACgFAgctDgYHACgHAgctDgYHJwIHBAMAOAUHBi0MBgctDgQHACgHAgctDgEHACgHAgctDgIHACgFAgQtDQQCJwIGBAIAOAQGATkDiIBDgEMAAwABAAIgAgABIQIAAicCAwQALQgBBQAoBQIILQ0IBycCCQQCADgICQYiPAADAAIABi0MAgcnAgkEAwA4BwkIABABCAEnAwUEAQAoBQIJLQ4HCQAoCQIJLQ4HCS0MBwQGKAQCBCQCAAEAAAGZIwAAAXAtDQUBACgBAgEtDgEFACgFAgMtDQMCJwIGBAIAOAMGATwNAQIjAAABmScCAQQBCjgEAQIkAgACAAABtCcCAwQAPAkBAwEoAAWARAACLQ0CASYoAIAEBHgADQAAAIAEgAMkAIADAAAB6SoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "1drdquIwEAfwd+l1LzIfSSa+yrIcqtZDoVSpurCI776t2Fbq2dObg87ciJUx/vgjk6TNJduW6/PnR9Xs9sds9euS1ftNcar2TXd1uebZuq3quvr8ePw4c/0LENy+cDwUTX99PBXtKVtBBJA8K5vt7T1JN8iuqsts5d01fyrn5OK9mhOEsTjAF8XCPAwtHPix+HfegcJ/QC5MoBi+BwmJH38DaCqmL4rJMdyLyfkwB7FXBvJOG0hbQkFbQoG1gZIyUNSWUNSWkJA2kCgDJdQGirpA6JQlhE7ZbI+gbOpAUDa5IihrjIjKpg7ENzTGNCzACePCAhwcRDdAHNJ8CY5Exv3Rtp/RuN94/m/YPlAY9sREgkv+SDT6o3/2v74hMg2JEnNc8ssEcULuyf/6/skAk1+W/An86E9e5v5Ixv3Rtl/QuD/Y9icw7redPznb/ZPAdv8kMJ4/Gs8fjedPxvMn2+sHYtvrB2Lj89cbHnD9qF/V/qUHRU1/6BtIU4foQfL6JatHHkB+ccsMlMbn8cBIT/5g25+ccb837WdnO392P/JQwo/3BcVL+N7fjTbehItxaigcbiBgbSBtCWFUBiLUBgovB4mMd8ZF4hzErAl07a7+FG1VrOvyftBtd242D+feTn8P5ewI3KHdb8rtuS37w3AP5+D6/ieQS+iG7Yb+Bw==",
      "brillig_names": [
        "nested_call_to_add"
      ]
    },
    {
      "name": "create_same_nullifier_in_nested_call",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nestedAddress",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAASyUAAABxKAIAAQSARicCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABnjQCAAIpAgADANl9DIonAgUEAicCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBgQDADgEBgUtDAUGLQ4DBgAoBgIGLQ4CBicCAgQCACgEAgYtDQYFJwIHBAIAOAYHAzkDiIBDgEMAAQADAAUgAgABIQIAAicCAwQALQgBBQAoBQIILQ0IBycCCQQCADgICQYiPAADAAIABi0MAgcnAgkEAwA4BwkIABABCAEnAwUEAQAoBQIJLQ4HCQAoCQIJLQ4HCS0MBwQGKAQCBCQCAAEAAAGHIwAAAV4tDQUBACgBAgEtDgEFACgFAgYtDQYCJwIHBAIAOAYHATwNAQIjAAABhwo4BAMBJAIAAQAAAZ0nAgIEADwJAQImKACABAR4AA0AAACABIADJACAAwAAAcYqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "1ZrdavJAEIbvJcc5mL/981Y+PkrUWAIhStRCEe+9iZgYVOpJ28ycSFZed95nRnZ2dU/Zulwe39+qZrPdZ4t/p6zeropDtW260emcZ8u2quvq/W36dgb9C2K8fGC/K5p+vD8U7SFbYKSQ8qxs1v0zA3aTbKq6zBYOzvmDXALRVS1Bwij2+EScPPurOHkfp+L/eYZEzw3xGKJ7DvF7Q4iEYZAjibvJ+YmcQfCqZnD+3hKjPktenSXRlyXRlyUH+iw5dZa8vix5hVlK6iwF0WcpqrMUWZ8lfVlK+nYCSV1DIVDXdglmWSrToGYK/vstKAIGGOYGYrknQDBPYL8GyToBiXkC8zWQOZoI+zgQcKRXBIF5JAjukWCOniM8ZJXl1YEeIYIfCbpfC+4JZjnzCOKNIL4iSOhGguTiA4EzT5CsE3gxTxCtEwQ2T2C+Bsn8apqsr6YM1mvAYL4GaL4GaL8G1ncVPMsZ7WcJrHc0ZrJOoOyEc7Gk64t9saRrtegt+Tk2tI5ksOReHq6RUxznFuIHgmidIJB5gmCdIJqvQfqZ/0E4yi0K0JTgEsX/QRQB+ZMo6dejnLvRR9FWxbIur3eRNsdmNbmadPjclXe3lHbtdlWuj23Z31eaXFXqe2xweYRu2m7qLw==",
      "brillig_names": [
        "create_same_nullifier_in_nested_call"
      ]
    },
    {
      "name": "divide_by_zero",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABfJwIBAgEnAgICAAY4AQIDLQwDASYoAIAEBHgADQAAAIAEgAMkAIADAAAAhyoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "nY/dCsMgDIXfJdde1FLp2lcZo9gaiyAq/gyG+O7TMljpZW9CTkhOzpdB4Jr2RRlpA8zPDNpuPCprqsqFwOqV1mpfzmPoWhnZsR8cN02GyH2EmVLGJgJoxNGPQ/WQSiPMPSsvAo/u1tWNX6WqN/eKrxp/MDKZ7cQWPw4vmM7bDUXy2ID/rLSlphPph2pbrb8=",
      "brillig_names": [
        "divide_by_zero"
      ]
    },
    {
      "name": "revert_oracle",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAZyUAAABvACgBAgIoAgADBIBEJwIEBAMuBAACgAMuBAADgAQuBAAEgAUlAAABMygCAAIEgEQnAgMEAzsNAAIAAygAgEMEAAMmJQAAAXknAgEAAScCAgACJwIDAAMnAgUEAycCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBgQDADgEBgUtDAUGLQ4BBgAoBgIGLQ4CBgAoBgIGLQ4DBgAoBAIDLQ0DAicCBQQCADgDBQE8DQECJwIBAAQnAgIABScCAwAGLQgBBCcCBQQEABABBQEnAwQEAQAoBAIFLQwFBi0OAQYAKAYCBi0OAgYAKAYCBi0OAwYtDAQBJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAABeC4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAABRyYoAIAEBHgADQAAAIAEgAMkAIADAAABoSoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "vZbJasMwFEX/RWsv9CRZg3+llOBBDgJjGw+FYvzvldqQmLRd5EKyMXrmHR9rAN2NNb5az6fQt8PMireNdUNdLmHoY7XtGaum0HXhfDq+Zjw9iPQ3MI9ln+p5KaeFFU4ZypjvmzS0PH6iDZ1nRc7394yRIARCTBIxScSkEJNCTDlHoByANGLSkMkBkFEIZAHISgRCTE4gEHCMBCcEAjZXEEegfzZXyBtERyj71Uwknb10E0Xy2q7px+Ge7xDyBQ77fId8wTyk+dtxpeLQ3R8UJRAIMeWIKdcApAmBEJNBTAYxWY5ACoEcADmJQPZRaI/VRzmFsur8JV21a18fwtbyOfq73DVOQ+2bdfIpgd3CV/pjLTMj0x2QVteozLioiJov",
      "brillig_names": [
        "revert_oracle"
      ]
    },
    {
      "name": "new_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABQNAIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAeCoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "bY/RCoQgEEX/ZZ59yDLd+pVYwmoKQTTMFpbo31cjNtntZZg7HC5zNhiwW6dWmdEuUDcbaNtLr6wJadsJdE5praY2PUMWhygPfpmliXHx0nmoaSHynACa4dgZCx2j0gh1me3kD2cXzQQTX5jTG7jiBT/hivNHCj/3kF7SKdlpPF8fV9MnJv4944/U7GyPw+ow6l1mNMyGcpLTUBuqPw==",
      "brillig_names": [
        "new_nullifier"
      ]
    },
    {
      "name": "external_call_to_divide_by_zero",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAPyUAAABlKAIAAQSARCcCAgQAOw0AAQACLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACYlAAABih4CAAEAKQIAAgB9v4jhJwIEBAEnAgYEAwA4BAYFLQgBAwAQAQUBJwMDBAEAKAMCBS0OBAUAKAUCBS0OBAUnAgUEAwA4AwUELQwEBS0OAgUnAgIEAQAoAwIGLQ0GBScCBwQCADgGBwQ5A4iAQ4BDAAEABAAFIAIAASECAAMnAgQEAC0IAQYAKAYCCS0NCQgnAgoEAgA4CQoHIjwABAADAActDAMIJwIKBAMAOAgKCQAQAQkBJwMGBAEAKAYCCi0OCAoAKAoCCi0OCAotDAgFBigFAgUkAgABAAABcyMAAAFKLQ0GAQAoAQIBLQ4BBgAoBgIELQ0EAycCBwQCADgEBwE8DQEDIwAAAXMKOAUCASQCAAEAAAGJJwIDBAA8CQEDJigAgAQEeAANAAAAgASAAyQAgAMAAAGyKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "1drNboJAEAfwd9kzh52d2d1ZX6VpGlRsSAga1CaN8d0LVpCIKZeGzFyMmBF+/EP2i72YbbE+f36U9W5/NKu3i6n2m/xU7uv26HLNzLopq6r8/Bj/bGz3ATbc/nA85HV3fDzlzcmsAkfITFFvu68J2lPsyqowK2+v2aSYko33YkoQhuIAL4qZiO/FTIHGxe+ZAYDXHJ96zvgKLzmM7IcrAD6K8UUxWupvFK0PzxxnZXG8KA7KSgeFpZNEcYhkcWSl42Wl41kUJ6AsThTFiU4WR1Y6LKtH58U7idQPjtDFmcERWIj2Xg3W4WR4lKxqve7sk2K9s6Rarzp7t3QHgaGfYyGym9NHxEEf/VQfFtYT9mkiUZzTsw2DntE+6xefoxDAQ89z+gR+0CfPE71XrU+a9YtPmP5Xz5r1HlXrVWcfVbeYUXWLyaqzZ9XZJ9XZJ93Zax4ptCsOqvWaeysEp1kvaHZy48h5kG8cOa1Cx6GlB6XeUc/xsxPh9n1TP+kHIIcTPWvWe6daHzXrg+rs4z+8f/DD+h57Dn/rIYZhOS3GRyNC4ZcTRHGYZHGSHM61PfrKmzJfV8V9H83uXG9G22pO34fiaYfNodlviu25Kbq9NuNtNu19RchiaE/bnvoH",
      "brillig_names": [
        "external_call_to_divide_by_zero"
      ]
    },
    {
      "name": "set_storage_list",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAASyUAAABMKAIAAQSARicCAgQAOw0AAQACJiUAAABoJwIDAAIwDAABAAMnAgEAAzAMAAIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAkCoBAAEF96Hzr6Wt1Mo8AQECJg==",
      "debug_symbols": "5ZNBCoMwFETv8tdZ5Mckpl6llBI1SiBEiVoo4t0bi1pppRdw85n5PAZmMSOUJh/qu/VV00F2HcE1he5t46MbJwJ5sM7Z+r5/A52PwjfftdrPtut16CFjQiQEjC9nmWJMqKwzkAk6kR8YOcUFRs7SDUbJD2jFFFtolVC+0RKPYKrECmMi/8OIkq7RUfNkj98IKHmaqhd2nqrpSapO0T10sDp3Zpl1Nfhit/L+2ZqvwbehKUw5BDNP/7N6jPfKKGEixsboFw==",
      "brillig_names": [
        "set_storage_list"
      ]
    },
    {
      "name": "add_args_return",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "arg_a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "arg_b",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgMEAicCBAQAHxgABAADgEQuCIBEAAEuCIBFAAIlAAAAUSUAAABSLgQAAYBGKAIAAgSARicCAwQBOw0AAgADJiUAAABhADgBAgMtDAMBJigAgAQEeAANAAAAgASAAyQAgAMAAACJKgEAAQX3ofOvpa3UyjwBAQIm",
      "debug_symbols": "ZY5BCoMwEEXvMussjDW1ehUpEnWUQEgkJoUScvdORFqpm+H/4fF5ESYcwtIrM9sN2i6CtqP0yhpqMTEYnNJaLf35DUU+j3rnt1WaXDcvnYeWcyEaBmimPdcVbcxKI7SlSOyC3+51cdAUmy8sivRM1F7SKTloPGzmYMaTnH+v+Oe5OjviFBxm458sp9vxhpUVzdL0Bw==",
      "brillig_names": [
        "add_args_return"
      ]
    },
    {
      "name": "get_fee_per_l2_gas",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAABRHgIAAQcmKACABAR4AA0AAACABIADJACAAwAAAHkqAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "bY/RCoMwDEX/Jc99aNxs1V+RIVWjFEortQ6G+O+rIlvZfAm54XDJWaGndhkbbQc3Q1WvYFyngnY2pnVj0HptjB6b9Ax8HzI/+HlSdo9zUD5AhVnOSwZk+2O/YewYtCGocr6xP1wIiSctRCE/sMALuChRnnBR3nkKP7aYnspr1Ro6Xx8W2yUm4TXRj9TkXUf94mnX+5phnDUKlmGsjdVv",
      "brillig_names": [
        "get_fee_per_l2_gas"
      ]
    },
    {
      "name": "set_storage_map",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABAMnAgMEAicCBAQAHxgABAADgEgdAIBJgEkELgiASAABLgiASQACJQAAAFglAAAAfC4EAAGASigCAAIEgEonAgMEATsNAAIAAygAgEMEAAMoAIBEAQAAKACARQQAACgAgEYAAAAoAIBHBAABJiUAAAD5JwIDAAQnAgUEBi0IAAYtDAMHLQwBCAAQAAUAJQAAASItBAAALQwHBAsoAASARgAFCygABYBEAAYkAgAGAAAAxiUAAAKcHAwCBQAwDAAFAAQnAgQEBS0IAAUtDAMGLQwBBwAQAAQAJQAAASItBAAALQwGAi0MAgEmKACABAR4AA0AAACABIADJACAAwAAASEqAQABBfeh86+lrdTKPAEBAiYlAAAA+S0IAQMnAgQEBAAQAQQBJwMDBAEAKAMCBC0MBAUuCoBGAAUAKAUCBS4KgEYABQAoBQIFLgqARgAFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy4KgEYABwAoBwIHLgqARgAHACgHAgcuCoBGAAcAKAcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4KgEUABS0IAQYAAAECAS4KgEQABicCBwQILQgACC0MBAktDAMKLQwFCy0MBgwtDAENABAABwAlAAACri0EAAAnAgEEBy0IAActDAQILQwDCS0MBQotDAYLLQwCDAAQAAEAJQAAAq4tBAAALQ0GAQsoAAGARAACJAIAAgAAAmAnAgcEADwJAQcnAgEEBy0IAActDAQILQwDCS0MBQotDAYLABAAAQAlAAAD3C0EAAAtDQMBASgAAYBHAAMtDQMCLQwCASYqAQABBQLcbieAdhKdPAEBAiYlAAAA+S0NAwYtDQQHCygAB4BEAAgkAgAIAAAC1CcCCQQAPAkBCQsoAAaAQwAHJAIABwAAA2gjAAAC6S0NAQYtDQIHLQ0DCC0NBAkNKAAIgEMACicCCwEBJAIACgAAAxMlAAAE7y4EAAaAAygAgAQEAAQlAAAFAS4IgAUACgAoCgILADgLCAwtDgUMASgACIBHAAUOOAgFBiQCAAYAAANTJQAABY8tDgoBLQ4HAi0OBQMtDgkEIwAAA9snAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAAAD3C0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAABQEuCIAFAAkAKAkCCgEoAAqARQALLQ4FCy0OCQEtDgcCLgqARwADLQ4IBCMAAAPbJiUAAAD5LgiARQAFIwAAA+wNKAAFgEMABiQCAAYAAARcIwAABAEtDQEFLQ0CBi0NAwctDQQILQ0GCQAoCQIJLQ4JBicCCQQELQgBCicCCwQFABABCwEnAwoEAQAoBgILJwIMBAQAKAoCDT8PAAsADS0OBQEtDgoCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBHAAYkAgAHAAAEeiMAAATmLQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAAAFAS4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAAATmLQwGBSMAAAPsKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AGCwCABgACgAckAIAHAAAFHCMAAAUnLgCAA4AFIwAABY4uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFei4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAAFSSgBgAUEAAEDAIAGAAKABiMAAAWOJioBAAEFRafKcRlB5BU8AQECJg==",
      "debug_symbols": "5ZzbbtswDIbfxde5EKkDpb7KMAxpmw4BgrRI2wFD0Xef7cV2OksmQiSDFN0UTauv5C9RFK1K/mgeN/fvP39s90/Pr83dt49m9/ywfts+79tPH5+r5v6w3e22P3+c/rhR3RfA0AOvL+t99/n1bX14a+7QA62azf6x+1ZD+yeetrtNc2fV52rWGJTTx8YAoMfGYO3n91UD2lzfxPVVGH19E3R1Exaub8Jd3YS7vgpnr2/iAkEL3g8m0NgvJuatrQ3q2Np5NGPrECKNycGxLZGf/rAzve9E5frubbm+B12w75713XC+GzVYAIP0xcS8ddsV4djaawxjawfRblFjtwBOfmjdz1ZU+n97jx5H75VZ9t4rb4fGoB0n1SkctTqjT5v3WqOZCdoICSNmaXIJ/3YRGBnmRRiiDHMiTIMMk1kzSoSFaGZrV+QhRBVOcQ0Um8HBDHFEIUyt0ccCWtshjAxMMYcq1hYhDMGPbYAxrS0OQq1WX9r2OkMVOttZX4nOSsYTKhlPqGQ8UVeis5Lx1JXMz0R5cXs666iHdHxXp0idYXiccmBnOgkr0enq0OkriVtfyXiGSsYz1DGeRt1OnbCss5LxhDrmpwGqQyfWUQ8Z9HXo1Lezn7Css9D52fluCs2hve+FrnOd77bQWqT33RTse6F7f53vrtB82vtecI4sdZ+m973QWqPz3Rfc777geA855xn0w9Yx6hM/Rt9zjvdl363KOd4533OuxRjfIedajPPdFOx7wXM1670Kzvec1ybGd11wv+uCc2TW+wSc7zn/35zzPefnVcZ3W24daW3BOdIVPFddwXOVCq4jqeR+zzlHEoxu0D9nnc5r3Sn1OWfUs5SCc8NFHHAnt2sGpVmfvbis0puJXkapU6YapTk/2Z6nlGi89Ulhlnsd3E5G4pTmXBFeVCneTu7llOZc9VxW6e2sMozSrE+dXFZpNauMqWZMTTWrTNa3PM5TGtR4jzlgROnt5F5GaeKpTeF4P185O6esiErc6tdjZQ5mVpmTIgkFVkKhElEmTrnpHQd+1huU2OPW48HF9tu5rcTuMkMl9nU5iiRUYi+To0S6yEioxCkVjkrkeRxjwxqaUamTGYuUT917YCgroVJn8hnKSSgU2UrW/GNms352JsYnq8plykuo5LnWRSq5ni5Tot5IrmiLlBP1YeL0nZ5WIo1+TpGEStzg4ygrooKESmQAjpL0RlAookS2AESUFVGSng+JtyNoY0bK0pwKEipxUoChEv+j5yiSUBYllFMiSrIuB+clFKGIktgCFd8QJzNUemTcHIqvX9MDQrARS/EwZKD4msdBJIDikctBko6I37vgICN4QGmxIMISyySLeRFGMmsks+Zl1rzMWpBZC6JxA6VlGIkwABnmzk85EH+QbVf6YdJgDBJMT4iXvowlK3EvPqc5yAsgh4KOcII0CiSxFH87Rxi3GwJFwiheKHOQxFLgEnYUEsQeKpBAXgCBlkCCJRzjm0kcJLEkKRZQUiygpFjAs4uFz/bjr/Vhu77fbY7vHX963z+cvIb87ffL5p83kr8cnh82j++HTfdu8um15F0IY7sp2+6w9gtM+9HQymIfq93vyLS/c63N1u4f",
      "brillig_names": [
        "set_storage_map"
      ]
    },
    {
      "name": "n_storage_writes",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "num",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHxgAAwACgEgdAIBIgEgELgiASAABJQAAAEwlAAAAcCgCAAEEgEknAgIEADsNAAEAAigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYBAAEoAIBHBAABJiUAAAJrJwIDAAAtCAEEJwIFBAQAEAEFAScDBAQBACgEAgUtDAUGLQ4DBgAoBgIGLQ4DBgAoBgIGLQ4DBisCAAUAAAAAAAAAAAIAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwgtDgMIACgIAggtDgMIACgIAggtDgMIACgIAggtDgUIJwIFAAQuCIBFAAIjAAABDAw4AgEHJAIABwAAAR8jAAABHiYcDAIHAC0NBAgAKAgCCC0OCAQtDQYIACgIAggtDggGLQgBCAAAAQIBLQ4ECC0IAQkAAAECAS0OBgktCAEKAAABAgEuCoBFAAotCAELAAABAgEuCoBEAAsnAgwEDS0IAA0tDAgOLQwJDy0MChAtDAsRLQwFEgAQAAwAJQAAApQtBAAAJwIMBA0tCAANLQwIDi0MCQ8tDAoQLQwLES0MBxIAEAAMACUAAAKULQQAAC0NCwwLKAAMgEQADSQCAA0AAAHpJwIOBAA8CQEOJwIMBA0tCAANLQwIDi0MCQ8tDAoQLQwLEQAQAAwAJQAAA70tBAAALQ0IDC0NCQ0tDQoOLQ4MCC0ODQktDg4KLgqARgALASgADYBHAAktDQkICjgIAwkLKAAJgEQACiQCAAoAAAJUJQAABNAwDAAHAAgBKAACgEcABy0MBwIjAAABDCgAgAQEeAANAAAAgASAAyQAgAMAAAKTKgEAAQX3ofOvpa3UyjwBAQImJQAAAmstDQMGLQ0EBwsoAAeARAAIJAIACAAAAronAgkEADwJAQkLKAAGgEMAByQCAAcAAANJIwAAAs8tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAAC9CUAAATiLgQABoADKACABAQABCUAAAT0LgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAAzQlAAAFgi0OCgEtDgcCLQ4FAy0OCQQjAAADvCcCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAO9LQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAE9C4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA7wmJQAAAmsuCIBFAAUjAAADzQ0oAAWAQwAGJAIABgAABD0jAAAD4i0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAARbIwAABMctDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAT0LgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABMctDAYFIwAAA80qAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUPIwAABRouAIADgAUjAAAFgS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVtLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAU8KAGABQQAAQMAgAYAAoAGIwAABYEmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3bbuM4DIbfxde5EHWi1FcZLIq0zRQGgqRI0wUWRd99lWxsZ0ZSlVACBgvxpmhq/qX8RSYp+vQ5vGyePl4fx93P/fvw8ONz2O6f18dxvwufPr9Ww9Nh3G7H18frPw/i9AMAz4L3t/Xu9Pn9uD4chwdQzsjVsNm9nH+3NvyTn+N2MzwY8bWKzYVVkzWAmo3BmJS1sRdjKeRsqwATtui1uRij94u1dKlxqHnQGpYhS5GyleBhGoYUvmBtpL8YGyV+sf1rNYCUDLEeomWI1RAVMMR6iDwT6yFqnokNIPJMrIdoBEOsh6gZYj1EzxCrIVrFEOshOoZYDRF52XcTRI8XYwsmguj5cG4Akbs41RDDbjDEeog8E+shAs/EBhB5JtZDlNzFaQDRMMRqiIq7OA0gaoZYD5G7OPUQNS/7GkDkLk49xGwrTOkFosJriCeZy5WXfmHvrxBdZJ5L++rGm/R8WqwaohJc2jeAyKV9dQRWgguqeoigGWI9RC6oYognMHyFYw4MdxnTYPhKxBwYLhnSYDR3+DJgNINJg+F0nQZjuLuWAcNLjTQYvqouB4ZjTBoMdpuVpJtaQuGspIzBdBtjCmBctzGmBKbbRWQBjO92EVkC0+0isgSGg28SjBYcfDNgui3wCmCAZ0wGDKfrNJh+zxKUwHR7wUIBTL9XdZbAaAaTBsPpOg1Gc/DNgOHgmwZjeHWdAcMzJg3GdpuuEeZh4G/XAd5nfcaoGeMNGMFaMe2hRRdh7Pf++6YYHR/UTTB225Jti7HbBu59GBHnPUQfZ2rPKaYJxm5Xmy0xmn4frdEWY7frkqYYgQueJhg5xTTByAVPC4ySZ2MTjFzwtMCouOBpgpELnhYY+72zpi1GTjFNMHKKaYHRcIppgpFn400YvZjODIKXMUbLmboFRmySqcG5yVpqU8BojJ8a8tZJPVt7n+Jop3uC8Kp3D1b/N3rzfx59m9tT/tTo29wq8cdGf0P48CAKo9di8gFa4i9OYmsn3fS/nRLL6C2kjIWb4ocDZb83BrBiHnZwrq7Nw97aW9rhv+3tSWbTh5eQs0rY6Jkm1nqKCtMHA6j55B3o6OSddUBSeYoqc4arpEqne7DLF+YiGpjr0c0Pkwm/Rr5QKpIKKarc4zYKKkNRadJ+GdIIM5diGTl/y0ZjpLKSpPIUVeY+2IIqc9FFSWUoKk/ylTm+jJ0LGOOiu4JdJrSVVEhRgaGopCCpSDQy3dSCSpEY5l64thScSrpYZSmq3Cu1CipNUjmKKhMBSioSDSSRR5IvRyLvSOQdiXzuCad6eZyqwVjlCCqfe/zi96rc+d+CylJUuQfoF1SeolKUvOwVpd7wGkgqkq90LYp6KtlQ20iTzl5LF8Cb2E96Dn6rAZFOeCWRJYjS07Yk0hSRJ4gy1e7364yw2ZFkmRxZlCFJpmneNM2boXkzNG+W5s3Svjekecsky5Isky2LMnN3wAmi9EEjptDmZUJECFOhM2ru9wRAGB6kj+mSCAmi9Pq1AEIRwmjmxcQlURr53DXwGE+jzItnSyKSp1LAToksZe6hoIiQIHKSIiKk8MwrCEsigidJKRYkpViQlGJB3l0sfIWPf68P4/ppu3kPktPWj93zcdzvLh+P/7xNW54O43Y7vj6+HfbPm5ePw+Zxu38+bRvE5ccPacQqnFA5h8bwMcSfFUh35n3aijJs1cFr8Pwv",
      "brillig_names": [
        "n_storage_writes"
      ]
    },
    {
      "name": "set_storage_single",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "a",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAABXJwICAAEwDAABAAImKACABAR4AA0AAACABIADJACAAwAAAH8qAQABBfeh86+lrdTKPAEBAiY=",
      "debug_symbols": "5dLRCoMgFAbgdznXXnjMynqVMYaVhSAWZoMRvft0VIst9gK7kXPk4wfln6FR1dTdtG37EcrLDKavpde9Ddu8EKicNkZ3t+M10Hjk6cuPg7RxHb10Hkos8oKAsk0ciyIktNooKFO6kG/MKW6Ys3zHmPETLZhgqxYJ5bvO8AxTkW4Yk+w3RszoFh1mnhz5lYCgf/LUJWx36bSsjFoL0E62PvTBPwb1UY3B9bVqJqdiSd79wPhpmBPGQmyIfgI=",
      "brillig_names": [
        "set_storage_single"
      ]
    },
    {
      "name": "assert_calldata_copy",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "args",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13488375577656017388": {
            "error_kind": "string",
            "string": "Calldata copy failed"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgIEAycCAwQAHxgAAwACgEQoAgABBIBEJwIDBAMtCAECJwIEBAQAEAEEAScDAgQBACgCAgQuBAABgAMuBAAEgAQuBAADgAUlAAAAfi0MAgElAAAAxCUAAADMKAIAAQSARycCAgQAOw0AAQACAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAADDLgGACIAGLgKABoAJAQCACAACgAgBAIAJAAKACSMAAACSJigAgEMEAAMmJQAAAYYnAgMEAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBR8sAAOAQwAFLQgBBQAAAQIBJwIGAQEtDgYFLQ0EBwAoBwIHLQ4HBCcCBwQBLQwDAiMAAAEjDSgAAoBDAAMkAgADAAABSiMAAAE4LQ0FASQCAAEAAAFJJQAAAa8mLQ0FAwAoBAIJADgJAgotDQoIACgBAgoAOAoCCy0NCwkKOAgJCgQ4AwoILQ4IBQA4AgcDLQwDAiMAAAEjKACABAR4AA0AAACABIADJACAAwAAAa4qAQABBfeh86+lrdTKPAEBAiYqAQABBbswVh+XPcHsPAEBAiY=",
      "debug_symbols": "vZbRasMwDEX/xc9+sCXbsvsrY5S0dUsgJCVNB6Pk32dvWVPSUVgb5SVY4Ton15aELmIXN+fDuqz3zUms3i6iarZFVzZ1ii69FJu2rKrysL59LVR+gArfG07Hos7xqSvaTqy880aKWO/SkoxNn9iXVRQrq3p5J9bKWjuo0zq4q9zp/l0K0GYBhudnAC7AWMAHLuADF/Bh3J8McnBlEDxmPBBnglXsBMtNcOwenHmZoAPp36sOXo/iH4BnBhAyA4LmBaCGGQDBDWJQ4KaA/xZb3gTmiU2omM8KX89XUGo8K41TQGAGGG4Hxs8A0DSmk50ALHIDuB04mPkObivuXkuEg5T8tDYdMRc/cXcXcpyAPgUfRVsWmyoOI/H+XG9vJuTu8xgnw/KxbbZxd25jHpvHiTnnLaBETL+tc6ciIynkILd4r6SHxEvMLw==",
      "brillig_names": [
        "assert_calldata_copy"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AvmTest"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "single",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "list",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "map",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::assert_same_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::assert_same_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nullifier_exists_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nullifier_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::read_assert_storage_single_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::read_assert_storage_single_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_a",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_fields",
                    "type": {
                      "kind": "array",
                      "length": 3,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::get_args_hash_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_args_hash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "num",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::n_storage_writes_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::n_storage_writes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "num",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::n_new_public_logs_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::n_new_public_logs_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nested_static_call_to_add_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_static_call_to_add_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::new_note_hash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::new_note_hash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::read_storage_list_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::read_storage_list_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_timestamp_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_timestamp_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::u128_addition_overflow_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::u128_addition_overflow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_da_gas_left_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_da_gas_left_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nestedAddress",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::create_same_nullifier_in_nested_call_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::create_same_nullifier_in_nested_call_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::revert_oracle_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 3,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::revert_oracle_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "args",
                    "type": {
                      "kind": "array",
                      "length": 3,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::assert_calldata_copy_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::assert_calldata_copy_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "num",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::n_new_nullifiers_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::n_new_nullifiers_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::assert_nullifier_exists_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::assert_nullifier_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::emit_nullifier_and_check_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::emit_nullifier_and_check_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_add_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_add_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "addrs",
                    "type": {
                      "kind": "array",
                      "length": 23,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_add_n_times_different_addresses_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_add_n_times_different_addresses_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::emit_public_log_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::emit_public_log_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::set_storage_map_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_storage_map_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::test_get_contract_instance_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::test_get_contract_instance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::returndata_copy_oracle_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::returndata_copy_oracle_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "l2_gas",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "da_gas",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_add_with_gas_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_add_with_gas_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::return_oracle_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 3,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::return_oracle_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::add_args_return_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::add_args_return_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::add_storage_map_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::add_storage_map_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "expected_deployer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "expected_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "expected_initialization_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::test_get_contract_instance_matches_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::test_get_contract_instance_matches_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_small_field_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_small_field_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_l2_gas_left_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_l2_gas_left_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "input",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::to_radix_le_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::to_radix_le_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "b",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::conditional_move_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 1,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::conditional_move_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::set_storage_list_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_storage_list_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_version_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_version_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "num",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::n_new_note_hashes_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::n_new_note_hashes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::new_nullifier_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::new_nullifier_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_u32_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_u32_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "b",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::add_u128_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::add_u128_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_nothing_recovers_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_nothing_recovers_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::external_call_to_divide_by_zero_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::external_call_to_divide_by_zero_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::set_storage_single_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_storage_single_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::set_read_storage_single_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_read_storage_single_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_transaction_fee_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_transaction_fee_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nullifier_collision_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nullifier_collision_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::note_hash_exists_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::note_hash_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "a",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::modulo2_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::modulo2_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_fee_per_l2_gas_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_fee_per_l2_gas_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_big_field_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_big_field_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::assertion_failure_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::assertion_failure_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_block_number_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_block_number_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "args_field",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "args_u8",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "get_instance_for_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "expected_deployer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "expected_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "expected_initialization_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::bulk_testing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::bulk_testing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_u8_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_u8_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::send_l2_to_l1_msg_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::send_l2_to_l1_msg_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "num",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::n_new_l2_to_l1_msgs_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::n_new_l2_to_l1_msgs_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::debug_logging_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::debug_logging_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_fee_per_da_gas_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_fee_per_da_gas_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "msg_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "msg_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::l1_to_l2_msg_exists_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::l1_to_l2_msg_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::divide_by_zero_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::divide_by_zero_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::read_storage_single_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::read_storage_single_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::external_call_to_divide_by_zero_recovers_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::external_call_to_divide_by_zero_recovers_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::elliptic_curve_add_and_double_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_infinite",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::elliptic_curve_add_and_double_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_chain_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_chain_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::enqueue_public_from_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::enqueue_public_from_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_sender_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_sender_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::nested_static_call_to_set_storage_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_static_call_to_set_storage_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::external_call_to_assertion_failure_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::external_call_to_assertion_failure_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::read_storage_map_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::read_storage_map_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "scalar_lo",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "scalar_hi",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "scalar2_lo",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "scalar2_hi",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::variable_base_msm_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_infinite",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::variable_base_msm_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::get_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::get_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_u64_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_u64_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "nestedAddress",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::create_different_nullifier_in_nested_call_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::create_different_nullifier_in_nested_call_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "arg_a",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "arg_b",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::nested_call_to_assert_same_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::nested_call_to_assert_same_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AvmTest::set_opcode_really_big_field_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::set_opcode_really_big_field_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::pedersen_commit_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_infinite",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::pedersen_commit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "lhs",
                    "type": {
                      "fields": [
                        {
                          "name": "x",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "y",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_infinite",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                    }
                  },
                  {
                    "name": "rhs",
                    "type": {
                      "fields": [
                        {
                          "name": "x",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "y",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_infinite",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AvmTest::elliptic_curve_add_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "x",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "y",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_infinite",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
              }
            }
          ],
          "kind": "struct",
          "path": "AvmTest::elliptic_curve_add_abi"
        }
      ]
    }
  },
  "file_map": {
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "140": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "200": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "263": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "271": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "279": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "296": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "317": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "352": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "353": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "355": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "366": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/compressed-string/src/compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{traits::{Deserialize, Serialize}, utils::field::field_from_bytes};\n\n// The general Compressed String.\n// Compresses M bytes into N fields.\n// Can be used for longer strings that don't fit in a single field.\n// Each field can store 31 characters, so N should be M/31 rounded up.\npub struct CompressedString<let N: u32, let M: u32> {\n    value: [Field; N],\n}\n\nimpl<let N: u32, let M: u32> CompressedString<N, M> {\n    pub fn from_string(input_string: str<M>) -> Self {\n        let mut fields = [0; N];\n        let byts = input_string.as_bytes();\n\n        let mut r_index = 0 as u32;\n\n        for i in 0..N {\n            let mut temp = [0 as u8; 31];\n            for j in 0..31 {\n                if r_index < M {\n                    temp[j] = byts[r_index];\n                    r_index += 1;\n                }\n            }\n\n            fields[i] = field_from_bytes(temp, true);\n        }\n\n        Self { value: fields }\n    }\n\n    pub fn to_bytes(self) -> [u8; M] {\n        let mut result = [0; M];\n        let mut w_index = 0 as u32;\n        for i in 0..N {\n            let bytes: [u8; 31] = self.value[i].to_be_bytes();\n            for j in 0..31 {\n                if w_index < M {\n                    result[w_index] = bytes[j];\n                    w_index += 1;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let M: u32> Eq for CompressedString<N, M> {\n    fn eq(self, other: CompressedString<N, M>) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Serialize<N> for CompressedString<N, M> {\n    fn serialize(self) -> [Field; N] {\n        self.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Deserialize<N> for CompressedString<N, M> {\n    fn deserialize(input: [Field; N]) -> Self {\n        Self { value: input }\n    }\n}\n\n#[test]\nunconstrained fn test_short_string() {\n    let i = \"Hello world\";\n    let b = i.as_bytes();\n    let name: CompressedString<1, 11> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<4, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string_work_with_too_many_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<5, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_serde() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let name: CompressedString<5, 118> = CompressedString::from_string(i);\n\n    assert_eq(name, CompressedString::deserialize(name.serialize()));\n}\n\n#[test(should_fail)]\nunconstrained fn test_long_string_fail_with_too_few_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<3, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n"
    },
    "370": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr",
      "source": "mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        wrapping_add_hlp(self, y)\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        wrapping_sub_hlp(self, y) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        wrapping_sub_hlp(self, y) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        wrapping_sub_hlp(self, y) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        wrapping_sub_hlp(self, y) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/test/avm_test_contract/src/main.nr",
      "source": "mod note;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AvmTest {\n    use crate::note::Note;\n\n    global big_field_128_bits: Field = 0x001234567890abcdef1234567890abcdef;\n    global big_field_136_bits: Field = 0x991234567890abcdef1234567890abcdef;\n    global big_field_254_bits: Field =\n        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n\n    // Libs\n    use dep::aztec::context::gas::GasOpts;\n    use dep::aztec::context::public_context::{call, returndata_size, success_copy};\n    use dep::aztec::macros::{functions::{private, public}, storage::storage};\n    use dep::aztec::oracle::get_contract_instance::{\n        get_contract_instance_class_id_avm, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    };\n    use dep::aztec::prelude::Map;\n    use dep::aztec::protocol_types::{\n        abis::function_selector::FunctionSelector,\n        address::{AztecAddress, EthAddress},\n        point::Point,\n        scalar::Scalar,\n    };\n    use dep::aztec::protocol_types::{\n        constants::{GRUMPKIN_ONE_X, GRUMPKIN_ONE_Y, MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS},\n        contract_class_id::ContractClassId,\n        storage::map::derive_storage_slot_in_map,\n        traits::{Empty, FromField, ToField},\n    };\n    use dep::aztec::state_vars::PublicMutable;\n    use dep::compressed_string::CompressedString;\n    use aztec::protocol_types::traits::Serialize;\n    use std::embedded_curve_ops::{EmbeddedCurvePoint, multi_scalar_mul};\n\n    use std::ops::Add;\n\n    #[storage]\n    struct Storage<Context> {\n        single: PublicMutable<Field, Context>,\n        list: PublicMutable<Note, Context>,\n        map: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n    }\n\n    /************************************************************************\n     * Storage\n     ************************************************************************/\n    #[public]\n    fn set_storage_single(a: Field) {\n        storage.single.write(a);\n    }\n\n    #[public]\n    fn read_storage_single() -> Field {\n        storage.single.read()\n    }\n\n    #[public]\n    fn read_assert_storage_single(a: Field) {\n        assert(a == storage.single.read(), \"Storage value does not match input\");\n    }\n\n    // should still be able to use ` -> pub *` for return type even though macro forces `pub`\n    #[public]\n    fn set_read_storage_single(a: Field) -> pub Field {\n        storage.single.write(a);\n        storage.single.read()\n    }\n\n    #[public]\n    fn set_storage_list(a: Field, b: Field) {\n        storage.list.write(Note { a, b });\n    }\n\n    #[public]\n    fn read_storage_list() -> [Field; 2] {\n        let note: Note = storage.list.read();\n        note.serialize()\n    }\n\n    #[public]\n    fn set_storage_map(to: AztecAddress, amount: u32) -> Field {\n        storage.map.at(to).write(amount);\n        // returns storage slot for key\n        derive_storage_slot_in_map(storage.map.storage_slot, to)\n    }\n\n    #[public]\n    fn add_storage_map(to: AztecAddress, amount: u32) -> Field {\n        let new_balance = storage.map.at(to).read().add(amount);\n        storage.map.at(to).write(new_balance);\n        // returns storage slot for key\n        derive_storage_slot_in_map(storage.map.storage_slot, to)\n    }\n\n    #[public]\n    fn read_storage_map(address: AztecAddress) -> u32 {\n        storage.map.at(address).read()\n    }\n\n    #[public]\n    fn add_args_return(arg_a: Field, arg_b: Field) -> Field {\n        add(arg_a, arg_b)\n    }\n\n    // Auxiliary method to test usage of contract library methods in public fns\n    #[contract_library_method]\n    unconstrained fn add(lhs: Field, rhs: Field) -> Field {\n        lhs + rhs\n    }\n\n    /************************************************************************\n     * General Opcodes\n     ************************************************************************/\n    #[public]\n    fn set_opcode_u8() -> u8 {\n        8 as u8\n    }\n\n    #[public]\n    fn set_opcode_u32() -> u32 {\n        1 << 30 as u8\n    }\n\n    #[public]\n    fn set_opcode_u64() -> u64 {\n        1 << 60 as u8\n    }\n\n    #[public]\n    fn set_opcode_small_field() -> Field {\n        big_field_128_bits\n    }\n\n    #[public]\n    fn set_opcode_big_field() -> Field {\n        big_field_136_bits\n    }\n\n    #[public]\n    fn set_opcode_really_big_field() -> Field {\n        big_field_254_bits\n    }\n\n    #[public]\n    fn add_u128(a: u128, b: u128) -> u128 {\n        a + b\n    }\n\n    #[public]\n    fn modulo2(a: u64) -> u64 {\n        a % 2\n    }\n\n    #[public]\n    fn elliptic_curve_add(lhs: Point, rhs: Point) -> Point {\n        lhs + rhs\n    }\n\n    #[public]\n    fn elliptic_curve_add_and_double() -> Point {\n        let g = Point { x: GRUMPKIN_ONE_X, y: GRUMPKIN_ONE_Y, is_infinite: false };\n\n        let doubled = g + g;\n        let added = g + doubled;\n        added\n    }\n\n    #[public]\n    fn variable_base_msm(\n        scalar_lo: Field,\n        scalar_hi: Field,\n        scalar2_lo: Field,\n        scalar2_hi: Field,\n    ) -> Point {\n        let g = Point { x: GRUMPKIN_ONE_X, y: GRUMPKIN_ONE_Y, is_infinite: false };\n\n        let triple_g = multi_scalar_mul(\n            [g, g],\n            [Scalar { lo: scalar_lo, hi: scalar_hi }, Scalar { lo: scalar2_lo, hi: scalar2_hi }],\n        );\n        triple_g\n    }\n\n    #[public]\n    fn pedersen_commit(x: Field, y: Field) -> EmbeddedCurvePoint {\n        let commitment = dep::std::hash::pedersen_commitment_with_separator([x, y], 20);\n        commitment\n    }\n\n    #[public]\n    fn conditional_move(x: [Field; 1], y: [Field; 1], b: bool) -> [Field; 1] {\n        if b {\n            x\n        } else {\n            y\n        }\n    }\n\n    /************************************************************************\n     * Misc\n     ************************************************************************/\n\n    #[public]\n    fn u128_addition_overflow() -> u128 {\n        let max_u128: u128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        let one: u128 = 1;\n        max_u128 + one\n    }\n\n    #[public]\n    fn to_radix_le(input: Field) -> [u8; 10] {\n        input.to_le_radix(/*base=*/ 2)\n    }\n\n    // Helper functions to demonstrate an internal call stack in error messages\n    #[contract_library_method]\n    fn inner_helper_with_failed_assertion() {\n        let not_true = false;\n        assert(not_true == true, \"This assertion should fail!\");\n    }\n\n    #[contract_library_method]\n    fn helper_with_failed_assertion() {\n        inner_helper_with_failed_assertion();\n    }\n\n    #[public]\n    fn assertion_failure() {\n        helper_with_failed_assertion()\n    }\n\n    #[public]\n    fn external_call_to_assertion_failure() {\n        AvmTest::at(context.this_address()).assertion_failure().call(&mut context);\n    }\n\n    #[public]\n    fn divide_by_zero() -> u8 {\n        1 / 0\n    }\n\n    #[public]\n    fn external_call_to_divide_by_zero() {\n        AvmTest::at(context.this_address()).divide_by_zero().call(&mut context);\n    }\n\n    #[public]\n    fn external_call_to_divide_by_zero_recovers() {\n        // Be sure to allocate ~200k+ gas to this function~\n\n        // Get the gas remaining and allocate some smaller amount to nested call.\n        // We don't want to allocate too much to the nested call\n        // since it will all be consumed on exceptional halt.\n        let l2_gas_left = context.l2_gas_left();\n        let da_gas_left = context.da_gas_left();\n        let selector = FunctionSelector::from_signature(\"divide_by_zero()\");\n\n        // Call without capturing a return value since call no longer returns success\n        call(\n            l2_gas_left - 200_000,\n            da_gas_left - 200_000,\n            context.this_address(),\n            &[selector.to_field()],\n        );\n\n        // Use SUCCESSCOPY to get the success status\n        let success = success_copy();\n\n        assert(!success, \"Nested CALL instruction should return failure on exceptional halt\");\n        assert(\n            returndata_size() == 0,\n            \"Returndata should be empty when nested call exceptionally halts\",\n        );\n    }\n\n    #[public]\n    fn debug_logging() {\n        dep::aztec::oracle::debug_log::debug_log(\"just text\");\n        dep::aztec::oracle::debug_log::debug_log_format(\"second: {1}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log_format(\"whole array: {}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log(\"tabs and newlines\\n\\t- first\\n\\t- second\");\n    }\n\n    #[public]\n    fn assert_same(arg_a: Field, arg_b: Field) -> pub Field {\n        assert(arg_a == arg_b, \"Values are not equal\");\n        1\n    }\n\n    #[public]\n    fn assert_calldata_copy(args: [Field; 3]) {\n        let offset = 0;\n        let cd: [Field; 3] = dep::aztec::context::public_context::calldata_copy(offset, 3);\n        assert(cd == args, \"Calldata copy failed\");\n    }\n\n    #[public]\n    fn returndata_copy_oracle() {\n        AvmTest::at(context.this_address()).return_oracle().call(&mut context);\n        let returndatasize = dep::aztec::context::public_context::returndata_size();\n        let returndata = dep::aztec::context::public_context::returndata_copy(0, returndatasize);\n        assert(returndata == &[1, 2, 3], \"Returndata copy failed\");\n    }\n\n    #[public]\n    fn return_oracle() -> [Field; 3] {\n        dep::aztec::context::public_context::avm_return([1, 2, 3]);\n        [4, 5, 6] // Should not get here.\n    }\n\n    #[public]\n    fn revert_oracle() -> [Field; 3] {\n        dep::aztec::context::public_context::avm_revert([1, 2, 3]);\n        [4, 5, 6] // Should not get here.\n    }\n\n    /************************************************************************\n     * Contract instance\n     ************************************************************************/\n    #[public]\n    fn test_get_contract_instance(address: AztecAddress) {\n        let deployer = get_contract_instance_deployer_avm(address);\n        let class_id = get_contract_instance_class_id_avm(address);\n        let initialization_hash = get_contract_instance_initialization_hash_avm(address);\n\n        assert(deployer.is_some(), \"Contract instance not found when getting DEPLOYER!\");\n        assert(class_id.is_some(), \"Contract instance not found when getting CLASS_ID!\");\n        assert(\n            initialization_hash.is_some(),\n            \"Contract instance not found when getting INIT_HASH!\",\n        );\n\n        // The values here should match those in `avm_simulator.test.ts`\n        assert(deployer.unwrap().eq(AztecAddress::from_field(0x456)));\n        assert(class_id.unwrap().eq(ContractClassId::from_field(0x789)));\n        assert(initialization_hash.unwrap() == 0x101112);\n    }\n\n    #[public]\n    fn test_get_contract_instance_matches(\n        address: AztecAddress,\n        expected_deployer: AztecAddress,\n        expected_class_id: ContractClassId,\n        expected_initialization_hash: Field,\n    ) {\n        let deployer = get_contract_instance_deployer_avm(address);\n        let class_id = get_contract_instance_class_id_avm(address);\n        let initialization_hash = get_contract_instance_initialization_hash_avm(address);\n\n        assert(deployer.is_some(), \"Contract instance not found when getting DEPLOYER!\");\n        assert(class_id.is_some(), \"Contract instance not found when getting CLASS_ID!\");\n        assert(\n            initialization_hash.is_some(),\n            \"Contract instance not found when getting INIT_HASH!\",\n        );\n\n        // The values here should match those in `avm_simulator.test.ts`\n        assert(deployer.unwrap().eq(expected_deployer));\n        assert(class_id.unwrap().eq(expected_class_id));\n        assert(initialization_hash.unwrap().eq(expected_initialization_hash));\n    }\n\n    /************************************************************************\n     * AvmContext functions\n     ************************************************************************/\n    #[public]\n    fn get_address() -> AztecAddress {\n        context.this_address()\n    }\n\n    #[public]\n    fn get_sender() -> AztecAddress {\n        context.msg_sender()\n    }\n\n    #[public]\n    fn get_transaction_fee() -> Field {\n        context.transaction_fee()\n    }\n\n    #[public]\n    fn get_chain_id() -> Field {\n        context.chain_id()\n    }\n\n    #[public]\n    fn get_version() -> Field {\n        context.version()\n    }\n\n    #[public]\n    fn get_block_number() -> Field {\n        context.block_number()\n    }\n\n    #[public]\n    fn get_timestamp() -> u64 {\n        context.timestamp()\n    }\n\n    #[public]\n    fn get_fee_per_l2_gas() -> Field {\n        context.fee_per_l2_gas()\n    }\n\n    #[public]\n    fn get_fee_per_da_gas() -> Field {\n        context.fee_per_da_gas()\n    }\n\n    #[public]\n    fn get_l2_gas_left() -> Field {\n        context.l2_gas_left()\n    }\n\n    #[public]\n    fn get_da_gas_left() -> Field {\n        context.da_gas_left()\n    }\n\n    #[public]\n    fn get_args_hash(_a: u8, _fields: [Field; 3]) -> Field {\n        context.get_args_hash()\n    }\n\n    #[public]\n    fn emit_public_log() {\n        context.emit_public_log(/*message=*/ [10, 20, 30]);\n        context.emit_public_log(/*message=*/ \"Hello, world!\");\n        let s: CompressedString<2, 44> =\n            CompressedString::from_string(\"A long time ago, in a galaxy far far away...\");\n        context.emit_public_log(/*message=*/ s);\n    }\n\n    #[public]\n    fn note_hash_exists(note_hash: Field, leaf_index: Field) -> bool {\n        context.note_hash_exists(note_hash, leaf_index)\n    }\n\n    // Use the standard context interface to emit a new note hash\n    #[public]\n    fn new_note_hash(note_hash: Field) {\n        context.push_note_hash(note_hash);\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[public]\n    fn new_nullifier(nullifier: Field) {\n        context.push_nullifier(nullifier);\n    }\n\n    #[public]\n    fn n_storage_writes(num: u32) {\n        for i in 0..num {\n            storage.map.at(AztecAddress::from_field(i as Field)).write(i);\n        }\n    }\n\n    #[public]\n    fn n_new_note_hashes(num: u32) {\n        for i in 0..num {\n            context.push_note_hash(i as Field);\n        }\n    }\n\n    #[public]\n    fn n_new_nullifiers(num: u32) {\n        for i in 0..num {\n            context.push_nullifier(i as Field);\n        }\n    }\n\n    #[public]\n    fn n_new_l2_to_l1_msgs(num: u32) {\n        for i in 0..num {\n            context.message_portal(EthAddress::from_field(i as Field), i as Field)\n        }\n    }\n\n    #[public]\n    fn n_new_public_logs(num: u32) {\n        for i in 0..num {\n            context.emit_public_log(/*message=*/ [i as Field]);\n        }\n    }\n\n    // Use the standard context interface to check for a nullifier\n    #[public]\n    fn nullifier_exists(nullifier: Field) -> bool {\n        context.nullifier_exists(nullifier, context.this_address())\n    }\n\n    #[public]\n    fn assert_nullifier_exists(nullifier: Field) {\n        assert(\n            context.nullifier_exists(nullifier, context.this_address()),\n            \"Nullifier doesn't exist!\",\n        );\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[public]\n    fn emit_nullifier_and_check(nullifier: Field) {\n        context.push_nullifier(nullifier);\n        let exists = context.nullifier_exists(nullifier, context.this_address());\n        assert(exists, \"Nullifier was just created, but its existence wasn't detected!\");\n    }\n\n    // Create the same nullifier twice (shouldn't work!)\n    #[public]\n    fn nullifier_collision(nullifier: Field) {\n        context.push_nullifier(nullifier);\n        // Can't do this twice!\n        context.push_nullifier(nullifier);\n    }\n\n    #[public]\n    fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> bool {\n        context.l1_to_l2_msg_exists(msg_hash, msg_leaf_index)\n    }\n\n    #[public]\n    fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n        context.message_portal(recipient, content)\n    }\n\n    /************************************************************************\n     * Nested calls\n     ************************************************************************/\n    #[public]\n    fn nested_call_to_nothing() {\n        let garbageAddress = AztecAddress::from_field(42);\n        AvmTest::at(garbageAddress).nested_call_to_nothing().call(&mut context)\n    }\n\n    #[public]\n    fn nested_call_to_nothing_recovers() {\n        let garbageAddress = AztecAddress::from_field(42);\n        call(1, 1, garbageAddress, &[]);\n        let success = success_copy();\n        assert(\n            !success,\n            \"Nested CALL instruction should return failure if target contract does not exist\",\n        );\n    }\n\n    #[public]\n    fn nested_call_to_add_with_gas(\n        arg_a: Field,\n        arg_b: Field,\n        l2_gas: Field,\n        da_gas: Field,\n    ) -> pub Field {\n        AvmTest::at(context.this_address())\n            .add_args_return(arg_a, arg_b)\n            .with_gas(GasOpts::new(l2_gas, da_gas))\n            .call(&mut context)\n    }\n\n    // Use the `call_public_function` wrapper to initiate a nested call to the add function\n    #[public]\n    fn nested_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).call(&mut context)\n    }\n\n    #[public]\n    fn nested_call_to_add_n_times_different_addresses(\n        addrs: [AztecAddress; MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS + 2],\n    ) {\n        for i in 0..MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS + 2 {\n            let addr = addrs[i];\n            if addr != AztecAddress::empty() {\n                let _ = AvmTest::at(addr).add_args_return(1, 2).call(&mut context);\n            }\n        }\n    }\n\n    // Indirectly call_static the external call opcode to initiate a nested call to the add function\n    #[public]\n    fn nested_static_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).view(&mut context)\n    }\n\n    // Indirectly call_static `set_storage_single`. Should revert since it's accessing storage.\n    #[public]\n    fn nested_static_call_to_set_storage() {\n        AvmTest::at(context.this_address()).set_storage_single(20).view(&mut context);\n    }\n\n    #[public]\n    fn create_same_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier).call(&mut context);\n    }\n\n    #[public]\n    fn create_different_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier + 1).call(&mut context);\n    }\n\n    #[public]\n    fn nested_call_to_assert_same(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).assert_same(arg_a, arg_b).call(&mut context)\n    }\n\n    /**\n     * Enqueue a public call from private\n     */\n    #[private]\n    fn enqueue_public_from_private() {\n        AvmTest::at(context.this_address()).set_opcode_u8().enqueue_view(&mut context);\n        AvmTest::at(context.this_address()).set_read_storage_single(5).enqueue(&mut context);\n    }\n\n    /************************************************************************\n     * Bulk testing: exercise many functions in a single call.\n     * It only makes sense to call functions with side effects (or oracle\n     * calls - but not blackboxes!), since otherwise the whole call will\n     * be optimized away.\n     ************************************************************************/\n    #[public]\n    fn bulk_testing(\n        args_field: [Field; 10],\n        args_u8: [u8; 10],\n        get_instance_for_address: AztecAddress,\n        expected_deployer: AztecAddress,\n        expected_class_id: ContractClassId,\n        expected_initialization_hash: Field,\n    ) {\n        dep::aztec::oracle::debug_log::debug_log(\"set_storage_single\");\n        set_storage_single(30);\n        dep::aztec::oracle::debug_log::debug_log(\"set_storage_list\");\n        set_storage_list(40, 50);\n        dep::aztec::oracle::debug_log::debug_log(\"read_storage_list\");\n        let _ = set_storage_map(context.this_address(), 60);\n        dep::aztec::oracle::debug_log::debug_log(\"add_storage_map\");\n        let _ = add_storage_map(context.this_address(), 10);\n        dep::aztec::oracle::debug_log::debug_log(\"read_storage_map\");\n        let _ = read_storage_map(context.this_address());\n        dep::aztec::oracle::debug_log::debug_log(\"keccak_hash\");\n        let _ = keccak256::keccak256(args_u8, args_u8.len());\n        dep::aztec::oracle::debug_log::debug_log(\"sha256_hash\");\n        let _ = sha256::sha256_var(args_u8, args_u8.len() as u64);\n        dep::aztec::oracle::debug_log::debug_log(\"poseidon2_hash\");\n        let _ = std::hash::poseidon2::Poseidon2::hash(args_field, args_field.len());\n        dep::aztec::oracle::debug_log::debug_log(\"pedersen_hash\");\n        let _ = std::hash::pedersen_hash(args_field);\n        dep::aztec::oracle::debug_log::debug_log(\"pedersen_hash_with_index\");\n        let _ = std::hash::pedersen_hash_with_separator(args_field, /*index=*/ 20);\n        dep::aztec::oracle::debug_log::debug_log(\"test_get_contract_instance\");\n        test_get_contract_instance_matches(\n            get_instance_for_address,\n            expected_deployer,\n            expected_class_id,\n            expected_initialization_hash,\n        );\n        dep::aztec::oracle::debug_log::debug_log(\"get_address\");\n        let _ = get_address();\n        dep::aztec::oracle::debug_log::debug_log(\"get_sender\");\n        let _ = get_sender();\n        dep::aztec::oracle::debug_log::debug_log(\"get_transaction_fee\");\n        let _ = get_transaction_fee();\n        dep::aztec::oracle::debug_log::debug_log(\"get_chain_id\");\n        let _ = get_chain_id();\n        dep::aztec::oracle::debug_log::debug_log(\"get_version\");\n        let _ = get_version();\n        dep::aztec::oracle::debug_log::debug_log(\"get_block_number\");\n        let _ = get_block_number();\n        dep::aztec::oracle::debug_log::debug_log(\"get_timestamp\");\n        let _ = get_timestamp();\n        dep::aztec::oracle::debug_log::debug_log(\"get_fee_per_l2_gas\");\n        let _ = get_fee_per_l2_gas();\n        dep::aztec::oracle::debug_log::debug_log(\"get_fee_per_da_gas\");\n        let _ = get_fee_per_da_gas();\n        dep::aztec::oracle::debug_log::debug_log(\"get_l2_gas_left\");\n        let _ = get_l2_gas_left();\n        dep::aztec::oracle::debug_log::debug_log(\"get_da_gas_left\");\n        let _ = get_da_gas_left();\n        dep::aztec::oracle::debug_log::debug_log(\"emit_public_log\");\n        let _ = emit_public_log();\n        dep::aztec::oracle::debug_log::debug_log(\"note_hash_exists\");\n        let _ = note_hash_exists(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"new_note_hash\");\n        let _ = new_note_hash(1);\n        dep::aztec::oracle::debug_log::debug_log(\"new_nullifier\");\n        let _ = new_nullifier(1);\n        dep::aztec::oracle::debug_log::debug_log(\"nullifier_exists\");\n        let _ = nullifier_exists(1);\n        dep::aztec::oracle::debug_log::debug_log(\"l1_to_l2_msg_exists\");\n        let _ = l1_to_l2_msg_exists(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"send_l2_to_l1_msg\");\n        let _ = send_l2_to_l1_msg(EthAddress::from_field(0x2020), 1);\n        dep::aztec::oracle::debug_log::debug_log(\"storage_read_and_write\");\n        set_storage_single(read_storage_single());\n        dep::aztec::oracle::debug_log::debug_log(\"nested_call_to_add\");\n        let _ = nested_call_to_add(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"nested_static_call_to_add\");\n        let _ = nested_static_call_to_add(1, 2);\n        //let _ = nested_call_to_nothing_recovers();\n    }\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "60": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "67": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "89": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "96": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
