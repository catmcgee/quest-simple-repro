{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "rZLNisMgFIXfxbUL/732VcpQTGKKICaYZGAIefcxxcyEprSbbC5e+Th86JlR46rpfvOx7QZ0uc4odLUdfRfzNi8YVcmH4O+3/TUi66D8wQ+9jes6jDaN6EKJoBwjF5vHWbOc0frg1k0t+MBrUIUGIv5YzV+gksmCSkn+YwUsXxhRcYYNcL3ZSPPeRnBTUKHgYCNPsQGx2Rh4b6PI9jaKqYONOsPGMFZow+UHGyAF1eTpp5a8ftvkbRVcqVg7xXrXuPGnd0/l61NXu2ZKbq3hroF5XilgxnNsjv4F",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "verify_private_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "19458536156181958": {
            "error_kind": "string",
            "string": "Function verify_private_authwit can only be called statically"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ABn3bwQ+y0vOjnZkjz2LZwk0tu9G4aL9jQJkwmNOzPwssvAp+ay6FaLKY6hHfvR/KwRXrP3r/KJAQDRX9hfL0dwEbtW5LfurzvVxnMrHIHsMpW1MsO7VZ6x8Jzg2GZNRtL7O1XJUrk0SL9L1CXJGKm3ZQL83BMVoj/G68pqIXlMwwKPGYIYGtgk9E6sy9k3Avm26aJTncSMncF6GPILU1MQsz+6FtcgHnOdoutdv/L27Gjxw9GPdTpLchFImJcY81HgxV8S9LghQSDGcoBozNeaCZaHxNkpdZnvKXkiPTLkArfL1oQq8J8derlk2VskAn5pIbLblRTAwl3M8noot8jiPLWnYxGCZupyeQ0k2krAjNQJI/Wz3f9CVX6BAVg3SeKT79MGMU50az3WdXLMmm5FrFvvGKaaLRteAToNaHIqgclT9DSQjDooybfvwzIlT7eRifPeXZZzq1vjeBHH/dFRHd73RQXBn9TDeogSDS23DE5A+krbq4Cdg7lMWVpxuuIuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icA1Wu+8Ucnj9wFf5ozbZhNCgAIDNjzS6DjdUbBAmZcj+KR+74Lf28oI9VGnPmBoe8R8+rthyYCYhHS7g+D4y5FMktf5eJlEiSct7vyhbrV6C0cRBJm99K6TQ/Kpy2hGNoh6lM636uddyJ8nNOTI9I27rlWcXnIOsowa7tt7rT8aJLPEHYPP9XHfwjubgEXMpFCXIcvCHdq+8pEJ5FvfN7M8JVnhT6mfVdkGMnrAkDltXO9Rn/L3qFbTFUij+6x9WBxSTzjng82Fpzx9PDa3uf3M3FoZTrY9j4mAn0DrO7DLHB343Uw8OcTYZEbtTcrZeFj20Jws/F26IF5MtsRLOMKwR2sHe4izXIbOhwlAeTJXmV7oaouWl9Z2O1at1JMFzAQUE4QlEqE7Ztan+JduFgO+JSvnZjORe2P8D9bqPlME7HfWKf0zqTShDD09yQw2Hv+h1T+PCDLbvfFKtQvU4pdsKfT4OAkUDvRsvO03KkY/tWgA/zcH2P9+RhmmEjVLm8hrP29pg7ocfjkGADu/NVWUEJXhtCA0EJ8P7KKhaz+T+GtHpKUm05AOzXknXhH9FCOqTq8znVFvLcjsiWjrjQUUrIW3bLff+fzsLvnK7bzlWK+gr17yRqELAbzRblB2ZPRdEP/89yFH1Yqgw+OVD+ZQn/Kgj8xsZu+YBFYc1t5PjI2ktumyU4uw8mlhBL0ARQWyTzx9q3m/8qOwoX+DZn38j3DtrPOI937IgS0QD90WuW5GTZlgiLRzaz0GO/iiTIRfoBrjMdsTkNWmcamL+MK4yVBGQNtSZAUCtU9HLSmsPGGmmulSD1+dDPUM7ki9Ju+bJi4InR/aSWfgcJNTT4I8qMdyUa4KXDQjHtUhIrvBE4nsAjgMBGB3Gub7VAN3fnRKUB5aHMrOy+lJtjubAgQw71P6VB/vZo+xX03XDkSKdD7CUAIdCJ2l0QLpd0IfC1+UglQf9kmuafr48fpm70I0MV8KK4jtPDs1uV0zGp2WZIeSuJIr1Okz2VVh6OOlsWhAvrCOJgBeDSXbJjszI38s7cvKGn3m/qx7hE8lfcFbgHVfjup9WlQCyhVJOR4JgS8kuOxqZilc2mxpPpBLct2cjoKus38zB1/EtLrhq8FY77S+bdkYV3BwEtDBo9XS1OBkqh8hvEoR/MbIsJB4tU51yJl9r+SHD+OyJZB28rrQTAmveVeDzc7qE9oi0FkB1jxCBfjLELqgu0BByKfBE9g4K4RQzcKWCklt8D0paLSrBakPDEsIa1UBTydDQYe7xWQqFAZ4SUmmTEsvV7GojsoSps1J80uv/YrJFoEqrJY+SG7oabknwumZkPosy/QkOALXu5yM2Qww/632muLV+FVEAs04Agrxa7YGagbs2dExNYSyA/JGiaaqqqXXITI5Y1gATrqO8wIQextlLKF8b6765aeDyx4VicNxf2ixdOZ3MAtnwRl70srEW1LiGJTRPJnF4KpM3Kq02lTCuS3XCK9smXwxwU27AL3yb5M4Zwp0m6YOZQtcpIBQf69qwfkwgwyeAek97I9nMHIZe+ZMJmToznoy4xkjQfDTdy070RSeDDL+dbgtvqmCd29WBf10QvE/YEMeB17I5pHoIY2FobtwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJ2fA5Wa7LlOBymgvADlTZwg7C8Ppm73VPNQmV4KkdpoJ+eV6//PhraWZmum2YDVateD+shv5yOZBnvdDZyX4uQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "entrypoint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "app_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::app::AppPayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 4,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::fee::FeePayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 2,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_fee_payer",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cancellable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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iQgNJDdQtAr7HutSA70TERronYjQQO9EhAZ6JyIz0PdYlxronYjQQO9EhAZ6JyLrRHyPdamB3okIDfRORGigdyJCA70TEa7C3onIDPQ91qUGeiciNNA7EaGB3okIDSQ3UGagdyJCA70TERronYisE/E91qUGeiciM9D3WJca6J2I0EDvRGSrsO+xLjWQ3ECZgd6JCA30TkRooHciQgO9ExEa6J2IzEDfY11qoHcisk7E91iXGuidiNBAcgNlBnonIjTQOxHhKuydiNBA70SEBnonIjPQ91iXGuidiNBA70SEBnonIjSQ3ECZgd6JyDoR32NdaqB3IkIDvRMRGuidiMjAsPgm67Jl+OSg9yJSB70ZkTro3YjUQXIHhQ56PyJ10BsSqYPekUgd9JZE6qD3JMKexLdbFzvoPYnUQe9JpA56TyJ1kNxB2Vrse66LHfSeROqg9yRSB70nkTroPYnQQd94Xeyg9yRSB70nkTroPYmwJ/HN18UOek8iddB7EqmD3pNIHfSeRLoWe08idNC3YBc76D2J1EHvSaQOek8idZDcQaGD3pNIHfSeROqg9yTCnsS3Yhc76D2J0EHfjF3soPckUge9JxGuxb4fu9hBcgeFDnpPInXQexKpg96TSB30nkTqoPckQgd9W3axg96TCHsS35hd7KD3JFIHyR0UOug9idRB70mka7H3JFIHvSeROug9idBB36Bd7KD3JFIHvSeROug9idRBcgeFDnpPIuxJfJt2sYPek0gd9J5E6qD3JEIHfat26Vrse7WLHfSeROqg9yRSB8kdFDroPYnUQe9JpA56TyJ10HsSqYPekwh7Et+0Xeyg9yRSB70nkTroPYnUQXIHZWux79wudtB7EqmD3pNIHfSeROqg9yRCB337drGD3pNIHfSeROqg9yTCnsS3cBc76D2J1EHvSaQOek8iddB7Eula7D2JzMHg+7iLHfSeROqg9yRSB70nkTpI7qDQQe9JpA56TyJ10HsSWU8SfB93sYPekwgd9H3cxQ56TyJ10HsS4Vrs+7iLHSR3UOig9yRSB70nkTroPYnUQe9JpA56TyJ00PdxFzvoPYmwJ/F93MUOek8idZDcQaGD3pNIHfSeRLoWe08ivQe9J5E66D2J0EHfx13soPckUge9JxGuxb6Pu/geJHdQ6KD3JFIHvSeROug9idRB70mka7H3JEIH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",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "lte_hint",
        "notify_enqueued_public_function_call_wrapper",
        "call_private_function_internal",
        "debug_log_oracle_wrapper",
        "notify_set_min_revertible_side_effect_counter_oracle_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
      "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrSingleKeyAccount::verify_private_authwit_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrSingleKeyAccount::verify_private_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "app_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 4,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::app::AppPayload"
                    }
                  },
                  {
                    "name": "fee_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 2,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_fee_payer",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::fee::FeePayload"
                    }
                  },
                  {
                    "name": "cancellable",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrSingleKeyAccount::entrypoint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrSingleKeyAccount::entrypoint_abi"
        }
      ]
    }
  },
  "file_map": {
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "272": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "289": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "290": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "307": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "316": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "376": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/schnorr/v0.1.1/src/lib.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\nuse std::hash::{blake2s, pedersen_hash};\n\npub fn verify_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) -> bool {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n    // pub_key is on Grumpkin curve\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\n        & (!public_key.is_infinite);\n\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\n        let (r_is_infinite, result) =\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n        is_ok &= !r_is_infinite;\n        for i in 0..32 {\n            is_ok &= result[i] == signature[32 + i];\n        }\n    } else {\n        is_ok = false;\n    }\n    is_ok\n}\n\npub fn assert_valid_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n\n    // assert pub_key is on Grumpkin curve\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\n    assert(public_key.is_infinite == false);\n    // assert signature is not null\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\n\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n    assert(!r_is_infinite);\n    for i in 0..32 {\n        assert(result[i] == signature[32 + i]);\n    }\n}\n\nfn calculate_signature_challenge<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    sig_s: EmbeddedCurveScalar,\n    sig_e: EmbeddedCurveScalar,\n    message: [u8; N],\n) -> (bool, [u8; 32]) {\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    let r = multi_scalar_mul([g1, public_key], [sig_s, sig_e]);\n    // compare the _hashes_ rather than field elements modulo r\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\n\n    let mut hash_input = [0; N + 32];\n    for i in 0..32 {\n        hash_input[i] = pde[i];\n    }\n    for i in 0..N {\n        hash_input[32 + i] = message[i];\n    }\n\n    let result = blake2s(hash_input);\n    (r.is_infinite, result)\n}\n\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n    let mut v: Field = 1;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..16 {\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\n    sig_s\n}\n\nmod test {\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    use super::verify_signature;\n\n    #[test]\n    fn test_zero_signature() {\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let signature: [u8; 64] = [0; 64];\n        let message: [u8; _] = [2; 64]; // every message\n        let verified = verify_signature(public_key, signature, message);\n        assert(!verified);\n    }\n\n    #[test]\n    fn smoke_test() {\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\n        let signature: [u8; 64] = [\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\n            199, 19, 84, 239, 138, 124, 12,\n        ];\n\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\n        let valid_signature = verify_signature(pub_key, signature, message);\n        assert(valid_signature);\n        super::assert_valid_signature(pub_key, signature, message);\n    }\n\n}\n\nmod bench {\n    use super::{assert_valid_signature, verify_signature};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    #[export]\n    pub fn bench_verify_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) -> bool {\n        verify_signature(public_key, signature, message)\n    }\n\n    #[export]\n    pub fn bench_assert_valid_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) {\n        assert_valid_signature(public_key, signature, message)\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/auth_oracle.nr",
      "source": "use dep::authwit::auth_witness;\nuse dep::aztec::{\n    protocol_types::{address::PartialAddress, public_keys::{PUBLIC_KEYS_LENGTH, PublicKeys}},\n    utils::array,\n};\nuse aztec::protocol_types::traits::Deserialize;\n\npub struct AuthWitness {\n    keys: PublicKeys,\n    signature: [u8; 64],\n    partial_address: PartialAddress,\n}\n\nimpl AuthWitness {\n    fn deserialize(values: [Field; 77]) -> Self {\n        let mut signature = [0; 64];\n        for i in 0..64 {\n            signature[i] = values[i + PUBLIC_KEYS_LENGTH] as u8;\n        }\n        Self {\n            keys: PublicKeys::deserialize(array::subarray(values, 0)),\n            signature,\n            partial_address: PartialAddress::from_field(values[76]),\n        }\n    }\n}\n\npub unconstrained fn get_auth_witness(message_hash: Field) -> AuthWitness {\n    let witness: [Field; 77] = auth_witness::get_auth_witness(message_hash);\n    AuthWitness::deserialize(witness)\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/main.nr",
      "source": "mod util;\nmod auth_oracle;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract SchnorrSingleKeyAccount {\n    use dep::aztec::prelude::PrivateContext;\n\n    use dep::authwit::{account::AccountActions, entrypoint::{app::AppPayload, fee::FeePayload}};\n\n    use crate::{auth_oracle::get_auth_witness, util::recover_address};\n\n    use dep::aztec::macros::functions::{private, view};\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Safety: The witness is only used as a \"magical value\" that makes the signature verification\n        // in `recover_address` and the address check below pass. Hence it's safe.\n        let witness = unsafe { get_auth_witness(outer_hash) };\n        recover_address(outer_hash, witness).eq(context.this_address())\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/util.nr",
      "source": "use crate::auth_oracle::AuthWitness;\nuse dep::aztec::prelude::AztecAddress;\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\npub fn recover_address(message_hash: Field, witness: AuthWitness) -> AztecAddress {\n    let message_bytes: [u8; 32] = message_hash.to_be_bytes();\n    let public_key = EmbeddedCurvePoint {\n        x: witness.keys.ivpk_m.inner.x,\n        y: witness.keys.ivpk_m.inner.y,\n        is_infinite: false,\n    };\n\n    // In a single key account contract we re-used ivpk_m as signing key\n    schnorr::assert_valid_signature(public_key, witness.signature, message_bytes);\n\n    AztecAddress::compute(witness.keys, witness.partial_address)\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/account.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::{\n        constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::Hash,\n    },\n};\n\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"
    },
    "54": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth_witness.nr",
      "source": "#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"
    },
    "57": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",
      "source": "use dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\n#[derive(Serialize)]\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    pub nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage()\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"
    },
    "58": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr",
      "source": "use crate::entrypoint::function_call::FunctionCall;\nuse dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\n#[derive(Serialize)]\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage()\n    }\n\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
